{"version":3,"sources":["webpack://alg/webpack/universalModuleDefinition","webpack://alg/webpack/bootstrap","webpack://alg/./src/jison_parser/index.js","webpack://alg/./src/debug.ts","webpack://alg/./src/algorithm/alg-part.ts","webpack://alg/./src/algorithm/sign-move.ts","webpack://alg/./src/traversal.ts","webpack://alg/./src/example.ts","webpack://alg/./src/json.ts","webpack://alg/./src/validation.ts","webpack://alg/./src/parser.ts","webpack://alg/./src/keyboard.ts","webpack://alg/./src/url.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","index","k","v","length","$V0","$V1","$V2","$V3","$V4","$V5","$V6","$V7","$V8","$V9","$Va","$Vb","$Vc","$Vd","$Ve","$Vf","$Vg","parser","trace","yy","symbols_","error","expressions","TOP_LEVEL_ALG","EOF","LAYER","NUMBER","REPETITION","AMOUNT","PRIME","COMMENT","COMMENT_SHORT","COMMENT_LONG","FAMILY","LONG_FAMILY","SIGN_MOVE","DASH","OPTIONAL_WHITESPACE","WHITESPACE","REPEATABLE_UNIT","OPEN_BRACKET","SEQUENCE","COMMA","CLOSE_BRACKET","COLON","OPEN_PARENTHESIS","CLOSE_PARENTHESIS","REPEATED_UNIT","ANNOTATION","NEWLINE","PAUSE","UNIT_LIST_WITHOUT_WHITESPACE","UNIT_LIST","$accept","$end","terminals_","2","5","7","10","12","13","15","17","19","21","23","24","25","26","27","30","31","productions_","performAction","yytext","yyleng","yylineno","yystate","$$","_$","$0","$","parseInt","type","comment","slice","family","innerLayer","outerLayer","A","B","nestedSequence","amount","concat","nestedUnits","table","3","4","22","18","1","33","32","28","29","20","11","16","14","6","9","8","defaultActions","parseError","str","hash","recoverable","Error","parse","input","stack","vstack","lstack","recovering","args","arguments","lexer","sharedState","setInput","yylloc","yyloc","push","ranges","options","getPrototypeOf","symbol","preErrorSymbol","state","action","len","newState","expected","lex","token","yyval","errStr","showPosition","join","text","match","line","loc","Array","first_line","last_line","first_column","last_column","range","apply","_input","_more","_backtrack","done","matched","conditionStack","offset","ch","unput","lines","split","substr","oldLines","more","reject","backtrack_lexer","less","pastInput","past","replace","upcomingInput","next","pre","test_match","indexed_rule","backup","matches","tempMatch","rules","_currentRules","flex","begin","condition","popState","pop","conditions","topState","Math","abs","pushState","stateStackSize","yy_","$avoiding_name_collisions","YY_START","INITIAL","inclusive","Parser","CHECK_TYPES","AlgPart","[object Object]","freeze","Unit","Annotation","UnitWithAmount","super","BaseMove","alg_part_Sequence","Group","Commutator","Conjugate","Pause","NewLine","CommentShort","CommentLong","sign_move_SiGNMove","BareSiGNMove","undefined","LayerSiGNMove","RangeSiGNMove","dispatch","algPart","dataDown","traverseSequence","traverseGroup","traverseSiGNMove","traverseCommutator","traverseConjugate","traversePause","traverseNewLine","traverseCommentShort","traverseCommentLong","traversal_TraversalDownUp","out","traverse","traversal_TraversalUp","invertInstance","traversal_Invert","sequence","reverse","map","a","traverseIntoUnit","group","signMove","commutator","conjugate","pause","newLine","commentShort","commentLong","expandInstance","traversal_Expand","algList","flattened","part","accordingTo","once","invert","repeated","flattenSequenceOneLevel","repeat","expandedA","expandedB","structureEqualsInstance","traversal_StructureEquals","coalesceBaseMovesInstance","traversal_CoalesceBaseMoves","moveA","moveB","coalesced","last","sameBlock","algToStringInstance","traversal_ToString","absAmount","String","u1","u2","output","spaceBetween","repetitionSuffix","expand","structureEquals","coalesceBaseMoves","algToString","example_Example","fromJSON","json","j","unitFromJSON","Example","Sune","AntiSune","SuneCommutator","Niklas","EPerm","FURURFCompact","APermCompact","FURURFMoves","TPerm","HeadlightSwaps","TriplePause","AllAlgParts","ValidationError","validation_ValidatorTraversal","validateFamily","allowedFamilyLists","list","plainMoveFamilies","x","y","z","M","E","S","e","singleSliceMoveFamilies","U","L","F","R","D","wideMoveFamilies","u","f","b","Uw","Lw","Fw","Rw","Bw","Dw","BaseMoveValidator","unit","SiGNMoveValidatorInstance","SiGNMoveValidator","validateSiGNMoves","flatAlgValidatorInstance","FlatAlgValidator","validateFlatAlg","validateSiGNAlg","validators","algo","jison_parser","validate","cubeKeyMapping","73","75","87","79","83","76","68","69","74","70","72","71","78","86","67","82","85","77","84","89","66","186","59","65","80","81","190","keyToMove","altKey","ctrlKey","keyCode","serializeURLParam","escaped","deserializeURLParam","unescaped","getAlgURLParam","URLSearchParams","window","location","search","algCubingNetLink","url","URL","alg","searchParams","set","setup","puzzle","indexOf","stage","view","toString"],"mappings":"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","file":"alg.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"alg\"] = factory();\n\telse\n\t\troot[\"alg\"] = factory();\n})(typeof self !== \"undefined\" ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/* parser generated by jison 0.4.18 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar index = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[2,14],$V1=[1,5],$V2=[5,23,24,25,27],$V3=[1,23],$V4=[1,18],$V5=[1,19],$V6=[1,22],$V7=[1,16],$V8=[1,17],$V9=[1,12],$Va=[1,13],$Vb=[5,7,12,13,15,21,23,24,25,26,27,30,31],$Vc=[5,19,23,24,25,27],$Vd=[5,12,13,19,23,24,25,27,30,31],$Ve=[5,7,12,13,15,19,21,23,24,25,26,27,30,31],$Vf=[5,7,10,12,13,19,23,24,25,27,30,31],$Vg=[7,12,13,15,21,24,26,30,31];\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"expressions\":3,\"TOP_LEVEL_ALG\":4,\"EOF\":5,\"LAYER\":6,\"NUMBER\":7,\"REPETITION\":8,\"AMOUNT\":9,\"PRIME\":10,\"COMMENT\":11,\"COMMENT_SHORT\":12,\"COMMENT_LONG\":13,\"FAMILY\":14,\"LONG_FAMILY\":15,\"SIGN_MOVE\":16,\"DASH\":17,\"OPTIONAL_WHITESPACE\":18,\"WHITESPACE\":19,\"REPEATABLE_UNIT\":20,\"OPEN_BRACKET\":21,\"SEQUENCE\":22,\"COMMA\":23,\"CLOSE_BRACKET\":24,\"COLON\":25,\"OPEN_PARENTHESIS\":26,\"CLOSE_PARENTHESIS\":27,\"REPEATED_UNIT\":28,\"ANNOTATION\":29,\"NEWLINE\":30,\"PAUSE\":31,\"UNIT_LIST_WITHOUT_WHITESPACE\":32,\"UNIT_LIST\":33,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",7:\"NUMBER\",10:\"PRIME\",12:\"COMMENT_SHORT\",13:\"COMMENT_LONG\",15:\"LONG_FAMILY\",17:\"DASH\",19:\"WHITESPACE\",21:\"OPEN_BRACKET\",23:\"COMMA\",24:\"CLOSE_BRACKET\",25:\"COLON\",26:\"OPEN_PARENTHESIS\",27:\"CLOSE_PARENTHESIS\",30:\"NEWLINE\",31:\"PAUSE\"},\nproductions_: [0,[3,2],[6,1],[8,1],[9,1],[9,2],[9,1],[11,1],[11,1],[14,1],[16,1],[16,2],[16,4],[18,2],[18,0],[20,1],[20,5],[20,5],[20,3],[20,1],[20,5],[20,5],[20,3],[28,1],[28,2],[29,1],[29,1],[29,1],[32,1],[32,3],[32,2],[32,2],[32,1],[33,1],[33,3],[22,3],[22,1],[4,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\n return $$[$0-1]; \nbreak;\ncase 2: case 3:\nthis.$ = parseInt($$[$0]);\nbreak;\ncase 5:\nthis.$ = -$$[$0-1];\nbreak;\ncase 6:\nthis.$ = -1;\nbreak;\ncase 7:\nthis.$ = {type: \"commentShort\", comment: $$[$0].slice(2)};\nbreak;\ncase 8:\nthis.$ = {type: \"commentLong\", comment: $$[$0].slice(2, -2)};\nbreak;\ncase 10:\nthis.$ = {type: \"signMove\", family: $$[$0]};\nbreak;\ncase 11:\nthis.$ = {type: \"signMove\", family: $$[$0], innerLayer: $$[$0-1]};\nbreak;\ncase 12:\nthis.$ = {type: \"signMove\", family: $$[$0], outerLayer: $$[$0-3], innerLayer: $$[$0-1]};\nbreak;\ncase 16: case 20:\nthis.$ = {\"type\": \"commutator\", \"A\": $$[$0-3], \"B\": $$[$0-1]};\nbreak;\ncase 17: case 21:\nthis.$ = {\"type\": \"conjugate\", \"A\": $$[$0-3], \"B\": $$[$0-1]};\nbreak;\ncase 18: case 22:\nthis.$ = {\"type\": \"group\", \"nestedSequence\": $$[$0-1]};\nbreak;\ncase 23:\n$$[$0].amount = 1; this.$ = $$[$0];\nbreak;\ncase 24:\n$$[$0-1].amount = $$[$0]; this.$ = $$[$0-1];\nbreak;\ncase 25:\nthis.$ = {\"type\": \"newLine\"};\nbreak;\ncase 26:\nthis.$ = {\"type\": \"pause\"};\nbreak;\ncase 28: case 32:\nthis.$ = [$$[$0]];\nbreak;\ncase 29:\nthis.$ = $$[$0-2].concat([$$[$0-1]]).concat($$[$0]);\nbreak;\ncase 30:\nthis.$ = [$$[$0-1]].concat($$[$0]);\nbreak;\ncase 31:\nthis.$ = $$[$0-1].concat([$$[$0]]);\nbreak;\ncase 33: case 37:\nthis.$ = $$[$0];\nbreak;\ncase 34:\nthis.$ = $$[$0-2].concat($$[$0]);\nbreak;\ncase 35:\nthis.$ = {\"type\": \"sequence\", \"nestedUnits\": $$[$0-1]};\nbreak;\ncase 36:\nthis.$ = {\"type\": \"sequence\", \"nestedUnits\": []};\nbreak;\n}\n},\ntable: [o([5,7,12,13,15,21,26,30,31],$V0,{3:1,4:2,22:3,18:4,19:$V1}),{1:[3]},{5:[1,6]},{5:[2,37]},o($V2,[2,36],{33:7,32:8,28:9,29:10,20:11,11:14,16:15,14:20,6:21,7:$V3,12:$V4,13:$V5,15:$V6,21:$V7,26:$V8,30:$V9,31:$Va}),o($Vb,$V0,{18:24,19:$V1}),{1:[2,1]},o($V2,$V0,{18:25,19:[1,26]}),o($Vc,[2,33],{11:14,29:27,12:$V4,13:$V5,30:$V9,31:$Va}),o($Vd,[2,28]),o($Vc,[2,32],{28:9,29:10,20:11,11:14,16:15,14:20,6:21,32:28,7:$V3,12:$V4,13:$V5,15:$V6,21:$V7,26:$V8,30:$V9,31:$Va}),o($Vd,[2,23],{9:29,8:30,7:[1,32],10:[1,31]}),o($Ve,[2,25]),o($Ve,[2,26]),o($Ve,[2,27]),o($Vf,[2,15]),o([7,12,13,15,21,23,25,26,30,31],$V0,{18:4,22:33,19:$V1}),o([7,12,13,15,21,26,27,30,31],$V0,{18:4,22:34,19:$V1}),o($Ve,[2,7]),o($Ve,[2,8]),o($Vf,[2,10]),{14:35,15:$V6,17:[1,36]},o($Vf,[2,9]),o([15,17],[2,2]),o($Vb,[2,13]),o($V2,[2,35]),o($V2,$V0,{28:9,29:10,20:11,11:14,16:15,14:20,6:21,18:24,32:37,7:$V3,12:$V4,13:$V5,15:$V6,19:$V1,21:$V7,26:$V8,30:$V9,31:$Va}),o($Vc,[2,31],{28:9,29:10,20:11,11:14,16:15,14:20,6:21,32:38,7:$V3,12:$V4,13:$V5,15:$V6,21:$V7,26:$V8,30:$V9,31:$Va}),o($Vc,[2,30],{11:14,29:27,12:$V4,13:$V5,30:$V9,31:$Va}),o($Vd,[2,24]),o($Vd,[2,4],{10:[1,39]}),o($Vd,[2,6]),o([5,10,12,13,19,23,24,25,27,30,31],[2,3]),{23:[1,40],25:[1,41]},{27:[1,42]},o($Vf,[2,11]),{6:43,7:$V3},o($Vc,[2,34],{11:14,29:27,12:$V4,13:$V5,30:$V9,31:$Va}),o($Vc,[2,29],{11:14,29:27,12:$V4,13:$V5,30:$V9,31:$Va}),o($Vd,[2,5]),o($Vg,$V0,{18:4,22:44,19:$V1}),o($Vg,$V0,{18:4,22:45,19:$V1}),o($Vf,[2,18]),{14:46,15:$V6},{24:[1,47]},{24:[1,48]},o($Vf,[2,12]),o($Vf,[2,16]),o($Vf,[2,17])],\ndefaultActions: {3:[2,37],6:[2,1]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:return \"WHITESPACE\"\nbreak;\ncase 1:return \"NUMBER\"\nbreak;\ncase 2:return \"DASH\"\nbreak;\ncase 3:return \"LONG_FAMILY\"\nbreak;\ncase 4:return \"PRIME\"\nbreak;\ncase 5:return \"PAUSE\"\nbreak;\ncase 6:return \"COMMENT_SHORT\"\nbreak;\ncase 7:return \"COMMENT_LONG\"\nbreak;\ncase 8:return \"NEWLINE\"\nbreak;\ncase 9:return \"OPEN_BRACKET\"\nbreak;\ncase 10:return \"CLOSE_BRACKET\"\nbreak;\ncase 11:return \"OPEN_PARENTHESIS\"\nbreak;\ncase 12:return \"CLOSE_PARENTHESIS\"\nbreak;\ncase 13:return \"COMMA\"\nbreak;\ncase 14:return \"COLON\"\nbreak;\ncase 15:return \"EOF\"\nbreak;\ncase 16:return \"INVALID\"\nbreak;\n}\n},\nrules: [/^(?:[^\\S\\r\\n]+)/,/^(?:[0-9]+)/,/^(?:-)/,/^(?:[_A-Za-z]+)/,/^(?:')/,/^(?:\\.)/,/^(?:\\/\\/[^\\n\\r]*)/,/^(?:\\/\\*[^]*?\\*\\/)/,/^(?:[\\n\\r])/,/^(?:\\[)/,/^(?:\\])/,/^(?:\\()/,/^(?:\\))/,/^(?:,)/,/^(?::)/,/^(?:$)/,/^(?:.)/],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = index;\nexports.Parser = index.Parser;\nexports.parse = function () { return index.parse.apply(index, arguments); };\n}\n","export var CHECK_TYPES = true;\n","import {CHECK_TYPES} from \"../debug\"\n\n// TODO: Remove AlgPart and only have Sequence and Unit?\nexport abstract class AlgPart {\n  public readonly abstract type: string\n\n  // TODO: Figure out if we can statically enforce that all AlgPart subclasses\n  // are frozen after initial construction.\n  protected freeze() {\n    Object.freeze(this);\n  }\n}\n\nexport abstract class Unit extends AlgPart {}\n\nexport abstract class Annotation extends Unit {}\n\nexport abstract class UnitWithAmount extends Unit {\n  // TODO: Allow `amount` to be `undefined`, to distinguish between R and R1?\n  constructor(public amount: number = 1) {\n    super();\n  }\n}\n\nexport abstract class BaseMove extends UnitWithAmount {\n}\n\n// TODO: Reintroduce an Algorithm class, and allow a mutable sequence too?\nexport class Sequence extends AlgPart {\n  public type: string = \"sequence\";\n  constructor(public nestedUnits: Unit[]) {\n    super();\n    for (var n of nestedUnits) {\n      if (CHECK_TYPES && !(n instanceof Unit)) {\n        throw \"A Sequence can only contain `Unit`s.\"\n      }\n    }\n    Object.freeze(this.nestedUnits);\n    this.freeze();\n  }\n}\n\nexport class Group extends UnitWithAmount {\n  public type: string = \"group\";\n  constructor(public nestedSequence: Sequence, amount?: number) {\n    super(amount);\n    this.freeze();\n  }\n}\n\nexport class Commutator extends UnitWithAmount {\n  public type: string = \"commutator\";\n  constructor(public A: Sequence, public B: Sequence, amount?: number) {\n    super(amount);\n    this.freeze();\n  }\n}\n\nexport class Conjugate extends UnitWithAmount {\n  public type: string = \"conjugate\";\n  constructor(public A: Sequence, public B: Sequence, amount?: number) {\n    super(amount);\n    this.freeze();\n  }\n}\n\nexport class Pause extends Unit {\n  public type: string = \"pause\";\n  constructor() {\n    super();\n    this.freeze();\n  }\n}\n\nexport class NewLine extends Annotation {\n  public type: string = \"newLine\";\n  constructor() {\n    super();\n    this.freeze();\n  }\n}\n\n// TODO: must be followed by a newline, unless at the end of an alg?\nexport class CommentShort extends Annotation {\n  public type: string = \"commentShort\";\n  constructor(public comment: string) {\n    super();\n    this.freeze();\n  }\n}\n\nexport class CommentLong extends Annotation {\n  public type: string = \"commentLong\";\n  constructor(public comment: string) {\n    super();\n    this.freeze();\n  }\n}\n\n// TODO\n// export class TimeStamp extends AlgPart implements AlgPart\n","import {BaseMove} from \"./alg-part\"\n\n// TODO: Move SiGN move defs into a separate file.\nexport type MoveFamily = string; // TODO: Convert to an enum with string mappings.\n\n// TODO: Handle layers\nexport class SiGNMove extends BaseMove {\n  public type: string = \"signMove\";\n\n  // If `outerLayer` is set, `innerLayer` must also be set.\n  public outerLayer?: number;\n  public innerLayer?: number;\n  constructor(outerLayer: number | undefined, innerLayer: number | undefined, public family: MoveFamily, amount?: number) {\n    super(amount);\n    this.outerLayer = outerLayer;\n    this.innerLayer = innerLayer;\n    this.freeze();\n  }\n}\n\nexport function BareSiGNMove(family: MoveFamily, amount?: number): SiGNMove {\n  return new SiGNMove(undefined, undefined, family, amount);\n}\n\nexport function LayerSiGNMove(innerLayer: number, family: MoveFamily, amount?: number): SiGNMove {\n  return new SiGNMove(undefined, innerLayer, family, amount);\n}\n\nexport function RangeSiGNMove(outerLayer: number,innerLayer: number, family: MoveFamily, amount?: number): SiGNMove {\n  return new SiGNMove(outerLayer, innerLayer, family, amount);\n}\n","import {CHECK_TYPES} from \"./debug\"\n\nimport {\n  AlgPart,\n  Unit,\n  UnitWithAmount,\n  Sequence,\n  Group,\n  SiGNMove,\n  Commutator,\n  Conjugate,\n  Pause,\n  NewLine,\n  CommentShort,\n  CommentLong\n} from \"./algorithm\";\n\nfunction dispatch<DataDown, DataUp>(t: TraversalDownUp<DataDown, DataUp>, algPart: AlgPart, dataDown: DataDown): DataUp {\n  switch (algPart.type) {\n    case \"sequence\":\n      if (CHECK_TYPES && !(algPart instanceof Sequence)) {\n        throw `Alg part is not an object of type Sequence despite having \"type\": \\\"${algPart.type}\\\"`\n      }\n      return t.traverseSequence(<Sequence >algPart, dataDown);\n    case \"group\":\n      if (CHECK_TYPES && !(algPart instanceof Group)) {\n        throw `Alg part is not an object of type Group despite having \"type\": \\\"${algPart.type}\\\"`\n      }\n      return t.traverseGroup(<Group >algPart, dataDown);\n    case \"signMove\":\n      if (CHECK_TYPES && !(algPart instanceof SiGNMove)) {\n        throw `Alg part is not an object of type SiGNMove despite having \"type\": \\\"${algPart.type}\\\"`\n      }\n      return t.traverseSiGNMove(<SiGNMove >algPart, dataDown);\n    case \"commutator\":\n      if (CHECK_TYPES && !(algPart instanceof Commutator)) {\n        throw `Alg part is not an object of type Commutator despite having \"type\": \\\"${algPart.type}\\\"`\n      }\n      return t.traverseCommutator (<Commutator>algPart, dataDown);\n    case \"conjugate\":\n      if (CHECK_TYPES && !(algPart instanceof Conjugate)) {\n        throw `Alg part is not an object of type Conjugate despite having \"type\": \\\"${algPart.type}\\\"`\n      }\n      return t.traverseConjugate(<Conjugate >algPart, dataDown);\n    case \"pause\":\n      if (CHECK_TYPES && !(algPart instanceof Pause)) {\n        throw `Alg part is not an object of type Pause despite having \"type\": \\\"${algPart.type}\\\"`\n      }\n      return t.traversePause(<Pause>algPart, dataDown);\n    case \"newLine\":\n      if (CHECK_TYPES && !(algPart instanceof NewLine)) {\n        throw `Alg part is not an object of type NewLine despite having \"type\": \\\"${algPart.type}\\\"`\n      }\n      return t.traverseNewLine(<NewLine >algPart, dataDown);\n    case \"commentShort\":\n      if (CHECK_TYPES && !(algPart instanceof CommentShort)) {\n        throw `Alg part is not an object of type CommentShort despite having \"type\": \\\"${algPart.type}\\\"`\n      }\n      return t.traverseCommentShort (<CommentShort>algPart, dataDown);\n    case \"commentLong\":\n      if (CHECK_TYPES && !(algPart instanceof CommentLong)) {\n        throw `Alg part is not an object of type CommentLong despite having \"type\": \\\"${algPart.type}\\\"`\n      }\n      return t.traverseCommentLong (<CommentLong>algPart, dataDown);\n    default: \n      throw `Unknown algPart type: ${algPart.type}`\n  }\n}\n\nexport abstract class TraversalDownUp<DataDown, DataUp> {\n  // Immediate subclasses should overwrite this.\n  public traverse(algPart: AlgPart, dataDown: DataDown): DataUp {\n    return dispatch(this, algPart, dataDown);\n  }\n\n  public traverseIntoUnit(algPart: AlgPart, dataDown: DataDown): Unit {\n    var out = this.traverse(algPart, dataDown);\n    if (CHECK_TYPES && !(out instanceof Unit)) {\n      throw \"Traversal did not produce a unit as expected.\"\n    }\n    return <Unit><any>out;\n  }\n\n  public abstract traverseSequence(sequence: Sequence, dataDown: DataDown): DataUp;\n  public abstract traverseGroup(group: Group, dataDown: DataDown): DataUp;\n  public abstract traverseSiGNMove(signMove: SiGNMove, dataDown: DataDown): DataUp;\n  public abstract traverseCommutator(commutator: Commutator, dataDown: DataDown): DataUp;\n  public abstract traverseConjugate(conjugate: Conjugate, dataDown: DataDown): DataUp;\n  public abstract traversePause(pause: Pause, dataDown: DataDown): DataUp;\n  public abstract traverseNewLine(newLine: NewLine, dataDown: DataDown): DataUp;\n  public abstract traverseCommentShort(commentShort: CommentShort, dataDown: DataDown): DataUp;\n  public abstract traverseCommentLong(commentLong: CommentLong, dataDown: DataDown): DataUp;\n}\n\nexport abstract class TraversalUp<DataUp> extends TraversalDownUp<undefined, DataUp> {\n  public traverse(algPart: AlgPart): DataUp {\n    return dispatch<undefined, DataUp>(this, algPart, undefined);\n  }\n\n  public traverseIntoUnit(algPart: AlgPart): Unit {\n    var out = this.traverse(algPart);\n    if (CHECK_TYPES && !(out instanceof Unit)) {\n      throw \"Traversal did not produce a unit as expected.\"\n    }\n    return <Unit><any>out;\n  }\n\n  public abstract traverseSequence(sequence: Sequence): DataUp;\n  public abstract traverseGroup(group: Group): DataUp;\n  public abstract traverseSiGNMove(signMove: SiGNMove): DataUp;\n  public abstract traverseCommutator(commutator: Commutator): DataUp;\n  public abstract traverseConjugate(conjugate: Conjugate): DataUp;\n  public abstract traversePause(pause: Pause): DataUp;\n  public abstract traverseNewLine(newLine: NewLine): DataUp;\n  public abstract traverseCommentShort(commentShort: CommentShort): DataUp;\n  public abstract traverseCommentLong(commentLong: CommentLong): DataUp;\n};\n\n// TODO: Test that inverses are bijections.\nexport class Invert extends TraversalUp<AlgPart> {\n  public traverseSequence(sequence: Sequence): Sequence {\n    // TODO: Handle newLines and comments correctly\n    return new Sequence(sequence.nestedUnits.slice().reverse().map(a => this.traverseIntoUnit(a)));\n  }\n  public traverseGroup(group: Group): AlgPart {\n    return new Group(this.traverseSequence(group.nestedSequence), group.amount);\n  }\n  public traverseSiGNMove(signMove: SiGNMove): AlgPart {\n    return new SiGNMove(signMove.outerLayer, signMove.innerLayer, signMove.family, -signMove.amount);\n  }\n  public traverseCommutator(commutator: Commutator): AlgPart {\n    return new Commutator(commutator.B, commutator.A, commutator.amount);\n  }\n  public traverseConjugate(conjugate: Conjugate): AlgPart {\n    return new Conjugate(conjugate.A, this.traverseSequence(conjugate.B), conjugate.amount);\n  }\n  public traversePause(pause: Pause):                      AlgPart { return pause; }\n  public traverseNewLine(newLine: NewLine):                AlgPart { return newLine; }\n  public traverseCommentShort(commentShort: CommentShort): AlgPart { return commentShort; }\n  public traverseCommentLong(commentLong: CommentLong):    AlgPart { return commentLong; }\n}\n\nexport class Expand extends TraversalUp<AlgPart> {\n  private flattenSequenceOneLevel(algList: AlgPart[]): Unit[] {\n    var flattened: Unit[] = [];\n    for (var part of algList) {\n      if (part instanceof Sequence) {\n        flattened = flattened.concat(part.nestedUnits);\n      } else if (part instanceof Unit) {\n        flattened.push(part)\n      } else {\n        throw \"expand() encountered an internal error. Did you pass in a valid Algorithm?\"\n      }\n    }\n    return flattened;\n  }\n\n  private repeat(algList: Unit[], accordingTo: UnitWithAmount): Sequence {\n    var amount = Math.abs(accordingTo.amount);\n    var amountDir = (accordingTo.amount > 0) ? 1 : -1; // Mutable\n\n    // TODO: Cleaner inversion\n    var once: Unit[];\n    if (amountDir == -1) {\n      // TODO: Avoid casting to sequence.\n      once = (<Sequence>(invert(new Sequence(algList)))).nestedUnits;\n    } else {\n      once = algList;\n    }\n\n    var repeated: Unit[] = [];\n    for (var i = 0; i < amount; i++) {\n      repeated = repeated.concat(once);\n    }\n\n    return new Sequence(repeated);\n  }\n\n  public traverseSequence(sequence: Sequence): Sequence {\n    return new Sequence(this.flattenSequenceOneLevel(sequence.nestedUnits.map(a => this.traverse(a))));\n  }\n  public traverseGroup(group: Group): AlgPart {\n    // TODO: Pass raw AlgPart[] to sequence.\n    return this.repeat(this.flattenSequenceOneLevel([this.traverse(group.nestedSequence)]), group);\n  }\n  public traverseSiGNMove(signMove: SiGNMove): AlgPart {\n    return signMove;\n  }\n  public traverseCommutator(commutator: Commutator): AlgPart {\n    var expandedA = this.traverseSequence(commutator.A)\n    var expandedB = this.traverseSequence(commutator.B)\n    var once: AlgPart[] = [];\n    once = once.concat(\n      expandedA,\n      expandedB,\n      invert(expandedA),\n      invert(expandedB)\n    );\n    return this.repeat(this.flattenSequenceOneLevel(once), commutator);\n  }\n  public traverseConjugate(conjugate: Conjugate): AlgPart {\n    var expandedA = this.traverseSequence(conjugate.A)\n    var expandedB = this.traverseSequence(conjugate.B)\n    var once: AlgPart[] = [];\n    once = once.concat(\n      expandedA,\n      expandedB,\n      invert(expandedA)\n    );\n    return this.repeat(this.flattenSequenceOneLevel(once), conjugate);\n  }\n  public traversePause(pause: Pause):                      AlgPart { return pause; }\n  public traverseNewLine(newLine: NewLine):                AlgPart { return newLine; }\n  public traverseCommentShort(commentShort: CommentShort): AlgPart { return commentShort; }\n  public traverseCommentLong(commentLong: CommentLong):    AlgPart { return commentLong; }\n}\n\nexport class StructureEquals extends TraversalDownUp<AlgPart, boolean> {\n  public traverseSequence(sequence: Sequence, dataDown: AlgPart): boolean {\n    if (!(dataDown instanceof Sequence)) {\n      return false;\n    }\n    if (sequence.nestedUnits.length !== dataDown.nestedUnits.length) {\n      return false;\n    }\n    for (var i = 0; i < sequence.nestedUnits.length; i++) {\n      if (!this.traverse(sequence.nestedUnits[i], dataDown.nestedUnits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  public traverseGroup(group: Group, dataDown: AlgPart): boolean {\n    return (dataDown instanceof Group) && this.traverse(group.nestedSequence, dataDown.nestedSequence);\n  }\n  public traverseSiGNMove(signMove: SiGNMove, dataDown: AlgPart): boolean {\n    // TODO: Handle layers.\n    return dataDown instanceof SiGNMove &&\n           signMove.outerLayer === dataDown.outerLayer &&\n           signMove.innerLayer === dataDown.innerLayer &&\n           signMove.family === dataDown.family &&\n           signMove.amount === dataDown.amount;\n  }\n  public traverseCommutator(commutator: Commutator, dataDown: AlgPart): boolean {\n    return (dataDown instanceof Commutator) &&\n           this.traverse(commutator.A, dataDown.A) &&\n           this.traverse(commutator.B, dataDown.B);\n  }\n  public traverseConjugate(conjugate: Conjugate, dataDown: AlgPart): boolean {\n    return (dataDown instanceof Conjugate) &&\n           this.traverse(conjugate.A, dataDown.A) &&\n           this.traverse(conjugate.B, dataDown.B);\n  }\n  public traversePause(pause: Pause, dataDown: AlgPart): boolean {\n    return dataDown instanceof Pause;\n  }\n  public traverseNewLine(newLine: NewLine, dataDown: AlgPart): boolean {\n    return dataDown instanceof NewLine;\n  }\n  public traverseCommentShort(commentShort: CommentShort, dataDown: AlgPart): boolean {\n    return (dataDown instanceof CommentShort) && (commentShort.comment == dataDown.comment);\n  }\n  public traverseCommentLong(commentLong: CommentLong, dataDown: AlgPart): boolean {\n    return (dataDown instanceof CommentLong) && (commentLong.comment == dataDown.comment);\n  }\n}\n\n// TODO: Test that inverses are bijections.\nexport class CoalesceBaseMoves extends TraversalUp<AlgPart> {\n  private sameBlock(moveA: SiGNMove, moveB: SiGNMove): boolean {\n    // TODO: Handle layers\n    return moveA.outerLayer === moveB.outerLayer &&\n           moveA.innerLayer === moveB.innerLayer &&\n           moveA.family === moveB.family;\n  }\n\n  // TODO: Handle\n  public traverseSequence(sequence: Sequence): Sequence {\n    var coalesced: Unit[] = [];\n    for (var part of sequence.nestedUnits) {\n      if (!(part instanceof SiGNMove)) {\n        coalesced.push(this.traverseIntoUnit(part));\n      } else if (coalesced.length > 0) {\n        var last = coalesced[coalesced.length-1];\n        if (last instanceof SiGNMove &&\n            this.sameBlock(last, part)) {\n          // TODO: This is cube-specific. Perhaps pass the modules as DataDown?\n          var amount = last.amount + part.amount;\n          coalesced.pop();\n          if (amount !== 0) {\n            // We could modify the last element instead of creating a new one,\n            // but this is safe against shifting coding practices.\n            // TODO: Figure out if the shoot-in-the-foot risk\n            // modification is worth the speed.\n            coalesced.push(new SiGNMove(part.outerLayer, part.innerLayer, part.family, amount));\n          }\n        } else {\n          coalesced.push(part);\n        }\n      } else {\n        coalesced.push(part);\n      }\n    }\n    return new Sequence(coalesced);\n  }\n  public traverseGroup(group: Group):                      AlgPart { return group; }\n  public traverseSiGNMove(signMove: SiGNMove):             AlgPart { return signMove; }\n  public traverseCommutator(commutator: Commutator):       AlgPart { return commutator; }\n  public traverseConjugate(conjugate: Conjugate):          AlgPart { return conjugate; }\n  public traversePause(pause: Pause):                      AlgPart { return pause; }\n  public traverseNewLine(newLine: NewLine):                AlgPart { return newLine; }\n  public traverseCommentShort(commentShort: CommentShort): AlgPart { return commentShort; }\n  public traverseCommentLong(commentLong: CommentLong):    AlgPart { return commentLong; }\n}\n\n// export class Concat extends TraversalDownUp<Algorithm, Sequence> {\n//   private concatIntoSequence(A: Algorithm[], B: Algorithm): Sequence {\n//     var nestedAlgs: Algorithm[] = A.slice();\n//     if (B instanceof Sequence) {\n//       nestedAlgs = nestedAlgs.concat(B.nestedUnits)\n//     } else {\n//       nestedAlgs.push(B);\n//     }\n//     return new Sequence(nestedAlgs)\n//   }\n//   public traverseSequence(     sequence:     Sequence,     dataDown: Algorithm): Sequence {return this.concatIntoSequence(sequence.nestedUnits, dataDown); }\n//   public traverseGroup(        group:        Group,        dataDown: Algorithm): Sequence {return this.concatIntoSequence([group]          , dataDown); }\n//   public traverseSiGNMove(    SiGNMove:    SiGNMove,    dataDown: Algorithm): Sequence {return this.concatIntoSequence([SiGNMove]      , dataDown); }\n//   public traverseCommutator(   commutator:   Commutator,   dataDown: Algorithm): Sequence {return this.concatIntoSequence([commutator]     , dataDown); }\n//   public traverseConjugate(    conjugate:    Conjugate,    dataDown: Algorithm): Sequence {return this.concatIntoSequence([conjugate]      , dataDown); }\n//   public traversePause(        pause:        Pause,        dataDown: Algorithm): Sequence {return this.concatIntoSequence([pause]          , dataDown); }\n//   public traverseNewLine(      newLine:      NewLine,      dataDown: Algorithm): Sequence {return this.concatIntoSequence([newLine]        , dataDown); }\n//   public traverseCommentShort( commentShort: CommentShort, dataDown: Algorithm): Sequence {return this.concatIntoSequence([commentShort]   , dataDown); }\n//   public traverseCommentLong(  commentLong:  CommentLong,  dataDown: Algorithm): Sequence {return this.concatIntoSequence([commentLong]    , dataDown); }\n// }\n\nexport class ToString extends TraversalUp<string> {\n  private repetitionSuffix(amount: number): string {\n    var absAmount = Math.abs(amount);\n    var s = \"\";\n    if (absAmount !== 1) {\n      s += String(absAmount)\n    }\n    if (absAmount !== amount) {\n      s += \"'\"\n    }\n    return s;\n  }\n\n  private spaceBetween(u1: Unit, u2: Unit): string {\n    if (u1 instanceof Pause && u2 instanceof Pause) {\n      return \"\"\n    }\n    return \" \"\n  }\n\n  public traverseSequence(sequence: Sequence): string {\n    var output = \"\";\n    if (sequence.nestedUnits.length > 0) {\n      output += this.traverse(sequence.nestedUnits[0]);\n      for (var i = 1; i < sequence.nestedUnits.length; i++) {\n        output += this.spaceBetween(sequence.nestedUnits[i-1], sequence.nestedUnits[i]);\n        output += this.traverse(sequence.nestedUnits[i]);\n      }\n    }\n    return output;\n  }\n  public traverseGroup(        group:        Group       ): string { return \"(\" + this.traverse(group.nestedSequence) + \")\" + this.repetitionSuffix(group.amount); }\n  public traverseSiGNMove(     signMove:     SiGNMove    ): string {\n    var out = signMove.family + this.repetitionSuffix(signMove.amount);\n    if (typeof signMove.innerLayer !== \"undefined\") {\n      out = String(signMove.innerLayer) + out;\n      if (typeof signMove.outerLayer !== \"undefined\") {\n        out = String(signMove.outerLayer) + \"-\" + out;\n      }\n    }\n    return out;\n  }\n  public traverseCommutator(   commutator:   Commutator  ): string { return \"[\" + this.traverse(commutator.A) + \", \" + this.traverse(commutator.B) + \"]\" + this.repetitionSuffix(commutator.amount); }\n  public traverseConjugate(    conjugate:    Conjugate   ): string { return \"[\" + this.traverse(conjugate.A) + \": \" + this.traverse(conjugate.B) + \"]\" + this.repetitionSuffix(conjugate.amount); }\n  // TODO: Remove spaces between repeated pauses (in traverseSequence)\n  public traversePause(        pause:        Pause       ): string { return \".\"; }\n  public traverseNewLine(      newLine:      NewLine     ): string { return \"\\n\"; }\n  // TODO: Enforce being followed by a newline (or the end of the alg)?\n  public traverseCommentShort( commentShort: CommentShort): string { return \"//\" + commentShort.comment; }\n    // TODO: Sanitize `*/`\n  public traverseCommentLong(  commentLong:  CommentLong ): string { return \"/*\" + commentLong.comment + \"*/\"; }\n}\n\nconst invertInstance = new Invert();\nconst expandInstance = new Expand();\nconst structureEqualsInstance = new StructureEquals();\nconst coalesceBaseMovesInstance = new CoalesceBaseMoves();\nconst algToStringInstance = new ToString();\n\nexport const invert            = <(a: Sequence) => Sequence>invertInstance.traverseSequence.bind(invertInstance)\nexport const expand            = <(a: Sequence) => Sequence>expandInstance.traverseSequence.bind(expandInstance);\nexport const structureEquals   = <(a1: Sequence, a2: Sequence) => boolean>structureEqualsInstance.traverseSequence.bind(structureEqualsInstance);\nexport const coalesceBaseMoves = <(a: Sequence) => Sequence>coalesceBaseMovesInstance.traverseSequence.bind(coalesceBaseMovesInstance);\nexport const algToString       = <(a: Sequence) => string>algToStringInstance.traverseSequence.bind(algToStringInstance);\n\nexport const algPartStructureEqualsForTesting = <(a1: AlgPart, a2: AlgPart) => boolean>algToStringInstance.traverse.bind(algToStringInstance);\nexport const algPartToStringForTesting = <(a: AlgPart) => Sequence>algToStringInstance.traverse.bind(algToStringInstance);\n","import {\n  AlgPart,\n  Sequence,\n  Group,\n  BareSiGNMove,\n  Commutator,\n  Conjugate,\n  Pause,\n  NewLine,\n  CommentShort,\n  CommentLong\n} from \"./algorithm\";\n\nexport namespace Example {\n\n  export const Sune: Sequence = new Sequence([\n    BareSiGNMove(\"R\",  1),\n    BareSiGNMove(\"U\",  1),\n    BareSiGNMove(\"R\", -1),\n    BareSiGNMove(\"U\",  1),\n    BareSiGNMove(\"R\",  1),\n    BareSiGNMove(\"U\", -2),\n    BareSiGNMove(\"R\", -1)\n  ]);\n\n  export const AntiSune: Sequence = new Sequence([\n    BareSiGNMove(\"R\",  1),\n    BareSiGNMove(\"U\",  2),\n    BareSiGNMove(\"R\", -1),\n    BareSiGNMove(\"U\", -1),\n    BareSiGNMove(\"R\",  1),\n    BareSiGNMove(\"U\", -1),\n    BareSiGNMove(\"R\", -1)\n  ]);\n\n  export const SuneCommutator: Sequence = new Sequence([new Commutator(\n    new Sequence([\n      BareSiGNMove(\"R\",  1),\n      BareSiGNMove(\"U\",  1),\n      BareSiGNMove(\"R\", -2)\n    ]),\n    new Sequence([new Conjugate(\n      new Sequence([BareSiGNMove(\"R\",  1)]),\n      new Sequence([BareSiGNMove(\"U\",  1)]),\n      1\n    )]),\n    1\n  )]);\n\n  export const Niklas: Sequence = new Sequence([\n    BareSiGNMove(\"R\",  1),\n    BareSiGNMove(\"U\",  -1),\n    BareSiGNMove(\"L\", -1),\n    BareSiGNMove(\"U\", 1),\n    BareSiGNMove(\"R\",  -1),\n    BareSiGNMove(\"U\",  -1),\n    BareSiGNMove(\"L\", 1),\n    BareSiGNMove(\"U\", 1)\n  ]);\n\n  export const EPerm: Sequence = new Sequence([\n    BareSiGNMove(\"x\", -1),\n    new Commutator(\n      new Sequence([new Conjugate(\n        new Sequence([BareSiGNMove(\"R\", 1)]),\n        new Sequence([BareSiGNMove(\"U\", -1)])\n      )]),\n      new Sequence([BareSiGNMove(\"D\", 1)]),\n      1\n    ),\n    new Commutator(\n      new Sequence([new Conjugate(\n        new Sequence([BareSiGNMove(\"R\", 1)]),\n        new Sequence([BareSiGNMove(\"U\", 1)])\n      )]),\n      new Sequence([BareSiGNMove(\"D\", 1)]),\n      1\n    ),\n    BareSiGNMove(\"x\", 1)\n  ]);\n\n  export const FURURFCompact: Sequence = new Sequence([new Conjugate(\n    new Sequence([BareSiGNMove(\"F\",  1)]),\n    new Sequence([new Commutator(\n      new Sequence([BareSiGNMove(\"U\",  1)]),\n      new Sequence([BareSiGNMove(\"R\",  1)]),\n      1\n    )]),\n    1\n  )]);\n\n  export const APermCompact: Sequence = new Sequence([new Conjugate(\n    new Sequence([BareSiGNMove(\"R\", 2)]),\n    new Sequence([new Commutator(\n      new Sequence([BareSiGNMove(\"F\", 2)]),\n      new Sequence([\n        BareSiGNMove(\"R\", -1),\n        BareSiGNMove(\"B\", -1),\n        BareSiGNMove(\"R\", 1),\n      ]),\n      1\n    )]),\n    1\n  )]);\n\n  export const FURURFMoves: Sequence = new Sequence([\n    BareSiGNMove(\"F\",  1),\n    BareSiGNMove(\"U\",  1),\n    BareSiGNMove(\"R\",  1),\n    BareSiGNMove(\"U\", -1),\n    BareSiGNMove(\"R\", -1),\n    BareSiGNMove(\"F\", -1)\n  ]);\n\n  export const TPerm: Sequence = new Sequence([\n    BareSiGNMove(\"R\",  1),\n    BareSiGNMove(\"U\",  1),\n    BareSiGNMove(\"R\", -1),\n    BareSiGNMove(\"U\", -1),\n    BareSiGNMove(\"R\", -1),\n    BareSiGNMove(\"F\",  1),\n    BareSiGNMove(\"R\",  2),\n    BareSiGNMove(\"U\", -1),\n    BareSiGNMove(\"R\", -1),\n    BareSiGNMove(\"U\", -1),\n    BareSiGNMove(\"R\",  1),\n    BareSiGNMove(\"U\",  1),\n    BareSiGNMove(\"R\", -1),\n    BareSiGNMove(\"F\", -1)\n  ]);\n\n\n  export const HeadlightSwaps: Sequence = new Sequence([new Conjugate(\n    new Sequence([BareSiGNMove(\"F\", 1)]),\n    new Sequence([new Commutator(\n      new Sequence([BareSiGNMove(\"R\", 1)]),\n      new Sequence([BareSiGNMove(\"U\", 1)]),\n      3\n    )]),\n    1\n  )]);\n\n\n  export const TriplePause: Sequence = new Sequence([\n      new Pause(),\n      new Pause(),\n      new Pause(),\n    ]\n  );\n\n\n  export const AllAlgParts: AlgPart[] = [\n    new Sequence([BareSiGNMove(\"R\", 1), BareSiGNMove(\"U\", -1)]),\n    new Group(new Sequence([BareSiGNMove(\"F\", 1)]), 2),\n    // new Rotation(\"y\", -1),\n    BareSiGNMove(\"R\", 2),\n    new Commutator(new Sequence([BareSiGNMove(\"R\", 2)]), new Sequence([BareSiGNMove(\"U\", 2)]), 2),\n    new Conjugate(new Sequence([BareSiGNMove(\"L\", 2)]), new Sequence([BareSiGNMove(\"D\", -1)]), 2),\n    new Pause(),\n    new NewLine(),\n    new CommentShort(\"short comment\"),\n    new CommentLong(\"long comment\")\n  ];\n\n}\n","import {\n  AlgPart,\n  Sequence,\n  Group,\n  SiGNMove,\n  Commutator,\n  Conjugate,\n  Pause,\n  NewLine,\n  CommentShort,\n  CommentLong\n} from \"./algorithm\";\n\n// TODO: Turn this into a union.\nexport interface AlgJSON {\n  type: string;\n  nestedSequence?: AlgJSON;\n  nestedUnits?: AlgJSON[];\n  innerLayer?: number;\n  outerLayer?: number;\n  family?: string;\n  amount?: number;\n  A?: AlgJSON;\n  B?: AlgJSON;\n  comment?: string;\n}\n\nexport function fromJSON(json: AlgJSON): Sequence {\n  if (json.type !== \"sequence\") {\n    throw `Expected Sequence while parsing, got: ${json.type}`\n  }\n  if (!json.nestedUnits) { throw \"Missing nestedUnits\" }\n  return new Sequence(json.nestedUnits.map(j => unitFromJSON(j)));\n}\n\nfunction unitFromJSON(json: AlgJSON): AlgPart {\n  switch (json.type) {\n    case \"sequence\":\n      throw `Expected AlgPart while parsing, got \\`Sequence\\`.`\n    case \"group\":\n      if (!json.nestedSequence) { throw \"Missing nestedSequence\" }\n      if (!json.amount) { throw \"Missing amount\" }\n      return new Group(fromJSON(json.nestedSequence), json.amount);\n    case \"signMove\":\n      // TODO: Double-check that there is no outer layer without an inner layer?\n      if (!json.family) { throw \"Missing family\" }\n      if (!json.amount) { throw \"Missing amount\" }\n      return new SiGNMove(json.outerLayer, json.innerLayer, json.family, json.amount);\n    case \"commutator\":\n      if (!json.A) { throw \"Missing A\" }\n      if (!json.B) { throw \"Missing B\" }\n      if (!json.amount) { throw \"Missing amount\" }\n      return new Commutator(fromJSON(json.A), fromJSON(json.B), json.amount);\n    case \"conjugate\":\n      if (!json.A) { throw \"Missing A\" }\n      if (!json.B) { throw \"Missing B\" }\n      if (!json.amount) { throw \"Missing amount\" }\n      return new Conjugate(fromJSON(json.A), fromJSON(json.B), json.amount);\n    case \"pause\":\n      return new Pause();\n    case \"newLine\":\n      return new NewLine();\n    case \"commentShort\":\n      if (!json.comment) { throw \"Missing comment\" }\n      return new CommentShort(json.comment);\n    case \"commentLong\":\n      if (!json.comment) { throw \"Missing comment\" }\n      return new CommentLong(json.comment);\n    default:\n      throw `Unknown alg type: ${json.type}`;\n  }\n}\n","import {\n  Sequence,\n  Group,\n  SiGNMove,\n  Commutator,\n  Conjugate,\n  Pause,\n  NewLine,\n  CommentShort,\n  CommentLong\n} from \"./algorithm\";\n\nimport {TraversalUp} from \"./traversal\"\n\nexport class ValidationError extends Error {}\n\nexport abstract class ValidatorTraversal extends TraversalUp<void> {}\n\ntype FamilyList = { [s: string]: boolean; }\n\nfunction validateFamily(family: string, allowedFamilyLists: FamilyList[]): boolean {\n  for (var list of allowedFamilyLists) {\n    if (list[family] === true) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// TODO: Switch to `Set`?\nvar plainMoveFamilies: FamilyList = {\n  \"x\": true,\n  \"y\": true,\n  \"z\": true,\n  \"M\": true,\n  \"E\": true,\n  \"S\": true,\n  \"m\": true,\n  \"e\": true,\n  \"s\": true\n}\n\nvar singleSliceMoveFamilies: FamilyList = {\n  \"U\": true,\n  \"L\": true,\n  \"F\": true,\n  \"R\": true,\n  \"B\": true,\n  \"D\": true\n}\n\nvar wideMoveFamilies: FamilyList = {\n  \"u\": true,\n  \"l\": true,\n  \"f\": true,\n  \"r\": true,\n  \"b\": true,\n  \"d\": true,\n  \"Uw\": true,\n  \"Lw\": true,\n  \"Fw\": true,\n  \"Rw\": true,\n  \"Bw\": true,\n  \"Dw\": true\n}\n\nabstract class BaseMoveValidator extends ValidatorTraversal {\n  public traverseSequence(sequence: Sequence): void {\n    // TODO: Handle newLines and comments correctly\n    for (var unit of sequence.nestedUnits) {\n      this.traverse(unit);\n    }\n  }\n  public traverseGroup(group: Group): void {\n    return this.traverse(group.nestedSequence);\n  }\n  public traverseCommutator(commutator: Commutator): void {\n    this.traverse(commutator.A);\n    this.traverse(commutator.B);\n  }\n  public traverseConjugate(conjugate: Conjugate): void {\n    this.traverse(conjugate.A);\n    this.traverse(conjugate.B);\n  }\n  public traversePause(pause: Pause):                      void { return; }\n  public traverseNewLine(newLine: NewLine):                void { return; }\n  public traverseCommentShort(commentShort: CommentShort): void { return; }\n  public traverseCommentLong(commentLong: CommentLong):    void { return; }\n}\n\n// TODO: Export function instead?\nexport class SiGNMoveValidator extends BaseMoveValidator {\n  public traverseSiGNMove(signMove: SiGNMove): void {\n    if (typeof signMove.outerLayer !== \"undefined\") {\n      if (typeof signMove.innerLayer === \"undefined\") {\n        throw new ValidationError(\"A SiGNMove with an outer layer must have an inner layer.\");\n      }\n      if (!validateFamily(signMove.family, [wideMoveFamilies])) {\n        throw new ValidationError(`The provided SiGN move family is invalid, or cannot have an outer and inner layer: ${signMove.family}`);\n      }\n      if (signMove.outerLayer <= 0) {\n        throw new ValidationError(\"Cannot have an outer layer of 0 or less.\");\n      }\n      // TODO: Allow 2-2r?\n      if (signMove.outerLayer >= signMove.innerLayer) {\n        throw new ValidationError(\"The outer layer must be less than the inner layer.\");\n      }\n      return;\n    } else if (typeof signMove.innerLayer !== \"undefined\") {\n      if (!validateFamily(signMove.family, [wideMoveFamilies, singleSliceMoveFamilies])) {\n        throw new ValidationError(`The provided SiGN move family is invalid, or cannot have an inner slice: ${signMove.family}`);\n      }\n      if (signMove.innerLayer <= 0) {\n        throw new ValidationError(\"Cannot have an inner layer of 0 or less.\");\n      }\n      return;\n    } else {\n      if (!validateFamily(signMove.family, [wideMoveFamilies, singleSliceMoveFamilies, plainMoveFamilies])) {\n          throw new ValidationError(`Invalid SiGN plain move family: ${signMove.family}`);\n      }\n      return;\n    }\n  }\n}\n\n// TODO: Export function instead?\nexport class FlatAlgValidator extends ValidatorTraversal {\n\n  public traverseSequence(sequence: Sequence): void {\n    // TODO: Handle newLines and comments correctly\n    for (var unit of sequence.nestedUnits) {\n      this.traverse(unit);\n    }\n    return;\n  }\n  public traverseGroup(group: Group): void {\n    throw new ValidationError(\"A flat alg cannot contain a group.\");\n  }\n  public traverseSiGNMove(signMove: SiGNMove): void {\n    return;\n  }\n  public traverseCommutator(commutator: Commutator): void {\n    throw new ValidationError(\"A flat alg cannot contain a commutator.\");\n  }\n  public traverseConjugate(conjugate: Conjugate): void {\n    throw new ValidationError(\"A flat alg cannot contain a conjugate.\");\n  }\n  public traversePause(pause: Pause):                      void { return; }\n  public traverseNewLine(newLine: NewLine):                void { return; }\n  public traverseCommentShort(commentShort: CommentShort): void { return; }\n  public traverseCommentLong(commentLong: CommentLong):    void { return; }\n}\n\nexport type Validator = (a: Sequence) => void;\n\n\nconst SiGNMoveValidatorInstance = new SiGNMoveValidator();\nexport const validateSiGNMoves = <Validator>SiGNMoveValidatorInstance.traverse.bind(SiGNMoveValidatorInstance);\n\nconst flatAlgValidatorInstance = new FlatAlgValidator();\nexport const validateFlatAlg = <Validator>flatAlgValidatorInstance.traverse.bind(flatAlgValidatorInstance);\n\n// TODO: Option for puzzle size?\nexport const validateSiGNAlg = function(a: Sequence) {\n  validateSiGNMoves(a);\n  validateFlatAlg(a);\n}\n","import {Sequence} from \"./algorithm\"\nimport {fromJSON} from \"./json\"\nimport {parse as jison_parse} from \"./jison_parser\";\nimport {Validator, validateSiGNAlg} from \"./validation\"\n\nexport type ParseOptions = {\n  validators?: Validator[]\n}\n\n// TODO: Include token location info.\n// TODO: Take validators in a way that allows optimizing parsing.\nexport function parse(s: string, options: ParseOptions = {validators: []}): Sequence {\n  options.validators = options.validators || [];\n\n  const algo = fromJSON(jison_parse(s));\n  for (var validate of options.validators) {\n    validate(algo);\n  }\n  return algo;\n}\n\nexport function parseSiGN(s: string): Sequence {\n  return parse(s, {validators: [validateSiGNAlg]});\n}\n","import {SiGNMove, BareSiGNMove} from \"./algorithm\"\n\nconst cubeKeyMapping: {[key: number]: SiGNMove} = {\n  73: BareSiGNMove(\"R\"), 75: BareSiGNMove(\"R\", -1),\n  87: BareSiGNMove(\"B\"), 79: BareSiGNMove(\"B\", -1),\n  83: BareSiGNMove(\"D\"), 76: BareSiGNMove(\"D\", -1),\n  68: BareSiGNMove(\"L\"), 69: BareSiGNMove(\"L\", -1),\n  74: BareSiGNMove(\"U\"), 70: BareSiGNMove(\"U\", -1),\n  72: BareSiGNMove(\"F\"), 71: BareSiGNMove(\"F\", -1), // Heise\n  78: BareSiGNMove(\"F\"), 86: BareSiGNMove(\"F\", -1), //Kirjava\n\n  67: BareSiGNMove(\"l\"), 82: BareSiGNMove(\"l\", -1),\n  85: BareSiGNMove(\"r\"), 77: BareSiGNMove(\"r\", -1),\n\n  84: BareSiGNMove(\"x\"), 89: BareSiGNMove(\"x\"), 66: BareSiGNMove(\"x\", -1), // 84 (T) and 89 (Y) are alternatives.\n  186: BareSiGNMove(\"y\"), 59: BareSiGNMove(\"y\"), 65: BareSiGNMove(\"y\", -1), // 186 is WebKit, 59 is Mozilla; see http://unixpapa.com/js/key.html\n  80: BareSiGNMove(\"z\"), 81: BareSiGNMove(\"z\", -1),\n\n  190: BareSiGNMove(\"M\", -1),\n}\n\n// TODO: options about whether to ignore modifier keys (e.g. alt, ctrl).\n// TODO: Support different mappings.\n// TODO: Return BaseMove instead?\nexport function keyToMove(e: KeyboardEvent): SiGNMove | null {\n  if(e.altKey || e.ctrlKey) {\n    return null;\n  }\n\n  return cubeKeyMapping[e.keyCode] || null;\n}\n","import {Sequence} from \"./algorithm\"\nimport {algToString} from \"./traversal\"\nimport {parse} from \"./parser\"\n\n// This is not the most sophisticated scheme, but it has been used in production\n// at alg.cubing.net for years.\nexport function serializeURLParam(a: Sequence): string {\n  var escaped = algToString(a);\n  escaped = escaped.replace(/_/g, \"&#95;\").replace(/ /g, \"_\");\n  escaped = escaped.replace(/\\+/g, \"&#2b;\");\n  escaped = escaped.replace(/-/g, \"&#45;\").replace(/'/g, \"-\");\n  return escaped;\n}\n\nexport function deserializeURLParam(a: string): Sequence {\n  var unescaped = a;\n  unescaped = unescaped.replace(/-/g, \"'\").replace(/&#45;/g, \"-\");\n  unescaped = unescaped.replace(/\\+/g, \" \").replace(/&#2b;/g, \"+\"); // Recognize + as space. Many URL encodings will do this.\n  unescaped = unescaped.replace(/_/g, \" \").replace(/&#95;/g, \"_\");\n  return parse(unescaped);\n}\n\n// Returns an empty sequence if the parameter is not present.\n// Throws an error if an alg is present but not valid.\nexport function getAlgURLParam(name: string): Sequence {\n  const s = new URLSearchParams(window.location.search).get(name) || \"\";\n  return deserializeURLParam(s);\n}\n\nexport type AlgCubingNetOptions = {\n  alg?: Sequence;\n  setup?: Sequence;\n  puzzle?: \"1x1x1\" | \"2x2x2\" | \"3x3x3\" | \"4x4x4\" | \"5x5x5\" | \"6x6x6\" | \"7x7x7\" | \"8x8x8\" | \"9x9x9\" | \"10x10x10\" | \"11x11x11\" | \"12x12x12\" | \"13x13x13\" | \"14x14x14\" | \"16x16x16\" | \"17x17x17\";\n  stage?: \"full\" | \"cross\" | \"F2L\" | \"LL\" | \"OLL\" | \"PLL\" | \"CLS\" | \"ELS\" | \"L6E\" | \"CMLL\" | \"WV\" | \"ZBLL\" | \"void\";\n  view?: \"editor\" | \"playback\" | \"fullscreen\"\n  type?: \"moves\" | \"reconstruction\" | \"alg\" | \"reconstruction-end-with-setup\"\n}\n\n// TODO: runtime validation?\nexport function algCubingNetLink(options: AlgCubingNetOptions) {\n  var url = new URL(\"https://alg.cubing.net\")\n  if (!options.alg) {\n    throw (\"An alg parameter is required.\");\n  }\n  url.searchParams.set(\"alg\", serializeURLParam(options.alg))\n\n  if (options.setup) {\n    url.searchParams.set(\"setup\", serializeURLParam(options.setup))\n  }\n  if (options.puzzle) {\n    if ([\"1x1x1\", \"2x2x2\", \"3x3x3\", \"4x4x4\", \"5x5x5\", \"6x6x6\", \"7x7x7\", \"8x8x8\", \"9x9x9\", \"10x10x10\", \"11x11x11\", \"12x12x12\", \"13x13x13\", \"14x14x14\", \"16x16x16\", \"17x17x17\"].indexOf(options.puzzle) === -1) {\n      throw `Invalid puzzle parameter: ${options.puzzle}`\n    }\n    url.searchParams.set(\"puzzle\", options.puzzle);\n  }\n  if (options.stage) {\n    if ([\"full\", \"cross\", \"F2L\", \"LL\", \"OLL\", \"PLL\", \"CLS\", \"ELS\", \"L6E\", \"CMLL\", \"WV\", \"ZBLL\", \"void\"].indexOf(options.stage) === -1) {\n      throw `Invalid stage parameter: ${options.stage}`\n    }\n    url.searchParams.set(\"stage\", options.stage);\n  }\n  if (options.view) {\n    if ([\"editor\", \"playback\", \"fullscreen\"].indexOf(options.view) === -1) {\n      throw `Invalid view parameter: ${options.view}`\n    }\n    url.searchParams.set(\"view\", options.view);\n  }\n  if (options.type) {\n    if ([\"moves\", \"reconstruction\", \"alg\", \"reconstruction-end-with-setup\"].indexOf(options.type) === -1) {\n      throw `Invalid type parameter: ${options.type}`\n    }\n    url.searchParams.set(\"type\", options.type);\n  }\n  return url.toString();\n}\n"],"sourceRoot":""}