
<r><B><6>1 colscan.mll</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: colscan.mll,v 1.5 2001/05/25 12:37:20 maranget Exp $          *)
     (***********************************************************************)
     </w>{
     <b><U>open</U><r> Lexing
     
  </r><m>15 </m><U>exception</U></b> Error <b><U>of</U><r> string
     ;;
     
     </r><U>let</U></b> buf = Out.create_buff ()
     ;;
  <m>20 <r>}
     rule one = parse
       ' '*('0'|'1')?'.'?['0'-'9']*' '*
       {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
       float_of_string lxm}
  </r>25 <r>| "" {raise (Error "Syntax error in color argument")}
     
     <b><U>and</U></b> other = parse
       ' '* ',' {one lexbuf}
     |  ""      {raise (Error "Syntax error in color argument")}
  </r>30 
     <b><U>and</U></b></m> three = parse
       ""
       {<b><U>let</U><r> fst = one lexbuf </r><U>in</U>
       <U>let</U></b> snd = other lexbuf <b><U>in</U><m>
  35   </m><U>let</U></b> thrd = other lexbuf <b><U>in</U><r>
       fst,snd,thrd}
     </r><U>and</U></b> four = parse
       ""
       {<b><U>let</U><r> fst = one lexbuf </r><U>in</U><m>
  40   </m><U>let</U></b> snd = other lexbuf <b><U>in</U>
       <U>let</U></b> thrd = other lexbuf <b><U>in</U>
       <U>let</U></b> fourth = other lexbuf <b><U>in</U></b>
       fst,snd,thrd,fourth}</TT>
<6><B>2 cut.mll</B></6>
<TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <r>{
     <b><U>open</U><r> Lexing
     </r><U>open</U></b> Stack
  <m>15 <b><U>let</U></b></m> header = "$Id: cut.mll,v 1.30 2001/05/25 09:07:07 maranget Exp $"
     
     <b><U>let</U><r> verbose = ref 0
     ;;
     
  </r><m>20 </m><U>let</U></b> language = ref "eng"
     ;;
     
     <b><U>let</U><r> tocbis = ref </r><U>false</U></b>
     ;;
  <m>25 
     <b><U>exception</U></b></m> Error <b><U>of</U></b> string
     
     
     </r>(* Accumulate all META, LINK and similar tags that appear in the preamble
  <m>30    <w>in order to output them in the preamble of every generated page. *)
     
     <b><U>let</U><r> header_buff = Out.create_buff ()
     </r><U>let</U><r> common_headers = ref "";;
     
  <m>35 <b><U>let</U></b></m> adjoin_to_header s = Out.put header_buff s
     
     <b><U>and</U><r> adjoin_to_header_char c = Out.put_char header_buff c
     
     </r><U>and</U></b> finalize_header () =
  <m>40   <r>common_headers := Out.to_string header_buff
     
     <b><U>let</U><r> html_buff = Out.create_buff ()
     </r><U>let</U></b> html_head = ref ""
     <b><U>and</U></b> html_foot = ref ""
  </r>45 
     <b><U>let</U></b></m> phase = ref (-1)
     ;;
     
     <b><U>let</U><r> name = ref "main"
  </r><m>50 </m><U>and</U></b> count = ref 0
     ;;
     
     <b><U>let</U><r> body = ref "&lt;BODY&gt;"
     </r><U>and</U></b> doctype = ref ""
  <m>55 <b><U>and</U></b></m> html = ref "&lt;HTML&gt;"
     ;;
     
     <b><U>let</U><r> changed_t = Hashtbl.create 17
     
  </r><m>60 </m><U>let</U> <U>rec</U></b> check_changed name =
       <b><U>try</U>
         <U>let</U></b> r = Hashtbl.find changed_t name <b><U>in</U><r>
         check_changed r
       </r><U>with</U><m>
  65   <r>| Not_found -&gt; name
     
     <b><U>let</U><r> new_filename () =
       incr count ;
       </r><U>let</U></b> r1 = Printf.sprintf "%s%0.3d.html" !name !count <b><U>in</U><m>
  70   </m><U>let</U></b> r2 = check_changed r1 <b><U>in</U><r>
       r2
     ;;
     
     </r><U>let</U></b> out = ref (Out.create_null ())
  </r>75 </m><U>and</U></b> out_prefix = ref (Out.create_null ())
     <b><U>and</U><r> outname = ref ""
     </r><U>and</U></b> lastclosed = ref ""
     <b><U>and</U><r> otheroutname = ref ""
     </r><U>and</U></b> flowname_stack = (Stack.create "flowname" : string Stack.t)
  <m>80 <b><U>and</U></b></m> flow_stack = (Stack.create "flow" : Out.t Stack.t)
     ;;
     
     <b><U>let</U><r> toc = ref !out
     </r><U>and</U></b> tocname = ref !outname
  <m>85 <b><U>and</U></b></m> otherout = ref !out
     ;;
     
     <b><U>let</U><r> change_name oldname name =
       </r><U>if</U></b> !phase &lt;= 0 <b><U>then</U> <U>begin</U><m>
  90     <r>Thread.change oldname name ;
         Cross.change oldname name ;
         outname := name ;
         Hashtbl.add changed_t oldname name
       <b><U>end</U><m>
  95 
     
     </m><U>let</U></b> start_phase name =
       incr phase ;
       <b><U>if</U><r> !verbose &gt; 0 </r><U>then</U><m>
 100     <r>prerr_endline ("Starting phase number: "^string_of_int !phase);
       outname := name ;
       tocname := name ;
       otheroutname := "" ;
       count := 0 ;
 </r>105   </m><U>if</U></b> !phase &gt; 0 <b><U>then</U> <U>begin</U></b>
         out := (Out.create_chan (open_out name))
       <b><U>end</U></b> ;
       toc := !out
     ;;
 </r>110 
     </m><U>let</U></b> openlist out = Out.put out "&lt;UL&gt;\n"
     <b><U>and</U><r> closelist out = Out.put out "&lt;/UL&gt;\n"
     </r><U>and</U></b> itemref filename s out =
       Out.put out "&lt;LI&gt;" ;
 <m>115   <r>Out.put out "&lt;A HREF=\"" ;
       Out.put out filename ;
       Out.put out "\"&gt;" ;
       Out.put out s ;
       Out.put out "&lt;/A&gt;\n"
 </r>120 
     <b><U>and</U></b></m> itemanchor filename label s out =
       Out.put out "&lt;LI&gt;" ;
       Out.put out "&lt;A HREF=\"" ;
       Out.put out filename ;
 <m>125   <r>Out.put_char out '#' ;
       Out.put out label ;
       Out.put out "\"&gt;" ;
       Out.put out s ;
       Out.put out "&lt;/A&gt;\n"
 </r>130 
     <b><U>and</U></b></m> putanchor label out =
       Out.put out "&lt;A NAME=\"" ;
       Out.put out label ;
       Out.put out "\"&gt;&lt;/A&gt;"
 <m>135 
     <b><U>and</U></b></m> itemlist s out =
       Out.put out "&lt;LI&gt;" ;
       Out.put out s
     ;;
 <m>140 
     <b><U>let</U></b></m> putlink out name img alt =
       Out.put out "&lt;A HREF=\"" ;
       Out.put out name ;
       Out.put out "\"&gt;&lt;IMG SRC =\"" ;
 <m>145   <r>Out.put out img ;
       Out.put out "\" ALT=\"" ;
       Out.put out alt ;
       Out.put out "\"&gt;&lt;/A&gt;\n"
     ;;
 </r>150 
     <b><U>let</U></b></m> link_buff = Out.create_buff ()
     
     <b><U>let</U><r> putlinks  name =
       </r><U>let</U></b> links_there = ref <b><U>false</U> <U>in</U><m>
 155   </m><U>if</U></b> !verbose &gt; 0 <b><U>then</U><r>
         prerr_endline ("putlinks: "^name) ;
       </r><U>begin</U> <U>try</U></b>
         putlink link_buff (Thread.prev name) "previous_motif.gif"
           (<b><U>if</U><r> !language = "fra" </r><U>then</U></b> "Precedent"
 <m>160        <b><U>else</U></b></m> "Previous") ;
         links_there := <b><U>true</U>
       <U>with</U></b> Not_found -&gt; () <b><U>end</U><r> ;
       </r><U>begin</U> <U>try</U></b>
         putlink link_buff (Thread.up name) "contents_motif.gif"
 <m>165       <r>(<b><U>if</U><r> !language = "fra" </r><U>then</U></b> "Index"
            <b><U>else</U><r> "Contents") ;
         links_there := </r><U>true</U>
       <U>with</U></b> Not_found -&gt; () <b><U>end</U><r> ;
       </r><U>begin</U> <U>try</U><m>
 170     <r>putlink link_buff (Thread.next name) "next_motif.gif"
           (<b><U>if</U><r> !language = "fra" </r><U>then</U></b> "Suivant"
            <b><U>else</U><r> "Next") ;
         links_there := </r><U>true</U>
       <U>with</U></b> Not_found -&gt; () <b><U>end</U></b> ;
 </r>175   </m><U>if</U></b> !links_there <b><U>then</U><r>
         Some (Out.to_string link_buff)
       </r><U>else</U></b>
         None
     
 </r>180 <b><U>let</U></b></m> putlinks_start out outname = <b><U>match</U><r> putlinks outname </r><U>with</U></b>
     | Some s -&gt;
         Out.put out s ;
         Out.put out "&lt;HR&gt;\n"
     | None -&gt; ()
 <m>185 
     <b><U>let</U></b></m> putlinks_end out outname = <b><U>match</U><r> putlinks outname </r><U>with</U></b>
     | Some s -&gt;
         Out.put out "&lt;HR&gt;\n" ;
         Out.put out s
 <m>190 <r>| None -&gt; ()
     
     
     <b><U>let</U></b> openhtml withlinks title out outname =
       Out.put out !doctype ; Out.put_char out '\n' ;
 </r>195   <r>Out.put out !html ; Out.put_char out '\n' ;
       Out.put out "&lt;HEAD&gt;\n" ;
       Out.put out !common_headers;
       Out.put out "&lt;TITLE&gt;\n" ;
       <b><U>let</U><r> title = Save.tagout (Lexing.from_string title) </r><U>in</U><m>
 200   <r>Out.put out title ;
       Out.put out "\n&lt;/TITLE&gt;\n" ;
       Out.put out "&lt;/HEAD&gt;\n" ;
       Out.put out !body;
       Out.put out "\n" ;
 </r>205   </m><U>if</U></b> withlinks <b><U>then</U></b>
         putlinks_start out outname ;
       Out.put out !html_head
     
     
 </r>210 <b><U>and</U></b></m> closehtml withlinks name out =
       Out.put out !html_foot ;
       <b><U>if</U><r> withlinks </r><U>then</U> <U>begin</U></b>
         putlinks_end out name
       <b><U>end</U><r> ;
 </r><m>215   <r>Out.put out "&lt;/BODY&gt;\n" ;
       Out.put out "&lt;/HTML&gt;\n" ;
       Out.close out
     ;;
     
 </r>220 </m><U>let</U></b> put_sec hd title hde out =
       Out.put out hd ;
       Out.put_char out '\n' ;
       Out.put out title ;
       Out.put out hde ;
 <m>225   <r>Out.put_char out '\n'
     ;;
     
     
     <b><U>let</U></b> put s = Out.put !out s
 </r>230 <b><U>and</U></b></m> put_char c = Out.put_char !out c
     ;;
     
     <b><U>let</U><r> cur_level = ref (Section.value "DOCUMENT")
     </r><U>and</U></b> chapter = ref (Section.value "CHAPTER")
 <m>235 <b><U>and</U><r> depth = ref 2
     ;;
     
     
     </r><w>(* Open all lists in toc from chapter to sec, with sec &gt; chapter *)
 <m>240 <b><U>let</U> <U>rec</U><r> do_open l1 l2 =
       <b><U>if</U><r> l1 &lt; l2 </r><U>then</U> <U>begin</U></b>
         openlist !toc ;
         <b><U>if</U><r> !tocbis </r><U>then</U></b> openlist !out_prefix ;
         do_open (l1+1) l2
 </r></b>245   <b><U>end</U><r>
     ;;
     
     </r><w>(* close from l1 down to l2 *)
     </w><U>let</U> <U>rec</U><r> do_close l1 l2 =
 </r></b>250   <b><U>if</U><r> l1 &gt; l2 </r><U>then</U> <U>begin</U><r>
          closelist !toc ;
          <b><U>if</U><r> !tocbis </r><U>then</U></b> closelist !out_prefix ;
          do_close (l1-1) l2
       <b><U>end</U> <U>else</U><m>
 255   <r>cur_level := l1
     ;;
     
     <b><U>let</U></b> anchor = ref 0
     ;;
 </r>260 
     </m><U>let</U></b> open_section sec name =
       <b><U>if</U><r> !phase &gt; 0 </r><U>then</U> <U>begin</U>
         <U>if</U></b> !cur_level &gt; sec <b><U>then</U><r> do_close !cur_level sec
         </r><U>else</U> <U>if</U></b> !cur_level &lt; sec <b><U>then</U></b> do_open  !cur_level sec ;
 </r></b>265     <r>incr anchor ;
         <b><U>let</U><r> label = "toc"^string_of_int !anchor </r><U>in</U></b>
         itemanchor !outname label name !toc ;
         <b><U>if</U><r> !tocbis </r><U>then</U></b> itemanchor !outname label name !out_prefix ;
         putanchor label !out ;
 </r>270     <r>cur_level := sec
       <b><U>end</U> <U>else</U></b>
         cur_level := sec
     
     <b><U>and</U></b> close_section sec =
 </r>275   <b><U>if</U><r> !phase &gt; 0 </r><U>then</U><r> do_close !cur_level sec
       <b><U>else</U></b>
         cur_level := sec
     ;;
     
 </r></b>280 <b><U>let</U><r> close_chapter () =
       </r><U>if</U><r> !verbose &gt; 0 <b><U>then</U><r>
         prerr_endline ("Close chapter out="^ !outname^" toc="^ !tocname) ;
       </r><U>if</U></b> !phase &gt; 0 <b><U>then</U> <U>begin</U></b>
         closehtml <b><U>true</U></b> !outname !out ;
 </r></b>285     <b><U>if</U><r> !tocbis </r><U>then</U> <U>begin</U>
           <U>let</U><r> real_out = open_out !outname <b><U>in</U></b>
           Out.to_chan real_out !out_prefix ;
           Out.to_chan real_out !out ;
           close_out real_out
 </r></b>290     <b><U>end</U> <U>else</U><r>
           Out.close !out ;
         out := !toc
       <b><U>end</U> <U>else</U> <U>begin</U></b>
         lastclosed := !outname ;
 </r></b>295     <r>outname := !tocname
       <b><U>end</U>
     
     <U>and</U></b> open_chapter name =
       outname := new_filename () ;
 </r>300   <b><U>if</U><r> !verbose &gt; 0 </r><U>then</U><r>
         prerr_endline
           ("Open chapter out="^ !outname^" toc="^ !tocname^
            " cur_level="^string_of_int !cur_level) ;
       <b><U>if</U><r> !phase &gt; 0 </r><U>then</U> <U>begin</U><m>
 305     </m><U>if</U></b> !tocbis <b><U>then</U> <U>begin</U></b>
           out_prefix := Out.create_buff () ;
           out := !out_prefix ;
           openhtml <b><U>true</U><r> name !out_prefix !outname
         </r><U>end</U> <U>else</U> <U>begin</U><m>
 310       <r>out := Out.create_chan (open_out !outname) ;
           openhtml <b><U>true</U><r> name !out !outname
         </r><U>end</U></b> ;
         itemref !outname name !toc ;
         cur_level := !chapter
 </r>315   </m><U>end</U> <U>else</U> <U>begin</U>
         <U>if</U></b> !verbose &gt; 0 <b><U>then</U></b>
           prerr_endline ("link prev="^ !lastclosed^" next="^ !outname) ;
         Thread.setup !outname !tocname ;
         Thread.setprevnext !lastclosed !outname ;
 </r></b>320     <r>cur_level := !chapter
       <b><U>end</U><r>
     ;;
     </r><U>let</U></b> setlink set target =
       <b><U>if</U><r> !phase = 0 &amp;&amp; target &lt;&gt; "" </r><U>then</U><m>
 325     <r>set !outname target
     
     <b><U>let</U><r> open_notes sec_notes =
       </r><U>if</U></b> sec_notes &lt;&gt; !chapter || !outname = !tocname <b><U>then</U> <U>begin</U></b>
         otheroutname := !outname ;
 </r>330     <r>outname := new_filename () ;
         <b><U>if</U><r> !phase &gt; 0 </r><U>then</U> <U>begin</U></b>
           otherout := !out ;
           out := Out.create_chan (open_out !outname) ;
           Out.put !out !doctype ; Out.put_char !out '\n' ;
 </r>335       <r>Out.put !out !html ; Out.put_char !out '\n' ;
           Out.put !out "&lt;HEAD&gt;&lt;TITLE&gt;Notes&lt;/TITLE&gt;\n" ;
           Out.put !out !common_headers ;
           Out.put !out "&lt;/HEAD&gt;\n" ;
           Out.put !out !body ;
 </r>340       <r>Out.put !out "\n"
         <b><U>end</U>
       <U>end</U> <U>else</U></b>
        otheroutname := ""
     
 </r>345 </m><U>and</U></b> close_notes () =
       <b><U>if</U><r> !otheroutname &lt;&gt; "" </r><U>then</U> <U>begin</U></b>
          Out.put !out "\n&lt;/BODY&gt;&lt;/HTML&gt;\n" ;
          Out.close !out ;
          outname := !otheroutname ;
 </r>350      <r>out := !otherout ;
          otheroutname := ""
       <b><U>end</U></b>
     ;;
     
 </r>355 <b><U>let</U><r> toc_buf = Out.create_buff ()
     </r><U>and</U><r> arg_buf = Out.create_buff ()
     ;;
     
     <b><U>let</U></b> stack = Stack.create "main"
 </r></b>360 <r>;;
     
     <b><U>let</U><r> save_state newchapter newdepth =
       </r><U>if</U></b> !verbose &gt; 0 <b><U>then</U></b>
         prerr_endline ("New state: "^string_of_int newchapter) ;
 </r>365   <r>push stack
         (!outname, Stack.save flowname_stack, Stack.save flow_stack,
          !chapter,!depth,!toc,!tocname,!cur_level,!lastclosed,!out_prefix) ;
       chapter := newchapter ;
       depth := newdepth ;
 </r>370   <r>tocname := !outname ;
       lastclosed := "" ;
       toc := !out
     ;;
     
 </r>375 <b><U>let</U><r> restore_state () =
       </r><U>if</U><r> !verbose &gt; 0 <b><U>then</U><r> prerr_endline ("Restore") ;
       </r><U>let</U></b>
         oldoutname, oldflowname, oldflow,
         oldchapter,olddepth,oldtoc,oldtocname,
 </r></b>380     <r>oldlevel,oldlastclosed,oldprefix  = pop stack <b><U>in</U></b>
       outname := oldoutname ;
       Stack.restore flowname_stack oldflowname ;
       Stack.restore flow_stack oldflow ;
       chapter := oldchapter ;
 </r>385   <r>depth := olddepth ;
       toc := oldtoc ;
       tocname := oldtocname ;
       lastclosed := !lastclosed ;
       cur_level := oldlevel ;
 </r>390   <r>out_prefix := oldprefix
     ;;
     
     <b><U>let</U><r> hevea_footer = ref </r><U>false</U><m>
     
 395 </m><U>let</U></b> close_top lxm =
       putlinks_end !toc !tocname ;
       <b><U>if</U><r> !hevea_footer </r><U>then</U> <U>begin</U></b>
         Out.put !out "&lt;!--FOOTER--&gt;\n" ;
         <b><U>begin</U> <U>try</U><m>
 400       <r>Mysys.put_from_file
             (Filename.concat Mylib.libdir ("cutfoot-"^ !language^".html"))
             (Out.put !out)
         <b><U>with</U><r> Mysys.Error s -&gt; </r><U>begin</U></b>
           Location.print_pos () ;
 </r>405       <r>prerr_endline s
         <b><U>end</U>
         <U>end</U>
       <U>end</U></b> ;
       Out.put !toc lxm ;
 </r>410   </m><U>if</U></b> !tocname = "" <b><U>then</U><r>
         Out.flush !toc
       </r><U>else</U></b>
        Out.close !toc
     ;;
 </r>415 
     <b><U>let</U><r> open_toc () = </r><U>if</U><r> !phase &gt; 0 <b><U>then</U><r> openlist !toc
     </r><U>and</U></b> close_toc () = <b><U>if</U><r> !phase &gt; 0 </r><U>then</U></b> closelist !toc
     ;;
     
 </r></b>420 <b><U>let</U><r> close_all () =
       </r><U>if</U><r> !cur_level &gt; !chapter <b><U>then</U> <U>begin</U></b>
         close_section !chapter ;
         close_chapter () ;
         close_toc ()
 </r></b>425   <b><U>end</U> <U>else</U> <U>if</U><r> !cur_level = !chapter <b><U>then</U> <U>begin</U></b>
         close_chapter () ;
         close_toc ()
       <b><U>end</U></b> ;
       cur_level := (Section.value "DOCUMENT")
 </r></b>430 
     <b><U>let</U><r> openflow title =
       </r><U>let</U><r> new_outname = new_filename () <b><U>in</U></b>
       push flowname_stack !outname ;
       outname := new_outname ;
 </r></b>435   <b><U>if</U><r> !phase &gt; 0 </r><U>then</U> <U>begin</U><r>
         push flow_stack !out ;
         out := Out.create_chan (open_out !outname) ;
         openhtml <b><U>false</U><r> title !out !outname
       </r><U>end</U><m>
 440 
     </m><U>and</U></b> closeflow () =
       <b><U>if</U><r> !phase &gt; 0 </r><U>then</U> <U>begin</U></b>
         closehtml <b><U>false</U></b> !outname !out;
         Out.close !out ;
 </r></b>445     <r>out := pop flow_stack
       <b><U>end</U></b> ;
       outname := pop flowname_stack
     
     
 </r>450 <r>}
     
       rule main = parse
     | "&lt;!--HEVEA" [^'&gt;']* "--&gt;" '\n'?
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U><m>
 455     </m><U>if</U></b> !phase &gt; 0 <b><U>then</U> <U>begin</U></b>
           put lxm ;
           put ("&lt;!--HACHA command line is: ") ;
           <b><U>for</U><r> i = 0 </r><U>to</U></b> Array.length Sys.argv - 1 <b><U>do</U></b>
             put Sys.argv.(i) ;
 </r>460         <r>put_char ' '
           <b><U>done</U><r> ;
           put "--&gt;\n"
         </r><U>end</U></b> ;
         main lexbuf}
 </r>465 <r>|  "&lt;!--" "FLOW" ' '+
        {<b><U>let</U><r> title = flowline lexbuf </r><U>in</U></b>
        openflow title ;
        main lexbuf}
     | "&lt;!--" "LINKS" ' '+
 </r>470    <r>{linkline lexbuf ;
        main lexbuf}
     | "&lt;!--" "END" ' '+ "FLOW" ' '* "--&gt;" '\n'?
        {closeflow () ;
        main lexbuf}
 </r>475 <r>| "&lt;!--" "NAME" ' '+
         {<b><U>let</U><r> name = tocline lexbuf </r><U>in</U></b>
         change_name !outname name ;
         main lexbuf}
     |  "&lt;!--" ("TOC"|"toc") ' '+
 </r>480     <r>{<b><U>let</U><r> arg = secname lexbuf </r><U>in</U>
         <U>let</U></b> sn =
           <b><U>if</U><r> String.uppercase arg = "NOW" </r><U>then</U></b> !chapter
           <b><U>else</U><r> Section.value arg </r><U>in</U>
         <U>let</U></b> name = tocline lexbuf <b><U>in</U><m>
 485     </m><U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
           prerr_endline ("TOC "^arg^" "^name)
         <b><U>end</U><r>;
         </r><U>if</U></b> sn &lt; !chapter <b><U>then</U> <U>begin</U>
           <U>if</U></b> !cur_level &gt;= !chapter <b><U>then</U> <U>begin</U><m>
 490         <r>close_section (!chapter) ;
             close_chapter () ;
             close_toc ()
           <b><U>end</U></b> ;
           cur_level := sn
 </r>495     </m><U>end</U> <U>else</U> <U>if</U></b> sn = !chapter <b><U>then</U> <U>begin</U>
           <U>if</U></b> !cur_level &lt; sn <b><U>then</U> <U>begin</U></b>
             open_toc () ;
           <b><U>end</U> <U>else</U> <U>begin</U></b>
             close_section !chapter ;
 </r>500         <r>close_chapter  ()
           <b><U>end</U><r> ;
           open_chapter name
         </r><U>end</U> <U>else</U> <U>if</U></b> sn &lt;= !chapter + !depth <b><U>then</U> <U>begin</U><w> (* sn &gt; !chapter *)
           </w><U>if</U></b> !cur_level &lt; !chapter <b><U>then</U> <U>begin</U><m>
 505         <r>open_toc () ;
             open_chapter ""
           <b><U>end</U></b> ;
           close_section sn ;
           open_section sn name
 </r>510     </m><U>end</U></b> ;
         main lexbuf}
     | "&lt;!--CUT DEF" ' '+
         {<b><U>let</U><r> chapter = Section.value (String.uppercase (secname lexbuf)) </r><U>in</U></b>
         skip_blanks lexbuf;
 </r>515     <b><U>let</U><r> depth = intarg lexbuf </r><U>in</U><r>
         skip_endcom lexbuf ;
         save_state chapter depth ;
         cur_level := Section.value "DOCUMENT" ;
         main lexbuf}
 <m>520 </m>| "&lt;!--SEC END" ' '* "--&gt;" '\n'?
         {<b><U>if</U><r> !phase &gt; 0 </r><U>then</U> <U>begin</U>
           <U>if</U></b> !tocbis &amp;&amp; !out == !out_prefix <b><U>then</U><r>
             out := Out.create_buff ()
         </r><U>end</U></b> ;
 <m>525     </m>main lexbuf}
     | "&lt;!--CUT END" ' '* "--&gt;" '\n'?
         {close_all () ;
           restore_state () ;
           main lexbuf}
 <m>530 </m>| "&lt;!--BEGIN" ' '+ "NOTES" ' '+
         {<b><U>let</U><r> sec_notes = secname lexbuf </r><U>in</U></b>
         skip_endcom lexbuf ;
         open_notes (Section.value sec_notes) ;
         main lexbuf}
 <m>535 </m>| "&lt;!--END" ' '+ "NOTES" ' '* "--&gt;" '\n'?
         {<b><U>if</U><r> !otheroutname &lt;&gt; "" </r><U>then</U></b>
           close_notes ();
           main lexbuf}
     | "&lt;!--" ' '* "FRENCH" ' '* "--&gt;"
 <m>540     </m>{language := "fra" ;
           main lexbuf}
     | "&lt;A" ' '+
         {<b><U>if</U><r> !phase &gt; 0 </r><U>then</U></b> put (lexeme lexbuf) ;
         aargs lexbuf}
 <m>545 </m>| "&lt;!--HTML" ' '* "HEAD" ' '* "--&gt;" '\n' ?
         {<b><U>let</U><r> head = save_html lexbuf </r><U>in</U>
         <U>if</U></b> !phase = 0 <b><U>then</U></b>
           html_head := head
         </r><U>else</U></b>
 550       <r>Out.put !out head;
         main lexbuf}
     | "&lt;!--HTML" ' '* "FOOT" ' '* "--&gt;" '\n' ?
         {<b><U>let</U><r> foot =  save_html lexbuf </r><U>in</U>
         <U>if</U></b> !phase = 0 <b><U>then</U><m>
 555       <r>html_foot := foot ;
         main lexbuf}
     | "&lt;!--FOOTER--&gt;" '\n'?
         {close_all () ;
           <b><U>if</U><r> !phase &gt; 0 </r><U>then</U> <U>begin</U><m>
 560         <r>hevea_footer := <b><U>true</U><r> ;
             Out.put !out !html_foot
           </r><U>end</U></b> ;
           footer lexbuf}
     | "&lt;!DOCTYPE"  [^'&gt;']* '&gt;'
 </r>565     <r>{<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>if</U></b> !phase = 0 <b><U>then</U><r>
           doctype := lxm
         </r><U>else</U></b>
           Out.put !out lxm;
 </r>570     <r>main lexbuf}
     | "&lt;HTML"  [^'&gt;']* '&gt;'
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>if</U></b> !phase = 0 <b><U>then</U></b>
           html := lxm
 </r>575     </m><U>else</U></b>
           Out.put !out lxm;
         main lexbuf}
     | "&lt;BODY" [^'&gt;']* '&gt;'
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U><m>
 580     </m><U>if</U></b> !phase = 0 <b><U>then</U><r>
           body := lxm
         </r><U>else</U> <U>begin</U></b>
           Out.put !out lxm ;
           putlinks_start !out !outname
 </r>585     </m><U>end</U></b> ;
         main lexbuf}
     | "&lt;HEAD" [^'&gt;']* '&gt;'
         {put (lexeme lexbuf);
           <b><U>if</U><r> !phase = 0 </r><U>then</U> <U>begin</U><m>
 590         </m><U>if</U></b> !verbose &gt; 0 <b><U>then</U><r> prerr_endline "Collect header" ;
             collect_header lexbuf
           </r><U>end</U> <U>else</U></b>
             main lexbuf}
     | "&lt;/BODY&gt;"
 </r>595     <r>{<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
         close_all () ;
         <b><U>if</U><r> !phase &gt; 0 </r><U>then</U> <U>begin</U></b>
           close_top lxm
         <b><U>end</U></b>}
 </r>600 <r>|  _
         {<b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U>
         <U>if</U></b> !phase &gt; 0 <b><U>then</U></b> put_char lxm ;
         main lexbuf}
     | eof
 </r>605     <r>{raise (Error ("No &lt;/BODY&gt; tag in input file"))}
     
     <b><U>and</U><r> save_html = parse
     | "&lt;!--END" ' '* ['A'-'Z']+ ' '* "--&gt;" '\n'?
         {</r><U>let</U></b> s = Out.to_string html_buff <b><U>in</U><m>
 610     </m><U>if</U></b> !verbose &gt; 0 <b><U>then</U><r>
           prerr_endline ("save_html -&gt; ``"^s^"''");
         s}
     |  _
         {</r><U>let</U></b> lxm = lexeme_char lexbuf 0 <b><U>in</U><m>
 615     <r>Out.put_char html_buff lxm ;
         save_html lexbuf}
     | eof
         {raise (Misc.Fatal ("End of file in save_html"))}
     
 </r>620 </m><U>and</U></b> collect_header = parse
     | "&lt;/HEAD&gt;"
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
         finalize_header () ;
         <b><U>if</U><r> !verbose &gt; 0 </r><U>then</U> <U>begin</U><m>
 625       <r>prerr_string "Header is: ``" ;
           prerr_string !common_headers ;
           prerr_endline "''"
         <b><U>end</U></b> ;
         main lexbuf}
 </r>630 
     <r>| "&lt;TITLE" [^'&gt;']* '&gt;'
         {skip_title lexbuf ;
           collect_header lexbuf}
     | _
 </r>635     <r>{<b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U></b>
         adjoin_to_header_char lxm;
         collect_header lexbuf}
     
     <b><U>and</U></b> skip_title = parse
 </r>640 <r>|  "&lt;/TITLE&gt;" '\n'? {()}
     |  _          {skip_title lexbuf}
     
     <b><U>and</U></b> footer = parse
         "&lt;/BODY&gt;" _*
 </r>645     <r>{<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>if</U></b> !phase &gt; 0 <b><U>then</U> <U>begin</U></b>
           close_top lxm
         <b><U>end</U></b>}
     | _   {footer lexbuf}
 </r>650 <r>| eof {raise (Misc.Fatal ("End of file in footer (no &lt;/BODY&gt; tag)"))}
     
     <b><U>and</U><r> secname = parse
         ['a'-'z' 'A'-'Z']+
         {</r><U>let</U></b> r = lexeme lexbuf <b><U>in</U></b> r}
 </r>655 <r>| "" {raise (Error "Bad section name syntax")}
     
     <b><U>and</U></b> intarg = parse
         ['0'-'9']+ {int_of_string (lexeme lexbuf)}
     | ""         {!depth}
 </r>660 
     </m><U>and</U></b> tocline = parse
         "--&gt;" '\n' ? {Out.to_string toc_buf}
     | _
         {Out.put_char toc_buf (lexeme_char lexbuf 0) ;
 </r>665       <r>tocline lexbuf}
     
     <b><U>and</U></b> arg = parse
     | "&lt;/ARG&gt;" {Out.to_string arg_buf}
     | _         {Out.put_char arg_buf (Lexing.lexeme_char lexbuf 0) ; arg lexbuf}
 </r>670 <r>| eof       {raise (Misc.Fatal "Unclosed arg")}
     
     <b><U>and</U><r> flowline = parse
     | "&lt;ARG TITLE&gt;"
         {</r><U>let</U></b> title = arg lexbuf <b><U>in</U><m>
 675     </m><U>let</U></b> _ = flowline lexbuf <b><U>in</U></b>
         title}
     | "--&gt;" '\n'?
         {""}
     | eof {raise (Misc.Fatal "Unclosed comment")}
 </r>680 <r>| _   {flowline lexbuf}
     
     <b><U>and</U><r> linkline = parse
     | "&lt;ARG" ' '+ "PREV&gt;"
       {</r><U>let</U></b> link = arg lexbuf <b><U>in</U><m>
 685   <r>setlink Thread.setprev link ;
       linkline lexbuf}
     | "&lt;ARG" ' '+ "NEXT&gt;"
       {<b><U>let</U><r> link = arg lexbuf </r><U>in</U></b>
       setlink Thread.setnext link ;
 </r>690   <r>linkline lexbuf}
     | "&lt;ARG" ' '+ "UP&gt;"
       {<b><U>let</U><r> link = arg lexbuf </r><U>in</U></b>
       setlink Thread.setup link ;
       linkline lexbuf}
 </r>695 <r>| "--&gt;" '\n'?
       {()}
     | eof {raise (Misc.Fatal "Unclosed comment")}
     | _   {linkline lexbuf}
     
 </r>700 </m><U>and</U></b> aargs = parse
     | ("name"|"NAME") ' '* '=' ' '*
       {<b><U>if</U><r> !phase = 0 </r><U>then</U> <U>begin</U>
         <U>let</U></b> name = refname lexbuf <b><U>in</U></b>
         Cross.add name !outname
 </r>705   <b><U>end</U> <U>else</U><r>
         put (lexeme lexbuf) ;
       aargs lexbuf}
     | ("href"|"HREF") ' '* '=' ' '*
        {<b><U>if</U></b> !phase &gt; 0 </r><U>then</U> <U>begin</U></b>
 710       <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
           <U>let</U><r> name = refname lexbuf <b><U>in</U>
           <U>try</U>
             <U>let</U></b> newname =
               <b><U>if</U></b> String.length name &gt; 0 &amp;&amp; String.get name 0 = '#' </r><U>then</U></b>
 715             <r>Cross.fullname !outname (String.sub name 1 (String.length name-1))
               <b><U>else</U><r> name </r><U>in</U></b>
             put lxm ;
             put "\"" ;
             put newname ;
 </r>720         <r>put "\""
           <b><U>with</U><r> Not_found -&gt; ()
         </r><U>end</U></b> ;
         aargs lexbuf}
     | '&gt;'
 </r>725   <r>{<b><U>if</U><r> !phase &gt; 0 </r><U>then</U></b> put_char '&gt;' ;
       main lexbuf}
     | _
       {<b><U>if</U><r> !phase &gt; 0 </r><U>then</U></b> put_char (lexeme_char lexbuf 0) ;
       aargs lexbuf}
 </r>730 <r>| eof
       {raise (Error "Bad &lt;A ...&gt; tag")}
     
     <b><U>and</U></b> refname = parse
     |  '"' [^'"']* '"'
 </r>735    <r>{let lxm = lexeme lexbuf in
        String.sub lxm 1 (String.length lxm-2)}
     | ['a'-'z''A'-'Z''0'-'9''.''_''-']+
        {lexeme lexbuf}
     | "" {raise (Error "Bad reference name syntax")}
 </r>740 
     <r>and skip_blanks = parse
       ' '* {()}
     
     and skip_endcom  = parse
 </r>745   <r>' '* "--&gt;" '\n'? {()}
     | ""               {raise (Error "Bad HTML comment syntax")}
     and skip_aref = parse
       "&lt;/A&gt;" {()}
     | _      {skip_aref lexbuf}<PL><B>
<6>3 entry.mll</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w>{
     <b><U>open</U></b> Lexing
     
  </r>15 <b><U>let</U><r> header = "$Id: entry.mll,v 1.11 1999/12/07 16:12:15 maranget Exp $"
     
     </r><U>let</U><r> buff = Out.create_buff ()
     ;;
     
  <m>20 <b><U>let</U><r> put s =
       Out.put buff s
     </r><U>and</U><r> put_char c =
       Out.put_char buff c
     ;;
  <m>25 
     
     <b><U>type</U><r> res =
     | Bang </r><U>of</U><r> string * string
     | Bar <b><U>of</U><r> string * string
  <m>30 </m>| Eof </r><U>of</U></b> string * string
     ;;
     
     <b><U>let</U><r> extend r i = </r><U>match</U></b> r <b><U>with</U><r>
     | Bang (p,_) -&gt; Bang (i,p)
  <m>35 </m>| Bar (p,_) -&gt; Bar (i,p)
     | Eof (p,_) -&gt; Eof (i,p)
     ;;
     
     </r><U>type</U></b> key = string list * string list
  <m>40 
     <b><U>exception</U><r> Fini
     </r><U>exception</U><r> NoGood
     ;;
     
  <m>45 </m>}
     rule entry = parse
     | "\\\""
         {put "\\\"" ; entry lexbuf}
     | "\"!"
  <m>50     </m>{put_char '!' ; entry lexbuf}
     | "\"@"
         {put_char '@' ; entry lexbuf}
     | "\"|"
         {put_char '|' ; entry lexbuf}
  <m>55 </m>| '!' {Bang   (Out.to_string buff,"")}
     | '@' {<b><U>let</U><r> s = Out.to_string buff </r><U>in</U>
           <U>let</U></b> r = entry lexbuf <b><U>in</U><r>
           extend r s}
     | '|' {Bar (Out.to_string buff,"")}
  <m>60 </m>| eof {Eof (Out.to_string buff,"")}
     | _
        {</r><U>let</U></b> lxm = lexeme_char lexbuf 0 <b><U>in</U><r> put_char lxm ; entry lexbuf}
     
     </r><U>and</U></b> idx = parse
  <m>65 </m>|  "\\indexentry"
          {<b><U>let</U><r> key = Save.arg lexbuf </r><U>in</U>
          <U>let</U></b>  value = Save.arg lexbuf <b><U>in</U><r>
          key,value}
     | eof {raise Fini}
  <m>70 </m>| _   {idx lexbuf}
     
     
     {
     
  <m>75 <b><U>let</U><r> read_key lexbuf =
     
       </r><U>let</U><r> bar () = <b><U>match</U><r> entry lexbuf </r><U>with</U></b>
       | Eof (s,_) -&gt;
           <b><U>begin</U> <U>match</U></b> s </r><U>with</U></b>
  80       </m>| ""|"("|")" -&gt; None
           | s -&gt;
               </r><U>if</U></b> s.[0] = '(' <b><U>then</U></b>
                 Some (String.sub s 1 (String.length s - 1))
               </r><U>else</U></b>
  85             </m>Some s
           <b><U>end</U><r>
       | _         -&gt; raise NoGood </r><U>in</U>
     
       <U>let</U> <U>rec</U></b> get_rec () = <b><U>match</U></b> entry  lexbuf </r><U>with</U></b>
  90     </m>Bang (i,p) -&gt;
           <b><U>let</U><r> l,see = get_rec () </r><U>in</U></b>
           (i,p)::l,see
       | Bar (i,p) -&gt;
           <b><U>let</U></b> see = bar () </r><U>in</U></b>
  95       </m>[i,p],see
       | Eof (i,p) -&gt; [i,p],None <b><U>in</U>
     
       <U>let</U></b> separe (l,see) =
         <b><U>let</U> <U>rec</U></b> sep_rec = </r><U>function</U></b>
 100       <r>[] -&gt; [],[]
         | (x,y)::r -&gt;
             <b><U>let</U><r> xs,ys = sep_rec r </r><U>in</U></b>
             x::xs,y::ys <b><U>in</U>
         <U>let</U></b> xs,ys = sep_rec l <b><U>in</U><m>
 105     <r>((xs,ys),see) <b><U>in</U><r>
     
       separe (get_rec ())
     
     </r><U>let</U></b> read_indexentry lexbuf = idx lexbuf
 </r>110 <r>}<PL><B>
<6>4 get.mll</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w>{
     <b><U>open</U><r> Misc
     </r><U>open</U></b> Parse_opts
  </r>15 </m><U>open</U></b> Lexing
     <b><U>open</U><r> Latexmacros
     </r><U>open</U></b> Lexstate
     <b><U>open</U></b> Stack
     
  </r>20 </m>(* Compute functions *)
     </w><U>let</U><r> header = "$Id: get.mll,v 1.24 2001/02/12 10:05:29 maranget Exp $"
     
     <b><U>exception</U><r> Error </r><U>of</U></b> string
     
  <m>25 <b><U>let</U><r> sbool = </r><U>function</U><r>
       | <b><U>true</U><r> -&gt; "true"
       | </r><U>false</U></b> -&gt; "false"
     
     <b><U>let</U><r> get_this = ref (</r><U>fun</U></b> s -&gt; <b><U>assert</U> <U>false</U></b>)
  <m>30 <b><U>and</U><r> get_fun = ref (</r><U>fun</U><r> f lexbuf -&gt; <b><U>assert</U> <U>false</U></b>)
     <b><U>and</U><r> open_env = ref (</r><U>fun</U></b> _ -&gt; ())
     <b><U>and</U><r> close_env = ref (</r><U>fun</U></b> _ -&gt; ())
     <b><U>and</U><r> get_csname = ref (</r><U>fun</U></b> _ -&gt; <b><U>assert</U> <U>false</U></b>)
     <b><U>and</U><r> main = ref (</r><U>fun</U></b> _ -&gt; <b><U>assert</U> <U>false</U></b>)
  <m>35 </m>;;
     
     <b><U>let</U><r> bool_out = ref </r><U>false</U>
     <U>and</U></b> int_out = ref </r><U>false</U></b>
     
  40 <b><U>let</U><r> int_stack = Stack.create "int_stack"
     </r><U>and</U><r> bool_stack = Stack.create "bool_stack"
     <b><U>and</U><r> group_stack = Stack.create "group_stack"
     </r><U>and</U></b> just_opened = ref </r><U>false</U></b>
     
  45 <b><U>type</U><r> saved =
       bool * bool Stack.saved *
       bool * int Stack.saved *
       (unit -&gt; unit) Stack.saved * bool
     
  <m>50 <b><U>let</U><r> check () =
       !bool_out, Stack.save bool_stack,
       !int_out, Stack.save int_stack,
       Stack.save group_stack,
       !just_opened
  <m>55 
     <b><U>and</U><r> hot (b,bs,i,is,gs,j) =
       bool_out := b ; Stack.restore bool_stack bs ;
       int_out := i ; Stack.restore int_stack is ;
       Stack.restore group_stack gs ;
  <m>60   </m>just_opened := j
     
     </r><U>let</U><r> push_int x =
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U></b>
         prerr_endline ("PUSH INT: "^string_of_int x) ;
  <m>65   </m>just_opened := <b><U>false</U><r> ;
       push int_stack x
     
     </r><U>let</U></b> open_ngroups n =
       <b><U>let</U> <U>rec</U></b> open_ngroups_rec  = </r><U>function</U></b>
  70     </m>| 0 -&gt;()
         | n -&gt; push group_stack (</r><U>fun</U><r> () -&gt; ()) ; open_ngroups_rec (n-1) <b><U>in</U>
       <U>if</U></b> !verbose &gt; 2 <b><U>then</U><r>
         prerr_endline ("OPEN NGROUPS: "^string_of_int n) ;
       </r><U>if</U></b> n &gt; 0 </r><U>then</U> <U>begin</U></b>
  75     </m>just_opened := </r><U>true</U><r> ;
         open_ngroups_rec n
       <b><U>end</U>
     
     <U>let</U></b> close_ngroups n =
  <m>80   <b><U>let</U> <U>rec</U><r> close_ngroups_rec  = <b><U>function</U><r>
         | 0 -&gt; ()
         | n -&gt;
             </r><U>let</U></b> f = pop group_stack <b><U>in</U></b>
             f() ; close_ngroups_rec (n-1) </r><U>in</U></b>
  85   <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U><r>
         prerr_endline ("CLOSE NGROUPS: "^string_of_int n);
       close_ngroups_rec n
     
     <b><U>let</U><r> open_aftergroup f s =
  <m>90   <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U><r>
         prerr_endline ("OPEN AFTER: "^s) ;
       just_opened := <b><U>true</U><r> ;
       push group_stack f
     
  <m>95 </m>}
     </r><U>let</U></b> command_name =
      '\\' ((['@''A'-'Z' 'a'-'z']+ '*'?) | [^ '@' 'A'-'Z' 'a'-'z'])
     
     rule result = parse
 <m>100 <w>(* Skip comments and spaces *)
     </w></m>| '%' [^ '\n'] * '\n' {result lexbuf}
     | [' ' '\n']+         {result lexbuf}
     <w>(* Integers *)
     </w>| ['0'-'9']+
 <m>105     </m>{<b><U>let</U><r> lxm = Lexing.lexeme lexbuf </r><U>in</U></b>
         push_int (int_of_string lxm) ;
         result lexbuf}
     | '\'' ['0'-'7']+
         {<b><U>let</U></b> lxm = lexeme lexbuf </r><U>in</U></b>
 110     </m>push_int
           (int_of_string ("0o"^String.sub lxm 1 (String.length lxm-1))) ;
         result lexbuf}
     |  "\"" ['0'-'9' 'a'-'f' 'A'-'F']+
         {</r><U>let</U></b> lxm = lexeme lexbuf </r><U>in</U></b>
 115     </m>push_int
           (int_of_string ("0x"^String.sub lxm 1 (String.length lxm-1))) ;
         result lexbuf}
     | '`'
         {<b><U>let</U></b> token = !get_csname lexbuf </r><U>in</U></b>
 120     </m>after_quote (Lexing.from_string token) ;
         result lexbuf}
     |  "true"
         {push bool_stack <b><U>true</U><r> ;
         result lexbuf}
 <m>125 </m>|  "false"
         {push bool_stack </r><U>false</U></b> ;
         result lexbuf}
     <w>(* Operands *)
     </w>| '+' | '-'
 <m>130     </m>{<b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U>
         <U>let</U></b> unary = !just_opened <b><U>in</U>
         <U>if</U></b> unary <b><U>then</U> <U>begin</U>
           <U>let</U></b> f = pop group_stack <b><U>in</U><r>
           open_aftergroup
 <m>135         </m>(</r><U>fun</U></b> () -&gt;
               <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
                 prerr_endline ("UNARY: "^String.make 1 lxm) ;
                 Stack.pretty string_of_int int_stack
               <b><U>end</U><r> ;
 <m>140           <b><U>let</U><r> x1 = pop int_stack </r><U>in</U>
               <U>let</U><r> r = <b><U>match</U><r> lxm </r><U>with</U></b>
               | '+' -&gt; x1
               | '-' -&gt; 0 - x1
               | _   -&gt; </r><U>assert</U> <U>false</U> <U>in</U></b>
 145           </m>push_int r ; f()) "UNARY"
         </r><U>end</U> <U>else</U> <U>begin</U></b>
           close_ngroups 2 ;
           open_aftergroup
             (<b><U>fun</U><r> () -&gt;
 <m>150           <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U><r>
                 prerr_endline ("OPPADD: "^String.make 1 lxm) ;
                 Stack.pretty string_of_int int_stack
               <b><U>end</U><r> ;
               </r><U>let</U></b> x2 = pop int_stack </r><U>in</U></b>
 155           <b><U>let</U><r> x1 = pop int_stack </r><U>in</U>
               <U>let</U><r> r = <b><U>match</U><r> lxm </r><U>with</U></b>
               | '+' -&gt; x1 + x2
               | '-' -&gt; x1 - x2
               | _   -&gt; </r><U>assert</U> <U>false</U> <U>in</U></b>
 160           </m>push_int r) "ADD";
           open_ngroups 1 ;
         </r><U>end</U></b> ;
         result lexbuf}
     | '/' | '*'
 <m>165     </m>{<b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U></b>
         close_ngroups 1 ;
         open_aftergroup
             (<b><U>fun</U><r> () -&gt;
               </r><U>if</U></b> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
 170             </m>prerr_endline ("MULTOP"^String.make 1 lxm) ;
                 Stack.pretty string_of_int int_stack
               <b><U>end</U><r> ;
               </r><U>let</U></b> x2 = pop int_stack <b><U>in</U>
               <U>let</U></b> x1 = pop int_stack </r><U>in</U></b>
 175           <b><U>let</U><r> r = </r><U>match</U><r> lxm <b><U>with</U><r>
               | '*' -&gt; x1 * x2
               | '/' -&gt; x1 / x2
               | _   -&gt; </r><U>assert</U> <U>false</U> <U>in</U></b>
               push_int r) "MULT";
 <m>180     </m>result lexbuf}
     <w>(* boolean openrands *)
     </w>| '&lt;' | '&gt;' | '='
         {<b><U>let</U><r> lxm = Lexing.lexeme_char lexbuf 0 </r><U>in</U></b>
         close_ngroups 3 ;
 <m>185     </m>open_aftergroup
           (<b><U>fun</U><r> () -&gt;
             </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
               prerr_endline ("COMP: "^String.make 1 lxm) ;
               Stack.pretty string_of_int int_stack
 <m>190         <b><U>end</U><r> ;
             </r><U>let</U><r> x2 = pop int_stack <b><U>in</U>
             <U>let</U></b> x1 = pop int_stack <b><U>in</U><r>
             push bool_stack
               (</r><U>match</U></b> lxm </r><U>with</U></b>
 195           </m>| '&lt;' -&gt; x1 &lt; x2
               | '&gt;' -&gt; x1 &gt; x2
               | '=' -&gt; x1 = x2
               | _   -&gt; <b><U>assert</U> <U>false</U></b>) ;
               <b><U>if</U></b> !verbose &gt; 2 </r><U>then</U></b>
 200             </m>Stack.pretty sbool bool_stack) "COMP" ;
         open_ngroups 2 ;
         result lexbuf}
     
     </r></b>(* Parenthesis for integer computing *)
 </w>205 </m></w>| '('|'{'
         {open_ngroups 2 ;
         result lexbuf}
     | ')'|'}'
         {close_ngroups 2 ;
 <m>210     <r>result lexbuf}
     <w>(* Commands *)
     </w>|  '#' ['1'-'9']
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>let</U></b> i = Char.code (lxm.[1]) - Char.code '1' <b><U>in</U><m>
 215     <r>scan_arg (scan_this_arg result) i ;
         result lexbuf}
     | command_name
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>let</U></b> pat,body = Latexmacros.find lxm <b><U>in</U><m>
 220     </m><U>let</U></b> args = make_stack lxm pat lexbuf <b><U>in</U><r>
         scan_body
           (</r><U>function</U></b>
             | Subst body -&gt; scan_this result body
             | Toks l -&gt;
 </r>225             <r>List.iter
                   (scan_this result)
                   (List.rev l)
             | CamlCode f -&gt;
                 <b><U>let</U><r> rs = !get_fun f lexbuf </r><U>in</U><m>
 230             <r>scan_this result rs)
               body args ;
         result lexbuf}
     | _   {raise (Error ("Bad character in Get.result: ``"^lexeme lexbuf^"''"))}
     | eof {()}
 </r>235 
     </m><U>and</U></b> after_quote = parse
     |  '\\'  [^ 'A'-'Z' 'a'-'z'] eof
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
         push_int (Char.code lxm.[1]);
 </r>240     <r>result lexbuf}
     |  _ eof
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
         push_int (Char.code lxm.[0]);
         result lexbuf}
 </r>245 <r>| ""
         {Misc.fatal "Cannot understand `-like numerical argument"}
     {
     <b><U>let</U></b> init latexget latexgetfun latexopenenv latexcloseenv latexcsname
         latexmain =
 </r>250   <r>get_this := latexget ;
       get_fun := latexgetfun ;
       open_env := latexopenenv ;
       close_env := latexcloseenv ;
       get_csname := latexcsname ;
 </r>255   <r>main := latexmain
     ;;
     
     <b><U>let</U></b> def_loc  name f =
       Latexmacros.def name zero_pat (CamlCode f) ;
 </r>260 <r>;;
     
     <b><U>let</U><r> def_commands l =
       List.map
         (</r><U>fun</U></b> (name,f) -&gt;
 </r>265       <r>name,Latexmacros.replace name (Some (zero_pat,CamlCode f)))
         l
     
     <b><U>let</U></b> def_commands_int () =
       def_commands
 </r>270     <r>["\\value",
           (<b><U>fun</U><r> lexbuf -&gt;
             </r><U>let</U></b> name = !get_this (save_arg lexbuf) <b><U>in</U></b>
             push_int (Counter.value_counter name)) ;
           "\\pushint",
 </r>275         <r>(<b><U>fun</U><r> lexbuf -&gt;
               </r><U>let</U></b> s = !get_this (save_arg lexbuf) <b><U>in</U><r>
               scan_this result s)]
     
     </r><U>let</U></b> def_commands_bool () =
 </r>280   </m><U>let</U></b> old_ints = def_commands_int () <b><U>in</U>
       <U>let</U></b> old_commands =
         def_commands
           ["\\(", (<b><U>fun</U><r> _ -&gt; open_ngroups 7) ;
             "\\)",  (</r><U>fun</U></b> _ -&gt; close_ngroups 7) ;
 </r>285         <r>"\\@fileexists",
             (<b><U>fun</U><r> lexbuf -&gt;
               </r><U>let</U></b> name = !get_this (save_arg lexbuf) <b><U>in</U><r>
               push bool_stack
                 (</r><U>try</U><m>
 290               </m><U>let</U></b> _ = Myfiles.open_tex name <b><U>in</U>
                   <U>true</U>
                 <U>with</U></b> Myfiles.Except | Myfiles.Error _ -&gt; <b><U>false</U><r>)) ;
             "\\@commandexists",
             (</r><U>fun</U></b> lexbuf -&gt;
 </r>295           <b><U>let</U></b></m> name = !get_csname lexbuf <b><U>in</U><r>
               push bool_stack (Latexmacros.exists name)) ;
             "\\or",
             (</r><U>fun</U></b> _ -&gt;
               close_ngroups 7 ;
 <m>300           </m>open_aftergroup
                 (<b><U>fun</U></b> () -&gt;
                   <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
                     prerr_endline "OR" ;
                     Stack.pretty sbool bool_stack
 <m>305               <b><U>end</U></b></m> ;
                   <b><U>let</U><r> b1 = pop bool_stack </r><U>in</U>
                   <U>let</U></b> b2 = pop bool_stack <b><U>in</U><r>
                   push bool_stack (b1 || b2)) "OR";
               open_ngroups 6) ;
 <m>310         </m>"\\and",
             (</r><U>fun</U></b> _ -&gt;
               close_ngroups 6 ;
               open_aftergroup
                 (<b><U>fun</U><r> () -&gt;
 </r><m>315               </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
                     prerr_endline "AND" ;
                     Stack.pretty sbool bool_stack
                   <b><U>end</U><r> ;
                   </r><U>let</U></b> b1 = pop bool_stack <b><U>in</U><m>
 320               </m><U>let</U></b> b2 = pop bool_stack <b><U>in</U><r>
                   push bool_stack (b1 &amp;&amp; b2)) "AND";
               open_ngroups 5) ;
             "\\not",
             (</r><U>fun</U></b> _ -&gt;
 <m>325           <r>close_ngroups 4 ;
               open_aftergroup
                 (<b><U>fun</U><r> () -&gt;
                   </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
                     prerr_endline "NOT" ;
 </r>330                 <r>Stack.pretty sbool bool_stack
                   <b><U>end</U><r> ;
                   </r><U>let</U></b> b1 = pop bool_stack <b><U>in</U></b>
                   push bool_stack (not b1)) "NOT";
               open_ngroups 3) ;
 </r>335         <r>"\\boolean",
               (<b><U>fun</U><r> lexbuf -&gt;
                 </r><U>let</U></b> name = !get_this (save_arg lexbuf) <b><U>in</U>
                 <U>let</U></b> b = <b><U>try</U>
                   <U>let</U></b> r = !get_this
 </r>340                   <r>(string_to_arg ("\\if"^name^" true\\else false\\fi")) <b><U>in</U>
                   <U>match</U></b> r <b><U>with</U><r>
                   | "true" -&gt; </r><U>true</U></b>
                   | "false" -&gt; <b><U>false</U></b>
                   | _ -&gt; raise (Misc.Fatal ("boolean value: "^r))
 </r>345             <b><U>with</U></b></m>
                   Latexmacros.Failed -&gt; <b><U>true</U>  <U>in</U></b>
                 push bool_stack b) ;
             "\\isodd",
             (<b><U>fun</U><r> lexbuf -&gt;
 <m>350           </m>close_ngroups 3 ;
               open_aftergroup
                 (</r><U>fun</U></b> () -&gt;
                   <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
                     prerr_endline ("ISODD") ;
 <m>355                 <r>Stack.pretty string_of_int int_stack
                   <b><U>end</U><r> ;
                   </r><U>let</U></b> x = pop int_stack <b><U>in</U><r>
                   push bool_stack (x </r><U>mod</U></b> 2 = 1) ;
                   <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U><m>
 360                 <r>Stack.pretty sbool bool_stack) "ISODD" ;
               open_ngroups 2) ] <b><U>in</U>
       <U>let</U></b> old_equal =
         <b><U>try</U><r> Some (Latexmacros.find_fail "\\equal") </r><U>with</U></b> Failed -&gt; None <b><U>in</U><m>
     
 365   <r>def_loc "\\equal"
         (<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> arg1 = save_arg lexbuf <b><U>in</U>
           <U>let</U></b> arg2 = save_arg lexbuf <b><U>in</U></b>
           scan_this !main "\\begin{@norefs}" ;
 </r>370       </m><U>let</U></b> again = List.map (<b><U>fun</U><r> (name,x) -&gt; name,Latexmacros.replace name x)
               ((("\\equal",old_equal)::old_ints)@old_commands) </r><U>in</U></b>
           push bool_stack (!get_this arg1 = !get_this arg2) ;
           <b><U>let</U><r> _ =
             List.map (</r><U>fun</U></b> (name,x) -&gt; Latexmacros.replace name x) again <b><U>in</U><m>
 375       <r>scan_this !main "\\end{@norefs}")
     
     
     
     <b><U>let</U></b> first_try s =
 </r>380   </m><U>let</U></b> l = String.length s <b><U>in</U>
       <U>if</U></b> l &lt;= 0 <b><U>then</U><r> raise (Failure "first_try") ;
       </r><U>let</U> <U>rec</U></b> try_rec r i =
         <b><U>if</U><r> i &gt;= l </r><U>then</U></b> r
         <b><U>else</U> <U>match</U></b> s.[i] <b><U>with</U><m>
 385     <r>| '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9' -&gt;
             try_rec (10*r + Char.code s.[i] - Char.code '0') (i+1)
         | _ -&gt; raise (Failure ("first_try")) <b><U>in</U></b>
       try_rec 0 0
     ;;
 </r>390 
     </m><U>let</U></b> get_int {arg=expr ; subst=subst} =
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b>
         prerr_endline ("get_int : "^expr) ;
       <b><U>let</U></b> r =
 </r>395     </m><U>try</U></b> first_try expr <b><U>with</U><r> Failure _ -&gt; </r><U>begin</U>
           <U>let</U></b> old_int = !int_out <b><U>in</U><r>
           int_out := </r><U>true</U></b> ;
           start_normal subst ;
           !open_env "*int*" ;
 </r>400       <b><U>let</U></b></m> _ = def_commands_int () <b><U>in</U><r>
           open_ngroups 2 ;
           </r><U>begin</U> <U>try</U></b> scan_this result expr <b><U>with</U><r>
           | x -&gt;
               </r><U>begin</U><m>
 405             <r>prerr_endline
                   ("Error while scanning ``"^expr^"'' for integer result");
                 raise x
               <b><U>end</U>
           <U>end</U></b> ;
 </r>410       <r>close_ngroups 2 ;
           !close_env "*int*" ;
           end_normal () ;
           <b><U>if</U><r> Stack.empty int_stack </r><U>then</U></b>
             raise (Error ("``"^expr^"'' has no value as an integer"));
 </r>415       </m><U>let</U></b> r = pop int_stack <b><U>in</U><r>
           int_out := old_int ;
           r </r><U>end</U> <U>in</U>
       <U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
         prerr_endline ("get_int: "^expr^" = "^string_of_int r) ;
 <m>420   </m>r
     
     
     </r><U>let</U></b> get_bool {arg=expr ; subst=subst} =
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U><m>
 425     <r>prerr_endline ("get_bool : "^expr) ;
       <b><U>let</U><r> old_bool = !bool_out </r><U>in</U></b>
       bool_out := <b><U>true</U></b> ;
       start_normal subst ;
       !open_env "*bool*" ;
 </r>430   <r>def_commands_bool () ;
       open_ngroups 7 ;
       <b><U>begin</U> <U>try</U></b> scan_this result expr <b><U>with</U><r>
       | x -&gt;
           </r><U>begin</U><m>
 435         <r>prerr_endline
               ("Error while scanning ``"^expr^"'' for boolean result");
             raise x
           <b><U>end</U>
       <U>end</U></b> ;
 </r>440   <r>close_ngroups 7 ;
       !close_env "*bool*" ;
       end_normal () ;
       <b><U>if</U><r> Stack.empty bool_stack </r><U>then</U></b>
         raise (Error ("``"^expr^"'' has no value as a boolean"));
 </r>445   </m><U>let</U></b> r = pop bool_stack <b><U>in</U>
       <U>if</U></b> !verbose &gt; 1 <b><U>then</U></b>
         prerr_endline ("get_bool: "^expr^" = "^sbool r);
       bool_out := old_bool ;
       r
 </r>450 
     </m><U>let</U></b> get_length arg =
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b>
         prerr_endline ("get_length : "^arg) ;
       <b><U>let</U><r> r = Length.main (Lexing.from_string arg) </r><U>in</U><m>
 455   </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         prerr_string ("get_length : "^arg^" -&gt; ") ;
         prerr_endline (Length.pretty r)
       <b><U>end</U><r> ;
       r
 <m>460 </m>}<PL><B>
<6>5 htmllex.mll</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: htmllex.mll,v 1.9 2001/05/29 15:09:22 maranget Exp $          *)
     (***********************************************************************)
     </w>{
     </r><U>open</U></b> Lexing
     <b><U>open</U><r> Lexeme
  </r><m>15 </m><U>open</U></b> Buff
     
     <b><U>let</U><r> txt_level = ref 0
     </r><U>and</U></b> txt_stack = Stack.create "htmllex"
     
  <m>20 <b><U>exception</U></b></m> Error <b><U>of</U><r> string
     ;;
     
     
     </r><U>let</U></b> error msg lb =
  <m>25   <r>raise (Error msg)
     
     
     <b><U>let</U></b> init table (s,t)= Hashtbl.add table s t
     ;;
  </r>30 
     <b><U>let</U></b></m> block = Hashtbl.create 17
     ;;
     
     List.iter (init block)
  <m>35   </m>["CENTER", () ; "DIV", (); "BLOCKQUOTE", () ;
       "H1", () ; "H2", () ;"H3", () ;"H4", () ;"H5", () ;"H6", () ;
       "PRE", () ; "TABLE", () ; "TR",() ; "TD", () ; "TH",() ;
       "OL",() ; "UL",(); "P",() ; "LI",() ;
       "DL",() ; "DT", () ; "DD",() ;
  <m>40   <r>]
     ;;
     
     <b><U>let</U><r> ptop () =
       </r><U>if</U></b> not (Stack.empty txt_stack) <b><U>then</U> <U>begin</U><m>
  45     </m><U>let</U></b> pos = Stack.top txt_stack <b><U>in</U><r>
         Location.print_this_fullpos pos ;
         prerr_endline "This opening tag is pending"
       </r><U>end</U><m>
     
  50 </m><U>let</U></b> warnings = ref <b><U>true</U>
     
     <U>let</U></b> check_nesting lb name =
       <b><U>try</U></b>
         Hashtbl.find block (String.uppercase name) ;
  </r>55     <b><U>if</U><r> !txt_level &lt;&gt; 0 &amp;&amp; !warnings </r><U>then</U> <U>begin</U><r>
           Location.print_fullpos () ;
           prerr_endline
             ("Warning, block level element: "^name^" nested inside text-level element") ;
           ptop ()
  <m>60     <b><U>end</U>
       <U>with</U></b></m>
       |  Not_found -&gt; ()
     
     <b><U>let</U><r> text = Hashtbl.create 17
  </r><m>65 <r>;;
     
     
     List.iter (init text)
       ["TT",TT ; "I",I ; "B",B ; "BIG",BIG ; "SMALL",SMALL ;
  </r>70    <r>"STRIKE",STRIKE ; "S",S ; "U",U ; "FONT",FONT ;
        "EM",EM ; "STRONG",STRONG ; "DFN",DFN ; "CODE",CODE ; "SAMP",SAMP ;
        "KBD",KBD ; "VAR",VAR ; "CITE",CITE ; "ABBR",ABBR ; "ACRONYM",ACRONYM ;
        "Q",Q ; "SUB",SUB ; "SUP",SUP ; "A", A ; "SPAN", SPAN ; "SCRIPT", SCRIPT]
     ;;
  </r>75 
     </m><U>let</U></b> is_textlevel name =
       <b><U>try</U>
         <U>let</U></b> _ = Hashtbl.find text (String.uppercase name) <b><U>in</U>
         <U>true</U><m>
  80   </m><U>with</U></b>
       | Not_found -&gt; <b><U>false</U>
     
     <U>let</U></b> is_br name = "BR" = (String.uppercase name)
     <b><U>let</U><r> is_basefont name = "BASEFONT" = (String.uppercase name)
  </r><m>85 
     </m><U>let</U></b> set_basefont attrs lb =
       List.iter
         (<b><U>fun</U><r> (name,v,_) -&gt; </r><U>match</U></b> String.uppercase name,v <b><U>with</U><r>
         | "SIZE",Some s -&gt;
  </r><m>90         </m><U>begin</U> <U>try</U></b>
               Emisc.basefont := int_of_string s
             <b><U>with</U><r>
             | _ -&gt; error "BASEFONT syntax" lb
             </r><U>end</U><m>
  95     <r>| _ -&gt; ())
         attrs
     
     <b><U>let</U><r> get_value lb = </r><U>function</U></b>
       | Some s -&gt; s
 </r>100   <r>| _ -&gt; error "Bad attribute syntax" lb
     
     <b><U>let</U><r> norm_attrs lb attrs =
        List.map
             (</r><U>fun</U></b> (name,value,txt) -&gt;
 </r>105           </m><U>match</U></b> String.uppercase name <b><U>with</U><r>
               | "SIZE" -&gt;  SIZE (get_value lb value),txt
               | "COLOR" -&gt; COLOR (get_value lb value),txt
               | "FACE" -&gt; FACE (get_value lb value),txt
               | _      -&gt; OTHER, txt)
 <m>110     </m>attrs
     
     </r><U>let</U></b> print_attrs s attrs =
       print_string s ; print_string ":" ;
       List.iter
 <m>115     <r>(<b><U>fun</U><r> x -&gt; </r><U>match</U></b>  x <b><U>with</U><r>
         | name,Some value </r><U>when</U></b> name=s -&gt;
             print_char ' ' ;
             print_string value
         | _ -&gt; ())
 </r>120     <r>attrs ;
       print_char '\n'
     
     <b><U>let</U><r> ouvre lb name attrs txt =
       </r><U>let</U></b> uname = String.uppercase name <b><U>in</U><m>
 125   </m><U>try</U>
         <U>let</U></b> tag = Hashtbl.find text uname <b><U>in</U>
         <U>let</U></b> attrs = norm_attrs lb attrs <b><U>in</U></b>
         incr txt_level ;
         Stack.push txt_stack (Location.get_pos ()) ;
 </r>130     <r>Open (tag, attrs,txt)
       <b><U>with</U><r>
       | Not_found -&gt; </r><U>assert</U> <U>false</U>
     
     <U>and</U></b> ferme lb name txt =
 </r>135   <b><U>try</U>
         <U>let</U></b></m> tag = Hashtbl.find text (String.uppercase name) <b><U>in</U><r>
         decr txt_level ;
         </r><U>begin</U> <U>if</U></b> not (Stack.empty txt_stack) <b><U>then</U>
           <U>let</U></b> _  = Stack.pop txt_stack <b><U>in</U><r> ()
 </r><m>140     </m><U>end</U></b> ;
         Close (tag,txt)
       <b><U>with</U><r>
       | Not_found -&gt; Text txt
     
 </r><m>145 
     
     
     
     </m><U>let</U></b> unquote s =
 <m>150   <b><U>let</U></b></m> l = String.length s <b><U>in</U><r>
       String.sub s 1 (l-2)
     ;;
     
     </r><U>let</U></b> buff = Buff.create ()
 <m>155 <b><U>and</U></b></m> abuff = Buff.create ()
     
     <b><U>let</U><r> put s = Buff.put buff s
     </r><U>and</U></b> putc c = Buff.put_char buff c
     
 <m>160 <b><U>let</U></b></m> aput s = Buff.put abuff s
     <b><U>and</U><r> aputc c = Buff.put_char abuff c
     
     
     
 <m>165 </m>}
     
     
     </r><U>let</U></b> blank = [' ''\t''\n''\r']
     
 <m>170 <r>rule main = parse
     | (blank|"&amp;nbsp;")+ {Blanks (lexeme lexbuf)}
     | "&lt;!--"
       {put (lexeme lexbuf) ;
       in_comment lexbuf ;
 </r>175   <r>Text (Buff.to_string buff)}
     |   "&lt;!"
       {put (lexeme lexbuf) ;
       in_tag lexbuf ;
       Text (Buff.to_string buff)}
 </r>180 <r>| '&lt;'
         {putc '&lt;' ;
         <b><U>let</U><r> tag = read_tag lexbuf </r><U>in</U>
         <U>if</U></b> is_textlevel tag <b><U>then</U> <U>begin</U>
           <U>let</U></b> attrs = read_attrs lexbuf <b><U>in</U><m>
 185       <r>ouvre lexbuf tag attrs (Buff.to_string buff)
         <b><U>end</U> <U>else</U> <U>if</U></b> is_basefont tag <b><U>then</U> <U>begin</U>
           <U>let</U></b> attrs = read_attrs lexbuf <b><U>in</U></b>
           set_basefont attrs lexbuf ;
           Text (Buff.to_string buff)
 </r>190     </m><U>end</U> <U>else</U> <U>begin</U></b>
           check_nesting lexbuf tag ;
           in_tag lexbuf ;
           <b><U>let</U><r> txt = Buff.to_string buff </r><U>in</U>
           <U>if</U></b> is_br tag <b><U>then</U><m>
 195         <r>Blanks txt
           <b><U>else</U><r>
             Text txt
         </r><U>end</U></b>}
     |  "&lt;/"
 </r>200     <r>{put "&lt;/" ;
         <b><U>let</U><r> tag = read_tag lexbuf </r><U>in</U></b>
         in_tag lexbuf ;
         ferme lexbuf tag (Buff.to_string buff)}
     |  eof {Eof}
 </r>205 <r>| _
         {putc (lexeme_char lexbuf 0) ;
         text lexbuf ;
         Text (Buff.to_string buff)}
     
 </r>210 </m><U>and</U></b> text = parse
     | [^'&lt;']
       {putc (lexeme_char lexbuf 0) ; text lexbuf}
     | "" {()}
     
 </r>215 <b><U>and</U></b></m> read_tag = parse
     | ['a'-'z''A'-'Z''0'-'9']*
         {</r><U>let</U></b></m> lxm = lexeme lexbuf <b><U>in</U><r>
         put lxm ; lxm}
     
 </r><m>220 </m><U>and</U></b> read_attrs = parse
     | blank+
         {aput (lexeme lexbuf) ; read_attrs lexbuf}
     | ['a'-'z''A'-'Z''-''0'-'9']+
       {<b><U>let</U><r> name = lexeme lexbuf </r><U>in</U><m>
 225   <r>aput name ;
       <b><U>let</U><r> v = read_avalue lexbuf </r><U>in</U>
       <U>let</U></b> atxt = Buff.to_string abuff <b><U>in</U></b>
       put atxt ;
       (name,v,atxt)::read_attrs lexbuf}
 </r>230 <r>| '&gt;' {put_char buff '&gt;' ; []}
     | ""  {error "Attribute syntax" lexbuf}
     
     <b><U>and</U></b> read_avalue = parse
     | blank* '=' blank*
 </r>235     <r>{<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
         aput lxm ;
         Some (read_aavalue lexbuf)}
     | "" {None}
     
 </r>240 </m><U>and</U></b> read_aavalue = parse
     | '\''[^'\'']*'\''
     | '"'[^'"']*'"'
         {let lxm = lexeme lexbuf in
         aput lxm ;
 <m>245     <r>unquote lxm}
     | '#'?['a'-'z''A'-'Z''0'-'9''-''+''_'':''.']+
         {let lxm = lexeme lexbuf in
         aput lxm ;
         lxm}
 </r>250 <r>| "" {error "Attribute syntax" lexbuf}
     
     and in_tag = parse
     | '&gt;' {putc (lexeme_char lexbuf 0)}
     | _   {putc (lexeme_char lexbuf 0) ; in_tag lexbuf}
 </r>255 <r>| eof {error "End <b><U>of</U><r> file </r><U>in</U></b> tag" lexbuf}
     
     and in_comment = parse
     | "--&gt;" '\n'?
       {put (lexeme lexbuf)}
 </r>260 <r>| _
        {putc (lexeme_char lexbuf 0) ; in_comment lexbuf}
     | eof
         {error "End <b><U>of</U><r> file </r><U>in</U></b> comment" lexbuf}
     
 </r>265 <r>{
     
     let to_string = function
       | Open (_,_,txt)  | Close (_,txt)  | Text txt  | Blanks txt -&gt; txt
       | Eof -&gt; "Eof"
 </r>270 
     <r>let rec cost = function
       | {tag=FONT ; attrs=attrs} -&gt; (1,List.length attrs)
       | _          -&gt; (1,0)
     
 </r>275 <r>let tok_buff = ref None
     ;;
     
     let txt_buff = Buff.create ()
     ;;
 </r>280 
     <r>let rec read_tokens blanks lb =
       let t = main lb in
       match t with
       | Text txt -&gt; Buff.put txt_buff txt ; read_tokens false lb
 </r>285   <r>| Blanks txt -&gt; Buff.put txt_buff txt ; read_tokens blanks lb
       | _ -&gt;
           let txt = Buff.to_string txt_buff in
           match txt with
           | "" -&gt; t
 </r>290       <r>| _  -&gt;
               tok_buff := Some t ;
               if blanks then
                 Blanks txt
               else
 </r>295             <r>Text txt
     
     let reset () =
       txt_level := 0 ;
       Stack.reset txt_stack ;
 </r>300   <r>Buff.reset txt_buff ;
       Buff.reset buff ;
       Buff.reset abuff
     
     let next_token lb =
 </r>305   <r>try match !tok_buff with
       | Some t -&gt; tok_buff := None ; t
       | None   -&gt; read_tokens true lb
       with
       | e -&gt;
 </r>310       <r>reset () ;
           raise e
     
     }<PL><B>
<6>6 infoRef.mll</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w>{
     <b><U>let</U></b> header = "$Id: infoRef.mll,v 1.22 2001/05/25 09:07:15 maranget Exp $"
     ;;
  </r>15 
     
     <b><U>open</U><r> Lexing
     </r><U>open</U><r> Misc
     
  </r></b>20 <b><U>let</U><r> compat_mem tbl key =
       </r><U>try</U> <U>let</U><r> _ = Hashtbl.find tbl key <b><U>in</U> <U>true</U> <U>with</U></b> Not_found -&gt; <b><U>false</U></b>
     ;;
     
     
  </r></b>25 <b><U>exception</U><r> Error </r><U>of</U><r> string
     
     <b><U>type</U><r> node_t = {
         </r><U>mutable</U></b> name : string;
         <b><U>mutable</U></b> comment : string;
  </r></b>30     <b><U>mutable</U><r> previous : node_t option;
         </r><U>mutable</U><r> next : node_t option;
         <b><U>mutable</U><r> up : node_t option;
         </r><U>mutable</U></b> pos : int;
       }
  </r></b>35 <r>;;
     
     <b><U>type</U><r> menu_t = {
         </r><U>mutable</U></b> num : int;
         <b><U>mutable</U></b> nom : string;
  </r>40     <b><U>mutable</U><r> nod : node_t option;
         </r><U>mutable</U><r> nodes : node_t list;
       }
     ;;
     
  </r></b>45 
     <b><U>let</U><r> menu_list = ref [];;
     
     </r><U>let</U><r> nodes = Hashtbl.create 17;;
     <b><U>let</U></b> delayed  = ref [];;
  </r></b>50 <b><U>let</U><r> current_node = ref None;;
     
     </r><U>let</U><r> menu_num = ref 0
     ;;
     
  </r></b>55 <b><U>let</U><r> counter = ref 0
     </r><U>and</U><r> pos_file = ref 0
     ;;
     
     <b><U>let</U></b> abs_pos () = !counter + !pos_file
  </r></b>60 <r>;;
     
     
     <b><U>let</U></b> cur_file = ref (Parse_opts.name_out)
     ;;
  </r>65 
     <b><U>let</U><r> file_number = ref 1
     ;;
     
     </r><U>type</U><r> label_t = {
  </r></b>70     <b><U>mutable</U><r> lab_name : string;
         </r><U>mutable</U><r> noeud : node_t option;
       };;
     
     <b><U>let</U></b> labels_list = ref [];;
  </r></b>75 
     <b><U>let</U><r> files = ref [];;
     </r><U>let</U><r> top_node = ref <b><U>false</U><r>;;
     
     </r><U>let</U></b> hot_start () =
  </r></b>80   <r>menu_list :=  [];
       Hashtbl.clear nodes ;
       current_node := None ;
       menu_num := 0 ;
       counter := 0 ;
  </r>85   <r>pos_file := 0 ;
       cur_file := Parse_opts.name_out ;
       files := [] ;
       top_node := <b><U>false</U></b> ;
       file_number :=  1 ;
  </r>90   <r>labels_list := []
     ;;
     
     <b><U>let</U></b> infomenu arg =
       menu_num:=!menu_num+1;
  </r>95   <r>menu_list := {
         num = !menu_num;
         nom = arg;
         nod = !current_node;
         nodes = [];
 </r>100   <r>} ::!menu_list;
       Text.open_block "INFOLINE" "";
       Text.put ("\\@menu"^string_of_int !menu_num^"\n");
       Text.close_block "INFOLINE"
     ;;
 </r>105 
     <b><U>let</U> <U>rec</U><r> cherche_menu m = <b><U>function</U><r>
       | [] -&gt; raise (Error ("Menu ``"^m^"'' not found"))
       | menu::r -&gt;
           </r><U>if</U></b> menu.nom = m <b><U>then</U></b> menu
 </r></b>110       <b><U>else</U><r> cherche_menu m r
     ;;
     
     </r><U>let</U> <U>rec</U><r> cherche_menu_par_num n = <b><U>function</U></b>
       | [] -&gt; raise (Error ("Menu not found"))
 </r></b>115   <r>| menu::r -&gt;
           <b><U>if</U><r> menu.num = n </r><U>then</U></b> menu
           <b><U>else</U></b> cherche_menu_par_num n r
     ;;
     
 </r>120 <b><U>let</U><r> ajoute_node_dans_menu n m =
       </r><U>try</U>
       <U>let</U><r> menu = cherche_menu m !menu_list <b><U>in</U></b>
       menu.nodes &lt;- n :: menu.nodes;
       menu.nod
 </r></b>125   <b><U>with</U><r> _ -&gt; None
     ;;
     
     
     </r><U>let</U><r> verifie name =
 </r></b>130   <b><U>let</U><r> nom = String.copy name </r><U>in</U>
       <U>for</U><r> i = 0 <b><U>to</U><r> String.length name -1 </r><U>do</U>
         <U>match</U></b> nom.[i] <b><U>with</U></b>
         | '\t' -&gt; nom.[i] &lt;- ' '
         | ',' -&gt; nom.[i] &lt;- ' '
 </r></b>135     <r>| '.' -&gt; nom.[i] &lt;- '-'
         | '\n' -&gt; nom.[i] &lt;- ' '
         |  _ -&gt; ()
       <b><U>done</U></b>;
       nom
 </r>140 <r>;;
     
     
     
     
 </r>145 <w>(* References *)
     
     </w></m><b><U>let</U> <U>rec</U></b> cherche_label s = <b><U>function</U><r>
       | [] -&gt; raise Not_found
       | l::r -&gt; </r><U>if</U></b> l.lab_name=s <b><U>then</U><r> l.noeud </r><U>else</U></b> cherche_label s r
 <m>150 <r>;;
     
     <b><U>let</U> <U>rec</U></b> change_label s = <b><U>function</U></b>
       |  [] -&gt; Misc.warning ("Cannot change label: ``"^s^"''")
       | l::r -&gt;
 </r>155       <b><U>if</U></b></m> l.lab_name = s <b><U>then</U><r>
             l.noeud &lt;- !current_node
           </r><U>else</U></b>
             change_label s r
     
 <m>160 <b><U>let</U></b></m> loc_name s1 = <w>(* pose un label *)
       <b><U>let</U></b></w> _ =
         <b><U>try</U>
           <U>let</U></b> _ = cherche_label s1 !labels_list <b><U>in</U><r>
           Misc.warning ("Multiple use of label: "^s1)
 </r><m>165     </m><U>with</U></b> Not_found -&gt; ()
       <b><U>in</U>
     
       <U>let</U></b> l = {
         lab_name = s1;
 <m>170     <r>noeud = !current_node ;
       } <b><U>in</U></b>
     
       labels_list := l:: !labels_list;
       Text.open_block "INFO" "" ;
 </r>175   <r>Text.put "\\@name{" ;
       Text.put s1 ;
       Text.put "}" ;
       Text.close_block "INFO" ;
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b> prerr_endline ("InfoRef.loc_name, label="^s1);
 </r>180 <r>;;
     
     
     
     <w>(* Sortie du fichier final *)
 <m>185 
     <b><U>let</U><r> out_cur = ref (Out.create_null ())
     ;;
     
     </r><U>let</U><r> set_out chan =
 </r></b>190   <b><U>if</U><r> !verbose &gt;3 </r><U>then</U><r> prerr_endline "Set_out";
       out_cur := chan
     ;;
     
     <b><U>let</U></b> set_out_file s =
 </r></b>195   <b><U>if</U><r> !verbose &gt;3 </r><U>then</U><r> prerr_endline ("Set_out_file :"^s);
       cur_file := s
     ;;
     
     <b><U>let</U></b> put s =
 </r></b>200   <b><U>if</U><r> !verbose &gt;3 </r><U>then</U><r>
         prerr_endline ("put :"^s);
       counter:=!counter + String.length s;
       Out.put !out_cur s
     ;;
 </r></b>205 
     <b><U>let</U><r> put_char c =
       </r><U>if</U><r> !verbose &gt;3 <b><U>then</U></b>
         prerr_endline ("put_char :"^String.make 1 c);
       counter:=!counter +1;
 </r></b>210   <r>Out.put_char !out_cur c
     ;;
     
     <b><U>let</U></b> put_credits () =
       put "\n\n-------------------------------------\nThis file has been translated from LaTeX by HeVeA.\n\n";
 </r>215 
     <b><U>and</U><r> put_header () =
       put "This file has been translated from LaTeX by HeVeA.\n"
     ;;
     
 </r></b>220 <b><U>let</U><r> next_file () =
       Out.close !out_cur ;
       file_number := !file_number +1;
       cur_file := Parse_opts.name_out ^ "-" ^ string_of_int !file_number ;
       </r><U>if</U><r> !verbose &gt; 0 <b><U>then</U><m>
 225     <r>prerr_endline ("Change file to "^ !cur_file) ;
       set_out (Out.create_chan (open_out !cur_file)) ;
       files := (!cur_file,abs_pos ()) :: !files ;
       pos_file := abs_pos () ;
       put_header () ;
 </r>230   <r>counter := 0
     
     ;;
     
     
 </r>235 
     
     </m><U>let</U></b> noeud_name n = n.name
     ;;
     
 </r></b>240 
     <b><U>let</U><r> affiche_menu num =
       </r><U>let</U><r> menu = cherche_menu_par_num num !menu_list <b><U>in</U>
       <U>if</U></b> menu.nodes &lt;&gt; [] <b><U>then</U> <U>begin</U></b>
         put "* Menu:\n\n";
 </r></b>245     <r><b><U>let</U> <U>rec</U></b> affiche_items = <b><U>function</U></b>
           | [] -&gt; ()
           | n::reste -&gt;
        put ("* "^noeud_name n^"::\t"^n.comment^"\n");
        affiche_items reste;
 </r>250     <b><U>in</U><r>
         affiche_items (List.rev menu.nodes);
         </r><U>if</U><r> !verbose &gt;1 <b><U>then</U><r>
           prerr_endline ("Menu :"^menu.nom);
       </r><U>end</U><m>
 255 <r>;;
     
     
     <b><U>let</U><r>  do_affiche_tag_table s =
       put ("\n\nTag table:\n"^(</r><U>if</U></b> s&lt;&gt; "" <b><U>then</U><r> s^"\n" </r><U>else</U></b> "")) ;
 </r>260   <r>Hashtbl.iter
         (<b><U>fun</U></b> nom n -&gt;
           put ("Node: "^noeud_name n^""^string_of_int n.pos^"\n")) nodes;
       put "\nEnd tag table\n";
     ;;
 </r>265 
     
     </m><U>let</U></b> affiche_tag_table ()=
       <b><U>match</U><r> !files </r><U>with</U></b>
       | [_] -&gt;
 </r></b>270     <r>do_affiche_tag_table ""
       | _   -&gt;
         <b><U>let</U> <U>rec</U></b> do_indirect = <b><U>function</U></b>
           | [] -&gt; ()
           | (f,p)::reste -&gt;
 </r>275           <r>put (f^": "^string_of_int p^"\n");
        do_indirect reste
         <b><U>in</U></b>
         Out.close !out_cur ;
         set_out (Out.create_chan (open_out Parse_opts.name_out)) ;
 </r>280     <r>put_header () ;
         put "\nIndirect:\n";
         do_indirect (List.rev !files);
         do_affiche_tag_table "(Indirect)"
     ;;
 </r>285 
     
     <b><U>let</U><r> affiche_node nom =
       </r><U>if</U><r> !top_node <b><U>then</U> <U>begin</U></b>
         put_credits () ;
 </r></b>290     <r>top_node := <b><U>false</U>
       <U>end</U></b> ;
       <b><U>let</U><r> noeud =
         </r><U>try</U></b> Hashtbl.find nodes nom
         <b><U>with</U></b> Not_found -&gt;  raise (Error ("Node not found :"^nom))
 </r>295   <b><U>in</U>
       <U>if</U><r> not Parse_opts.filter &amp;&amp; !counter &gt; 50000 <b><U>then</U> <U>begin</U></b>
         next_file ()
       <b><U>end</U></b>;
       noeud.pos &lt;- abs_pos ();
 </r></b>300   <r>put "\n";
       put ("Node: "^noeud_name noeud);
       (<b><U>match</U><r> noeud.next </r><U>with</U></b>
       | None -&gt; ()
       | Some n -&gt; put (",\tNext: "^noeud_name n));
 </r>305   <r>(<b><U>match</U><r> noeud.previous </r><U>with</U></b>
       | None -&gt; ()
       | Some n -&gt; put (",\tPrev: "^noeud_name n));
       (<b><U>match</U><r> noeud.up </r><U>with</U></b>
       | None -&gt;
 </r>310       <b><U>if</U><r> noeud.name = "Top" </r><U>then</U> <U>begin</U><r>
             put ",\tUp: (dir)." ;
             top_node := <b><U>true</U>
           <U>end</U></b>
       | Some n -&gt; put (",\tUp: "^noeud_name n));
 </r></b>315   <r>put_char '\n';
       <b><U>if</U><r> !verbose &gt;1 </r><U>then</U></b>
         prerr_endline ("Node : "^noeud_name noeud);
     
     ;;
 </r>320 
     <b><U>let</U><r> affiche_ref key =
       </r><U>try</U>
         <U>let</U><r> l =  cherche_label key !labels_list <b><U>in</U>
         <U>match</U></b> l <b><U>with</U><m>
 325     <r>| None -&gt; ()
         | Some node -&gt; put ("*Note "^noeud_name node^"::")
       <b><U>with</U></b>
       | Not_found -&gt; () <w>(* A warning has already been given *)
     </w>;;
 </r>330 
     </m><U>let</U></b> footNote_label = ref ""
     ;;
     
     }
 </r></b>335 
     
     <r>rule main = parse
     | "\\@menu"
         {
 </r>340   <r><b><U>let</U><r> num = numero lexbuf </r><U>in</U></b>
       affiche_menu num;
       main lexbuf}
     | "\\@node"
         {
 </r>345   <b><U>let</U><r> nom = finitLigne lexbuf </r><U>in</U><r>
       affiche_node nom;
       main lexbuf}
     | "\\@reference{"
         {
 </r></b>350   <b><U>let</U><r> key = arg lexbuf </r><U>in</U><r>
       affiche_ref key;
       main lexbuf}
     | "\\@name{"
       {<b><U>let</U><r> _ = arg lexbuf </r><U>in</U><m>
 355   <r>main lexbuf}
     | eof
         {affiche_tag_table ()}
     
     | _
 </r>360     <r>{<b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U></b>
         put_char lxm;
         main lexbuf}
     
     <b><U>and</U></b> numero = parse
 </r>365     <r>['0'-'9']+
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
         int_of_string lxm}
     | _ {raise (Error "Syntax error in info temp file")}
     
 </r>370 </m><U>and</U></b> finitLigne = parse
         [^'\n']+'\n'
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
         String.sub lxm 0 ((String.length lxm) -1)}
     | _ {raise ( Error "Syntax error in info temp file: no node name.")}
 </r></b>375 
     <b><U>and</U><r> arg = parse
         [^'}']+'}'
         {</r><U>let</U><r> lxm= lexeme lexbuf <b><U>in</U></b>
         String.sub lxm 0 ((String.length lxm) -1)}
 </r></b>380 <r>| _ {raise (Error "Syntax error in info temporary file: invalid reference.")}
     
     <b><U>and</U><r> labels = parse
     | "\\@name{"
         {</r><U>let</U></b> key = arg lexbuf <b><U>in</U><m>
 385     <r>key::labels lexbuf}
     | _ {labels lexbuf}
     | eof {[]}
     
     
 </r>390 <r>{
     <b><U>let</U><r> do_infonode opt num arg =
     
       </r><U>let</U></b> n = {
         name = verifie num;
 </r>395     <r>comment = arg;
         previous = None;
         next = None;
         up = None;
         pos = 0;
 </r>400   <r>} <b><U>in</U>
       <U>if</U></b> compat_mem nodes n.name <b><U>then</U><r>
         raise (Error ("Duplicate node name: "^n.name));
       n.up &lt;- (</r><U>match</U></b> opt <b><U>with</U></b>
         "" -&gt; None
 </r>405   <r>| m -&gt;  ajoute_node_dans_menu n m);
       Hashtbl.add nodes n.name n;
       Text.open_block "INFOLINE" "";
       Text.put ("\\@node"^n.name^"\n");
       Text.close_block "INFOLINE";
 </r>410   <r>current_node := Some n;
       <b><U>if</U><r> !verbose&gt;1 </r><U>then</U></b> prerr_endline ("Node added :"^n.name^", "^n.comment)
     
     <b><U>let</U></b> infoextranode num nom text =
       delayed := (num,nom,text) :: !delayed
 </r>415 
     </m><U>and</U></b> flushextranodes () =
       <b><U>let</U> <U>rec</U></b> flush_rec = <b><U>function</U></b>
         | [] -&gt; ()
         | (num,nom,text) :: rest -&gt;
 </r>420         <r>do_infonode "" num nom ;
             Text.open_block "INFO" "" ;
             Text.put text ;
             Text.close_block "INFO" ;
             <b><U>let</U><r> labs = labels (Lexing.from_string text) </r><U>in</U><m>
 425         <r>List.iter (<b><U>fun</U><r> lab -&gt; change_label lab !labels_list) labs ;
             flush_rec rest </r><U>in</U></b>
       flush_rec !delayed ;
       delayed := []
     ;;
 </r>430 
     </m><U>let</U></b> infonode opt num arg =
       flushextranodes () ;
       do_infonode opt num arg
     
 </r>435 
     </m>(* finalisation des liens entre les noeuds *)
     <b><U>let</U> <U>rec</U></b></w> do_finalize_nodes suivant = <b><U>function</U></b>
       | [] -&gt; ()
       | n::reste -&gt;
 </r>440       <b><U>if</U></b></m> !verbose&gt;2 <b><U>then</U><r> prerr_endline ("node :"^n.name);
           n.next &lt;- suivant;
           (</r><U>match</U></b>  suivant <b><U>with</U><r>
           | None -&gt; ()
           | Some suiv -&gt; suiv.previous &lt;- Some n );
 <m>445       </m>do_finalize_nodes (Some n) reste
     ;;
     
     </r><U>let</U> <U>rec</U></b> do_finalize_menus = <b><U>function</U><r>
       | [] -&gt; ()
 <m>450   </m>| m::reste -&gt;
           </r><U>if</U></b> m.nodes &lt;&gt; [] <b><U>then</U> <U>begin</U></b>
      do_finalize_nodes
        (<b><U>match</U><r> m.nod </r><U>with</U></b>
          None -&gt; None
 <m>455    <r>| Some n -&gt; n.next)
        m.nodes;
      (<b><U>match</U><r> m.nod </r><U>with</U></b>
        None -&gt; ()
      |  Some n -&gt;
 </r>460      <b><U>let</U></b></m> first_node = List.hd (List.rev m.nodes) <b><U>in</U><r>
          n.next &lt;- Some first_node;
          first_node.previous &lt;- Some n;
        </r><w>(* On descend dans l'arborescence des menus *)
          </w><U>let</U></b> last_node = List.hd m.nodes <b><U>in</U><m>
 465      <r>(<b><U>match</U><r> last_node.next </r><U>with</U></b>
          | None -&gt; ()
          | Some suiv -&gt; suiv.previous &lt;- Some n);
               <w>(* On remonte les menus au meme niveau *)
        </w>);
 </r>470  <r>do_finalize_menus reste;
           <b><U>end</U><r>
     ;;
     
     </r><U>let</U></b> finalize_nodes () =
 </r>475   </m><U>if</U></b> !verbose&gt;2 <b><U>then</U><r> prerr_endline "finalizing nodes";
       flushextranodes () ;
       do_finalize_menus (List.rev !menu_list);
       </r><U>if</U></b> !verbose&gt;2 <b><U>then</U><r> prerr_endline "finalizing done.";
     ;;
 </r><m>480 
     </m><U>let</U></b> dump buff =
       <b><U>let</U><r> name,out_chan = </r><U>match</U></b> Parse_opts.name_out <b><U>with</U><r>
       | "" -&gt; "", Out.create_chan stdout
       | s  -&gt;
 </r><m>485       </m><U>let</U></b> name = s^"-1" <b><U>in</U><r>
           name, Out.create_chan (open_out name) </r><U>in</U>
       <U>if</U></b> !verbose &gt; 0 <b><U>then</U><r>
         prerr_endline ("Final dump in "^name) ;
       set_out out_chan ;
 </r><m>490   <r>set_out_file name ;
       put_header () ;
       files := [name,abs_pos ()] ;
       main buff ;
       Out.close !out_cur ;
 </r>495   </m><U>if</U></b> !file_number = 1 <b><U>then</U><r>
         Mysys.rename !cur_file Parse_opts.name_out
     }<PL><B>
<6>7 latexscan.mll</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     (* $Id: latexscan.mll,v 1.212 2001/06/06 16:52:47 maranget Exp $ *)
     
     
  <m>15 <r>{
     <b><U>module</U> <U>type</U></b> S =
       <b><U>sig</U><w>
         (* external entry points *)
         </w><U>val</U></b> no_prelude : unit -&gt; unit
  </r>20     <b><U>val</U><r> main : Lexing.lexbuf -&gt; unit
         </r><U>val</U><r> print_env_pos : unit -&gt; unit
     
         <w>(* additional resources needed for extension modules. *)
         <b><U>val</U></b></w> cur_env : string ref
  </r></b>25     <b><U>val</U><r> new_env : string -&gt; unit
         </r><U>val</U><r> close_env : string -&gt; unit
         <b><U>val</U><r> echo_toimage : unit -&gt; bool
         </r><U>val</U></b> echo_global_toimage : unit -&gt; bool
     
  </r></b>30     <b><U>val</U><r> fun_register : (unit -&gt; unit) -&gt; unit
         </r><U>val</U><r> newif_ref : string -&gt; bool ref -&gt; unit
         <b><U>val</U><r> top_open_block : string -&gt; string -&gt; unit
         </r><U>val</U></b> top_close_block : string -&gt; unit
         <b><U>val</U></b> check_alltt_skip : Lexing.lexbuf -&gt; unit
  </r></b>35     <b><U>val</U><r> skip_pop : Lexing.lexbuf -&gt; unit
     </r><w>(* ``def'' functions for initialisation only *)
         </w><U>val</U><r> def_code : string -&gt; (Lexing.lexbuf -&gt; unit) -&gt; unit
         <b><U>val</U><r> def_name_code : string -&gt; (string -&gt; Lexing.lexbuf -&gt; unit) -&gt; unit
         </r><U>val</U></b> def_fun : string -&gt; (string -&gt; string) -&gt; unit
  </r></b>40     <b><U>val</U><r> get_this_main : string -&gt; string
         </r><U>val</U><r> check_this_main : string -&gt; bool
         <b><U>val</U><r> get_prim : string -&gt; string
         </r><U>val</U></b> get_prim_arg : Lexing.lexbuf -&gt; string
         <b><U>val</U></b> get_prim_opt : string -&gt; Lexing.lexbuf -&gt; string
  </r></b>45     <b><U>val</U><r> get_csname : Lexing.lexbuf -&gt; string
       </r><U>end</U>
     
     <U>module</U><r> Make
       (Dest : OutManager.S) (Image : ImageManager.S) =
  </r></b>50 <b><U>struct</U>
     <U>open</U><r> Misc
     <b><U>open</U><r> Parse_opts
     </r><U>open</U></b> Element
     <b><U>open</U></b> Lexing
  </r></b>55 <b><U>open</U><r> Myfiles
     </r><U>open</U><r> Latexmacros
     <b><U>open</U><r> Save
     </r><U>open</U></b> Tabular
     <b><U>open</U></b> Lexstate
  </r></b>60 <r><b><U>open</U><r> Stack
     </r><U>open</U></b> Subst
     
     <b><U>let</U><r> sbool = </r><U>function</U></b>
       | <b><U>false</U></b> -&gt; "false"
  </r>65   <r>| <b><U>true</U><r>  -&gt; "true"
     
     
     
     </r><U>let</U></b> last_letter name =
  </r>70   <b><U>let</U><r> c = String.get name (String.length name-1) </r><U>in</U><r>
       ('a' &lt;= c &amp;&amp; c &lt;= 'z') || ('A' &lt;= c &amp;&amp; c &lt;= 'Z')
     ;;
     
     <b><U>let</U></b> top_par n =
  </r></b>75   <r><b><U>if</U><r> not (!display || !in_math) </r><U>then</U></b> Dest.par n
     ;;
     
     <b><U>let</U></b> if_level = ref 0
     ;;
  </r>80 
     <b><U>let</U><r> cur_env = ref ""
     </r><U>and</U><r> after = ref []
     <b><U>and</U></b> stack_env = Stack.create "stack_env"
     ;;
  </r></b>85 
     <b><U>let</U><r> echo_toimage () =  get_level () = 0 &amp;&amp; top_level ()
     </r><U>and</U><r> echo_global_toimage () = top_level ()
     
     <b><U>let</U><r> stack_env_pretty () =  Stack.pretty (</r><U>fun</U></b> (x,_,_) -&gt; x) stack_env
  </r></b>90 
     <b><U>let</U><r> fun_register f =
       </r><U>if</U><r> get_level () &gt; 0 <b><U>then</U></b> after := f :: !after
     ;;
     
  </r></b>95 
     <b><U>let</U><r> inc_size i =
       </r><U>let</U><r> n = Dest.get_fontsize () <b><U>in</U>
       <U>let</U></b> new_size =
         <b><U>if</U><r> n+i &lt;= 1 </r><U>then</U></b> 1
 </r></b>100     <b><U>else</U> <U>if</U><r> n+i &gt;= 7 <b><U>then</U><r> 7
         </r><U>else</U></b> n+i <b><U>in</U></b>
       Dest.open_mod (Font new_size)
     ;;
     
 </r></b>105 <b><U>let</U><r> big_size () =  Dest.open_mod (Font 7)
     ;;
     
     <w>(* Horizontal display *)
     
 <m>110 <b><U>let</U><r> top_open_display () =
       </r><U>if</U><r> !display <b><U>then</U> <U>begin</U>
         <U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
            prerr_endline "open display" ;
         Dest.open_display ()
 <m>115   <b><U>end</U>
     
     <U>and</U><r> top_item_display () =
       <b><U>if</U><r> !display </r><U>then</U> <U>begin</U></b>
         Dest.item_display ()
 <m>120   <b><U>end</U><r>
     ;;
     
     </r><U>let</U><r> top_close_display () =
       <b><U>if</U></b> !display </r><U>then</U> <U>begin</U></b>
 125     </m>Dest.close_display ()
       </r><U>end</U><w>
     
     
     (* Latex environment stuff *)
 </w></b>130 
     <b><U>let</U><r> print_env_pos () =
       </r><U>let</U><r> _,_,pos = Stack.pop stack_env <b><U>in</U><r>
       Location.print_this_pos pos ;
       prerr_endline ("Latex environment ``"^ !cur_env^"'' is pending")
 <m>135 </m>;;
     
     </r><U>let</U></b> new_env env =
       Latexmacros.open_group () ;
       push stack_env (!cur_env, !after, Location.get_pos ()) ;
 <m>140   </m>cur_env := env ;
       after := [] ;
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U> <U>begin</U></b>
         Location.print_pos () ;
         Printf.fprintf stderr "Begin : %s &lt;%d&gt;" env (get_level ());
 <m>145     </m>prerr_endline ""
       <b><U>end</U>
     
     <U>let</U></b> error_env close_e open_e =
       raise
 <m>150     </m>(Misc.Close
            ("Latex env error: ``"^close_e^"'' closes ``"^open_e^"''"))
     
     <b><U>let</U><r> close_env env  =
       </r><U>if</U></b> !verbose &gt; 1 </r><U>then</U> <U>begin</U></b>
 155     </m>Printf.fprintf stderr "End: %s &lt;%d&gt;" env (get_level ());
         prerr_endline  ""
       </r><U>end</U></b> ;
       <b><U>if</U><r> env = !cur_env </r><U>then</U> <U>begin</U>
         <U>let</U></b> e,a,_ = pop stack_env </r><U>in</U></b>
 160     </m></w>List.iter (</r><U>fun</U><r> f -&gt; f ()) !after ;
         cur_env := e ;
         after := a ;
         Latexmacros.close_group ()
       </r><U>end</U> <U>else</U></b>
 165     <r>error_env env !cur_env
     ;;
     
     <b><U>let</U><r> env_check () = !cur_env, !after, Stack.save stack_env
     </r><U>and</U></b> env_hot (e,a,s) =
 </r>170   <r>cur_env := e ;
       after := a ;
       Stack.restore stack_env s
     
     
 </r>175 </m>(* Top functions for blocks *)
     
     </w><U>type</U></b> array_type = {math : bool ; border : bool}
     <b><U>type</U><r> in_table = Table </r><U>of</U></b> array_type | NoTable | Tabbing
     ;;
 <m>180 
     <b><U>let</U></b></m> cur_format = ref [||]
     <b><U>and</U><r> stack_format = Stack.create "stack_format"
     </r><U>and</U></b> cur_col = ref 0
     <b><U>and</U><r> stack_col = Stack.create "stack_col"
 </r><m>185 </m><U>and</U></b> in_table = ref NoTable
     <b><U>and</U><r> stack_table = Stack.create_init "stack_table" NoTable
     </r><U>and</U></b> first_col = ref <b><U>false</U>
     <U>and</U></b> first_border = ref <b><U>false</U>
     <U>and</U></b> stack_first = Stack.create "stack_first"
 <m>190 <b><U>and</U></b></m> stack_first_b = Stack.create "stack_first_b"
     <b><U>and</U><r> in_multi = ref </r><U>false</U>
     <U>and</U></b> stack_multi_flag = Stack.create "stack_multi_flag"
     <b><U>and</U><r> stack_multi = Stack.create "stack_multi"
     ;;
 </r><m>195 
     
     </m><U>let</U></b> pretty_array_type = <b><U>function</U><r>
       | Table {math = m ; border = b} -&gt;
           "Table math="^(</r><U>if</U></b> m <b><U>then</U><r> "+" </r><U>else</U></b> "-")^
 <m>200       </m>" border="^(<b><U>if</U><r> b </r><U>then</U></b> "+" <b><U>else</U><r> "-")
       | NoTable -&gt; "NoTable"
       | Tabbing -&gt; "Tabbing"
     
     </r><U>let</U></b> prerr_array_state () =
 <m>205   </m>prerr_endline (pretty_array_type !in_table) ;
       prerr_string "  format:";
       pretty_formats !cur_format ;
       prerr_endline "" ;
       prerr_endline ("  cur_col="^string_of_int !cur_col) ;
 <m>210   </m>prerr_endline ("  first_col="^
           (<b><U>if</U><r> !first_col </r><U>then</U></b> "true" <b><U>else</U><r> "false"))
     ;;
     
     </r><U>let</U></b> save_array_state () =
 <m>215   </m>push stack_format !cur_format ;
       push stack_col !cur_col ;
       push stack_table !in_table ;
       push stack_first !first_col;
       push stack_first_b !first_border;
 <m>220   </m>push stack_multi_flag !in_multi ;
       in_multi := <b><U>false</U><r> ;
       </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
         prerr_endline "Save array state:" ;
         prerr_array_state ()
 <m>225   <b><U>end</U>
     
     <U>and</U><r> restore_array_state () =
       in_table := pop stack_table ;
       cur_col := pop stack_col ;
 <m>230   </m>cur_format := pop stack_format ;
       first_col := pop stack_first ;
       first_border := pop stack_first_b;
       in_multi := pop stack_multi_flag ;
       <b><U>if</U></b> !verbose &gt; 1 </r><U>then</U> <U>begin</U></b>
 235     </m>prerr_endline "Restore array state:" ;
         prerr_array_state ()
       <b><U>end</U><r>
     ;;
     
 <m>240 <b><U>let</U><r> top_open_block block args =
       </r><U>if</U><r> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("Top open: "^block);
       push stack_table !in_table ;
       in_table := NoTable ;
       </r><U>begin</U> <U>match</U></b> block </r><U>with</U></b>
 245   </m>| "PRE" -&gt;
           push stack_display !display ;
           </r><U>if</U></b> !display <b><U>then</U> <U>begin</U></b>
             Dest.item_display () ;
             display := <b><U>false</U><m>
 250       </m><U>end</U></b> ;
           Dest.open_block "PRE" args
       | "DISPLAY" -&gt;
           push stack_display !display ;
           display := <b><U>true</U></b> ;
 <m>255       </m>Dest.open_display ()
       | "TABLE" -&gt;
           save_array_state () ;
           in_table := NoTable ;
           top_item_display () ;
 </TT></r><m><TT>260       <r>Dest.open_block "TABLE" args
       | "TR" -&gt;
           Dest.open_block "TR" args
       | "TD" -&gt;
           Dest.open_block "TD" args ;
 </r>265       <r>top_open_display ()
       | _ -&gt;
           <b><U>if</U><r> !display </r><U>then</U> <U>begin</U></b>
             Dest.item_display () ; Dest.open_block block args ;
             Dest.open_display ()
 </r>270       <b><U>end</U> <U>else</U><r>
             Dest.open_block block args
       <b><U>end</U>
     
     <U>and</U></b> top_close_block_aux close_fun block =
 <m>275   <b><U>if</U></b></m> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("Top close: "^block) ;
       in_table := pop stack_table ;
       </r><U>begin</U> <U>match</U></b> block <b><U>with</U><r>
       | "PRE" -&gt;
           display := pop stack_display ;
 <m>280       </m>close_fun block ;
           top_item_display ()
       | "DISPLAY" -&gt;
           Dest.close_display () ;
           display := pop stack_display
 <m>285   </m>| "TABLE" -&gt;
           close_fun "TABLE" ;
           top_item_display () ;
           restore_array_state ()
       | "TR" -&gt;
 <m>290       </m>close_fun "TR"
       | "TD" -&gt;
           top_close_display () ;
           close_fun "TD"
       | _ -&gt;
 <m>295       <b><U>if</U><r> !display </r><U>then</U> <U>begin</U><r>
             Dest.close_display () ; close_fun block ; Dest.item_display ()
           <b><U>end</U> <U>else</U></b>
             close_fun block
       </r><U>end</U></b>
 300 </m>;;
     
     </r><U>let</U></b> top_close_block block = top_close_block_aux Dest.close_block block
     <b><U>and</U><r> top_erase_block block = top_close_block_aux Dest.erase_block block
     
 <m>305 <b><U>let</U><r> top_open_group () =
       top_open_block "" "" ; new_env ""
     
     </r><U>and</U><r> top_close_group () =
       <b><U>if</U></b> !cur_env = "*mbox" </r><U>then</U> <U>begin</U></b>
 310     </m>top_close_block "" ;
         in_math := pop stack_in_math ; display := pop stack_display ;
         </r><U>if</U></b> !display <b><U>then</U><r> Dest.item_display () ;
         close_env "*mbox"
       </r><U>end</U> <U>else</U> <U>begin</U><m>
 315     <r>top_close_block "" ;
         close_env ""
       <b><U>end</U></b>
     ;;
     
 </r>320 </m><U>let</U></b> start_mbox () =
       push stack_table !in_table ; in_table := NoTable ;
       push stack_in_math !in_math ; in_math := <b><U>false</U></b> ;
       </r><U>if</U></b><r> !display <b><U>then</U><r> Dest.item_display () ;
       push stack_display !display ; display := </r><U>false</U></b> ;
 </r>325   <r>Dest.open_block "" "" ;
       new_env "*mbox"
     ;;
     
     <b><U>let</U></b> get_fun_result f lexbuf =
 </r>330    <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U><r>
         prerr_endline ("get_fun") ;
       <b><U>let</U><r> r = Dest.to_string (</r><U>fun</U></b> () -&gt;
         top_open_group () ;
         Dest.nostyle () ;
 <m>335     <r>f lexbuf ;
         top_close_group ()) <b><U>in</U>
       <U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
         prerr_endline ("get_fun -&gt; ``"^r^"''")
       <b><U>end</U></b> ;
 </r>340   <r>r
     
     
     <b><U>let</U></b> do_get_this start_lexstate restore_lexstate
         make_style  lexfun {arg=s ; subst=subst} =
 </r>345   <b><U>let</U><r> par_val = Dest.forget_par () </r><U>in</U><r>
       start_lexstate subst;
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b>
         prerr_endline ("get_this : ``"^s^"''") ;
       verbose := !verbose - 1;
 </r></b>350   <b><U>let</U><r> lexer = Lexing.from_string s </r><U>in</U>
       <U>let</U><r> r = Dest.to_string (<b><U>fun</U><r> () -&gt;
         </r><U>if</U></b> !display <b><U>then</U><r>  Dest.open_display () ;
         top_open_group () ;
         make_style () ;
 <m>355     </m>lexfun lexer ;
         top_close_group () ;
         </r><U>if</U></b> !display <b><U>then</U><r> Dest.close_display ()) </r><U>in</U>
     
       <U>let</U></b> _ = Dest.forget_par () </r><U>in</U></b>
 360   <r>verbose := !verbose + 1 ;
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U> <U>begin</U></b>
         prerr_endline ("get_this ``"^s^"'' -&gt; ``"^r^"''")
       <b><U>end</U></b> ;
       restore_lexstate () ;
 </r>365   <r>Dest.par par_val ;
       r
     
     <b><U>let</U><r> get_this_arg =
       do_get_this start_lexstate_subst restore_lexstate (</r><U>fun</U></b> () -&gt; ())
 </r>370 
     <b><U>and</U><r> get_this_string main s =
       do_get_this start_lexstate_subst restore_lexstate (</r><U>fun</U><r> () -&gt; ())
         main (string_to_arg s)
     
 <m>375 <b><U>let</U><r> more_buff = Out.create_buff ()
     ;;
     
     </r><U>let</U><r> default_format =
       Tabular.Align
 <m>380     </m>{hor="left" ; vert = "" ; wrap = <b><U>false</U><r> ;
           pre = "" ; post = "" ; width = Length.Default}
     
     </r><U>and</U></b> center_format =
       Tabular.Align
 <m>385     </m>{hor="center" ; vert = "top" ; wrap = <b><U>false</U><r> ;
           pre = "" ; post = "" ; width = Length.Default}
     ;;
     
     
 <m>390 <b><U>let</U><r> is_table = </r><U>function</U><r>
       | Table _ -&gt; <b><U>true</U><r>
       | _       -&gt; </r><U>false</U>
     
     <U>and</U></b> is_noborder_table = </r><U>function</U></b>
 395   </m>| Table {border = b} -&gt; not b
       | _                  -&gt; </r><U>false</U>
     
     <U>and</U></b> is_tabbing = <b><U>function</U></b>
       | Tabbing -&gt; </r><U>true</U></b>
 400   </m>| _ -&gt; <b><U>false</U>
     
     <U>and</U></b> math_table = <b><U>function</U><r>
       | Table {math = m} -&gt; m
       | _ -&gt; raise (Misc.Fatal "Array construct outside an array")
 <m>405 </m>;;
     
     
     </r><U>exception</U></b> EndInside
     ;;
 <m>410 <b><U>exception</U><r> NoMulti
     ;;
     
     </r><U>let</U><r> attribut name = <b><U>function</U><r>
       | "" -&gt; ""
 <m>415   </m>| s  -&gt; " "^name^"="^s
     
     </r><U>and</U></b> as_colspan = <b><U>function</U><r>
       |  1  -&gt; ""
       |  n -&gt; " COLSPAN="^string_of_int n
 <m>420 
     <b><U>let</U><r> is_inside = </r><U>function</U><r>
         Tabular.Inside _ -&gt; <b><U>true</U></b>
       | _ -&gt; </r><U>false</U></b>
     
 425 <b><U>let</U><r> is_border = </r><U>function</U><r>
       | Tabular.Border _ -&gt; <b><U>true</U><r>
       | _ -&gt; </r><U>false</U>
     
     <U>and</U></b> as_wrap = </r><U>function</U></b>
 430   </m>| Tabular.Align {wrap = w} -&gt; w
       | _ -&gt; </r><U>false</U>
     
     <U>and</U></b> as_pre = <b><U>function</U><r>
       | Tabular.Align {pre=s} -&gt; s
 <m>435   </m>| _ -&gt; raise (Misc.Fatal "as_pre")
     
     </r><U>and</U></b> as_post = <b><U>function</U><r>
       | Tabular.Align {post=s} -&gt; s
       | f -&gt; raise (Misc.Fatal ("as_post "^pretty_format f))
 <m>440 </m>;;
     
     </r><U>let</U></b> get_col format i =
       <b><U>let</U><r> r =
         </r><U>if</U></b> i &gt;= Array.length format+1 </r><U>then</U></b>
 445       </m>raise (Misc.ScanError ("This array/tabular column has no specification"))
         <b><U>else</U> <U>if</U></b> i = Array.length format <b><U>then</U><r> default_format
         </r><U>else</U></b> format.(i) <b><U>in</U>
       <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
        Printf.fprintf stderr "get_col : %d: " i ;
 <m>450    </m>prerr_endline (pretty_format r) ;
        prerr_string " &lt;- " ;
        pretty_formats format ;
        prerr_newline ()
       <b><U>end</U><r> ;
 <m>455   </m>r
     ;;
     
     </r><w>(* Paragraph breaks are different in tables *)
     </w><U>let</U></b> par_val t =
 <m>460   <b><U>if</U><r> is_table t </r><U>then</U>
         <U>match</U><r> get_col !cur_format !cur_col <b><U>with</U><r>
         | Tabular.Align {wrap=</r><U>false</U></b>} -&gt; None
         | _                          -&gt; Some 0
       </r><U>else</U></b>
 465     </m>Some 1
     
     <b><U>let</U><r> show_inside main format i closing =
     </r><w>(*
       if !verbose &gt; -1 then begin
 <m>470     </m>prerr_string ("show_inside: "^string_of_int i)
       end ;
     *)
       </w><U>let</U></b> t = ref i </r><U>in</U>
       <U>begin</U> <U>try</U> <U>while</U> <U>true</U> <U>do</U></b>
 475     </m></r><U>begin</U> <U>match</U></b><r> get_col format !t <b><U>with</U><r>
           Tabular.Inside s -&gt;
             </r><U>let</U></b> saved_table = !in_table <b><U>in</U>
             <U>if</U></b> math_table saved_table <b><U>then</U><r>
               scan_this main "$"
 </r><m>480         </m><U>else</U></b>
               scan_this main "{" ;
             <b><U>let</U><r> s = get_this_string main s </r><U>in</U>
             <U>if</U></b> math_table saved_table <b><U>then</U><r>
               scan_this main "$"
 </r><m>485         </m><U>else</U></b>
               scan_this main "}" ;
      Dest.make_inside s !in_multi;
         | Tabular.Border s -&gt;
      Dest.make_border s;
 <m>490  <b><U>if</U></b></m> !first_border <b><U>then</U><r> first_border := </r><U>false</U></b>;
         | _ -&gt; raise EndInside
         <b><U>end</U><r> ;
         t := !t+1
       </r><U>done</U> <U>with</U></b> EndInside -&gt;
 <m>495     <b><U>if</U></b></m> (!t = i) &amp;&amp; (closing || !first_border)  <b><U>then</U><r>
           Dest.make_border " ";
       </r><U>end</U></b> ;
     <w>(*
       if !verbose &gt; -1 then
 <m>500     </m>prerr_endline (" -&gt; "^string_of_int !t) ;
     *)
       </w>!t
     ;;
     
 <m>505 <b><U>let</U> <U>rec</U></b></m> eat_inside format i b insides =
       <b><U>if</U><r> i &gt;= Array.length format </r><U>then</U></b> (i , b , insides)
       <b><U>else</U> <U>begin</U>
         <U>let</U></b> f = get_col format i <b><U>in</U>
         <U>if</U></b> is_inside f <b><U>then</U><m>
 510       <r>eat_inside format (i+1) b (insides+1)
         <b><U>else</U> <U>if</U></b> is_border f <b><U>then</U><r>
           eat_inside format (i+1) (b+1) insides
         </r><U>else</U></b> i, b, insides
       <b><U>end</U><m>
 515 <r>;;
     
     <b><U>let</U> <U>rec</U></b> find_end n format i b insides = <b><U>match</U><r> n </r><U>with</U></b>
       0 -&gt; eat_inside format i b insides
     | _ -&gt;
 </r>520    </m><U>let</U></b> f = get_col format i <b><U>in</U>
        <U>if</U></b> is_inside f <b><U>then</U><r>
          find_end n format (i+1) b (insides +1)
        </r><U>else</U> <U>if</U></b> is_border f <b><U>then</U></b>
          find_end n format (i+1) (b+1) insides
 </r>525    </m><U>else</U></b>
          find_end (n-1) format (i+1) b insides
     ;;
     
     
 <m>530 <b><U>let</U></b></m> find_start i = <b><U>if</U><r> !first_border </r><U>then</U></b> 0 <b><U>else</U><r> i
     
     </r><U>let</U></b> find_align format =
       <b><U>let</U><r> t = ref 0 </r><U>in</U>
       <U>while</U></b> (is_inside (get_col format !t)) || (is_border (get_col format !t)) <b><U>do</U><m>
 535     <r>t := !t+1
       <b><U>done</U></b> ;
       !t
     ;;
     
 </r>540 </m><U>let</U></b> next_no_border format n =
       <b><U>let</U><r> t = ref n </r><U>in</U>
       <U>while</U></b> is_border (get_col format !t) <b><U>do</U><r>
         t:= !t+1
       </r><U>done</U></b>;
 <m>545   <r>!t
     ;;
     
     <b><U>let</U><r> do_open_col main format span insides =
       </r><U>let</U></b> save_table = !in_table <b><U>in</U><m>
 550   <r>Dest.open_cell format span insides;
       <b><U>if</U><r> not (as_wrap format) &amp;&amp; math_table !in_table </r><U>then</U> <U>begin</U></b>
         display  := <b><U>true</U><r> ;
         Dest.open_display ()
       </r><U>end</U></b> ;
 </r>555   </m><U>if</U></b> math_table !in_table &amp;&amp; not (as_wrap format) <b><U>then</U> <U>begin</U></b>
         scan_this main "$"
       <b><U>end</U> <U>else</U></b>
         scan_this main "{" ;
       scan_this main (as_pre format) ;
 </r>560   <r>in_table := save_table
     
     <b><U>let</U><r> open_col main  =
       </r><U>let</U></b> _ = Dest.forget_par () <b><U>in</U></b>
       Dest.open_cell_group () ;
 </r>565   <r>cur_col :=  show_inside main !cur_format !cur_col <b><U>false</U><r>;
       </r><U>let</U></b> format = (get_col !cur_format !cur_col) <b><U>in</U></b>
       do_open_col main format 1 0
     ;;
     
 </r>570 <b><U>let</U></b></m> open_first_col main =
       first_col := <b><U>true</U><r> ;
       first_border := </r><U>true</U></b>;
       open_col main
     ;;
 <m>575 
     <b><U>let</U></b></m> erase_col main =
       <b><U>let</U><r> old_format = get_col !cur_format !cur_col </r><U>in</U></b>
       scan_this main (as_post old_format) ;
       <b><U>if</U><r> math_table !in_table  &amp;&amp; not (as_wrap old_format) </r><U>then</U><m>
 580     <r>scan_this main "$"
       <b><U>else</U><r>
         scan_this main "}" ;
       </r><U>if</U></b> !display <b><U>then</U> <U>begin</U></b>
         Dest.close_display () ;
 </r>585     <r>display := <b><U>false</U>
       <U>end</U></b> ;
       Dest.erase_cell () ;
       Dest.erase_cell_group ()
     ;;
 </r>590 
     
     </m><U>let</U></b> open_row () =
       cur_col := 0 ;
       Dest.new_row ()
 <m>595 
     <b><U>and</U></b></m> close_row () = Dest.close_row ()
     ;;
     
     
 <m>600 <b><U>let</U></b></m> do_hline main =
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "hline: %d %d" !cur_col (Array.length !cur_format) ;
         prerr_newline ()
       <b><U>end</U><r> ;
 <m>605   </m>erase_col main ;
       Dest.erase_row () ;
       Dest.make_hline (Array.length !cur_format) (is_noborder_table !in_table);
       open_row () ;
       open_first_col main
 <m>610 </m>;;
     
     </r><U>let</U></b> do_multi n format main =
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
         prerr_string
 <m>615       </m>("multicolumn: n="^string_of_int n^" format:") ;
         pretty_formats format ;
         prerr_endline ""
       <b><U>end</U></b> ;
     
 </r>620   <r>erase_col main ;
     
       <b><U>let</U><r> start_span = find_start !cur_col
       </r><U>and</U></b> k,b,insides = find_end n !cur_format !cur_col 0 0 <b><U>in</U>
       <U>let</U></b> end_span = k - b <b><U>in</U><m>
 625 
       <r>in_multi := <b><U>true</U><r>;
     
       </r><U>let</U></b> i = show_inside main format 0 <b><U>true</U> <U>in</U><m>
     
 630   <r>Dest.open_cell_group () ;
       do_open_col main (get_col format i) (end_span - start_span) insides;
       push stack_multi (!cur_format,k) ;
       cur_format := format ;
       cur_col := i ;
 </r>635 <r>;;
     
     
     <b><U>let</U><r> close_col_aux main content is_last =
       </r><U>let</U></b> old_format = get_col !cur_format !cur_col <b><U>in</U><m>
 640   <r>scan_this main (as_post old_format) ;
       <b><U>if</U><r> math_table !in_table &amp;&amp; not (as_wrap old_format) </r><U>then</U></b>
         scan_this main "$"
       <b><U>else</U></b>
         scan_this main "}" ;
 </r>645   </m><U>if</U></b> !display <b><U>then</U> <U>begin</U></b>
         Dest.close_display () ;
         display := <b><U>false</U>
       <U>end</U></b> ;
       <b><U>if</U><r> is_last &amp;&amp; Dest.is_empty () </r><U>then</U></b> Dest.erase_cell ()
 </r>650   </m><U>else</U> <U>begin</U>
         <U>if</U></b> !in_multi <b><U>then</U> <U>begin</U>
           <U>let</U></b> _ = show_inside main !cur_format (!cur_col+1) <b><U>true</U> <U>in</U></b>
           in_multi := <b><U>false</U><r> ;
           </r><U>let</U></b> f,n = pop stack_multi <b><U>in</U><m>
 655       <r>cur_format := f ;
           cur_col := next_no_border f n;
           cur_col := show_inside main !cur_format !cur_col <b><U>false</U><r>;
         </r><U>end</U> <U>else</U> <U>begin</U></b>
           cur_col := !cur_col + 1;
 </r>660       <r>cur_col := show_inside main !cur_format !cur_col <b><U>true</U><r>;
         </r><U>end</U></b>;
         Dest.close_cell content;
         <b><U>if</U><r> !first_col </r><U>then</U> <U>begin</U></b>
           first_col := <b><U>false</U></b>;
 </r>665       <r>first_border := <b><U>false</U><r>;
         </r><U>end</U>
       <U>end</U></b> ;
       Dest.close_cell_group ()
     ;;
 </r>670 
     </m><U>let</U></b> close_col main content = close_col_aux main content <b><U>false</U>
     <U>and</U></b> close_last_col main content = close_col_aux main content <b><U>true</U>
     
     <U>and</U></b> close_last_row () =
 </r>675   </m><U>if</U></b> !first_col <b><U>then</U><r>
         Dest.erase_row ()
       </r><U>else</U></b>
         Dest.close_row ()
     ;;
 </r>680 
     <w>(* Compute functions *)
     
     <b><U>let</U><r> get_style lexfun {arg=s ; subst=env} =
       start_normal env ;
 </r><m>685   </m><U>let</U><r> lexer = Lexing.from_string s <b><U>in</U>
       <U>let</U></b> r = Dest.to_style (<b><U>fun</U><r> () -&gt; lexfun lexer) </r><U>in</U></b>
       end_normal () ;
       r
     
 <m>690 <w>(* Image stuff *)
     
     <b><U>let</U><r> iput_newpage () = Image.page ()
     ;;
     
 <m>695 <b><U>let</U><r> stack_entry = Stack.create "stack_entry"
     </r><U>and</U><r> stack_out = Stack.create  "stack_out"
     ;;
     
     <b><U>let</U><r> start_other_scan env lexfun lexbuf =
 <m>700   <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U> <U>begin</U><r>
         prerr_endline ("Start other scan ("^env^")") ;
         stack_env_pretty () ;
         prerr_endline ("Current env is: ``"^ !cur_env^"''") ;
         pretty (<b><U>fun</U></b> x -&gt; x) stack_entry
 <m>705   <b><U>end</U><r>;
       save_lexstate () ;
       push stack_entry env ;
       rev stack_entry ;
       lexfun lexbuf
 <m>710 </m>;;
     
     </r><U>let</U><r> start_image_scan s image lexbuf =
       start_other_scan "toimage" (<b><U>fun</U><r> b -&gt; Image.dump s image b) lexbuf
     ;;
 <m>715 
     <b><U>let</U><r> complete_scan main lexbuf =
       main lexbuf ;
       close_env (pop stack_out) ;
       top_close_block "" ;
 <m>720   <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U> <U>begin</U><r>
         prerr_endline "Complete scan" ;
         stack_env_pretty () ;
         prerr_endline ("Current env is: ``"^ !cur_env^"''")
       </r><U>end</U></b>
 725 </m>;;
     
     
     </r><U>let</U><r> stop_other_scan comment main lexbuf =
       <b><U>if</U></b> !verbose &gt; 1 </r><U>then</U> <U>begin</U></b>
 730     </m>prerr_endline "Stop image: env stack is" ;
         stack_env_pretty () ;
         prerr_endline ("Current env is: ``"^ !cur_env^"''")
       </r><U>end</U></b>;
       <b><U>let</U></b> _ = pop stack_entry </r><U>in</U></b>
 735   <b><U>if</U><r> not comment </r><U>then</U><r> close_env !cur_env ;
       <b><U>if</U><r> not (Stack.empty stack_out) </r><U>then</U> <U>begin</U></b>
         complete_scan main lexbuf ;
         <b><U>while</U><r> not (Stack.empty stack_out) </r><U>do</U>
           <U>let</U></b> lexbuf = previous_lexbuf () </r><U>in</U></b>
 740       </m>complete_scan main lexbuf
         </r><U>done</U>
       <U>end</U><r> ;
       restore_lexstate ()
     ;;
 <m>745 
     <b><U>let</U><r> includes_table = Hashtbl.create 17
     </r><U>and</U><r> check_includes = ref <b><U>false</U><r>
     ;;
     
 <m>750 <b><U>let</U><r> add_includes l =
       check_includes := </r><U>true</U><r> ;
       List.iter (<b><U>fun</U></b> x -&gt; Hashtbl.add includes_table x ()) l
     ;;
     
 <m>755 
     <b><U>let</U><r> check_include s =
       not !check_includes ||
       </r><U>begin</U>  <U>try</U><r>
         Hashtbl.find includes_table s ; </r><U>true</U></b>
 760   <b><U>with</U><r> Not_found -&gt; </r><U>false</U>
       <U>end</U><r>
     ;;
     
     
 <m>765 <b><U>let</U><r> mk_out_file () = </r><U>match</U><r> Parse_opts.name_out,!Parse_opts.destination <b><U>with</U><r>
     | "", Parse_opts.Info -&gt;  Out.create_buff ()
     | "", _ -&gt; Out.create_chan stdout
     | x , Parse_opts.Info -&gt; Out.create_chan (open_out (x^".tmp"))
     | x , _  -&gt; Out.create_chan (open_out x)
 <m>770 </m>;;
     
     </r><U>let</U></b> no_prelude () =
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b> prerr_endline "Filter mode" ;
       flushing := <b><U>true</U><r> ;
 <m>775   <b><U>let</U><r> _ = Dest.forget_par () </r><U>in</U><r> () ;
       Dest.set_out (mk_out_file ())
     ;;
     
     <b><U>let</U><r> macro_depth = ref 0
 <m>780 </m>;;
     
     </r><U>let</U></b> debug = <b><U>function</U><r>
       | Not -&gt; "Not"
       | Macro -&gt; "Macro"
 <m>785   </m>| Inside -&gt; "Inside"
     ;;
     
     
     </r><U>let</U> <U>rec</U></b> expand_toks main = </r><U>function</U></b>
 790   </m>| [] -&gt; ()
       | s::rem -&gt;
           expand_toks main rem ;
           scan_this main s
     
 <m>795 <b><U>let</U><r> expand_command main skip_blanks name lexbuf =
       </r><U>if</U><r> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "expand_command: %s\n" name
       <b><U>end</U><r> ;
       </r><U>let</U></b> cur_subst = get_subst () </r><U>in</U></b>
 800   <b><U>let</U><r> exec =
         </r><U>if</U><r> !alltt_loaded <b><U>then</U>
           <U>function</U></b>
             | Subst body -&gt;
                 <b><U>if</U></b> !verbose &gt; 2 </r><U>then</U></b>
 805               </m>prerr_endline ("user macro: "^body) ;
                 </r><U>let</U></b> old_alltt = !alltt <b><U>in</U><r>
                 Stack.push stack_alltt old_alltt ;
                 alltt :=
                    (</r><U>match</U></b> old_alltt </r><U>with</U></b>
 810                </m>| Not -&gt; Not
                    | _   -&gt; Macro) ;
     <w>(*
       Printf.fprintf stderr
       "Enter: %s, %s -&gt; %s\n" name (debug old_alltt) (debug !alltt) ;
 <m>815   </m>*)
                 </w>scan_this_may_cont main lexbuf cur_subst (string_to_arg body) ;
                 <b><U>let</U><r> _ =  Stack.pop stack_alltt </r><U>in</U></b>
                 alltt :=
                    (<b><U>match</U></b> old_alltt, !alltt </r><U>with</U></b>
 820                </m>| Not, Inside         -&gt; Inside
                    | (Macro|Inside), Not -&gt; Not
                    | _, _                -&gt; old_alltt)
     <w>(*
       Printf.fprintf stderr
 <m>825   </m>"After: %s, %s -&gt; %s\n" name (debug old_alltt) (debug !alltt)
       *)
             </w>| Toks l -&gt; expand_toks main l
             | CamlCode f -&gt; f lexbuf
         </r><U>else</U></b>
 830       <b><U>function</U><r>
             | Subst body -&gt;
                 </r><U>if</U><r> !verbose &gt; 2 <b><U>then</U><r>
                   prerr_endline ("user macro: "^body) ;
                 scan_this_may_cont main lexbuf cur_subst (string_to_arg body)
 <m>835         </m>| Toks l -&gt; expand_toks main l
             | CamlCode f -&gt; f lexbuf </r><U>in</U>
     
       <U>let</U></b> pat,body = Latexmacros.find name <b><U>in</U>
       <U>let</U></b> par_before = Dest.forget_par () </r><U>in</U></b>
 840   <b><U>if</U><r>
         (</r><U>if</U><r> !in_math <b><U>then</U><r> Latexmacros.invisible name
         </r><U>else</U></b>
           not (effective !alltt) &amp;&amp;
           is_subst body &amp;&amp; last_letter name)
 <m>845   <b><U>then</U> <U>begin</U>
         <U>if</U><r> !verbose &gt; 2 <b><U>then</U></b>
           prerr_endline ("skipping blanks ("^name^")");
         skip_blanks lexbuf
       </r><U>end</U> <U>else</U> <U>begin</U></b>
 850     <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U><r>
           prerr_endline ("not skipping blanks ("^name^")")
         <b><U>end</U>
       <U>end</U></b> ;
       <b><U>let</U></b> par_after = Dest.forget_par () </r><U>in</U></b>
 855   </m>Dest.par par_before ;
       <b><U>let</U><r> args = make_stack name pat lexbuf </r><U>in</U>
       <U>let</U></b> saw_par = !Save.seen_par <b><U>in</U>
       <U>if</U></b> (!verbose &gt; 1) <b><U>then</U> <U>begin</U></b>
         prerr_endline
 <m>860       </m>("Expanding macro "^name^" {"^(string_of_int !macro_depth)^"}") ;
         macro_depth := !macro_depth + 1
       <b><U>end</U><r> ;
       scan_body exec body args ;
       </r><U>if</U></b> (!verbose &gt; 1) </r><U>then</U> <U>begin</U></b>
 865     </m>prerr_endline ("Cont after macro "^name^": ") ;
         macro_depth := !macro_depth - 1
       </r><U>end</U></b> ;
       Dest.par par_after ;
       <b><U>if</U></b> saw_par </r><U>then</U> <U>begin</U></b>
 870     </m>top_par (par_val !in_table)
       </r><U>end</U><r>
     ;;
     
     </r><U>let</U><r> count_newlines s =
 <m>875   <b><U>let</U><r> l = String.length s </r><U>in</U>
       <U>let</U> <U>rec</U><r> c_rec i =
         <b><U>if</U><r> i &gt;= l </r><U>then</U></b> 0
         <b><U>else</U> <U>match</U></b> s.[i] <b><U>with</U><r>
         | '\n'  -&gt; 1 + c_rec (i+1)
 <m>880     </m>| _     -&gt;  c_rec (i+1) </r><U>in</U></b>
       c_rec 0
     ;;
     
     <b><U>let</U><r> check_case s = </r><U>match</U></b> !case </r><U>with</U></b>
 885 </m>| Lower -&gt;  String.lowercase s
     | Upper -&gt; String.uppercase s
     | Neutral -&gt; s
     
     <b><U>and</U><r> check_case_char c = </r><U>match</U></b> !case </r><U>with</U></b>
 890 </m>| Lower -&gt; Char.lowercase c
     | Upper -&gt; Char.uppercase c
     | Neutral -&gt; c
     }
     
 <m>895 <b><U>let</U><r> command_name = '\\' (( ['@''A'-'Z' 'a'-'z']+ '*'?) | [^ 'A'-'Z' 'a'-'z'])
     
     rule  main = parse
     <w>(* comments *)
      <r>| '%'
 <m>900    </m>{expand_command main skip_blanks "\\@hevea@percent" lexbuf ;
        main lexbuf}
     
     </r>(* Paragraphs *)
       <r>| '\n'
 <m>905       </m>{expand_command main skip_blanks "\\@hevea@newline" lexbuf ;
           main lexbuf}
     </r>(* subscripts and superscripts *)
       <r>| '_'
           {expand_command main skip_blanks "\\@hevea@underscore" lexbuf ;
 <m>910       </m>main lexbuf}
       | '^'
           {expand_command main skip_blanks "\\@hevea@circ" lexbuf ;
           main lexbuf}
     </r>(* Math mode *)
 <m>915 </m></w>| "$" | "$$"
          {</r><U>let</U><r> lxm = lexeme lexbuf <b><U>in</U><w>
          (* ``$'' has nothing special *)
          </w><U>let</U></b> dodo = lxm &lt;&gt; "$" <b><U>in</U>
          <U>if</U></b> effective !alltt || not (is_plain '$') </r><U>then</U> <U>begin</U></b>
 920        </m>Dest.put lxm ; main lexbuf
          </r><w>(* vicious case ``$x$$y$'' *)
          </w><U>end</U> <U>else</U> <U>if</U></b> dodo &amp;&amp; not !display &amp;&amp; !in_math <b><U>then</U> <U>begin</U></b>
            scan_this main "${}$" ;
            main lexbuf
 <m>925      <b><U>end</U> <U>else</U> <U>begin</U><w> (* General case *)
            </w><U>let</U><r> math_env = <b><U>if</U><r> dodo </r><U>then</U></b> "*display" <b><U>else</U><r> "*math" </r><U>in</U>
            <U>if</U></b> !in_math <b><U>then</U> <U>begin</U></b>
              in_math := pop stack_in_math ;
              <b><U>if</U></b> dodo </r><U>then</U> <U>begin</U></b>
 930     </m>Dest.close_maths dodo
              <b><U>end</U> <U>else</U> <U>begin</U></b>
                top_close_display () ;
         Dest.close_maths dodo
              <b><U>end</U><r> ;
 <m>935          </m>display := pop stack_display ;
              </r><U>if</U></b> !display <b><U>then</U> <U>begin</U></b>
                Dest.item_display ()
              <b><U>end</U><r> ;
              close_env math_env ;
 <m>940          </m>main lexbuf
            </r><U>end</U> <U>else</U> <U>begin</U></b>
              push stack_in_math !in_math ;
              in_math := <b><U>true</U><r> ;
              </r><U>let</U></b> lexfun lb =
 <m>945            <b><U>if</U><r> !display </r><U>then</U><r>  Dest.item_display () ;
                push stack_display !display ;
                <b><U>if</U><r> dodo </r><U>then</U> <U>begin</U></b>
                  display  := <b><U>true</U><r> ;
           Dest.open_maths dodo;
 <m>950            <b><U>end</U> <U>else</U> <U>begin</U><r>
           Dest.open_maths dodo;
                  top_open_display () ;
                <b><U>end</U></b>;
                skip_blanks lb ; main lb </r><U>in</U></b>
 955          </m>new_env math_env ;
              lexfun lexbuf
            </r><U>end</U> <U>end</U></b>}
     
     <w>(* Definitions of  simple macros *)
 <m>960 </m>(* inside tables and array *)
       <r>| [' ''\n']* "&amp;"
         {expand_command main skip_blanks "\\@hevea@amper" lexbuf ;
         main lexbuf}
     </r>(* Substitution  *)
 <m>965   </m></w>| '#' ['1'-'9']
           {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
           <U>begin</U> <U>if</U></b> effective !alltt || not (is_plain '#') <b><U>then</U></b>
             Dest.put lxm
           </r><U>else</U></b>
 970         <b><U>let</U><r> i = Char.code lxm.[1] - Char.code '1' </r><U>in</U><r>
             scan_arg
               (<b><U>if</U><r> !alltt_loaded </r><U>then</U></b>
                 (<b><U>fun</U><r> arg -&gt;
                   </r><U>let</U></b> old_alltt = !alltt </r><U>in</U></b>
 975               </m>alltt := Stack.pop stack_alltt ;
                   scan_this_may_cont main lexbuf (get_subst ()) arg ;
                   alltt := old_alltt ;
                   Stack.push stack_alltt old_alltt)
               </r><U>else</U></b>
 980             </m>(</r><U>fun</U><r> arg -&gt; scan_this_may_cont main lexbuf (get_subst ()) arg))
               i
           <b><U>end</U></b> ;
           main lexbuf}
     </r></b>(* Commands *)
 </w>985   </m>| command_name
           {<b><U>let</U><r> name = lexeme lexbuf </r><U>in</U></b>
           expand_command main skip_blanks name lexbuf ;
           main lexbuf}
     </r></b>(* Groups *)
 </w>990 <r>| '{'
         {expand_command main skip_blanks "\\@hevea@obrace" lexbuf ;
         main lexbuf}
     | '}'
         {expand_command main skip_blanks "\\@hevea@cbrace" lexbuf ;
 </r>995     <r>main lexbuf}
     | eof {()}
     | ' '+
        {<b><U>if</U><r> effective !alltt </r><U>then</U>
          <U>let</U></b> lxm = lexeme lexbuf <b><U>in</U></b> Dest.put lxm
</r>1000    <b><U>else</U><r>
          Dest.put_char ' ';
        main lexbuf}
     <w>(* Alphabetic characters *)
     </w>| ['a'-'z' 'A'-'Z']+
<m>1005    </m>{</r><U>let</U><r> lxm = lexeme lexbuf <b><U>in</U>
        <U>let</U></b> lxm = check_case lxm <b><U>in</U>
        <U>if</U></b> !in_math <b><U>then</U> <U>begin</U></b>
           Dest.put_in_math lxm;
         <b><U>end</U> <U>else</U><m>
1010       <r>Dest.put lxm ;
         main lexbuf}
     <w>(* Numbers *)
     </w>| ['0'-'9']+
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U><m>
1015     <r>Dest.put lxm;
         main lexbuf}
     <w>(* Html specials *)
     </w>| '~'
       {expand_command main skip_blanks "\\@hevea@tilde" lexbuf ;
</r>1020   <r>main lexbuf }
     <w>(* Spanish stuff *)
     </w>| '?'
       {expand_command main skip_blanks "\\@hevea@question" lexbuf ;
       main lexbuf}
</r>1025 <r>| '!'
       {expand_command main skip_blanks "\\@hevea@excl" lexbuf ;
       main lexbuf}
     <w>(* One character *)
     </w>| _
</r>1030    <r>{<b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U>
        <U>let</U></b> lxm = check_case_char lxm <b><U>in</U></b>
        Dest.put (Dest.iso lxm) ;
        main lexbuf}
     
</r>1035 </m><U>and</U></b> gobble_one_char = parse
     | _   {()}
     | ""  {fatal ("Gobble at end of file")}
     
     <b><U>and</U></b> complete_newline = parse
</r>1040 <r>|  (' '* '\n')* {lexeme lexbuf}
     
     <b><U>and</U></b> latex2html_latexonly = parse
     | '%' + [ ' ' '\t' ] * "\\end{latexonly}" [ ^ '\n' ] * '\n'
         { () }
</r>1045 <r>| _
         {latex2html_latexonly lexbuf}
     | eof
         {fatal "End of file in latex2html_latexonly"}
     
</r>1050 </m><U>and</U></b> latexonly = parse
        '%'+ ' '* ("END"|"end") ' '+ ("LATEX"|"latex")  [^'\n']* '\n'
          {stop_other_scan <b><U>true</U><r> main lexbuf}
     |  '%'+ ' '* ("HEVEA"|"hevea") ' '*
          {latexonly lexbuf}
<m>1055 </m>|  '%'
          {latex_comment lexbuf ; latexonly lexbuf}
     |  "\\end"
          {</r><U>let</U></b> {arg=arg} = save_arg lexbuf <b><U>in</U>
          <U>if</U></b> arg = "latexonly" <b><U>then</U> <U>begin</U><m>
1060        <r>top_close_block "" ;
            stop_other_scan <b><U>false</U><r> main lexbuf
          </r><U>end</U> <U>else</U> <U>if</U></b> arg = top stack_entry <b><U>then</U> <U>begin</U>
            <U>let</U></b> _ = pop stack_entry <b><U>in</U></b>
            push stack_out arg ;
</r>1065        </m><U>begin</U> <U>match</U></b> Latexmacros.find (end_env arg) <b><U>with</U><r>
              _,(Subst body) -&gt;
                scan_this_may_cont latexonly lexbuf (get_subst ())
                  (string_to_arg body)
            |  _,_ -&gt;
<m>1070            </m>raise (Misc.ScanError ("Bad closing macro in latexonly: ``"^arg^"''"))
            </r><U>end</U>
          <U>end</U> <U>else</U></b>
            latexonly lexbuf}
     | command_name  | _ {latexonly lexbuf}
<m>1075 <r>| eof
         {<b><U>if</U><r> empty stack_lexbuf </r><U>then</U></b> ()
         <b><U>else</U> <U>begin</U>
           <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U></b>
           latexonly lexbuf
</r>1080     <b><U>end</U></b></m>}
     
     
     <b><U>and</U><r> latex_comment = parse
       '\n' | eof  {()}
<m>1085 </m>| [^'\n']+    {latex_comment lexbuf}
     
     
     
     </r><U>and</U></b> image = parse
<m>1090    </m>'%'+ ' '* ("END"|"end") ' '+ ("IMAGE"|"image")  [^'\n']* '\n'
          {stop_other_scan <b><U>true</U><r> main lexbuf}
     |  '%'+ ' '* ("HEVEA"|"hevea") ' '*
          {image lexbuf}
     |  '%'
<m>1095      </m>{</r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><r>
          Image.put lxm ;
          image_comment lexbuf ;
          image lexbuf}
     <w>(* Substitution in image *)
<m>1100 </m></w>| '#' ['1'-'9']
         {</r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U>
         <U>let</U></b> i = Char.code (lxm.[1]) - Char.code '1' <b><U>in</U><r>
         scan_arg (scan_this_arg image) i ;
         image lexbuf}
<m>1105 </m>|  "\\end"
          {</r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><r>
          Save.start_echo () ;
          </r><U>let</U></b> {arg=arg} = save_arg lexbuf <b><U>in</U>
          <U>let</U></b> true_arg = Save.get_echo () <b><U>in</U><m>
1110      </m><U>if</U></b> arg = "toimage" <b><U>then</U> <U>begin</U></b>
            top_close_block "" ;
            stop_other_scan <b><U>false</U><r> main lexbuf
          </r><U>end</U> <U>else</U> <U>if</U></b> arg = top stack_entry <b><U>then</U> <U>begin</U>
            <U>let</U></b> _ = pop stack_entry <b><U>in</U><m>
1115        <r>push stack_out arg ;
            <b><U>begin</U> <U>match</U></b> Latexmacros.find (end_env arg) <b><U>with</U></b>
              _,(Subst body) -&gt;
                scan_this_may_cont  image lexbuf (get_subst ())
                  (string_to_arg body)
</r>1120        <r>|  _,_ -&gt; raise (Misc.ScanError ("Bad closing macro in image: ``"^arg^"''"))
            <b><U>end</U>
          <U>end</U> <U>else</U> <U>begin</U></b>
            Image.put lxm ; Image.put true_arg ;
            image lexbuf
</r>1125      </m><U>end</U></b>}
     |  command_name
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>begin</U> <U>match</U></b> lxm <b><U>with</U><w>
     (* Definitions of  simple macros, bodies are not substituted *)
</w><m>1130     <r>| "\\def" | "\\gdef" -&gt;
             Save.start_echo () ;
             skip_csname lexbuf ;
             skip_blanks lexbuf ;
             <b><U>let</U><r> _ = Save.defargs lexbuf </r><U>in</U><m>
1135         </m><U>let</U></b> _ = save_arg lexbuf <b><U>in</U><r>
             Image.put lxm ;
             </r><U>let</U></b> saved = Save.get_echo () <b><U>in</U></b>
             Image.put saved
         | "\\renewcommand" | "\\newcommand" | "\\providecommand"
</r>1140     <r>| "\\renewcommand*" | "\\newcommand*" | "\\providecommand*" -&gt;
             Save.start_echo () ;
             <b><U>let</U><r> _ = save_arg lexbuf </r><U>in</U>
             <U>let</U></b> _ = save_opts ["0" ; ""] lexbuf <b><U>in</U>
             <U>let</U></b> _ = save_arg lexbuf <b><U>in</U><m>
1145         <r>Image.put lxm ;
             <b><U>let</U><r> saved = Save.get_echo () </r><U>in</U></b>
             Image.put saved
         | "\\newenvironment" | "\\renewenvironment"
         | "\\newenvironment*" | "\\renewenvironment*" -&gt;
</r>1150         <r>Save.start_echo () ;
             <b><U>let</U><r> _ = save_arg lexbuf </r><U>in</U>
             <U>let</U></b> _ = save_opts ["0" ; ""] lexbuf <b><U>in</U>
             <U>let</U></b> _ = save_arg lexbuf <b><U>in</U>
             <U>let</U></b> _ = save_arg lexbuf <b><U>in</U><m>
1155         <r>Image.put lxm ;
             Image.put (Save.get_echo ())
         | _ -&gt; Image.put lxm <b><U>end</U></b> ;
         image lexbuf}
     | _
</r>1160      <r>{<b><U>let</U><r> s = lexeme lexbuf </r><U>in</U></b>
          Image.put s ;
          image lexbuf}
     | eof
         {<b><U>if</U><r> empty stack_lexbuf </r><U>then</U> <U>begin</U><m>
1165       </m><U>if</U></b> not filter &amp;&amp; top_lexstate () <b><U>then</U><r>
             raise (Misc.ScanError ("No \\end{document} found"))
         </r><U>end</U> <U>else</U> <U>begin</U>
           <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U></b>
           image lexbuf
</r>1170     </m><U>end</U></b>}
     
     
     <b><U>and</U></b> image_comment = parse
       '\n' {Image.put_char '\n'}
</r>1175 <r>| eof  {()}
     | [^'\n']+
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
         Image.put lxm ;
         image_comment lexbuf}
</r>1180 
     </m><U>and</U></b> mbox_arg = parse
     | ' '+ | '\n' {mbox_arg lexbuf}
     | eof
          {<b><U>if</U><r> not (empty stack_lexbuf) </r><U>then</U> <U>begin</U><m>
1185      </m><U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U>
          <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
            prerr_endline "Poping lexbuf in mbox_arg" ;
            pretty_lexbuf lexbuf
          <b><U>end</U></b> ;
</r>1190      <r>mbox_arg lexbuf
        <b><U>end</U> <U>else</U></b> raise (Misc.ScanError "End of file in \\mbox argument")}
     | '{' | ("\\bgroup" ' '* '\n'? ' '*)
         {start_mbox ()}
     | ""
</r>1195     <r>{raise (Misc.ScanError "Cannot find a \\mbox argument here, use braces")}
     
     <b><U>and</U></b> no_skip = parse
     | "" {()}
     
</r>1200 </m><U>and</U></b> skip_blanks_pop = parse
       ' '+ {skip_blanks_pop lexbuf}
     | '\n' {more_skip_pop lexbuf}
     | ""   {()}
     | eof
<m>1205    </m>{</r><U>if</U><r> not (empty stack_lexbuf) <b><U>then</U> <U>begin</U>
          <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U>
          <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
            prerr_endline "Poping lexbuf in skip_blanks" ;
            pretty_lexbuf lexbuf
<m>1210      <b><U>end</U></b></m> ;
          skip_blanks_pop lexbuf
        <b><U>end</U> <U>else</U></b> ()}
     
     <b><U>and</U><r> more_skip_pop = parse
<m>1215   </m>'\n'+ {top_par (par_val !in_table)}
     | ""    {skip_blanks_pop lexbuf}
     | eof
        {</r><U>if</U></b> not (empty stack_lexbuf) <b><U>then</U> <U>begin</U>
          <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U><m>
1220      </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
            prerr_endline "Poping lexbuf in skip_blanks" ;
            pretty_lexbuf lexbuf
          <b><U>end</U><r> ;
          more_skip_pop lexbuf
</r><m>1225    </m><U>end</U> <U>else</U></b> ()}
     
     <b><U>and</U><r> to_newline = parse
     |  '\n' {()}
     | _     {Out.put_char more_buff (Lexing.lexeme_char lexbuf 0) ;
<m>1230         </m>to_newline lexbuf}
     | eof
        {</r><U>if</U></b> not (empty stack_lexbuf) <b><U>then</U>
          <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U><r>
          to_newline lexbuf}
</r><m>1235 
     </m><U>and</U></b> skip_blanks = parse
       ' '+ {skip_blanks lexbuf}
     | '\n' {more_skip lexbuf}
     | ""   {()}
<m>1240 
     <b><U>and</U></b></m> more_skip = parse
       '\n'+ {top_par (par_val !in_table)}
     | ""    {skip_blanks lexbuf}
     
<m>1245 <b><U>and</U></b></m> skip_spaces = parse
       ' ' * {()}
     | eof   {()}
     
     
<m>1250 <b><U>and</U></b></m> skip_false = parse
     |  '%'
          {<b><U>if</U><r> is_plain '%' </r><U>then</U></b> skip_comment lexbuf ;
            skip_false lexbuf}
     |  "\\ifthenelse"
<m>1255      <r>{skip_false lexbuf}
     |  "\\if" ['a'-'z' 'A'-'Z''@']+
          {if_level := !if_level + 1 ;
          skip_false lexbuf}
     | "\\else" ['a'-'z' 'A'-'Z''@']+
</r>1260      <r>{skip_false lexbuf}
     | "\\else"
          {<b><U>if</U><r> !if_level = 0 </r><U>then</U></b> skip_blanks lexbuf
          <b><U>else</U></b> skip_false lexbuf}
     | "\\fi" ['a'-'z' 'A'-'Z']+
</r>1265      <r>{skip_false lexbuf}
     | "\\fi"
          {<b><U>if</U><r> !if_level = 0 </r><U>then</U> <U>begin</U></b>
             skip_blanks lexbuf
          <b><U>end</U> <U>else</U> <U>begin</U><m>
1270        <r>if_level := !if_level -1 ;
            skip_false lexbuf
          <b><U>end</U></b>}
     | _  {skip_false lexbuf}
     | "" {raise (Error "End of entry while skipping TeX conditional macro")}
</r>1275 
     </m><U>and</U></b> comment = parse
     |  ['%'' ']* ("BEGIN"|"begin") ' '+ ("IMAGE"|"image")
         {skip_comment lexbuf ; start_image_scan "" image lexbuf}
     <w>(* Backward compatibility with latex2html *)
<m>1280 <r>| [ ' ' '\t' ] * "\\begin{latexonly}"
         {latex2html_latexonly lexbuf}
     | ['%'' ']* ("HEVEA"|"hevea") ' '*
        {()}
     | ['%'' ']* ("BEGIN"|"begin") ' '+ ("LATEX"|"latex")
</r>1285     <r>{skip_to_end_latex lexbuf}
     | ""
         {skip_comment lexbuf ; more_skip lexbuf}
     
     <b><U>and</U></b> skip_comment = parse
</r>1290 <r>|  [^ '\n']* '\n'
        {<b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b>
          prerr_endline ("Comment:"^lexeme lexbuf) ;
        <b><U>if</U><r> !flushing </r><U>then</U></b> Dest.flush_out () }
     | "" {raise (Misc.ScanError "Latex comment is not terminated")}
</r>1295 
     <b><U>and</U><r> skip_to_end_latex = parse
     | '%' ['%'' ']* ("END"|"end") ' '+ ("LATEX"|"latex")
         {skip_comment lexbuf ; skip_spaces lexbuf}
     | _
</r></b>1300     <r>{skip_to_end_latex lexbuf}
     | eof {fatal ("End of file in %BEGIN LATEX ... %END LATEX")}
     {
     <b><U>let</U></b> _ = ()
     ;;
</r>1305 </m>(* A few subst definitions, with 2 optional arguments *)
     
     </w>def "\\makebox" (latex_pat ["" ; ""] 3)
         (Subst "\\warning{makebox}\\mbox{#3}") ;
     def "\\framebox" (latex_pat ["" ; ""] 3)
</r>1310     <r>(Subst "\\warning{framebox}\\fbox{#3}")
     ;;
     
     
     <b><U>let</U></b> check_alltt_skip lexbuf =
</r>1315   <b><U>if</U></b></m> not (effective !alltt) <b><U>then</U><r> skip_blanks lexbuf
     
     </r><U>and</U></b> skip_pop lexbuf =
       save_lexstate () ;
       skip_blanks_pop lexbuf ;
<m>1320   <r>restore_lexstate ()
     ;;
     
     <b><U>let</U><r> def_code name f = def_init name f
     </r><U>let</U></b> def_name_code name f = def_init name (f name)
</r>1325 <r>;;
     
     
     def_code "\\@hevea@percent"
         (<b><U>fun</U></b> lexbuf -&gt;
</r>1330       <b><U>if</U></b></m> effective !alltt || not (is_plain '%') <b><U>then</U> <U>begin</U>
             <U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><r>
             Dest.put lxm ;
             main lexbuf
           </r><U>end</U> <U>else</U> <U>begin</U><m>
1335         <r>comment lexbuf
           <b><U>end</U></b>)
     ;;
     
     def_code "\\@hevea@newline"
</r>1340     <r>(<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> lxm = complete_newline lexbuf <b><U>in</U>
           <U>let</U></b> nlnum = count_newlines lxm <b><U>in</U>
           <U>if</U></b> !Lexstate.withinLispComment
           <b><U>then</U> <U>begin</U><m>
1345         </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline "NL caught after LispComment" ;
             raise (Misc.EndOfLispComment nlnum) </r><w>(* QNC *)
           </w><U>end</U> <U>else</U> <U>begin</U>
             <U>if</U></b> effective !alltt <b><U>then</U> <U>begin</U></b>
               Dest.put_char '\n' ;
</r>1350           <r>Dest.put lxm
             <b><U>end</U> <U>else</U> <U>if</U></b> nlnum &gt;= 1 <b><U>then</U><r>
               expand_command main skip_blanks "\\par" lexbuf
             </r><U>else</U></b>
               Dest.put_separator ()
</r>1355        </m><U>end</U></b>)
     ;;
     
     <b><U>let</U><r> sub_sup lxm lexbuf =
       </r><U>if</U></b> effective !alltt || not (is_plain lxm) <b><U>then</U><r> Dest.put_char lxm
<m>1360   <b><U>else</U> <U>if</U><r> not !in_math <b><U>then</U> <U>begin</U></b>
         warning ("``"^Char.escaped lxm^"''occuring outside math mode") ;
         Dest.put_char lxm
       <b><U>end</U> <U>else</U> <U>begin</U>
         <U>let</U></b> sup,sub = <b><U>match</U></b> lxm </r><U>with</U></b>
1365       </m>'^' -&gt;
             </r><U>let</U></b> sup = save_arg lexbuf </r><U>in</U></b>
             <b><U>let</U><r> sub = save_sub lexbuf </r><U>in</U><r>
             sup,unoption sub
         | '_'   -&gt;
<m>1370         <b><U>let</U></b></m> sub = save_arg lexbuf <b><U>in</U>
             <U>let</U></b> sup = save_sup lexbuf <b><U>in</U><r>
             unoption sup,sub
         | _ -&gt; </r><U>assert</U> <U>false</U> <U>in</U></b>
         Dest.standard_sup_sub (scan_this_arg main) (<b><U>fun</U><r> () -&gt; ()) sup sub !display
</r><m>1375   </m><U>end</U></b>
     ;;
     
     def_code "\\@hevea@underscore" (<b><U>fun</U><r> lexbuf -&gt; sub_sup '_' lexbuf) ;
     def_code "\\@hevea@circ" (</r><U>fun</U></b> lexbuf -&gt; sub_sup '^' lexbuf)
<m>1380 </m>;;
     
     def_code "\\mathop"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> symbol = save_arg lexbuf <b><U>in</U><m>
1385     </m><U>let</U></b> {limits=limits ; sup=sup ; sub=sub} = save_sup_sub lexbuf <b><U>in</U>
         <U>begin</U> <U>match</U></b> limits <b><U>with</U><r>
         | (Some Limits|None) </r><U>when</U></b> !display -&gt;
             Dest.limit_sup_sub
               (scan_this_arg main)
<m>1390           </m>(<b><U>fun</U></b> _ -&gt; scan_this_arg main symbol) sup sub !display
         | (Some IntLimits) </r><U>when</U><r> !display -&gt;
             Dest.int_sup_sub <b><U>true</U><r> 3
               (scan_this_arg main)
               (</r><U>fun</U></b> () -&gt; scan_this_arg main symbol)
<m>1395           <r>sup sub !display
         | _ -&gt;
             scan_this_arg main symbol ;
             Dest.standard_sup_sub
               (scan_this_arg main)
</r>1400           <r>(<b><U>fun</U><r> _ -&gt; ()) sup sub !display
         </r><U>end</U></b>)
     ;;
     
     
</r>1405 <r>def_code "\\@hevea@obrace"
         (<b><U>fun</U><r> _ -&gt;
           </r><U>if</U></b> !activebrace &amp;&amp; is_plain '{' <b><U>then</U><r>
             top_open_group ()
           </r><U>else</U> <U>begin</U><m>
1410         <r>Dest.put_char '{'
           <b><U>end</U><r>) ;
     
     def_code "\\bgroup"
         (</r><U>fun</U></b> lexbuf -&gt;
</r>1415       <r>top_open_group () ;
           check_alltt_skip lexbuf)
     ;;
     
     def_code "\\@hevea@cbrace"
</r>1420     <r>(<b><U>fun</U><r> _ -&gt;
           </r><U>if</U></b> !activebrace &amp;&amp; is_plain '}' <b><U>then</U> <U>begin</U></b>
             top_close_group ()
           <b><U>end</U> <U>else</U> <U>begin</U></b>
             Dest.put_char '}'
</r>1425       </m><U>end</U></b>) ;
     def_code "\\egroup"
         (<b><U>fun</U></b> lexbuf -&gt;
           top_close_group () ;
           check_alltt_skip lexbuf)
</r>1430 <r>;;
     
     
     def_code "\\@hevea@tilde"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>1435     <b><U>if</U></b></m> effective !alltt || not (is_plain '~') <b><U>then</U><r>
           Dest.put_char '~'
         </r><U>else</U></b> Dest.put_nbsp ())
     ;;
     
<m>1440 <r>def_code "\\@hevea@question"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>if</U></b> if_next_char '`' lexbuf <b><U>then</U> <U>begin</U></b>
           gobble_one_char lexbuf ;
           <b><U>if</U><r> effective !alltt </r><U>then</U></b> Dest.put "?`"
</r>1445       <b><U>else</U></b></m>
             Dest.put (Dest.iso '')
         <b><U>end</U> <U>else</U></b>
           Dest.put_char  '?')
     ;;
<m>1450 <r>def_code "\\@hevea@excl"
       (<b><U>fun</U><r> lexbuf -&gt;
          </r><U>if</U></b> if_next_char '`' lexbuf <b><U>then</U> <U>begin</U></b>
            gobble_one_char lexbuf ;
            <b><U>if</U><r> effective !alltt </r><U>then</U></b> Dest.put "!`"
</r>1455        <b><U>else</U></b></m> Dest.put (Dest.iso '')
          <b><U>end</U> <U>else</U></b>
            Dest.put_char '!')
     ;;
     
<m>1460 <b><U>let</U></b></m> get_this_main arg = get_this_string main arg
     
     <b><U>let</U><r> check_this_main s =
       </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
         prerr_endline ("check_this: ``"^s^"''");
<m>1465   </m>start_normal (get_subst ()) ;
       </r><U>let</U></b> save_par = Dest.forget_par () <b><U>in</U><r>
       Dest.open_block "TEMP" "";
       </r><U>let</U></b> r =
         <b><U>try</U><m>
1470       <r>scan_this main s ;
           <b><U>true</U>
         <U>with</U></b>
         |  x -&gt; <b><U>false</U> <U>in</U></b>
       Dest.erase_block "TEMP" ;
</r>1475   <r>Dest.par save_par ;
       end_normal () ;
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b>
         prerr_endline ("check_this: ``"^s^"'' = "^sbool r);
       r
</r>1480 
     </m><U>let</U></b> get_prim_onarg arg =
       <b><U>let</U><r> plain_sub = is_plain '_'
       </r><U>and</U></b> plain_sup = is_plain '^'
       <b><U>and</U><r> plain_dollar = is_plain '$'
</r><m>1485   </m><U>and</U></b> plain_amper = is_plain '&amp;' <b><U>in</U><r>
       unset_plain '_' ; unset_plain '^' ; unset_plain '$' ; unset_plain '&amp;' ;
       </r><U>let</U></b> r = do_get_this
           start_normal end_normal
           Dest.nostyle
<m>1490       <r>main arg <b><U>in</U></b>
       plain_back plain_sub '_' ; plain_back plain_sup '^' ;
       plain_back plain_dollar '$' ; plain_back plain_amper '&amp;' ;
       r
     
</r>1495 <b><U>let</U></b></m> get_prim s = get_prim_onarg (string_to_arg s)
     
     <b><U>let</U><r> get_prim_arg lexbuf =
       </r><U>let</U></b> arg = save_arg lexbuf <b><U>in</U><r>
       get_prim_onarg arg
</r><m>1500 
     </m><U>and</U></b> get_prim_opt def lexbuf =
       <b><U>let</U><r> arg = save_opt def lexbuf </r><U>in</U></b>
       get_prim_onarg arg
     
<m>1505 
     <b><U>let</U></b></m> get_csname lexbuf =
       protect_save_string
         (<b><U>fun</U><r> lexbuf -&gt; Save.csname lexbuf get_prim Subst.subst_this)
         lexbuf
<m>1510 
     
     <b><U>let</U><r> def_fun name f =
       def_code name
         (</r><U>fun</U><r> lexbuf -&gt;
<m>1515       <b><U>let</U><r> arg = subst_arg lexbuf </r><U>in</U><r>
           scan_this main (f arg))
     ;;
     
     <w>(* Paragraphs *)
<m>1520 <b><U>let</U><r> do_unskip () =
      </r><U>let</U><r> _ = Dest.forget_par () <b><U>in</U></b>
      Dest.unskip ()
     ;;
     
</r></b>1525 <r>def_code "\\unskip"
         (<b><U>fun</U></b> lexbuf -&gt;
           do_unskip () ;
           check_alltt_skip lexbuf)
     ;;
</r>1530 
     <r>def_code "\\par"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>match</U></b> par_val !in_table <b><U>with</U></b>
         | None -&gt;
</r>1535         <r>Dest.put_char ' ' ;
             check_alltt_skip lexbuf
         | pval -&gt;
             top_par pval ;
             check_alltt_skip lexbuf)
</r>1540 
     <r>;;
     
     <w>(* Styles and packages *)
     <b><U>let</U></b></w> do_documentclass command lexbuf =
</r>1545   <r>Save.start_echo () ;
       <b><U>let</U><r> {arg=opt_arg} = save_opt "" lexbuf </r><U>in</U>
       <U>let</U></b> {arg=arg} =  save_arg lexbuf <b><U>in</U>
       <U>let</U></b> real_args = Save.get_echo () <b><U>in</U>
       <U>begin</U> <U>try</U> <U>if</U></b> not !styleloaded <b><U>then</U><m>
1550     <r>input_file 0 main (arg^".hva")
       <b><U>with</U><r>
         Myfiles.Except | Myfiles.Error _ -&gt;
           raise (Misc.ScanError ("No base style"))
       </r><U>end</U></b> ;
</r>1555   </m><U>if</U></b> command = "\\documentstyle" <b><U>then</U> <U>begin</U>
         <U>let</U> <U>rec</U></b> read_packages = <b><U>function</U></b>
           | [] -&gt; ()
           | pack :: rest -&gt;
               scan_this main ("\\usepackage{"^pack^"}") ;
</r>1560           <r>read_packages rest <b><U>in</U><r>
         read_packages
           (Save.cite_arg (Lexing.from_string ("{"^opt_arg^"}")))
       </r><U>end</U></b> ;
       Image.start () ;
</r>1565   <r>Image.put command ;
       Image.put real_args ;
       Image.put_char '\n' ;
       Dest.set_out (mk_out_file ()) ;
       Dest.stop ()
</r>1570 <r>;;
     
     def_name_code  "\\documentstyle" do_documentclass ;
     def_name_code  "\\documentclass" do_documentclass
     ;;
</r>1575 
     
     <b><U>let</U><r> do_input lxm lexbuf =
       Save.start_echo () ;
       </r><U>let</U><r> arg = get_prim_arg lexbuf <b><U>in</U><m>
1580   </m><U>let</U></b> echo_arg = Save.get_echo () <b><U>in</U>
       <U>if</U></b> lxm &lt;&gt; "\\include" || check_include arg <b><U>then</U> <U>begin</U>
         <U>let</U></b> filename =
           <b><U>if</U><r> lxm = "\\bibliography" </r><U>then</U></b> Parse_opts.base_in^".bbl"
           <b><U>else</U><r> arg </r><U>in</U><m>
1585 
         </m><U>begin</U> <U>try</U></b> input_file !verbose main filename
         <b><U>with</U></b> Myfiles.Except -&gt;
           Image.put lxm ;
           Image.put echo_arg ;
</r></b>1590       <r>Image.put "\n" ;
         | Myfiles.Error _ -&gt; ()
         <b><U>end</U>
       <U>end</U></b>
     ;;
</r>1595 
     <r>def_code "\\input" (do_input "\\input") ;
     def_code "\\include" (do_input "\\include") ;
     def_code "\\bibliography" (do_input "\\bibliography")
     ;;
</r>1600 
     </m>(* Command definitions *)
     
     <b><U>let</U></b></w> do_newcommand lxm lexbuf =
       Save.start_echo () ;
<m>1605   <b><U>let</U><r> name = get_csname lexbuf </r><U>in</U>
       <U>let</U><r> nargs = save_opts ["0" ; ""] lexbuf <b><U>in</U>
       <U>let</U></b> body = subst_body lexbuf <b><U>in</U>
       <U>let</U></b> echo () =
         <b><U>if</U></b> echo_toimage () &amp;&amp; lxm &lt;&gt; "\\@forcecommand" </r><U>then</U> <U>begin</U></b>
1610       </m>Image.put lxm ;
           Image.put (Save.get_echo ()) ;
           Image.put_char '\n'
         <b><U>end</U> <U>in</U>
       <U>let</U></b> nargs,(def,defval) = <b><U>match</U></b> nargs </r><U>with</U></b>
1615     </m>[a1 ; a2] -&gt;
           Get.get_int (from_ok a1),
           (<b><U>match</U><r> a2 </r><U>with</U></b>
           | {arg=No s ; subst=env} -&gt; <b><U>false</U><r>,mkarg s env
           | {arg=Yes s ; subst=env} -&gt; </r><U>true</U></b>,mkarg s env)
<m>1620   </m>| _ -&gt; <b><U>assert</U> <U>false</U> <U>in</U>
       <U>let</U></b> pat =
         latex_pat (<b><U>if</U><r> def </r><U>then</U></b> [do_subst_this defval] <b><U>else</U><r> []) nargs </r><U>in</U>
       <U>match</U></b> lxm <b><U>with</U><r>
       | "\\@forcecommand" -&gt; Latexmacros.def name pat (Subst body)
<m>1625   </m>| "\\newcommand"|"\\newcommand*"    -&gt;
           echo () ;
           </r><U>if</U></b> Latexmacros.exists name <b><U>then</U></b>
             warning ("Ignoring (re-)definition of ``"^name^"'' by \\newcommand")
           </r><U>else</U> <U>begin</U></b>
1630         </m>Latexmacros.def name pat (Subst body)
           </r><U>end</U></b>
       | "\\renewcommand"|"\\renewcommand*" -&gt;
           <b><U>if</U><r> not (Latexmacros.exists name) </r><U>then</U> <U>begin</U></b>
             warning ("Defining ``"^name^"'' by \\renewcommand")
<m>1635       <b><U>end</U> <U>else</U><r>
             echo () ;
           Latexmacros.def name pat (Subst body)
       | _                -&gt;
           echo () ;
<m>1640       <b><U>if</U><r> not (Latexmacros.exists name) </r><U>then</U><r>
             Latexmacros.def name pat (Subst body)
     ;;
     
     def_name_code "\\renewcommand" do_newcommand  ;
<m>1645 </m>def_name_code "\\renewcommand*" do_newcommand  ;
     def_name_code "\\newcommand" do_newcommand ;
     def_name_code "\\newcommand*" do_newcommand ;
     def_name_code "\\providecommand" do_newcommand ;
     def_name_code "\\providecommand*" do_newcommand ;
<m>1650 </m>def_name_code "\\@forcecommand" do_newcommand
     ;;
     
     def_name_code "\\newcolumntype"
       (<b><U>fun</U><r> lxm lexbuf -&gt;
<m>1655     </m>Save.start_echo () ;
         </r><U>let</U></b> old_raw = !raw_chars <b><U>in</U><r>
         raw_chars := </r><U>true</U></b> ;
         <b><U>let</U><r> name = get_prim_arg lexbuf </r><U>in</U></b>
         raw_chars := old_raw ;
<m>1660     <b><U>let</U><r> nargs = save_opt "0" lexbuf </r><U>in</U>
         <U>let</U><r> body = subst_body lexbuf <b><U>in</U>
         <U>let</U></b> rest = Save.get_echo () <b><U>in</U>
         <U>if</U></b> echo_toimage () <b><U>then</U><r>
           Image.put (lxm^rest^"\n") ;
<m>1665     <b><U>let</U><r> col_cmd = Misc.column_to_command name </r><U>in</U>
         <U>if</U><r> Latexmacros.exists col_cmd <b><U>then</U></b>
           warning
             ("Not (re)-defining column type ``"^name^"'' with \\newcolumntype")
         </r><U>else</U></b>
1670       </m>Latexmacros.def
             col_cmd
             (latex_pat [] (Get.get_int nargs))
             (Subst body))
     ;;
<m>1675 
     <b><U>let</U><r> do_newenvironment lxm lexbuf =
       Save.start_echo () ;
       </r><U>let</U><r> name = get_prim_arg lexbuf <b><U>in</U>
       <U>let</U></b> nargs,optdef = <b><U>match</U></b> save_opts ["0" ; ""] lexbuf </r><U>with</U></b>
1680   </m>|  [x ; y ] -&gt; x,y
       | _ -&gt; </r><U>assert</U> <U>false</U> <U>in</U>
       <U>let</U></b> body1 = subst_body lexbuf <b><U>in</U>
       <U>let</U></b> body2 = subst_body lexbuf <b><U>in</U>
       <U>if</U></b> echo_toimage () </r><U>then</U></b>
1685     </m>Image.put (lxm^Save.get_echo ()^"\n") ;
     
       <b><U>let</U><r> do_defs () =
         Latexmacros.def
           (start_env name)
<m>1690       </m>(latex_pat
              (</r><U>match</U></b> optdef <b><U>with</U><r>
              | {arg=No _}    -&gt; []
              | {arg=Yes s ; subst=env} -&gt; [do_subst_this (mkarg s env)])
              (</r><U>match</U></b> nargs </r><U>with</U></b>
1695          </m>| {arg=No _} -&gt; 0
              | {arg=Yes s ; subst=env} -&gt; Get.get_int (mkarg s env)))
           (Subst body1) ;
         Latexmacros.def (end_env name)  zero_pat (Subst body2) </r><U>in</U></b>
     
1700   <b><U>if</U><r> lxm = "\\newenvironment" || lxm = "\\newenvironment*" </r><U>then</U>
         <U>if</U><r>
           Latexmacros.exists (start_env name) ||
           Latexmacros.exists (start_env name)
         </r><U>then</U></b>
1705       </m>warning
             ("Not (re)-defining environment ``"^name^"'' with "^lxm)
         </r><U>else</U><r>
           do_defs ()
       <b><U>else</U> <U>begin</U><m>
1710     </m><U>if</U></b>
           not (Latexmacros.exists (start_env name) &amp;&amp;
                Latexmacros.exists (start_env name))
         <b><U>then</U><r>
           warning
<m>1715         </m>("Defining environment ``"^name^"'' with "^lxm) ;
         do_defs ()
       </r><U>end</U></b>
     ;;
     
<m>1720 <r>def_name_code "\\newenvironment" do_newenvironment ;
     def_name_code "\\newenvironment*" do_newenvironment ;
     def_name_code  "\\renewenvironment" do_newenvironment ;
     def_name_code  "\\renewenvironment*" do_newenvironment
     ;;
</r>1725 
     <b><U>let</U><r> do_newcounter name within =
       </r><U>try</U><r>
         Counter.def_counter name within ;
         Latexmacros.global_def
<m>1730       </m>("\\the"^name) zero_pat (Subst ("\\arabic{"^name^"}"))
       <b><U>with</U><r>
       | Failed -&gt; ()
     
     </r><U>let</U></b> do_newtheorem lxm lexbuf =
<m>1735   </m>Save.start_echo () ;
       <b><U>let</U><r> name = get_prim_arg lexbuf </r><U>in</U>
       <U>let</U></b> numbered_like = <b><U>match</U><r> save_opts [""] lexbuf </r><U>with</U></b>
       |  [x] -&gt; x
       | _ -&gt; </r><U>assert</U> <U>false</U> <U>in</U></b>
1740   <b><U>let</U><r> caption = subst_arg lexbuf </r><U>in</U>
       <U>let</U><r> within =  <b><U>match</U><r> save_opts [""] lexbuf </r><U>with</U></b>
       | [x] -&gt; x
       | _   -&gt; <b><U>assert</U> <U>false</U> <U>in</U>
       <U>if</U></b> echo_global_toimage () </r><U>then</U></b>
1745     <r>Image.put (lxm^Save.get_echo ()^"\n") ;
       <b><U>let</U><r> cname = </r><U>match</U></b> numbered_like,within <b><U>with</U></b>
         {arg=No _},{arg=No _} -&gt;
           do_newcounter  name "" ; name
       | _,{arg=Yes _} -&gt;
</r>1750       <b><U>let</U><r> within = get_prim_onarg (from_ok within) </r><U>in</U><r>
           do_newcounter name within ; name
       | {arg=Yes _},_ -&gt;
           get_prim_onarg (from_ok numbered_like) <b><U>in</U><r>
       Latexmacros.global_def
<m>1755     </m>(start_env name) (latex_pat [""] 1)
         (Subst
            ("\\begin{flushleft}\\refstepcounter{"^cname^"}{\\bf "^caption^"~"^
             "\\the"^cname^"}\\quad\\ifoptarg{\\purple[#1]\\quad}\\fi\\em")) ;
       Latexmacros.global_def
<m>1760     </m>(end_env name) zero_pat
         (Subst "\\end{flushleft}")
     ;;
     
     def_name_code "\\newtheorem" do_newtheorem ;
<m>1765 </m>def_name_code "\\renewtheorem" do_newtheorem
     ;;
     
     <w>(* Command definitions, TeX style *)
     
<m>1770 <b><U>let</U><r> do_def global lxm lexbuf =
       Save.start_echo () ;
       </r><U>let</U><r> name = get_csname lexbuf <b><U>in</U><r>
       Save.skip_blanks_init lexbuf ;
       </r><U>let</U></b> name,args_pat,body =
<m>1775     <b><U>if</U><r> top_level () </r><U>then</U>
           <U>let</U><r> args_pat = Save.defargs lexbuf <b><U>in</U>
           <U>let</U></b> {arg=body} = save_arg lexbuf <b><U>in</U></b>
           name,args_pat,body
         </r><U>else</U></b>
1780       <b><U>let</U><r> args_pat =
             Save.defargs
               (Lexing.from_string
                  (subst_this (Save.get_defargs lexbuf))) </r><U>in</U>
           <U>let</U><r> body = subst_body lexbuf </r><U>in</U></b>
1785       </m>name,args_pat,body <b><U>in</U>
       <U>let</U></b> real_args = Save.get_echo () <b><U>in</U>
       <U>if</U></b> echo_toimage () || (global &amp;&amp; echo_global_toimage ()) <b><U>then</U> <U>begin</U></b>
         Image.put  (lxm^real_args) ;
         Image.put_char '\n'
<m>1790   <b><U>end</U><r> ;
       (</r><U>if</U><r> global <b><U>then</U><r> global_def </r><U>else</U></b> def)
         name ([],args_pat) (Subst body)
     ;;
     
<m>1795 </m>def_name_code "\\def" (do_def <b><U>false</U><r>) ;
     def_name_code "\\gdef" (do_def </r><U>true</U></b>)
     ;;
     
     <b><U>let</U><r> do_let global lxm lexbuf =
<m>1800   </m>Save.start_echo () ;
       </r><U>let</U></b> name = get_csname lexbuf <b><U>in</U><r>
       Save.skip_equal lexbuf ;
       </r><U>let</U></b> alt = get_csname lexbuf <b><U>in</U>
       <U>let</U></b> real_args = Save.get_echo () </r><U>in</U></b>
1805   <b><U>try</U>
         <U>let</U><r> nargs,body = Latexmacros.find_fail alt <b><U>in</U><r>
         (</r><U>if</U></b> global <b><U>then</U><r> global_def </r><U>else</U></b> def)
           name nargs body ;
         <b><U>if</U></b> echo_toimage () || (global &amp;&amp; echo_global_toimage ()) </r><U>then</U> <U>begin</U></b>
1810       </m>Image.put lxm ;
           Image.put real_args ;
           Image.put "\n"
         </r><U>end</U>
       <U>with</U></b>
1815   </m></w>| Failed -&gt;
           warning ("Not binding "^name^" with "^lxm^", command "^alt^" does not exist")
     ;;
     
     def_name_code "\\let" (do_let </r><U>false</U></b>) ;
<m>1820 </m>;;
     
     <b><U>let</U><r> do_global lxm lexbuf =
       </r><U>let</U></b> next = subst_arg lexbuf <b><U>in</U>
       <U>begin</U> <U>match</U></b> next </r><U>with</U></b>
1825   <r>| "\\def" -&gt; do_def <b><U>true</U><r> (lxm^next) lexbuf
       | "\\let" -&gt; do_let </r><U>true</U></b> (lxm^next) lexbuf
       | _       -&gt; warning "Ignored \\global"
       <b><U>end</U></b>
     ;;
</r>1830 
     
     
     <r>def_name_code "\\global" do_global
     ;;
</r>1835 
     <w>(* TeXisms *)
     </w></m>def_code "\\noexpand"
       (<b><U>fun</U><r> lexbuf -&gt;
          </r><U>let</U></b> arg = subst_arg lexbuf <b><U>in</U><m>
1840      <r>Dest.put arg)
     ;;
     
     def_code "\\execafter"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>1845      </m><U>let</U></b> arg = save_arg lexbuf <b><U>in</U>
          <U>let</U></b> next_arg = save_arg lexbuf <b><U>in</U>
          <U>let</U></b> cur_subst = get_subst () <b><U>in</U><r>
          scan_this_may_cont main lexbuf cur_subst next_arg ;
          scan_this_may_cont main lexbuf cur_subst arg)
<m>1850 </m>;;
     
     
     def_code "\\csname"
       (</r><U>fun</U></b> lexbuf -&gt;
<m>1855     </m>skip_blanks lexbuf ;
         <b><U>let</U><r> name = "\\"^get_prim (Save.incsname lexbuf) </r><U>in</U></b>
         check_alltt_skip lexbuf ;
         expand_command main skip_blanks name lexbuf)
     ;;
<m>1860 
     </m>def_code "\\string"
        (<b><U>fun</U><r> lexbuf -&gt;
          </r><U>let</U></b> arg = subst_arg lexbuf <b><U>in</U></b>
          Dest.put arg)
<m>1865 </m>;;
     
     </r><U>let</U><r> get_num_arg lexbuf =
       Save.num_arg lexbuf (</r><U>fun</U><r> s -&gt; Get.get_int (string_to_arg s))
     ;;
<m>1870 
     
     <b><U>let</U><r> top_plain c =
       </r><U>if</U><r> not (is_plain c) <b><U>then</U> <U>begin</U></b>
         set_plain c ;
<m>1875     </m>fun_register (<b><U>fun</U><r> () -&gt; unset_plain c)
       </r><U>end</U>
     
     <U>and</U></b> top_unplain c =
       <b><U>if</U></b> is_plain c </r><U>then</U> <U>begin</U></b>
1880     </m>unset_plain c ;
         fun_register (<b><U>fun</U><r> () -&gt; set_plain c)
       </r><U>end</U></b>
     ;;
     
<m>1885 </m>def_code "\\catcode"
        (<b><U>fun</U><r> lexbuf -&gt;
          </r><U>let</U></b> char = Char.chr
              (Get.get_int (save_arg_with_delim "=" lexbuf)) <b><U>in</U>
          <U>let</U></b> code = get_num_arg lexbuf <b><U>in</U><m>
1890      </m><U>begin</U> <U>match</U></b> char,code <b><U>with</U><r>
          | ('\\',0) | ('{',1) | ('}',2) | ('$',3) | ('&amp;' ,4) |
            ('#',6) | ('^',7) | ('_',8) | ('~',13) |
            ('%',14) -&gt; top_plain char
          | ('{',(11|12)) | ('}',(11|12)) | ('$',(11|12)) | ('&amp;' ,(11|12)) |
<m>1895        </m>('#',(11|12)) | ('^',(11|12)) | ('_',(11|12)) | ('~',(11|12)) |
            ('%',(11|12)) | ('\\',(11|12)) -&gt; top_unplain char
          | _ -&gt;
              warning "This \\catcode operation is not permitted"
          </r><U>end</U></b> ;
<m>1900      </m>main lexbuf)
     ;;
     
     def_code "\\chardef"
       (<b><U>fun</U><r> lexbuf -&gt;
<m>1905     <b><U>let</U><r> csname = get_csname lexbuf </r><U>in</U><r>
         Save.skip_equal lexbuf ;
         <b><U>let</U><r> i = get_num_arg lexbuf </r><U>in</U></b>
         Latexmacros.def csname zero_pat (Subst (string_of_int i)))
     ;;
<m>1910 
     <w>(* Complicated use of output blocks *)
     <r>def_code "\\left"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> dprev = !display <b><U>in</U><m>
1915     <r>Stack.push stack_display dprev ;
         display := <b><U>true</U><r> ;
         </r><U>if</U></b> not dprev <b><U>then</U><r>
           top_open_display () ;
         </r><U>let</U></b> delim = subst_arg lexbuf <b><U>in</U><m>
1920     </m><U>let</U></b> {sub=sub ; sup=sup} = save_sup_sub lexbuf <b><U>in</U><r>
         Dest.left delim
           (</r><U>fun</U></b> vsize -&gt;
             Dest.int_sup_sub <b><U>false</U><r> vsize
               (scan_this_arg main) (</r><U>fun</U></b> () -&gt; ())  sup sub <b><U>true</U></b>))
</r>1925 <r>;;
     
     <w>(* Display is true *)
     </w>def_code "\\right"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>1930     </m><U>let</U></b> delim = subst_arg lexbuf <b><U>in</U>
         <U>let</U></b> vsize = Dest.right delim <b><U>in</U>
         <U>let</U></b> {sup=sup ; sub=sub} = save_sup_sub lexbuf <b><U>in</U>
         <U>let</U></b> do_what = (<b><U>fun</U><r> () -&gt; ()) </r><U>in</U></b>
         Dest.int_sup_sub <b><U>false</U><r> vsize
<m>1935       </m>(scan_this_arg main) do_what sup sub !display ;
         </r><U>let</U></b> dprev = Stack.pop stack_display <b><U>in</U>
         <U>if</U></b> not dprev <b><U>then</U><r> top_close_display () ;
         display := dprev)
     ;;
<m>1940 
     </m>def_code "\\over"
        (</r><U>fun</U></b> lexbuf -&gt;
          Dest.over !display lexbuf;
          skip_blanks lexbuf)
<m>1945 </m>;;
     
     <b><U>let</U><r> check_not = </r><U>function</U></b>
       | "\\in" -&gt; "\\notin"
       | "="    -&gt; "\\neq"
<m>1950   </m>| "\\subset" -&gt; "\\notsubset"
       | s -&gt; "\\neg\\:"^s
     ;;
     
     def_fun "\\not" check_not
<m>1955 </m>;;
     
     def_code "\\uppercase"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = save_arg lexbuf <b><U>in</U><m>
1960     </m><U>let</U></b> old_case = !case <b><U>in</U><r>
         case := Upper ;
         scan_this_arg main arg ;
         case := old_case) ;
     def_code "\\lowercase"
<m>1965   </m>(</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> arg = save_arg lexbuf </r><U>in</U>
         <U>let</U></b> old_case = !case <b><U>in</U></b>
         case := Lower ;
         scan_this_arg main arg ;
<m>1970     </m>case := old_case)
     ;;
     
     </r>(* list items *)
     <r>def_code "\\@li" (<b><U>fun</U><r> _ -&gt; Dest.item ()) ;
<m>1975 </m>def_code "\\@linum" (</r><U>fun</U></b> _ -&gt; Dest.nitem ()) ;
     def_code "\\@dt"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = subst_arg lexbuf <b><U>in</U></b>
         Dest.ditem (scan_this main) arg ;
<m>1980     </m>check_alltt_skip lexbuf)
     ;;
     
     
     </r>(* Html primitives *)
</w>1985 </m>def_code "\\@open"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> tag = get_prim_arg lexbuf <b><U>in</U>
         <U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U><r>
         top_open_block tag arg)
<m>1990 </m>;;
     
     def_code "\\@insert"
       (</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U></b> tag = get_prim_arg lexbuf </r><U>in</U></b>
1995     <b><U>let</U><r> arg = get_prim_arg lexbuf </r><U>in</U><r>
         Dest.insert_block tag arg )
     ;;
     
     def_code "\\@close"
<m>2000   </m>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> tag = get_prim_arg  lexbuf <b><U>in</U><r>
         top_close_block tag)
     ;;
     
<m>2005 </m>def_code "\\@print"
       (</r><U>fun</U></b> lexbuf -&gt;
               <b><U>let</U><r> {arg=arg} = save_arg lexbuf </r><U>in</U></b>
               Dest.put arg) ;
     ;;
<m>2010 
     </m>def_code "\\@printnostyle"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> {arg=arg} =  save_arg lexbuf <b><U>in</U><r>
         top_open_group () ;
<m>2015     </m>Dest.nostyle () ;
         Dest.put arg ;
         top_close_group ())
     ;;
     
<m>2020 </m>def_code "\\@getprintnostyle"
       (</r><U>fun</U></b> lexbuf -&gt;
         top_open_group () ;
         Dest.nostyle () ;
         <b><U>let</U></b> arg = get_prim_arg lexbuf </r><U>in</U></b>
2025     </m>Dest.put arg ;
         top_close_group ())
     ;;
     
     def_code "\\@getprint"
<m>2030   </m>(</r><U>fun</U></b> lexbuf -&gt;
         </r><U>let</U><r> arg = get_prim_arg lexbuf <b><U>in</U>
         <U>let</U></b> buff = Lexing.from_string arg <b><U>in</U><r>
         Dest.put (Save.tagout buff)) ;
     ;;
<m>2035 
     </m>def_code "\\@subst"
       (</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> arg = subst_arg lexbuf </r><U>in</U></b>
         Dest.put arg)
<m>2040 <r>;;
     
     def_code "\\@notags"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = save_arg lexbuf <b><U>in</U><m>
2045     </m><U>let</U></b> arg = get_this_arg main arg <b><U>in</U>
         <U>let</U></b> r =
           <b><U>let</U><r> buff = Lexing.from_string arg </r><U>in</U></b>
           Save.tagout buff <b><U>in</U></b>
         Dest.put r)
</r>2050 <r>;;
     def_code "\\@anti"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = save_arg lexbuf <b><U>in</U>
         <U>let</U></b> envs = get_style main arg <b><U>in</U><m>
2055     </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
           prerr_string ("Anti result: ") ;
           List.iter
             (<b><U>fun</U></b> s -&gt;
               prerr_string (Element.pretty_text s^", ")) envs ;
</r>2060       <r>prerr_endline ""
         <b><U>end</U></b> ;
         Dest.erase_mods envs)
     ;;
     def_code "\\@style"
</r>2065   <r>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U></b>
         Dest.open_mod (Style arg) )
     ;;
     def_code "\\@fontcolor"
</r>2070   <r>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U></b>
         Dest.open_mod (Color arg))
     ;;
     def_code "\\@fontsize"
</r>2075   <r>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = save_arg lexbuf <b><U>in</U></b>
         Dest.open_mod (Font (Get.get_int arg)) )
     ;;
     def_code "\\@nostyle"
</r>2080         <r>(<b><U>fun</U><r> lexbuf -&gt; Dest.nostyle () ; check_alltt_skip lexbuf)
     ;;
     def_code "\\@clearstyle"
             (</r><U>fun</U></b> lexbuf -&gt; Dest.clearstyle ()  ; check_alltt_skip lexbuf)
     ;;
</r>2085 <r>def_code "\\@incsize"
       (<b><U>fun</U><r> lexbuf -&gt;
               </r><U>let</U></b> arg = save_arg lexbuf <b><U>in</U></b>
               inc_size (Get.get_int arg) )
     ;;
</r>2090 <r>def_code "\\htmlcolor"
       (<b><U>fun</U><r> lexbuf -&gt;
               </r><U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U></b>
               Dest.open_mod (Color ("\"#"^arg^"\"")) )
     ;;
</r>2095 
     <r>def_code "\\usecounter"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U></b>
         Counter.set_counter arg 0 ;
</r>2100     <r>scan_this main ("\\let\\@currentlabel\\the"^arg) ;
         Dest.set_dcount arg )
     ;;
     def_code "\\@fromlib"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>2105           <b><U>let</U></b></m> arg = get_prim_arg lexbuf <b><U>in</U><r>
               start_lexstate ();
               Mysys.put_from_file (Filename.concat Mylib.libdir arg) Dest.put;
               restore_lexstate ())
     ;;
<m>2110 </m>def_code "\\@imageflush"
       (</r><U>fun</U></b> lexbuf -&gt;
         iput_newpage () ;
         check_alltt_skip lexbuf)
     ;;
<m>2115 <r>def_code "\\textalltt"
       (<b><U>fun</U><r> lexbuf -&gt;
            </r><U>let</U></b> opt = get_prim_opt "CODE" lexbuf <b><U>in</U>
            <U>let</U></b> arg = save_arg lexbuf <b><U>in</U>
            <U>let</U></b> old = !alltt <b><U>in</U><m>
2120        <r>scan_this main "\\mbox{" ;
            alltt := Inside ;
            Dest.open_group opt ;
            scan_this_arg main arg ;
            Dest.close_group () ;
</r>2125        <r>scan_this main "}" ;
            alltt := old )
     ;;
     def_code "\\@itemdisplay"
       (<b><U>fun</U></b> lexbuf -&gt; Dest.force_item_display ())
</r>2130 <r>;;
     def_code "\\@br"
       (<b><U>fun</U></b> lexbuf -&gt; Dest.skip_line ())
     ;;
     
</r>2135 
     <w>(* TeX conditionals *)
     <b><U>let</U><r> testif cell lexbuf =
       </r><U>if</U><r> !cell <b><U>then</U><r> check_alltt_skip lexbuf
       </r><U>else</U></b> skip_false lexbuf
<m>2140 
     <b><U>let</U></b></m> setif cell b lexbuf =
       <b><U>let</U><r> old = !cell </r><U>in</U></b>
       fun_register (<b><U>fun</U><r> () -&gt; cell := old) ;
       cell := b ;
<m>2145   </m>check_alltt_skip lexbuf
     ;;
     
     </r><U>let</U></b> extract_if name =
       <b><U>let</U><r> l = String.length name </r><U>in</U><m>
2150   </m><U>if</U></b> l &lt;= 3 || String.sub name 0 3 &lt;&gt; "\\if" <b><U>then</U><r>
         raise (Error ("Bad newif: "^name)) ;
       String.sub name 3 (l-3)
     ;;
     
</r><m>2155 </m><U>let</U></b> def_and_register name f =
       def name zero_pat (CamlCode f)
     ;;
     
     <b><U>let</U><r> tverb name cell lexbuf =
</r><m>2160   </m><U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
       Printf.fprintf stderr
         "Testing %s -&gt; %b\n" name !cell ;
       testif cell lexbuf
     ;;
</r><m>2165 
     </m><U>let</U></b> newif_ref name cell =
       def_and_register ("\\if"^name) (tverb name cell) ;
       def_and_register ("\\"^name^"true") (setif cell <b><U>true</U><r>) ;
       def_and_register ("\\"^name^"false") (setif cell </r><U>false</U></b>) ;
<m>2170   </m>register_cell name cell ;
       fun_register (<b><U>fun</U><r> () -&gt; unregister_cell name)
     ;;
     
     </r><U>let</U></b> newif lexbuf =
<m>2175   <b><U>let</U><r> arg = get_csname lexbuf </r><U>in</U>
       <U>let</U><r> saw_par = !Save.seen_par  <b><U>in</U>
       <U>begin</U> <U>try</U>
         <U>let</U></b> name = extract_if arg <b><U>in</U>
         <U>let</U></b> cell = ref </r><U>false</U> <U>in</U></b>
2180     </m>newif_ref name cell ;
       <b><U>with</U><r> Latexmacros.Failed -&gt; ()
       </r><U>end</U></b> ;
       <b><U>if</U><r> saw_par </r><U>then</U> <U>begin</U></b>
         top_par (par_val !in_table)
<m>2185   <b><U>end</U><r>
     ;;
     
     </r><U>exception</U><r> FailedFirst
     ;;
<m>2190 
     </m>def_code "\\ifx"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg1 = get_csname lexbuf <b><U>in</U>
         <U>let</U></b> arg2 = get_csname lexbuf  </r><U>in</U></b>
2195     <b><U>let</U><r> r =
           </r><U>try</U>
             <U>let</U><r> m1 =
               <b><U>try</U><r> Latexmacros.find_fail arg1 </r><U>with</U></b>
               |  Failed -&gt; raise FailedFirst </r><U>in</U></b>
2200         <b><U>let</U><r> m2 = Latexmacros.find_fail arg2 </r><U>in</U><r>
             m1 = m2
           <b><U>with</U></b>
           | FailedFirst -&gt;
               </r><U>begin</U></b>
2205             <b><U>try</U> <U>let</U><r> _ = Latexmacros.find_fail arg2 <b><U>in</U> <U>false</U>
                 <U>with</U></b> Failed -&gt; <b><U>true</U>
               <U>end</U></b>
           | Failed -&gt; <b><U>false</U> <U>in</U>
         <U>if</U></b> r </r><U>then</U></b>
2210       </m>check_alltt_skip lexbuf
         <b><U>else</U><r>
           skip_false lexbuf)
     ;;
     def_code "\\ifu"
<m>2215   </m>(</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> arg1 = get_csname lexbuf </r><U>in</U>
         <U>try</U>
           <U>let</U></b> _ = Latexmacros.find_fail arg1 <b><U>in</U><r>
           skip_false lexbuf
<m>2220     <b><U>with</U><r>
         | Failed -&gt; check_alltt_skip lexbuf)
     ;;
     
     def_code "\\newif" newif
<m>2225 </m>;;
     
     def_code "\\else" (</r><U>fun</U><r> lexbuf -&gt; skip_false lexbuf)
     ;;
     
<m>2230 </m>def_code "\\fi" (<b><U>fun</U><r> lexbuf -&gt; check_alltt_skip lexbuf)
     ;;
     
     
     </r><U>let</U></b> sawdocument = ref </r><U>false</U></b>
2235 </m>;;
     
     newif_ref "symb" symbols ;
     newif_ref "iso" iso ;
     newif_ref "raw" raw_chars ;
<m>2240 </m>newif_ref "silent" silent;
     newif_ref "math" in_math ;
     newif_ref "mmode" in_math ;
     newif_ref "display" display ;
     newif_ref "french" french ;
<m>2245 </m>newif_ref "html" html;
     newif_ref "text" text;
     newif_ref "info" text;
     newif_ref "mathml" Parse_opts.mathml;
     newif_ref "entities" Parse_opts.entities;
<m>2250 </m>newif_ref "optarg" optarg;
     newif_ref "styleloaded" styleloaded;
     newif_ref "activebrace" activebrace;
     newif_ref "pedantic" pedantic ;
     newif_ref "fixpoint" fixpoint ;
<m>2255 </m>newif_ref "alltt@loaded" alltt_loaded ;
     newif_ref "filter" (ref filter) ;
     newif_ref "@sawdocument" sawdocument ;
     def_code "\\iftrue" (testif (ref </r><U>true</U></b>)) ;
     def_code "\\iffalse" (testif (ref <b><U>false</U><r>))
<m>2260 </m>;;
     
     def_code "\\if@toplevel"
       (</r><U>fun</U></b> lexbuf -&gt;
         <b><U>if</U><r> echo_global_toimage () </r><U>then</U></b> check_alltt_skip lexbuf
<m>2265     <b><U>else</U><r> skip_false lexbuf)
     ;;
     
     
     
<m>2270 <w>(* Bibliographies *)
     <b><U>let</U><r> bib_ref s1 s2 =
       scan_this main ("\\@bibref{"^s1^"}{"^s2^"}")
     ;;
     
<m>2275 </m>def_code "\\cite"
       (</r><U>fun</U><r> lexbuf -&gt;
         <b><U>let</U><r> opt = save_opt "" lexbuf </r><U>in</U></b>
         check_alltt_skip lexbuf ;
         <b><U>let</U></b> args = List.map subst_this (Save.cite_arg lexbuf) </r><U>in</U></b></w>
2280     </m>Dest.put_char '[' ;
         Dest.open_group "CITE" ;
         </r><U>let</U> <U>rec</U><r> do_rec = <b><U>function</U><r>
             [] -&gt; ()
           | [x] -&gt; bib_ref x (Auxx.bget </r><U>true</U></b> x)
<m>2285       </m>| x::rest -&gt;
               bib_ref x (Auxx.bget <b><U>true</U><r> x) ;
               Dest.put ", " ;
               do_rec rest </r><U>in</U></b>
         do_rec args ;
<m>2290     <b><U>if</U><r> opt.arg &lt;&gt; "" </r><U>then</U> <U>begin</U><r>
           Dest.put ", " ;
           scan_this_arg main opt ;
         <b><U>end</U><r> ;
         Dest.close_group () ;
<m>2295     </m>Dest.put_char ']' )
     ;;
     
     <w>(* Includes *)
     </w>def_code "\\includeonly"
<m>2300   </m>(</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> arg = Save.cite_arg lexbuf </r><U>in</U></b>
         add_includes arg )
     ;;
     
<m>2305 <w>(* Foot notes *)
     
     <r>def_code "\\@stepanchor"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> mark = Get.get_int (save_arg lexbuf) <b><U>in</U><m>
2310     <r>Foot.step_anchor mark) ;
     def_code "\\@anchorval"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> mark = Get.get_int (save_arg lexbuf) <b><U>in</U></b>
         Dest.put (string_of_int (Foot.get_anchor mark)))
</r>2315 <r>;;
     
     def_code "\\@footnotetext"
       (<b><U>fun</U></b> lexbuf -&gt;
         start_lexstate () ;
</r>2320     </m><U>let</U></b> mark = Get.get_int (save_arg lexbuf) <b><U>in</U>
         <U>let</U></b> text = save_arg lexbuf <b><U>in</U>
         <U>let</U></b> text =
           do_get_this
             start_normal end_normal Dest.clearstyle
<m>2325         <r>main text <b><U>in</U></b>
         Foot.register
           mark
           (get_this_string main ("\\@fnmarknote{"^string_of_int mark^"}"))
           text ;
</r>2330     <r>restore_lexstate ())
     ;;
     
     def_code "\\@footnoteflush"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>2335     <b><U>let</U></b></m> sec_here = get_prim_arg lexbuf
         <b><U>and</U><r> sec_notes = get_prim "\\@footnotelevel" </r><U>in</U></b>
         start_lexstate () ;
         Foot.flush (scan_this main) sec_notes sec_here ;
         restore_lexstate ())
<m>2340 </m>;;
     
     </r>(* Opening and closing environments *)
     
     
</w>2345 </m>def_code "\\begin"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> cur_subst = get_subst () <b><U>in</U>
         <U>let</U></b> env = get_prim_arg lexbuf <b><U>in</U><r>
         new_env env ;
<m>2350     </m>top_open_block "" "" ;
         </r><U>let</U></b> macro = start_env env <b><U>in</U>
         <U>let</U></b> old_envi = save stack_entry <b><U>in</U></b>
         push stack_entry env ;
         </r><U>begin</U> <U>try</U></b>
2355       </m>expand_command main no_skip macro lexbuf
         <b><U>with</U><r>
         | e -&gt;
             restore stack_entry old_envi ;
             raise e
<m>2360     <b><U>end</U><r> ;
         restore stack_entry old_envi)
     ;;
     
     
<m>2365 </m>def_code "\\@begin"
       (</r><U>fun</U><r> lexbuf -&gt;
          <b><U>let</U><r> env = get_prim_arg lexbuf </r><U>in</U></b>
          new_env env ;
          top_open_block "" "")
<m>2370 </m>;;
     
     def_code "\\end"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> env = get_prim_arg lexbuf </r><U>in</U></b>
2375     </m>expand_command main no_skip ("\\end"^env) lexbuf ;
         close_env env ;
         top_close_block "")
     ;;
     
<m>2380 </m>def_code "\\@raise@enddocument"
       (</r><U>fun</U></b> _ -&gt;
         <b><U>if</U><r> not !sawdocument </r><U>then</U></b>
           fatal ("\\end{document} with no \\begin{document}")
         <b><U>else</U> <U>if</U></b> not (Stack.empty stack_env) </r><U>then</U></b>
2385       </m>error_env "document" !cur_env
         <b><U>else</U><r>
           raise Misc.EndDocument)
     ;;
     
<m>2390 </m>def_code "\\@end"
       (</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> env = get_prim_arg lexbuf </r><U>in</U></b>
         top_close_block "" ;
         close_env env)
<m>2395 </m>;;
     
     <b><U>let</U><r> little_more lexbuf =
       to_newline lexbuf ;
       Out.to_string more_buff
<m>2400 </m>;;
     
     def_code "\\endinput" (</r><U>fun</U></b> lexbuf -&gt;
       <b><U>let</U><r> reste = little_more lexbuf </r><U>in</U></b>
       scan_this main reste ;
<m>2405   </m>raise Misc.EndInput)
     ;;
     
     </r></b>(* Boxes *)
     
</w>2410 <r>def_code "\\mbox" (<b><U>fun</U></b> lexbuf -&gt; mbox_arg lexbuf)
     ;;
     
     
     
</r>2415 <r>def_code "\\newsavebox"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> name = get_csname lexbuf <b><U>in</U>
         <U>try</U>
           <U>let</U></b> _ = find_fail name <b><U>in</U><m>
2420       <r>warning ("Not (re-)defining ``"^name^"'' with \\newsavebox")
         <b><U>with</U><r>
         | Failed -&gt;
             global_def name zero_pat (CamlCode (</r><U>fun</U></b> _ -&gt; ())))
     ;;
</r>2425 
     <r>def_code "\\providesavebox"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> name = get_csname lexbuf <b><U>in</U>
         <U>try</U><m>
2430       </m><U>let</U></b> _ = find_fail name <b><U>in</U><r> ()
         </r><U>with</U></b>
         | Failed -&gt;
             global_def name zero_pat (CamlCode (<b><U>fun</U></b> _ -&gt; ())))
     ;;
</r>2435 
     </m><U>let</U></b> caml_print s = CamlCode (<b><U>fun</U><r> _ -&gt; Dest.put s)
     
     </r><U>let</U></b> do_sbox global name body =
       <b><U>if</U><r> not (Latexmacros.exists name) </r><U>then</U><m>
2440     <r>warning ("\\sbox on undefined bin ``"^name^"''") ;
       start_mbox () ;
       <b><U>let</U><r> to_print =  get_this_arg main body </r><U>in</U></b>
       top_close_group () ;
       (<b><U>if</U><r> global </r><U>then</U></b> global_def <b><U>else</U></b> def) name zero_pat (caml_print to_print)
</r>2445 <r>;;
     
     def_code "\\savebox"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> name = get_csname lexbuf <b><U>in</U><m>
2450     <r>warning "savebox";
         skip_opt lexbuf ;
         skip_opt lexbuf ;
         <b><U>let</U><r> body = save_arg lexbuf </r><U>in</U></b>
         do_sbox <b><U>false</U></b> name body)
</r>2455 <r>;;
     
     def_code "\\sbox"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> name = get_csname lexbuf <b><U>in</U><m>
2460     </m><U>let</U></b> body = save_arg lexbuf <b><U>in</U><r>
         do_sbox </r><U>false</U></b> name body) ;
     
     def_code "\\gsbox"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>2465     </m><U>let</U></b> name = get_csname lexbuf <b><U>in</U>
         <U>let</U></b> body = save_arg lexbuf <b><U>in</U><r>
         do_sbox </r><U>true</U></b> name body) ;
     ;;
     
</r>2470 <r>def_code "\\usebox"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> name = get_csname lexbuf <b><U>in</U></b>
         top_open_group () ;
         Dest.nostyle () ;
</r>2475     <r>expand_command main skip_blanks name lexbuf ;
         top_close_group ())
     ;;
     
     def_code "\\lrbox"
</r>2480   <r>(<b><U>fun</U><r> lexbuf -&gt;
         close_env "lrbox" ;
         push stack_display !display ;
         display := </r><U>false</U></b> ;
         <b><U>let</U><r> name = get_csname lexbuf </r><U>in</U><m>
2485     <r>Dest.open_aftergroup
           (<b><U>fun</U></b> s -&gt;
             def name zero_pat (caml_print s) ;
             "") ;
         start_mbox ())
</r>2490 <r>;;
     
     def_code "\\endlrbox"
       (<b><U>fun</U><r> _ -&gt;
         top_close_group () ;   <w>(* close mbox *)
<m>2495     <r>Dest.close_group () ;  <w>(* close after group *)
         </w>display := pop stack_display ;
         new_env "lrbox")
     ;;
     
</r>2500 
     </m>(* chars *)
     </w>def_code "\\char"
       (</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> arg = get_num_arg lexbuf </r><U>in</U><m>
2505     </m><U>if</U></b> not !silent &amp;&amp; (arg &lt; 32 || (arg &gt; 127 &amp;&amp; arg &lt; 161)) <b><U>then</U> <U>begin</U></b>
           Location.print_pos () ;
           prerr_endline ("Warning: \\char, check output");
         <b><U>end</U></b> ;
         Dest.put (Dest.iso (Char.chr arg)) ;
</r>2510     </m><U>if</U></b> not (effective !alltt) <b><U>then</U><r> check_alltt_skip lexbuf)
     ;;
     
     def_code "\\symbol"
       (</r><U>fun</U></b> lexbuf -&gt;
</r>2515     </m><U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U><r>
         scan_this main ("\\char"^arg))
     ;;
     
     </r><w>(* labels *)
<m>2520 
     </m>(* Counters *)
     </w><U>let</U></b> alpha_of_int i = String.make 1 (Char.chr (i-1+Char.code 'a'))
     <b><U>and</U></b> upalpha_of_int i = String.make 1 (Char.chr (i-1+Char.code 'A'))
     ;;
</r>2525 
     </m><U>let</U> <U>rec</U></b> roman_of_int = <b><U>function</U></b>
       0 -&gt; ""
     | 1 -&gt; "i"
     | 2 -&gt; "ii"
</r>2530 <r>| 3 -&gt; "iii"
     | 4 -&gt; "iv"
     | 9 -&gt; "ix"
     | i -&gt;
        <b><U>if</U><r> i &lt; 9 </r><U>then</U></b> "v"^roman_of_int (i-5)
</r>2535    <b><U>else</U>
          <U>let</U></b></m> d = i / 10 <b><U>and</U><r> u = i </r><U>mod</U></b> 10 <b><U>in</U><r>
          String.make d 'x'^roman_of_int u
     ;;
     
</r><m>2540 </m><U>let</U></b> uproman_of_int i = String.uppercase (roman_of_int i)
     ;;
     
     <b><U>let</U><r> fnsymbol_of_int = </r><U>function</U></b>
       0 -&gt; " "
<m>2545 <r>| 1 -&gt; "*"
     | 2 -&gt; "#"
     | 3 -&gt; "%"
     | 4 -&gt; "\167"
     | 5 -&gt; "\182"
</r>2550 <r>| 6 -&gt; "||"
     | 7 -&gt; "**"
     | 8 -&gt; "##"
     | 9 -&gt; "%%"
     | i -&gt; alpha_of_int (i-9)
</r>2555 <r>;;
     
     <b><U>let</U><r> def_printcount name f =
       def_code name
         (</r><U>fun</U></b> lexbuf -&gt;
</r>2560       <b><U>let</U></b></m> cname = get_prim_arg lexbuf <b><U>in</U>
           <U>let</U></b> cval = Counter.value_counter cname </r><U>in</U></b></TT></m><r><TT>
           Dest.put (f cval))
     ;;
     
<m>2565 </m>def_printcount "\\arabic" string_of_int ;
     def_printcount "\\alph"  alpha_of_int ;
     def_printcount "\\Alph"  upalpha_of_int ;
     def_printcount "\\roman" roman_of_int;
     def_printcount "\\Roman" uproman_of_int;
<m>2570 </m>def_printcount "\\fnsymbol" fnsymbol_of_int
     ;;
     
     <b><U>let</U></b> pad p l s =
       <b><U>for</U><r> i = l-String.length s </r><U>downto</U></b> 1 <b><U>do</U><m>
2575     <r>Dest.put (Dest.iso_string p)
       <b><U>done</U></b>
     ;;
     
     def_code "\\@pad"
</r>2580   <r>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> p = get_prim_arg lexbuf <b><U>in</U>
         <U>let</U></b> l = Get.get_int (save_arg lexbuf) <b><U>in</U>
         <U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U></b>
         pad p l arg ;
</r>2585     <r>Dest.put (Dest.iso_string arg))
     ;;
     
     def_code "\\newcounter"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>2590     <r>Save.start_echo () ;
         <b><U>let</U><r> name = get_prim_arg lexbuf </r><U>in</U>
         <U>let</U></b> within = get_prim_opt "" lexbuf <b><U>in</U>
         <U>let</U></b> real_args = Save.get_echo () <b><U>in</U>
         <U>if</U></b> echo_global_toimage () <b><U>then</U> <U>begin</U><m>
2595       <r>Image.put "\\newcounter" ;
           Image.put real_args ;
           Image.put_char '\n'
         <b><U>end</U></b> ;
         do_newcounter name within)
</r>2600 <r>;;
     
     def_code "\\addtocounter"
       (<b><U>fun</U></b> lexbuf -&gt;
         Save.start_echo () ;
</r>2605     </m><U>let</U></b> name = get_prim_arg lexbuf <b><U>in</U>
         <U>let</U></b> arg = save_arg lexbuf <b><U>in</U>
         <U>let</U></b> real_args = Save.get_echo () <b><U>in</U>
         <U>if</U></b> echo_global_toimage () <b><U>then</U> <U>begin</U></b>
           Image.put "\\addtocounter" ;
</r>2610       <r>Image.put real_args ;
           Image.put_char '\n'
         <b><U>end</U></b> ;
         Counter.add_counter name (Get.get_int arg))
     ;;
</r>2615 
     <r>def_code "\\setcounter"
       (<b><U>fun</U><r> lexbuf -&gt;
         Save.start_echo () ;
         </r><U>let</U></b> name = get_prim_arg lexbuf <b><U>in</U><m>
2620     </m><U>let</U></b> arg = save_arg lexbuf <b><U>in</U>
         <U>let</U></b> real_args = Save.get_echo () <b><U>in</U>
         <U>if</U></b> echo_global_toimage () <b><U>then</U> <U>begin</U></b>
           Image.put "\\setcounter" ;
           Image.put real_args ;
</r>2625       <r>Image.put_char '\n'
         <b><U>end</U></b> ;
         Counter.set_counter name (Get.get_int arg) )
     ;;
     
</r>2630 <r>def_code "\\stepcounter"
       (<b><U>fun</U><r> lexbuf -&gt;
         Save.start_echo () ;
         </r><U>let</U></b> name = get_prim_arg lexbuf <b><U>in</U>
         <U>let</U></b> real_args = Save.get_echo () <b><U>in</U><m>
2635     </m><U>if</U></b> echo_global_toimage () <b><U>then</U> <U>begin</U></b>
           Image.put "\\stepcounter" ;
           Image.put real_args ;
           Image.put_char '\n'
         <b><U>end</U></b> ;
</r>2640     <r>Counter.step_counter name)
     ;;
     
     <w>(* terminal output *)
     </w>def_code "\\typeout"
</r>2645   <r>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> what = get_prim_arg lexbuf <b><U>in</U></b>
         prerr_endline what )
     ;;
     
</r>2650 <r>def_code "\\warning"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> what = subst_arg lexbuf <b><U>in</U></b>
         warning what )
     ;;
</r>2655 
     </m><w>(* spacing *)
     
     </w><U>let</U></b> stack_closed = Stack.create "stack_closed"
     ;;
<m>2660 
     <r>def_code "\\@saveclosed"
       (<b><U>fun</U></b> lexbuf -&gt;
         push stack_closed (Dest.get_last_closed ()) ;
         check_alltt_skip lexbuf)
</r>2665 <r>;;
     
     def_code "\\@restoreclosed"
       (<b><U>fun</U></b> lexbuf -&gt;
         Dest.set_last_closed (pop stack_closed) ;
</r>2670     <r>check_alltt_skip lexbuf)
     ;;
     
     <b><U>exception</U></b> Cannot
     ;;
</r>2675 
     <r>def_code "\\@getlength"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U>
         <U>let</U></b> pxls =
</r>2680       <b><U>match</U><r> Get.get_length arg </r><U>with</U><r>
           | Length.Pixel n -&gt; n
           | Length.Char n -&gt; Length.char_to_pixel n
           | _             -&gt; 0 <b><U>in</U></b>
         Dest.put (string_of_int (pxls/2)))
</r></b>2685 <r>;;
     
     <b><U>let</U><r> do_space vert lexbuf  =
       </r><U>let</U></b> arg = subst_arg lexbuf <b><U>in</U>
       <U>begin</U> <U>try</U><m>
2690     </m><U>let</U></b> n = <b><U>match</U><r> Length.main (Lexing.from_string arg) </r><U>with</U></b>
         | Length.Char n -&gt; n
         | Length.Pixel n -&gt; Length.pixel_to_char n
         | _                 -&gt; raise Cannot <b><U>in</U>
         <U>if</U></b> vert <b><U>then</U><m>
2695       </m><U>for</U></b> i=1 <b><U>to</U><r> n </r><U>do</U></b>
             Dest.skip_line ()
           <b><U>done</U>
         <U>else</U>
           <U>for</U></b> i=1 <b><U>to</U><r> n </r><U>do</U><m>
2700         <r>Dest.put_nbsp (); <w>(* "&amp;nbsp;"*)
           <b><U>done</U>
       <U>with</U></b></w> Cannot -&gt;
         warning ((<b><U>if</U><r> vert </r><U>then</U></b> "\\vspace" <b><U>else</U></b> "\\hspace")^
                  " with arg ``"^arg^"''")
</r>2705   </m><U>end</U></b>
     ;;
     
     def_code "\\hspace"  (<b><U>fun</U><r> lexbuf -&gt; do_space </r><U>false</U></b> lexbuf) ;
     def_code "\\vspace"  (<b><U>fun</U><r> lexbuf -&gt; do_space </r><U>true</U></b> lexbuf)
</r>2710 <r>;;
     
     <w>(* Explicit groups *)
     </w>def_code "\\begingroup"
       (<b><U>fun</U></b> lexbuf  -&gt;
</r>2715     <r>new_env "command-group" ; top_open_block "" "" ;
         check_alltt_skip lexbuf)
     ;;
     
     def_code "\\endgroup"
</r>2720   <r>(<b><U>fun</U></b> lexbuf  -&gt;
         top_close_block ""  ; close_env !cur_env ;
         check_alltt_skip lexbuf)
     ;;
     
</r>2725 <w>(* alltt *)
     
     </w></m>register_init "alltt"
         (<b><U>fun</U><r> () -&gt;
           def_code "\\alltt"
<m>2730         </m>(</r><U>fun</U></b> _ -&gt;
               <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b> prerr_endline "begin alltt" ;
               alltt := Inside ;
               fun_register (<b><U>fun</U><r> () -&gt; alltt := Not) ;
               Dest.close_block "" ; Dest.open_block "PRE" "") ;
<m>2735 
           </m>def_code "\\endalltt"
             (</r><U>fun</U></b> _ -&gt;
               <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b> prerr_endline "end alltt" ;
               Dest.close_block "PRE" ; Dest.open_block "" ""))
<m>2740 <r>;;
     
     <w>(* Multicolumn *)
     
     </w>def_code "\\multicolumn"
</r>2745     <r>(<b><U>fun</U><r> lexbuf -&gt;
           </r><U>if</U></b> not (is_table !in_table) <b><U>then</U><r>
             raise (ScanError "\\multicolumn should occur in some array") ;
           </r><U>let</U></b> n = Get.get_int (save_arg lexbuf) <b><U>in</U>
           <U>let</U></b> format =  Tabular.main (save_arg lexbuf) <b><U>in</U><m>
2750       <r>do_multi n  format main)
     ;;
     
     def_code "\\hline"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>2755     </m><U>if</U></b> not (is_table !in_table) <b><U>then</U><r>
           raise (ScanError "\\hline should occur in some array") ;
         do_hline main ;
         skip_blanks_pop lexbuf ;
         </r><U>let</U></b> _ = Dest.forget_par () <b><U>in</U><m>
2760     <r>())
     ;;
     
     <w>(* inside tabbing *)
     <b><U>let</U></b></w> do_tabul lexbuf =
</r>2765   </m><U>if</U></b> is_tabbing !in_table <b><U>then</U> <U>begin</U></b>
         do_unskip () ;
         Dest.close_cell ""; Dest.open_cell default_format 1 0
       <b><U>end</U></b> ;
       skip_blanks_pop lexbuf
</r>2770 <r>;;
     
     def_code "\\&gt;" do_tabul ;
     def_code "\\=" do_tabul
     ;;
</r>2775 
     <r>def_code "\\kill"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>if</U></b> is_tabbing !in_table <b><U>then</U> <U>begin</U></b>
           do_unskip () ;
</r>2780       <r>Dest.close_cell "";
           Dest.erase_row () ;
           Dest.new_row () ;
           Dest.open_cell default_format 1 0
         <b><U>end</U></b> ;
</r>2785     <r>skip_blanks_pop lexbuf)
     ;;
     
     
     <w>(* Tabular and arrays *)
<m>2790 
     
     <b><U>let</U><r> check_width = </r><U>function</U><r>
       | Length.Char x -&gt;
           " WIDTH="^string_of_int (Length.char_to_pixel x)
<m>2795   </m>| Length.Pixel x -&gt;
           " WIDTH="^string_of_int x
       | Length.Percent x -&gt;
           " WIDTH=\""^string_of_int x^"%\""
       | _ -&gt; ""
<m>2800 </m>;;
     
     <b><U>let</U><r> get_table_attributes border len =
       </r><U>let</U></b> attrs = get_prim
           (<b><U>if</U></b> border </r><U>then</U></b>
2805         <r>"\\@table@attributes@border"
           <b><U>else</U><r>
             "\\@table@attributes") </r><U>in</U></b>
       attrs^check_width len
     
</r>2810 
     <b><U>let</U><r> open_tabbing lexbuf =
       </r><U>let</U><r> lexbuf = Lexstate.previous_lexbuf <b><U>in</U>
       <U>let</U></b> lexfun lb =
         Dest.open_table <b><U>false</U><r> "border=0 cellspacing=0 cellpadding=0" ;
<m>2815     </m>Dest.new_row ();
         Dest.open_cell default_format 1 0 </r><U>in</U></b>
       push stack_table !in_table ;
       in_table := Tabbing ;
       new_env "tabbing" ;
<m>2820   </m>def "\\a" zero_pat
         (CamlCode
            (<b><U>fun</U><r> lexbuf -&gt;
              </r><U>let</U></b> acc = subst_arg lexbuf <b><U>in</U>
              <U>let</U></b> arg = subst_arg lexbuf </r><U>in</U></b>
2825          <r>scan_this main ("\\"^acc^arg))) ;
       lexfun lexbuf
     ;;
     
     def_code "\\tabbing" open_tabbing
</r>2830 <r>;;
     
     <b><U>let</U></b> close_tabbing _ =
       Dest.do_close_cell ();
       Dest.close_row ();
</r>2835   <r>Dest.close_table ();
       in_table := pop stack_table ;
       close_env "tabbing" ;
     ;;
     
</r>2840 <r>def_code "\\endtabbing" close_tabbing
     ;;
     
     <b><U>let</U></b> open_array env lexbuf =
       save_array_state ();
</r>2845   <r>Tabular.border := <b><U>false</U><r> ;
       </r><U>let</U></b> len =  <b><U>match</U><r> env </r><U>with</U></b>
         | "tabular*"|"Tabular*" -&gt;
             <b><U>let</U><r> arg = save_arg lexbuf </r><U>in</U>
             <U>begin</U> <U>match</U></b> Get.get_length (get_prim_onarg arg) <b><U>with</U><m>
2850         <r>| Length.No s -&gt;
                 warning ("``tabular*'' with length argument: "^
                          do_subst_this arg) ;
                 Length.Default
             | width -&gt; width
</r>2855         </m><U>end</U></b>
         | _ -&gt; Length.Default <b><U>in</U>
       <U>let</U></b> attributes = <b><U>match</U><r> env </r><U>with</U></b>
       | "Tabular*" | "Array" | "Tabular" -&gt; get_prim_opt "" lexbuf
       | _ -&gt; skip_opt lexbuf ; "" <b><U>in</U><m>
2860   <r>skip_opt lexbuf ;
       <b><U>let</U><r> format = save_arg lexbuf </r><U>in</U>
       <U>let</U></b> format = Tabular.main format <b><U>in</U></b>
       cur_format := format ;
       push stack_in_math !in_math ;
</r>2865   <r>in_table := Table
            {math = (env = "array")  ;
              border = !Tabular.border} ;
       <b><U>if</U><r> !display </r><U>then</U></b> Dest.item_display () ;
       in_math := <b><U>false</U></b> ;
</r>2870   <r>push stack_display !display ;
       display := <b><U>false</U><r> ;
       </r><U>begin</U> <U>match</U></b> attributes <b><U>with</U><r>
       | "" -&gt;
           </r><U>if</U></b> !Tabular.border <b><U>then</U><m>
2875         <r>Dest.open_table <b><U>true</U><r> (get_table_attributes </r><U>true</U></b> len)
           <b><U>else</U><r>
             Dest.open_table </r><U>false</U></b> (get_table_attributes <b><U>false</U></b> len);
       | _  -&gt;
            Dest.open_table !Tabular.border (attributes^check_width len)
</r>2880   </m><U>end</U></b> ;
       open_row() ;
       open_first_col main ;
       skip_blanks_pop lexbuf ;
     ;;
</r>2885 
     <r>def_code "\\@array" (open_array "array") ;
     def_code "\\@tabular" (open_array "tabular") ;
     def_code "\\@tabular*" (open_array "tabular*")
     ;;
</r>2890 <r>def_code "\\@Array" (open_array "Array") ;
     def_code "\\@Tabular" (open_array "Tabular") ;
     def_code "\\@Tabular*" (open_array "Tabular*")
     ;;
     
</r>2895 
     </m><U>let</U></b> close_array _ =
       do_unskip () ;
       close_last_col main "" ;
       close_last_row () ;
</r>2900   <r>Dest.close_table () ;
       restore_array_state () ;
       in_math := pop stack_in_math ;
       display := pop stack_display;
       <b><U>if</U><r> !display </r><U>then</U></b> Dest.item_display () ;
</r>2905 <r>;;
     
     def_code "\\end@array" close_array  ;
     def_code "\\end@tabular" close_array ;
     def_code "\\end@tabular*" close_array ;
</r>2910 <r>def_code "\\end@Array" close_array  ;
     def_code "\\end@Tabular" close_array ;
     def_code "\\end@Tabular*" close_array ;
     ;;
     
</r>2915 
     <b><U>let</U><r> do_amper lexbuf =
       </r><U>if</U><r> effective !alltt || not (is_plain '&amp;') <b><U>then</U> <U>begin</U>
         <U>let</U></b> lxm = lexeme lexbuf <b><U>in</U>
         <U>for</U></b> i = 0 <b><U>to</U></b> String.length lxm -1 </r><U>do</U></b>
2920       <r>Dest.put (Dest.iso lxm.[i])
         <b><U>done</U>
       <U>end</U> <U>else</U> <U>if</U></b> is_table !in_table  <b><U>then</U> <U>begin</U></b>
         close_col main "&amp;nbsp;";
         open_col main
</r>2925   <b><U>end</U><r> ;
       </r><U>if</U><r> not (effective !alltt) &amp;&amp; is_plain '&amp;' <b><U>then</U><r> skip_blanks_pop lexbuf
     
     </r><U>and</U></b> do_bsbs lexbuf =
       do_unskip () ;
<m>2930   </m>skip_opt lexbuf ;
       <b><U>if</U><r> is_table !in_table  </r><U>then</U> <U>begin</U></b>
         close_col main "&amp;nbsp;" ; close_row () ;
         open_row () ; open_first_col main
       <b><U>end</U> <U>else</U> <U>if</U></b> is_tabbing !in_table </r><U>then</U> <U>begin</U></b>
2935     <r>Dest.close_cell "";
         Dest.close_row () ;
         Dest.new_row () ;
         Dest.open_cell default_format 1 0
       <b><U>end</U> <U>else</U> <U>begin</U><m>
2940     </m><U>if</U></b> !display <b><U>then</U><r>
           warning "\\\\ in display mode, ignored"
         </r><U>else</U></b>
           Dest.skip_line ()
       <b><U>end</U></b> ;
</r>2945   <r>skip_blanks_pop lexbuf ;
       <b><U>let</U><r> _ = Dest.forget_par () </r><U>in</U></b> ()
     ;;
     
     def_code "\\@hevea@amper" do_amper ;
</r>2950 <r>def_code "\\\\"           do_bsbs  ;
     def_code "\\@HEVEA@amper" do_amper ;
     def_code "\\@HEVEA@bsbs"  do_bsbs  ; ()
     ;;
     
</r>2955 
     </m>(* Other scanners *)
     
     </w>def_code "\\latexonly"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>2960     <r>start_other_scan "latexonly" latexonly lexbuf)
     ;;
     
     def_code "\\toimage"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>2965     <r>start_image_scan "" image lexbuf)
     ;;
     
     def_code "\\@stopimage"
         (<b><U>fun</U></b> lexbuf  -&gt;
</r>2970       <r>Image.stop () ;
           check_alltt_skip lexbuf)
     ;;
     
     def_code "\\@restartimage"
</r>2975     <r>(<b><U>fun</U></b> lexbuf  -&gt;
           Image.restart () ;
           check_alltt_skip lexbuf)
     ;;
     
</r>2980 
     
     <r>def_code "\\@stopoutput"
         (<b><U>fun</U></b> lexbuf  -&gt;
           Dest.stop () ;
</r>2985       <r>check_alltt_skip lexbuf)
     ;;
     
     def_code "\\@restartoutput"
         (<b><U>fun</U></b> lexbuf  -&gt;
</r>2990       <r>Dest.restart () ;
           check_alltt_skip lexbuf)
     ;;
     
     
</r>2995 <w>(* Info  format specific *)
     
     <r>def_code "\\@infomenu"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U><m>
3000     <r>Dest.infomenu arg)
     ;;
     
     def_code  "\\@infonode"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>3005     </m><U>let</U></b> opt = get_prim_opt "" lexbuf <b><U>in</U>
         <U>let</U></b> num = get_prim_arg lexbuf <b><U>in</U>
         <U>let</U></b> nom = get_prim_arg lexbuf <b><U>in</U></b>
         Dest.infonode opt num nom)
     ;;
</r></w>3010 
     <r>def_code "\\@infoextranode"
       (<b><U>fun</U><r> lexbuf -&gt;
        </r><U>let</U></b> num = get_prim_arg lexbuf <b><U>in</U>
        <U>let</U></b> nom = get_prim_arg lexbuf <b><U>in</U><m>
3015    </m><U>let</U></b> text = get_prim_arg lexbuf <b><U>in</U></b>
        Dest.infoextranode num nom text)
     ;;
     
     def_code "\\@infoname"
</r>3020   <r>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U></b>
         Dest.loc_name arg)
     ;;
     
</r>3025 <b><U>let</U></b></m> safe_len = <b><U>function</U><r>
       | Length.No _ -&gt; Length.Default
       | l    -&gt; l
     ;;
     
<m>3030 </m>def_code "\\@printHR"
         (</r><U>fun</U></b> lexbuf -&gt;
           <b><U>let</U><r> arg = get_prim_arg lexbuf </r><U>in</U>
           <U>let</U></b> taille = safe_len (Get.get_length (get_prim_arg lexbuf)) <b><U>in</U><r>
           Dest.horizontal_line arg taille (Length.Pixel 2))
<m>3035 </m>;;
     
     def_code"\\@hr"
        (</r><U>fun</U></b> lexbuf -&gt;
          <b><U>let</U><r> attr = subst_opt "" lexbuf </r><U>in</U><m>
3040      </m><U>let</U></b> width = safe_len (Get.get_length (get_prim_arg lexbuf)) <b><U>in</U>
          <U>let</U></b> height = safe_len (Get.get_length (get_prim_arg lexbuf)) <b><U>in</U><r>
          Dest.horizontal_line attr width height)
     ;;
     
</r><m>3045 <w>(* Accents *)
     </w></m><U>let</U></b> aigu = <b><U>function</U><r>
       "a" -&gt; "" | "e" -&gt; "e" | "i" | "\\i" | "\\i " -&gt; ""
     | "o" -&gt; "" | "u" -&gt; ""
     | "A" -&gt; "" | "E" -&gt; "E" | "I" | "\\I" | "\\I " -&gt; ""
</r><m>3050 <r>| "O" -&gt; "" | "U" -&gt; ""
     | "y" -&gt; "" | "Y" -&gt; ""
     | "" | " " -&gt; "'"
     | s   -&gt; s
     
</r>3055 </m><U>and</U></b> grave = <b><U>function</U><r>
       "a" -&gt; "a" | "e" -&gt; "e"  | "i" -&gt; ""
     | "o" -&gt; "" | "u" -&gt; ""  | "\\i" | "\\i " -&gt; ""
     | "A" -&gt; "A" | "E" -&gt; "E"  | "I" -&gt; ""
     | "O" -&gt; "" | "U" -&gt; ""  | "\\I" | "\\I " -&gt; ""
<m>3060 </m>| "" | " " -&gt; "`"
     | s -&gt; s
     </r><U>and</U></b> circonflexe = <b><U>function</U><r>
       "a" -&gt; "a" | "e" -&gt; "e"  | "i" -&gt; "i"
     | "o" -&gt; "o" | "u" -&gt; "u"  | "\\i" | "\\i " -&gt; "i"
</r><m>3065 <r>| "A" -&gt; "A" | "E" -&gt; "E"  | "I" -&gt; "I"
     | "O" -&gt; "O" | "U" -&gt; "U"  | "\\I" | "\\I " -&gt; "I"
     | "" | " " -&gt; "\\@print{^}"
     | s -&gt; s
     
</r>3070 </m><U>and</U></b> trema = <b><U>function</U><r>
       "a" -&gt; "" | "e" -&gt; "e"  | "i" -&gt; "i"
     | "o" -&gt; "" | "u" -&gt; "u"  | "\\i" | "\\i " -&gt; "i"
     | "A" -&gt; "" | "E" -&gt; "E"  | "I" -&gt; "I"
     | "O" -&gt; "" | "U" -&gt; "U"  | "\\I" | "\\I " -&gt; "I"
<m>3075 </m>| "" | " " -&gt; ""
     | s -&gt; s
     
     </r><U>and</U></b> cedille = <b><U>function</U><r>
       "c" -&gt; "c"
<m>3080 </m>| "C" -&gt; "C"
     | s   -&gt; s
     
     </r><U>and</U></b> tilde = <b><U>function</U><r>
       "a" -&gt; "" | "A" -&gt; ""
<m>3085 </m>| "o" -&gt; "" | "O" -&gt; ""
     | "n" -&gt; "" | "N" -&gt; ""
     | "" | " " -&gt; "\\@print{~}"
     | s   -&gt; s
     ;;
<m>3090 
     
     
     </m>def_fun "\\'"  aigu ;
     def_fun "\\`"  grave ;
<m>3095 </m>def_fun "\\^"  circonflexe ;
     def_fun "\\\"" trema ;
     def_fun "\\c"  cedille ;
     def_fun "\\~"  tilde
     ;;
<m>3100 
     </m>Get.init
       get_prim_onarg
       get_fun_result
       new_env close_env
<m>3105   </m>get_csname
       main
     ;;
     
     def_code "\\@primitives"
<m>3110   </m>(</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> pkg = get_prim_arg lexbuf </r><U>in</U></b>
         exec_init pkg)
     ;;
     
<m>3115 <w>(* try e1 with _ -&gt; e2 *)
     
     <r>def_code "\\@try"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> saved_location = Location.check ()
</r></w>3120     <b><U>and</U></b></m> env_saved = env_check ()
         <b><U>and</U><r> saved = Hot.checkpoint ()
         </r><U>and</U></b> saved_lexstate = Lexstate.check_lexstate ()
         <b><U>and</U><r> saved_out = Dest.check ()
         </r><U>and</U></b> saved_get = Get.check ()
<m>3125     <b><U>and</U></b></m> saved_aux = Auxx.check () <b><U>in</U>
         <U>let</U></b> e1 = save_arg lexbuf <b><U>in</U>
         <U>let</U></b> e2 = save_arg lexbuf <b><U>in</U>
         <U>try</U></b>
           top_open_block "TEMP" "" ;
<m>3130       <r>scan_this_arg main e1 ;
           top_close_block "TEMP"
         <b><U>with</U><r> e -&gt; </r><U>begin</U></b>
           Location.hot saved_location ;
           env_hot env_saved ;
</r>3135       <r>Misc.print_verb 0
             ("\\@try caught exception : "^Printexc.to_string e) ;
           Lexstate.hot_lexstate saved_lexstate ;
           Dest.hot saved_out ;
           Get.hot saved_get ;
</r>3140       <r>Auxx.hot saved_aux ;
           Hot.start saved ;
           scan_this_arg main e2
         <b><U>end</U></b>)
     ;;
</r>3145 
     <r>def_code "\\@heveafail"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> s = get_prim_arg lexbuf <b><U>in</U></b>
         raise (Misc.Purposly s))
</r>3150 <r>;;
     
     <w>(*
     (* A la TeX ouput (more or less...) *)
     
<m>3155 </m>def_code "\\newwrite"
       (fun lexbuf -&gt;
         let cmd = save_arg lexbuf in
         let file = ref stderr in
         def_code cmd
<m>3160       </m>(fun lexbuf -&gt;
             let op = save_arg lexbuf in
             try
               match op with
               |  "\\write" -&gt;
<m>3165               </m>let what = subst_arg subst lexbuf in
                   output_string !file what ;
                   output_char !file '\n'
               | "\\closeout" -&gt;
                   close_out !file
<m>3170           </m>| "\\openout" -&gt;
                   let name = get_this_nostyle main (save_filename lexbuf) in
                   file := open_out name
               | _ -&gt;
                   warning ("Unkown file operation: "^op)
<m>3175         </m>with Sys_error s -&gt;
               warning ("TeX file error : "^s)))
     ;;
     
     let def_fileop me =
<m>3180   </m>def_code me
        (fun lexbuf -&gt;
          let cmd = subst_arg lexbuf in
          scan_this_may_cont main lexbuf (cmd^me))
     ;;
<m>3185 
     </m>def_fileop "\\write" ;
     def_fileop "\\openout" ;
     def_fileop "\\closeout"
     ;;
<m>3190 </m>*)
     
     
     
     <b><U>end</U></b></w>}<PL><B>
<6>8 length.mll</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: length.mll,v 1.13 2001/06/06 16:52:52 maranget Exp $          *)
     (***********************************************************************)
     
     </w>{
     <b><U>open</U></b> Lexing
  </r>15 <b><U>let</U></b></m> header = "$Id: length.mll,v 1.13 2001/06/06 16:52:52 maranget Exp $"
     
     <b><U>exception</U><r> Cannot
     ;;
     
  </r><m>20 </m><U>let</U></b> font = 10
     ;;
     
     <b><U>let</U><r> font_float = float font
     ;;
  </r><m>25 </m><U>type</U></b> t =
       Char <b><U>of</U><r> int | Pixel </r><U>of</U></b> int | Percent <b><U>of</U><r> int | No </r><U>of</U></b> string | Default
     
     <b><U>let</U><r> pretty = </r><U>function</U></b>
       | Char x -&gt; string_of_int x^" chars"
  <m>30   <r>| Pixel x -&gt; string_of_int x^" pxls"
       | Percent x  -&gt; string_of_int x^"%"
       | Default    -&gt; "default"
       | No s       -&gt; "*"^s^"*"
     
  </r>35 <b><U>let</U></b></m> pixel_to_char x =  (100 * x + 50)/(100 * font)
     <b><U>and</U><r> char_to_pixel x = font * x
     
     </r><U>let</U></b> mk_char x = Char (truncate (0.5 +. x))
     <b><U>let</U><r> mk_pixel x = Pixel (truncate (0.5 +. x))
  </r><m>40 </m><U>and</U></b> mk_percent x = Percent (truncate x)
     ;;
     
     <b><U>let</U><r> convert unit x = </r><U>match</U></b> unit <b><U>with</U><r>
         |   "ex"|"em" -&gt; mk_char x
  <m>45     </m>|  "pt"     -&gt; mk_pixel x
         |  "in"     -&gt; mk_char ((x *. 72.27) /. font_float)
         |  "cm"     -&gt; mk_char ((x *. 28.47) /. font_float)
         |  "mm"     -&gt; mk_char ((x *. 2.847) /. font_float)
         |  "pc"     -&gt; mk_char ((x *. 12.0)  /. font_float)
  <m>50     </m>|  "@percent" -&gt; mk_percent (100.0 *. x)
         |  _ -&gt; No unit
     ;;
     
     }
  <m>55 
     </m>rule main_rule = parse
       '-' {</r><U>let</U></b> x,unit = positif lexbuf <b><U>in</U><r> convert unit (0.0 -. x)}
     |  "" {</r><U>let</U></b> x,unit = positif lexbuf <b><U>in</U><r> convert unit x}
     
  </r><m>60 </m><U>and</U></b> positif = parse
     | ['0'-'9']*'.'?['0'-'9']+
        {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
        float_of_string lxm,unit lexbuf}
     | "@percent"  {1.0, "@percent"}
  <m>65 <r>|  "" {raise Cannot}
     <b><U>and</U></b> unit = parse
     | [' ''\n''\t''\r']+ {unit lexbuf}
     | [^' ''\n''\t''\r']* {lexeme lexbuf}
     
  </r>70 <r>{
     <b><U>open</U><r> Lexing
     
     </r><U>let</U></b> main lexbuf =
       <b><U>try</U><r> main_rule lexbuf </r><U>with</U><m>
  75   <r>| Cannot -&gt;
           <b><U>let</U><r> sbuf = lexbuf.lex_buffer </r><U>in</U></b>
           No (String.sub sbuf 0 lexbuf.lex_buffer_len)
     }<PL><B>
<6>9 save.mll</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w>{
     <b><U>open</U><r> Lexing
     </r><U>open</U></b> Misc
  </r>15 
     </m><U>let</U></b> header = "$Id: save.mll,v 1.60 2001/02/12 10:05:39 maranget Exp $"
     
     <b><U>let</U> <U>rec</U></b> if_next_char  c lb =
       <b><U>if</U><r> lb.lex_eof_reached </r><U>then</U><m>
  20     </m><U>false</U>
       <U>else</U>
         <U>let</U></b> pos = lb.lex_curr_pos
         <b><U>and</U><r> len = lb.lex_buffer_len </r><U>in</U>
         <U>if</U></b> pos &gt;= len <b><U>then</U> <U>begin</U><m>
  25       <r>warning "Refilling buffer" ;
           lb.refill_buff lb ;
           if_next_char c lb
         <b><U>end</U> <U>else</U></b>
           lb.lex_buffer.[pos] = c
  </r>30 
     </m><U>let</U> <U>rec</U></b> if_next_string s lb =
       <b><U>if</U><r> s = "" </r><U>then</U>
         <U>true</U>
       <U>else</U><m>
  35     </m><U>let</U></b> pos = lb.lex_curr_pos
         <b><U>and</U><r> len = lb.lex_buffer_len
         </r><U>and</U></b> slen = String.length s <b><U>in</U>
         <U>if</U></b> pos + slen - 1 &gt;= len <b><U>then</U> <U>begin</U>
           <U>if</U></b> lb.lex_eof_reached <b><U>then</U> <U>begin</U><m>
  40           </m><U>false</U>
           <U>end</U> <U>else</U> <U>begin</U></b>
               lb.refill_buff lb ;
             if_next_string s lb
           <b><U>end</U><m>
  45     </m><U>end</U> <U>else</U></b>
           String.sub lb.lex_buffer pos slen = s
     
     <b><U>let</U><r> verbose = ref 0 </r><U>and</U></b> silent = ref <b><U>false</U></b>
     ;;
  </r>50 
     <b><U>let</U></b></m> set_verbose s v =
       silent := s ; verbose := v
     ;;
     
  <m>55 <b><U>exception</U></b></m> Error <b><U>of</U><r> string
     ;;
     </r><U>exception</U></b> Delim <b><U>of</U><r> string
     ;;
     
  </r><m>60 </m><U>let</U></b> seen_par = ref <b><U>false</U><r>
     ;;
     
     
     </r><U>let</U></b> brace_nesting = ref 0
  <m>65 <b><U>and</U></b></m> arg_buff = Out.create_buff ()
     <b><U>and</U><r> echo_buff = Out.create_buff ()
     </r><U>and</U></b> tag_buff = Out.create_buff ()
     ;;
     
  <m>70 
     <b><U>let</U></b></m> echo = ref <b><U>false</U><r>
     ;;
     
     </r><U>let</U></b> get_echo () = echo := <b><U>false</U><r> ; Out.to_string echo_buff
  </r><m>75 </m><U>and</U></b> start_echo () = echo := <b><U>true</U><r> ; Out.reset echo_buff
     </r><U>and</U></b> stop_echo () = echo := <b><U>false</U><r> ; Out.reset echo_buff
     ;;
     
     </r><U>let</U></b> empty_buffs () =
  <m>80   <r>brace_nesting := 0 ; Out.reset arg_buff ;
       echo := <b><U>false</U></b> ; Out.reset echo_buff ;
       Out.reset tag_buff
     ;;
     
  </r>85 <b><U>let</U></b></m> error s =
       empty_buffs () ;
       raise (Error s)
     ;;
     
  <m>90 <b><U>let</U></b></m> my_int_of_string s =
       <b><U>try</U><r> int_of_string s
       </r><U>with</U></b> Failure "int_of_string" -&gt;
         error ("Integer argument expected: ``"^s^"''")
     
  <m>95 <b><U>exception</U></b></m> Eof
     ;;
     <b><U>exception</U><r> NoOpt
     ;;
     
 </r><m>100 </m><U>let</U></b> put_echo s =
       <b><U>if</U><r> !echo </r><U>then</U></b> Out.put echo_buff s
     <b><U>and</U><r> put_echo_char c =
       </r><U>if</U></b> !echo <b><U>then</U><r> Out.put_char echo_buff c
     </r><U>and</U></b> blit_echo lb =
 <m>105   <b><U>if</U></b></m> !echo <b><U>then</U><r> Out.blit echo_buff lb
     ;;
     
     </r><U>let</U></b> put_both s =
       put_echo s ; Out.put arg_buff s
 <m>110 <r>;;
     <b><U>let</U><r> blit_both lexbuf =
       blit_echo lexbuf ; Out.blit arg_buff lexbuf
     
     </r><U>let</U></b> put_both_char c =
 </r>115   <r>put_echo_char c ; Out.put_char arg_buff c
         ;;
     
     <b><U>type</U><r> kmp_t = Continue </r><U>of</U></b> int | Stop <b><U>of</U></b> string
     
 </r>120 <b><U>let</U> <U>rec</U></b></m> kmp_char delim next i c =
       <b><U>if</U><r> i &lt; 0 </r><U>then</U> <U>begin</U></b>
         Out.put_char arg_buff c ;
         Continue 0
       <b><U>end</U> <U>else</U> <U>if</U></b> c = delim.[i] <b><U>then</U> <U>begin</U><m>
 125     </m><U>if</U></b> i &gt;= String.length delim - 1 <b><U>then</U><r>
           Stop (Out.to_string arg_buff)
         </r><U>else</U></b>
           Continue (i+1)
       <b><U>end</U> <U>else</U> <U>begin</U><m>
 130     </m><U>if</U></b> next.(i) &gt;= 0 <b><U>then</U><r>
           Out.put arg_buff (String.sub delim 0 (i-next.(i))) ;
         kmp_char delim next next.(i) c
       </r><U>end</U></b>
     }
 <m>135 <b><U>let</U></b></m> command_name = '\\' (( ['@''A'-'Z' 'a'-'z']+ '*'?) | [^ 'A'-'Z' 'a'-'z'])
     <b><U>let</U><r> space = [' ''\t''\r']
     
     rule opt = parse
     | space* '\n'? space* '['
 </r><m>140     <r>{put_echo (lexeme lexbuf) ;
         opt2 lexbuf}
     |  eof  {raise Eof}
     |  ""   {raise NoOpt}
     
 </r>145 
     </m><U>and</U></b> opt2 =  parse
     | '{'         {incr brace_nesting;
                      put_both_char '{' ; opt2 lexbuf}
     | '}'        { decr brace_nesting;
 <m>150                <b><U>if</U></b></m> !brace_nesting &gt;= 0 <b><U>then</U> <U>begin</U></b>
                      put_both_char '}' ; opt2 lexbuf
                    <b><U>end</U> <U>else</U> <U>begin</U></b>
                      error "Bad brace nesting in optional argument"
                    <b><U>end</U><r>}
 <m>155 </m>| ']'
         {</r><U>if</U></b> !brace_nesting &gt; 0 <b><U>then</U> <U>begin</U></b>
           put_both_char ']' ; opt2 lexbuf
         <b><U>end</U> <U>else</U> <U>begin</U></b>
           put_echo_char ']' ;
 <m>160       <r>Out.to_string arg_buff
         <b><U>end</U><r>}
       | _
           {</r><U>let</U></b> s = lexeme_char lexbuf 0 <b><U>in</U></b>
           put_both_char s ; opt2 lexbuf }
 </r>165 
     <b><U>and</U></b></m> skip_comment = parse
       | eof       {()}
       | '\n' space* {()}
       | _         {skip_comment lexbuf}
 <m>170 
     <b><U>and</U></b></m> check_comment = parse
       | '%' {skip_comment lexbuf}
       | ""  {()}
     
 <m>175 <b><U>and</U></b></m> arg = parse
         space+ | '\n'+  {put_echo (lexeme lexbuf) ; arg lexbuf}
       | '{'
           {incr brace_nesting;
           put_echo_char '{' ;
 <m>180       <r>arg2 lexbuf}
       | '%'
          {skip_comment lexbuf  ; arg lexbuf}
       | "\\box" '\\' (['A'-'Z' 'a'-'z']+ '*'? | [^ 'A'-'Z' 'a'-'z'])
          {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U><m>
 185      <r>put_echo lxm ;
          lxm}
       | command_name
          {blit_both lexbuf ;
          skip_blanks lexbuf}
 </r>190   <r>| '#' ['1'-'9']
          {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
          put_echo lxm ; lxm}
       | [^ '}']
           {<b><U>let</U><r> c = lexeme_char lexbuf 0 </r><U>in</U><m>
 195       <r>put_both_char c ;
           Out.to_string arg_buff}
       | eof    {raise Eof}
       | ""     {error "Argument expected"}
     
 </r>200 
     </m><U>and</U></b> first_char = parse
       | _
           {<b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U></b>
           put_echo_char lxm ;
 </r>205       <r>lxm}
       | eof {raise Eof}
     
     <b><U>and</U></b> rest = parse
       |   _ * eof
 </r>210       <r>{<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
           put_echo lxm ;
           lxm}
     
     <b><U>and</U></b> skip_blanks = parse
 </r>215 <r>| space* '\n'
         {seen_par := <b><U>false</U></b> ;
         put_echo (lexeme lexbuf) ;
         more_skip lexbuf}
     | space*
 </r>220     <r>{put_echo (lexeme lexbuf) ; Out.to_string arg_buff}
     
     <b><U>and</U><r> more_skip = parse
       (space* '\n' space*)+
        {seen_par := </r><U>true</U></b> ;
 </r>225    <r>put_echo (lexeme lexbuf) ;
        more_skip lexbuf}
     | ""
       {Out.to_string arg_buff}
     
 </r>230 </m><U>and</U></b> skip_equal = parse
         space* '='? space* {()}
     
     <b><U>and</U></b> arg2 = parse
       '{'
 </r>235      <r>{incr brace_nesting;
          put_both_char '{' ;
          arg2 lexbuf}
     | '}'
          {decr brace_nesting;
 </r>240      <b><U>if</U></b></m> !brace_nesting &gt; 0 <b><U>then</U> <U>begin</U></b>
            put_both_char '}' ; arg2 lexbuf
          <b><U>end</U> <U>else</U> <U>begin</U></b>
            put_echo_char '}' ;
            Out.to_string arg_buff
 <m>245      <b><U>end</U></b></m>}
     | "\\{" | "\\}" | "\\\\"
           {blit_both lexbuf ; arg2 lexbuf }
     | eof
         {error "End of file in argument"}
 <m>250 
     <r>| [^'\\''{''}']+
           {blit_both lexbuf ; arg2 lexbuf }
     
     | _
 </r>255     <r>{<b><U>let</U><r> c = lexeme_char lexbuf 0 </r><U>in</U></b>
         put_both_char c ; arg2 lexbuf}
     
     <b><U>and</U></b> csname = parse
       (space|'\n')+
 </r>260     <r>{(<b><U>fun</U><r> get_prim subst -&gt;
           blit_echo lexbuf ; csname lexbuf get_prim subst)}
     | '{'? "\\csname" space*
           {(</r><U>fun</U></b> get_prim subst_fun -&gt;
             blit_echo lexbuf ;
 </r>265         <b><U>let</U></b></m> r = incsname lexbuf <b><U>in</U><r>
             "\\"^get_prim r)}
     | ""  {</r><U>fun</U></b> get_prim subst -&gt; <b><U>let</U><r> r = arg lexbuf </r><U>in</U></b> subst r}
     
     <b><U>and</U><r> incsname = parse
 <m>270   </m>"\\endcsname"  '}'?
         {</r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><r>
         put_echo lxm ; Out.to_string arg_buff}
     | _
         {put_both_char (lexeme_char lexbuf 0) ;
 <m>275     </m>incsname lexbuf}
     | eof           {error "End of file in command name"}
     
     </r><U>and</U></b> cite_arg = parse
       space* '{'   {cite_args_bis lexbuf}
 <m>280 <r>| ""         {error "No opening ``{'' in citation argument"}
     
     <b><U>and</U><r> cite_args_bis = parse
       (space|[^'}''\n''%'','])* {</r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U></b> lxm::cite_args_bis lexbuf}
     |  '%' [^'\n']* '\n' {cite_args_bis lexbuf}
 </r>285 <r>| ','         {cite_args_bis lexbuf}
     | (space|'\n')+ {cite_args_bis lexbuf}
     | '}'         {[]}
     | ""          {error "Bad syntax for \\cite argument"}
     
 </r>290 <b><U>and</U></b></m> num_arg = parse
     | (space|'\n')+ {(<b><U>fun</U><r> get_int -&gt; num_arg lexbuf get_int)}
     | ['0'-'9']+
         {</r><U>fun</U></b> get_int -&gt;
           <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U><m>
 295       <r>my_int_of_string lxm}
     |  "'" ['0'-'7']+
         {<b><U>fun</U><r> get_int -&gt;</r><U>let</U></b> lxm = lexeme  lexbuf <b><U>in</U></b>
         my_int_of_string ("0o"^String.sub lxm 1 (String.length lxm-1))}
     |  '"' ['0'-'9' 'a'-'f' 'A'-'F']+
 </r>300     <r>{fun get_int -&gt;let lxm = lexeme  lexbuf in
         my_int_of_string ("0x"^String.sub lxm 1 (String.length lxm-1))}
     | '`' '\\' _
         {fun get_int -&gt;let c = lexeme_char lexbuf 2 in
         Char.code c}
 </r>305 <r>| '`' '#' ['1'-'9']
         {fun get_int -&gt;
           let lxm = lexeme lexbuf in
           get_int (String.sub lxm 1 2)}
     | '`' _
 </r>310     <r>{fun get_int -&gt;let c = lexeme_char lexbuf 1 in
         Char.code c}
     | ""
         {fun get_int -&gt;
           let s = arg lexbuf in
 </r>315       <r>get_int s}
     
     
     and filename = parse
       [' ''\n']+     {put_echo (lexeme lexbuf) ; filename lexbuf}
 </r>320 <r>| [^'\n''{'' ']+ {let lxm = lexeme lexbuf in put_echo lxm ; lxm}
     | ""             {arg lexbuf}
     
     and get_limits = parse
       space+          {get_limits lexbuf}
 </r>325 <r>| "\\limits"    {Some Limits}
     | "\\nolimits"  {Some NoLimits}
     | "\\intlimits" {Some IntLimits}
     | eof           {raise Eof}
     | ""            {None}
 </r>330 
     <r>and get_sup = parse
     | space* '^'  {try Some (arg lexbuf) with Eof -&gt; error "End <b><U>of</U></b> file after ^"}
     | eof       {raise Eof}
     | ""        {None}
 </r>335 
     
     <r>and get_sub = parse
     | space* '_'  {try Some (arg lexbuf) with Eof -&gt; error "End <b><U>of</U></b> file after _"}
     | eof       {raise Eof}
 </r>340 <r>| ""        {None}
     
     and defargs = parse
     |  '#' ['1'-'9']
         {let lxm = lexeme lexbuf in
 </r>345     <r>put_echo lxm ;
         lxm::defargs lexbuf}
     | [^'{'] | "\\{"
         {blit_both lexbuf ;
         let r = in_defargs lexbuf in
 </r>350     <r>r :: defargs lexbuf}
     | "" {[]}
     
     and in_defargs = parse
     | "\\{" | "\\#" {blit_both lexbuf ; in_defargs lexbuf}
 </r>355 <r>| [^'{''#']     {put_both_char (lexeme_char lexbuf 0) ; in_defargs lexbuf}
     | ""            {Out.to_string arg_buff}
     
     and get_defargs = parse
       [^'{']* {let r = lexeme lexbuf in r}
 </r>360 
     <r>and tagout = parse
     | "&lt;BR&gt;" {Out.put_char tag_buff ' ' ; tagout lexbuf}
     |  '&lt;'  {intag lexbuf}
     | "&amp;nbsp;" {Out.put tag_buff " " ; tagout lexbuf}
 </r>365 <r>| "&amp;gt;" {Out.put tag_buff "&gt;" ; tagout lexbuf}
     | "&amp;lt;" {Out.put tag_buff "&lt;" ; tagout lexbuf}
     | _    {Out.blit tag_buff lexbuf ; tagout lexbuf}
     | eof  {Out.to_string tag_buff}
     
 </r>370 <r>and intag = parse
       '&gt;'  {tagout lexbuf}
     | '"'  {instring lexbuf}
     | _    {intag lexbuf}
     | eof  {Out.to_string tag_buff}
 </r>375 
     </m><U>and</U></b> instring = parse
       '"'  {intag lexbuf}
     | '\\' '"' {instring lexbuf}
     | _    {instring lexbuf}
 <m>380 <r>| eof  {Out.to_string tag_buff}
     
     
     <b><U>and</U><r> checklimits = parse
       "\\limits"   {</r><U>true</U></b>}
 </r>385 <r>| "\\nolimits" {<b><U>false</U><r>}
     | ""           {</r><U>false</U></b>}
     
     <b><U>and</U></b> eat_delim_init = parse
     | eof {raise Eof}
 </r>390 <r>| '{'
         {<b><U>fun</U><r> delim next _ -&gt;
           put_echo_char '{' ;
           incr brace_nesting ;
           </r><U>let</U></b> r = arg2 lexbuf <b><U>in</U><m>
 395       <r>check_comment lexbuf ;
           <b><U>if</U><r> if_next_string delim lexbuf </r><U>then</U> <U>begin</U></b>
             skip_delim_rec lexbuf delim 0 ;
             r
           <b><U>end</U> <U>else</U> <U>begin</U><m>
 400         <r>Out.put_char arg_buff '{' ;
             Out.put arg_buff r ;
             Out.put_char arg_buff '}' ;
             eat_delim_rec lexbuf delim next 0
           <b><U>end</U></b>}
 </r>405 <r>| ""  {eat_delim_rec lexbuf}
     
     <b><U>and</U><r> eat_delim_rec = parse
     | "\\{"
       {</r><U>fun</U></b> delim next i -&gt;
 </r>410     <r>put_echo "\\{" ;
         <b><U>match</U><r> kmp_char delim next i '\\' </r><U>with</U></b>
         | Stop _ -&gt;
             error "Delimitors cannot end with ``\\''"
         | Continue i -&gt; <b><U>match</U><r>  kmp_char delim next i '{' </r><U>with</U><m>
 415       <r>| Stop s -&gt; s
           | Continue i -&gt;  eat_delim_rec lexbuf delim next i}
     
     | '{'
       {<b><U>fun</U></b> delim next i -&gt;
 </r>420     <r>put_echo_char '{' ;
         Out.put arg_buff (<b><U>if</U><r> i &gt; 0 </r><U>then</U></b> String.sub delim 0 i <b><U>else</U><r> "") ;
         Out.put_char arg_buff '{' ;
         incr brace_nesting ;
         </r><U>let</U></b> r = arg2 lexbuf <b><U>in</U><m>
 425     <r>Out.put arg_buff r ;
         Out.put_char arg_buff '}' ;
         eat_delim_rec lexbuf delim next 0}
     | _
       {<b><U>fun</U></b> delim next i -&gt;
 </r>430     </m><U>let</U></b> c = lexeme_char lexbuf 0 <b><U>in</U><r>
         put_echo_char c ;
         </r><U>match</U></b> kmp_char delim next i c <b><U>with</U></b>
         | Stop s -&gt; s
         | Continue i -&gt; eat_delim_rec lexbuf delim next i}
 </r>435 <r>|  eof
         {error ("End of file in delimited argument, read:
      "^
                 Out.to_string echo_buff)}
     
 </r>440 </m><U>and</U></b> skip_delim_init = parse
     | space|'\n' {skip_delim_init lexbuf}
     | ""       {skip_delim_rec lexbuf}
     
     <b><U>and</U></b> skip_delim_rec = parse
 </r>445 <r>| _
       {<b><U>fun</U><r> delim i -&gt;
         </r><U>let</U></b> c = lexeme_char lexbuf 0 <b><U>in</U><r>
         put_echo_char c ;
         </r><U>if</U></b> c &lt;&gt; delim.[i] <b><U>then</U><m>
 450       <r>raise (Delim delim) ;
         <b><U>if</U><r> i+1 &lt; String.length delim </r><U>then</U></b>
           skip_delim_rec lexbuf delim (i+1)}
     |  eof
         {<b><U>fun</U></b> delim i -&gt;
 </r>455       <r>error ("End of file checking delimiter ``"^delim^"''")}
     <b><U>and</U><r> check_equal = parse
     | '=' {</r><U>true</U></b>}
     | ""  {<b><U>false</U></b>}
     
 </r>460 <r>{
     
     <b><U>let</U><r> init_kmp s =
       </r><U>let</U></b> l = String.length s <b><U>in</U>
       <U>let</U></b> r = Array.create l (-1) <b><U>in</U><m>
 465   </m><U>let</U> <U>rec</U></b> init_rec i j =
     
         <b><U>if</U><r> i+1 &lt; l </r><U>then</U> <U>begin</U>
           <U>if</U></b> j = -1 || s.[i]=s.[j] <b><U>then</U> <U>begin</U></b>
             r.(i+1) &lt;- j+1 ;
 </r>470         <r>init_rec (i+1) (j+1)
           <b><U>end</U> <U>else</U></b>
             init_rec i r.(j)
         <b><U>end</U> <U>in</U></b>
       init_rec 0 (-1) ;
 </r>475   <r>r
     
     <b><U>let</U><r> with_delim delim lexbuf =
       </r><U>let</U></b> next = init_kmp delim  <b><U>in</U></b>
       check_comment lexbuf ;
 </r>480   </m><U>let</U></b> r = eat_delim_init lexbuf delim next 0 <b><U>in</U><r>
       r
     
     </r><U>and</U></b> skip_delim delim lexbuf =
       check_comment lexbuf ;
 </r>485   <r>skip_delim_init lexbuf delim 0
     
     <b><U>let</U><r> skip_blanks_init lexbuf =
       </r><U>let</U></b> _ = skip_blanks lexbuf <b><U>in</U></b>
       ()
 </r>490 
     </m><U>let</U></b> arg_verbatim lexbuf = <b><U>match</U><r> first_char lexbuf </r><U>with</U></b>
       | '{' -&gt;
            incr brace_nesting ;
            arg2 lexbuf
 </r>495   <r>| c -&gt;
           <b><U>let</U><r> delim = String.make 1 c </r><U>in</U></b>
           with_delim delim lexbuf
     }<PL><B>
<6>10 subst.mll</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: subst.mll,v 1.14 2001/05/25 12:37:29 maranget Exp $           *)
     (***********************************************************************)
     </w>{
     <b><U>open</U><r> Misc
     </r><U>open</U></b> Lexstate
  </r>15 </m><U>open</U></b> Lexing
     
     
     <b><U>let</U></b> subst_buff = Out.create_buff ()
     ;;
  </r>20 <r>}
     <b><U>let</U></b> command_name = '\\' ((['@''A'-'Z' 'a'-'z']+ '*'?) | [^ 'A'-'Z' 'a'-'z'])
     
     rule subst = parse
     | '#' ['1'-'9']
  </r>25     <r>{<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>if</U></b> is_plain '#' <b><U>then</U> <U>begin</U>
           <U>let</U></b> i = Char.code (lxm.[1]) - Char.code '1' <b><U>in</U><r>
           scan_arg
             (</r><U>fun</U></b> arg -&gt; scan_this_arg subst arg) i
  </r>30     <b><U>end</U> <U>else</U></b></m>
           Out.put subst_buff lxm ;
         subst lexbuf}
     | '#' '#'
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U><m>
  35     </m><U>if</U></b> is_plain '#' <b><U>then</U><r>
           Out.put_char subst_buff '#'
         </r><U>else</U></b>
           Out.put subst_buff lxm ;
         subst lexbuf}
  <m>40 <r>|  "\\#" | '\\' | [^'\\' '#']+
         {Out.blit subst_buff lexbuf ; subst lexbuf}
     | "\\@print"
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
         Save.start_echo () ;
  </r>45     <b><U>let</U></b></m> _ = Save.arg lexbuf <b><U>in</U>
         <U>let</U></b> real_arg = Save.get_echo () <b><U>in</U><r>
         Out.put subst_buff lxm ;
         Out.put subst_buff real_arg ;
         subst lexbuf}
  <m>50 </m>|  command_name
         {Out.blit subst_buff lexbuf ;
         subst lexbuf}
     |  eof {()}
     | "" {raise (Error "Empty lexeme in subst")}
  <m>55 
     </m>{
     
     </r><U>let</U></b> do_subst_this ({arg=arg ; subst=env} <b><U>as</U><r> x) =
       </r><U>if</U></b> not (is_top env) <b><U>then</U> <U>begin</U><m>
  60     </m><U>try</U>
           <U>let</U></b> _ = String.index arg '#' <b><U>in</U>
           <U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
             Printf.fprintf stderr "subst_this : [%s]\n" arg ;
             prerr_args ()
  <m>65       <b><U>end</U></b></m> ;
           <b><U>let</U><r> _ = scan_this_arg subst x </r><U>in</U>
           <U>let</U></b> r = Out.to_string subst_buff <b><U>in</U>
           <U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
             prerr_endline ("subst_this ["^arg^"] = "^r);
  <m>70       </m>r
         </r><U>with</U></b> Not_found -&gt; arg
       <b><U>end</U> <U>else</U></b>
         arg
     ;;
  <m>75 
     <b><U>let</U></b></m> subst_this s = do_subst_this (mkarg s (get_subst ()))
     
     <b><U>let</U><r> subst_arg lexbuf = do_subst_this (save_arg lexbuf)
     </r><U>and</U></b> subst_opt def lexbuf = do_subst_this (save_opt def lexbuf)
  <m>80 
     
     <b><U>let</U></b></m> subst_body = subst_arg
     
     }<PL><B>
<6>11 tabular.mll</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     (* $Id: tabular.mll,v 1.26 2001/03/01 22:17:00 maranget Exp $ *)
     </w>{
     <b><U>open</U><r> Misc
  </r><m>15 </m><U>open</U></b> Lexing
     <b><U>open</U><r> Table
     </r><U>open</U></b> Lexstate
     <b><U>open</U><r> Subst
     
  </r><m>20 </m><U>exception</U></b> Error <b><U>of</U><r> string
     ;;
     
     </r><U>type</U></b> align =
         {hor : string ; <b><U>mutable</U></b> vert : string ; wrap : bool ;
  <m>25       <b><U>mutable</U><r> pre : string ; </r><U>mutable</U><r> post : string ; width : Length.t}
     
     <b><U>let</U><r> make_hor = </r><U>function</U></b>
         'c' -&gt; "center"
       | 'l' -&gt; "left"
  <m>30   </m>| 'r' -&gt; "right"
       | 'p'|'m'|'b' -&gt; "left"
       | _ -&gt; raise (Misc.Fatal "make_hor")
     
     <b><U>and</U></b> make_vert = </r><U>function</U></b>
  35   <r>| 'c'|'l'|'r' -&gt; ""
       | 'p' -&gt; "top"
       | 'm' -&gt; "middle"
       | 'b' -&gt; "bottom"
       | _ -&gt; raise (Misc.Fatal "make_vert")
  </r>40 
     <b><U>type</U><r> format =
       Align </r><U>of</U><r> align
     | Inside <b><U>of</U><r> string
     | Border </r><U>of</U></b> string
  <m>45 </m>;;
     
     <w>(* Patch vertical alignment (for HTML) *)
     <b><U>let</U></b></w> check_vert f =
       </r><U>try</U></b>
  50     <b><U>for</U><r> i = 0 </r><U>to</U><r> Array.length f-1 <b><U>do</U>
           <U>match</U></b> f.(i) <b><U>with</U><r>
           | Align {vert=s} </r><U>when</U></b> s &lt;&gt; "" -&gt; raise Exit
           | _ -&gt; ()
         <b><U>done</U><r> ;
  <m>55     </m>f
       </r><U>with</U></b> Exit -&gt; <b><U>begin</U>
         <U>for</U></b> i = 0 <b><U>to</U><r> Array.length f-1 </r><U>do</U>
           <U>match</U></b> f.(i) <b><U>with</U><r>
           | Align ({vert=""} </r><U>as</U></b> f) -&gt;
  <m>60           </m>f.vert &lt;- "top"
           | _ -&gt; ()
         <b><U>done</U></b> ;
         f
       </r><U>end</U></b>
  65 
     <w>(* Compute missing length (for text) *)
     <b><U>and</U></b><r> check_length f =
       <b><U>for</U><r> i = 0 </r><U>to</U></b> Array.length f - 1 <b><U>do</U>
         <U>match</U></b> f.(i) <b><U>with</U><m>
  70     <r>| Align ({wrap=<b><U>true</U><r> ; width=Length.No _} </r><U>as</U></b> r) -&gt;
             f.(i) &lt;-
                Align
                  {r <b><U>with</U></b>
                   width =
  </r>75               <r>Length.Percent
                     (truncate (100.0 /. float (Array.length f)))}
         | _ -&gt; ()
       <b><U>done</U><m>
     
  80 </m><U>let</U></b> border = ref <b><U>false</U>
     
     
     
     <U>let</U></b> push s e = s := e:: !s
  </r>85 </m><U>and</U></b> pop s = <b><U>match</U><r> !s </r><U>with</U></b>
       [] -&gt; raise (Misc.Fatal "Empty stack in Latexscan")
     | e::rs -&gt; s := rs ; e
     
     <b><U>let</U><r> out_table = Table.create (Inside "")
  </r><m>90 
     </m><U>let</U></b> pretty_format = <b><U>function</U><r>
       |   Align {vert = v ; hor = h ; pre = pre ; post = post ; wrap = b ; width = w}
           -&gt;
             "[&gt;{"^pre^"}"^
  <m>95         </m>", h="^h^", v="^v^
             ", &lt;{"^post^"}"^(</r><U>if</U></b> b <b><U>then</U><r> ", wrap" </r><U>else</U></b> "")^
             ", w="^Length.pretty w^"]"
       | Inside s -&gt; "@{"^s^"}"
       | Border s -&gt; s
 <m>100 
     <b><U>let</U></b></m> pretty_formats f =
       Array.iter (<b><U>fun</U><r> f -&gt; prerr_string (pretty_format f) ; prerr_string "; ") f
     
     
 <m>105 </m>}
     
     rule tfone = parse
       '&gt;'
         {</r><U>let</U></b> pre = subst_arg lexbuf <b><U>in</U><m>
 110     <r>tfmiddle lexbuf ;
         <b><U>try</U><r>
           apply out_table (</r><U>function</U></b>
             |  Align a <b><U>as</U></b> r -&gt; a.pre &lt;- pre
             | _ -&gt; raise (Error "Bad syntax in array argument (&gt;)"))
 </r>115     </m><U>with</U></b> Table.Empty -&gt;
           raise (Error "Bad syntax in array argument (&gt;)")}
     | "" {tfmiddle lexbuf}
     
     <b><U>and</U><r> tfmiddle = parse
 <m>120 </m>| [' ''\t''\n''\r'] {tfmiddle lexbuf}
     | ['c''l''r']
       {</r><U>let</U></b> f = Lexing.lexeme_char lexbuf 0 <b><U>in</U>
       <U>let</U></b> post = tfpostlude lexbuf <b><U>in</U><r>
       emit out_table
 <m>125     </m>(Align {hor = make_hor f ; vert = make_vert f ; wrap = </r><U>false</U></b> ;
             pre = "" ;   post = post ; width = Length.Default})}
     | ['p''m''b']
       {<b><U>let</U><r> f = Lexing.lexeme_char lexbuf 0 </r><U>in</U>
       <U>let</U></b> width = subst_arg lexbuf <b><U>in</U><m>
 130   </m><U>let</U></b> my_width = Length.main (Lexing.from_string width) <b><U>in</U>
       <U>let</U></b> post = tfpostlude lexbuf <b><U>in</U><r>
       emit out_table
         (Align {hor = make_hor f ; vert = make_vert f ; wrap = </r><U>true</U></b> ;
               pre = "" ;   post = post ; width = my_width})}
 <m>135 <r>| '#' ['1'-'9']
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>let</U></b> i = Char.code (lxm.[1]) - Char.code '1' <b><U>in</U></b>
         Lexstate.scan_arg (scan_this_arg tfmiddle) i}
     | [^'|' '@' '&lt;' '&gt;' '!' '#']
 </r>140     <r>{<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>let</U></b> name = column_to_command lxm <b><U>in</U>
         <U>let</U></b> pat,body = Latexmacros.find name <b><U>in</U>
         <U>let</U></b> args = Lexstate.make_stack name pat lexbuf <b><U>in</U></b>
         Lexstate.scan_body
 </r>145       <r>(<b><U>function</U><r>
             | Lexstate.Subst body -&gt; scan_this lexformat body ;
             | _ -&gt; </r><U>assert</U> <U>false</U></b>)
           body args ;
         <b><U>let</U><r> post = tfpostlude lexbuf </r><U>in</U><m>
 150     </m><U>if</U></b> post &lt;&gt; "" <b><U>then</U>
           <U>try</U></b>
             Table.apply out_table
               (<b><U>function</U></b>
                 | Align f -&gt; f.post &lt;- post
 </r>155             <r>| _ -&gt; Misc.warning ("``&lt;'' after ``@'' in tabular arg scanning"))
           <b><U>with</U></b>
           | Table.Empty -&gt;
               raise (Error ("``&lt;'' cannot start tabular arg"))}
     | eof {()}
 </r>160 <r>| ""
       {<b><U>let</U><r> rest =
         String.sub lexbuf.lex_buffer lexbuf.lex_curr_pos
           (lexbuf.lex_buffer_len - lexbuf.lex_curr_pos) </r><U>in</U></b>
       raise (Error ("Syntax of array format near: "^rest))}
 </r>165 
     <b><U>and</U></b></m> tfpostlude = parse
       '&lt;' {subst_arg lexbuf}
     | ""  {""}
     
 <m>170 
     <b><U>and</U></b></m> lexformat = parse
      '*'
        {<b><U>let</U><r> ntimes = save_arg lexbuf </r><U>in</U>
        <U>let</U></b> what = save_arg lexbuf <b><U>in</U><m>
 175    </m><U>let</U> <U>rec</U></b> do_rec = <b><U>function</U><r>
          0 -&gt; lexformat lexbuf
        | i -&gt;
           scan_this_arg lexformat what ; do_rec (i-1) </r><U>in</U></b>
        do_rec (Get.get_int ntimes)}
 <m>180 </m>| '|' {border := <b><U>true</U><r> ; emit out_table (Border "|") ; lexformat lexbuf}
     | '@'|'!'
         {</r><U>let</U></b> lxm = Lexing.lexeme_char lexbuf 0 <b><U>in</U>
         <U>let</U></b> inside = subst_arg lexbuf <b><U>in</U>
         <U>if</U></b> lxm = '!' || inside &lt;&gt; "" <b><U>then</U><r> emit out_table (Inside inside) ;
 <m>185     </m>lexformat lexbuf}
     | '#' ['1'-'9']
         {</r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U>
         <U>let</U></b> i = Char.code (lxm.[1]) - Char.code '1' <b><U>in</U><r>
         Lexstate.scan_arg (scan_this_arg lexformat) i ;
 <m>190     </m>lexformat lexbuf}
     | eof {()}
     | "" {tfone lexbuf ; lexformat lexbuf}
     
     
 <m>195 
     </m>{
     </r><U>open</U></b> Parse_opts
     
     <b><U>let</U><r> main {arg=s ; subst=env} =
 <m>200   <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U><r> prerr_endline ("Table format: "^s);
       start_normal env ;
       lexformat (Lexing.from_string s) ;
       end_normal () ;
       <b><U>let</U></b> r = check_vert (trim out_table) </r><U>in</U></b>
 205   <b><U>begin</U> <U>match</U><r> !destination <b><U>with</U><r>
       | (Text | Info) -&gt; check_length r
       | Html -&gt; ()
       </r><U>end</U></b> ;
       <b><U>if</U></b> !verbose &gt; 1 </r><U>then</U> <U>begin</U></b>
 210     </m>prerr_string "Format parsed: " ;
         pretty_formats r ;
         prerr_endline ""
       </r><U>end</U></b> ;
       r
 <m>215 </m>}<PL><B>
<6>12 verb.mll</6>
</B></PL></r> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: verb.mll,v 1.55 2001/06/05 13:18:41 maranget Exp $            *)
     (***********************************************************************)
     <r>{
     <b><U>exception</U><r> VError </r><U>of</U></b> string
     
  <m>15 <b><U>module</U> <U>type</U></b></m> S = <b><U>sig</U>  <U>end</U></b>
     ;;
     <b><U>module</U><r> Make
       (Dest : OutManager.S) (Image : ImageManager.S)
       (Scan : Latexscan.S) : S =
  </r><m>20 </m><U>struct</U>
     <U>open</U></b> Misc
     <b><U>open</U><r> Lexing
     </r><U>open</U></b> Save
     <b><U>open</U><r> Lexstate
  </r><m>25 </m><U>open</U></b> Latexmacros
     <b><U>open</U><r> Stack
     </r><U>open</U></b> Scan
     <b><U>open</U><r> Subst
     
  </r><m>30 </m><U>exception</U></b> Eof <b><U>of</U></b> string
     ;;
     
     </r>(* For file verbatim scanning *)
     <b><U>let</U><r> input_verb = ref </r><U>false</U><m>
  35 <r>;;
     
     <w>(* For scanning by line *)
     <b><U>let</U></b></w> verb_delim = ref (Char.chr 0)
     <b><U>and</U></b> line_buff = Out.create_buff ()
  </r>40 </m><U>and</U><r> process = ref (<b><U>fun</U><r> () -&gt; ())
     </r><U>and</U></b> finish = ref (<b><U>fun</U><r> () -&gt; ())
     ;;
     
     </r><U>let</U></b> env_extract s =
  <m>45   <b><U>let</U></b></m> i = String.index s '{'
       <b><U>and</U><r> j = String.rindex s '}' </r><U>in</U></b>
       String.sub s (i+1) (j-i-1)
     
     <b><U>and</U><r> newlines_extract s =
  </r><m>50   </m><U>let</U> <U>rec</U></b> do_rec i =
         <b><U>if</U><r> i &lt; String.length s </r><U>then</U> <U>begin</U>
           <U>if</U></b> s.[i] = '\n' <b><U>then</U><r>
             1+do_rec (i+1)
           </r><U>else</U><m>
  55         <r>0
         <b><U>end</U> <U>else</U></b>
           0 <b><U>in</U></b>
       do_rec 0
     
  </r>60 <w>(* For scanning the ``listings'' way *)
     
     <b><U>let</U><r> lst_process_error _ lxm =
        warning ("listings, unknown character: ``"^Char.escaped lxm^"''")
     
  </r><m>65 </m><U>let</U><r> lst_char_table = Array.create 256 lst_process_error
     ;;
     
     <b><U>let</U><r> lst_init_char c f =
       lst_char_table.(Char.code c) &lt;- f
  </r><m>70 
     </m><U>let</U></b> lst_init_chars s f =
       <b><U>let</U><r> last = String.length s - 1 </r><U>in</U>
       <U>for</U></b> i = 0 <b><U>to</U><r> last </r><U>do</U></b>
         lst_char_table.(Char.code s.[i]) &lt;- f
  <m>75   <b><U>done</U>
     
     <U>let</U></b></m> lst_init_save_char c f =
       <b><U>let</U><r> old = lst_char_table.(Char.code c) </r><U>in</U></b>
       lst_char_table.(Char.code c) &lt;- f old
  <m>80 
     <b><U>let</U></b></m> lst_init_save_chars s f =
       <b><U>let</U><r> last = String.length s - 1 </r><U>in</U>
       <U>for</U></b> i = 0 <b><U>to</U><r> last </r><U>do</U></b>
         lst_init_save_char s.[i] f
  <m>85   <b><U>done</U><w>
     
     (* Output functions *)
     </w><U>let</U></b></m> lst_gobble  = ref 0
     <b><U>and</U><r> lst_nlines  = ref 0
  </r><m>90 </m><U>and</U></b> lst_first   = ref 1
     <b><U>and</U><r> lst_last    = ref 9999
     </r><U>and</U></b> lst_print   = ref <b><U>true</U>
     <U>and</U></b> lst_string_spaces = ref <b><U>true</U>
     <U>and</U></b> lst_texcl   = ref <b><U>false</U><m>
  95 </m><U>and</U></b> lst_extended = ref <b><U>false</U>
     <U>and</U></b> lst_sensitive = ref <b><U>true</U>
     <U>and</U></b> lst_mathescape = ref <b><U>false</U>
     <U>and</U></b> lst_directives = ref <b><U>false</U>
     <U>and</U></b> lst_showlines = ref <b><U>false</U><m>
 100 
     </m><U>let</U></b> lst_effective_spaces = ref <b><U>false</U><w> (* false =&gt; spaces are spaces *)
     </w><U>and</U></b> lst_save_spaces  = ref <b><U>false</U>
     
     <U>let</U></b> lst_buff = Out.create_buff ()
 <m>105 
     <b><U>let</U></b></m> lst_last_char = ref ' '
     <b><U>and</U><r> lst_finish_comment = ref 0
     
     </r><U>let</U></b> lst_put c =
 <m>110   </m>lst_last_char := c ;
       Out.put_char lst_buff c
     
     <b><U>and</U><r> lst_direct_put c =
       lst_last_char := c ;
 <m>115   </m>Dest.put_char c
     
     </r><U>type</U></b> lst_scan_mode =
       | Letter | Other | Empty | Start
       | Directive <b><U>of</U></b> bool </r></b>(* bool flags some letter read *)
 </w>120 
     </m><U>let</U></b> lst_scan_mode = ref Empty
     
     <b><U>type</U><r> comment_type =
       | Nested </r><U>of</U></b> int
 <m>125   <r>| Balanced <b><U>of</U><r> (char -&gt; string -&gt; bool)
       | Line
     
     </r><U>type</U></b> lst_top_mode =
       | Skip
 </r>130   <r>| String <b><U>of</U><r> (char * (char * (Lexing.lexbuf -&gt; char -&gt; unit)) list)
       | Normal | Comment </r><U>of</U></b> comment_type
       | Delim <b><U>of</U><r> int * (char * (Lexing.lexbuf -&gt; char -&gt; unit)) list
       | Gobble </r><U>of</U></b> lst_top_mode * int
       | Escape <b><U>of</U><r> lst_top_mode * char * bool </r><w>(* bool flags mathescape *)
 <m>135 
     <b><U>let</U><r> string_of_top_mode = </r><U>function</U><r>
       | Delim (i,_) -&gt; "Delim: "^string_of_int i
       | Skip -&gt; "Skip"
       | Comment (Balanced _) -&gt; "Balanced"
 </r></b>140   <r>| Comment (Nested n)   -&gt; "(Nested "^string_of_int n^")"
       | _ -&gt; "?"
     
     <b><U>let</U></b> lst_top_mode = ref Skip
     
 </r>145 
     <b><U>let</U><r> lst_ptok s =  prerr_endline (s^": "^Out.to_string lst_buff)
     
     </r><w>(* Final ouput, with transformations *)
     </w><U>let</U><r> dest_string s =
 </r></b>150   <b><U>for</U><r> i = 0 </r><U>to</U><r> String.length s - 1 <b><U>do</U><r>
         Dest.put (Dest.iso s.[i])
       </r><U>done</U><w>
     
     (* Echo, with case change *)
 <m>155 <b><U>let</U><r> dest_case s =
       Dest.put
         (</r><U>match</U><r> !case <b><U>with</U></b>
         | Upper -&gt; String.uppercase s
         | Lower -&gt; String.lowercase s
 </r></b>160     <r>| _     -&gt; s)
     
     <w>(* Keywords *)
     
     <b><U>let</U></b></w> def_print s =
 </r>165   <r>Latexmacros.def "\\@tmp@lst" zero_pat
         (CamlCode (<b><U>fun</U><r> _ -&gt;  dest_case s)) ;
       Latexmacros.def "\\@tmp@lst@print" zero_pat
         (CamlCode (</r><U>fun</U></b> _ -&gt;  dest_string s))
     ;;
 </r>170 
     <b><U>let</U><r> lst_output_other () =
       </r><U>if</U><r> not (Out.is_empty lst_buff) <b><U>then</U> <U>begin</U>
         <U>let</U></b> arg = Out.to_string lst_buff <b><U>in</U>
         <U>match</U></b> !lst_top_mode <b><U>with</U><m>
 175     <r>| Normal -&gt;
             def_print arg ;
             scan_this Scan.main
               ("\\lst@output@other{\\@tmp@lst}{\\@tmp@lst@print}")
         | _ -&gt;
 </r>180         <r>scan_this main "\\@NewLine" ;
             dest_string arg
       <b><U>end</U>
     
     <U>and</U></b> lst_output_letter () =
 </r>185   </m><U>if</U></b> not (Out.is_empty lst_buff) <b><U>then</U> <U>begin</U>
         <U>match</U></b> !lst_top_mode <b><U>with</U><r>
         | Normal -&gt;
             </r><U>let</U></b> arg = Out.to_string lst_buff <b><U>in</U></b>
             def_print arg ;
 </r></b>190         <r>scan_this Scan.main ("\\lst@output{\\@tmp@lst}{\\@tmp@lst@print}")
         | _ -&gt;
             scan_this main "\\@NewLine" ;
             dest_string (Out.to_string lst_buff)
       <b><U>end</U><m>
 195 
     </m><U>and</U></b> lst_output_directive () =
       <b><U>if</U><r> not (Out.is_empty lst_buff) </r><U>then</U> <U>begin</U>
         <U>match</U></b> !lst_top_mode <b><U>with</U></b>
         | Normal -&gt;
 </r>200         <r><b><U>let</U><r> arg = Out.to_string lst_buff </r><U>in</U></b>
             def_print arg ;
             scan_this Scan.main ("\\lst@output@directive{\\@tmp@lst}{\\@tmp@lst@print}")
         | _ -&gt;
             scan_this main "\\@NewLine" ;
 </r>205         <r>dest_string (Out.to_string lst_buff)
       <b><U>end</U>
     
     <U>let</U></b> lst_output_token () =
       <b><U>match</U><r> !lst_scan_mode </r><U>with</U><m>
 210   <r>| Letter -&gt; lst_output_letter ()
       | Other  -&gt; lst_output_other ()
       | Directive _ -&gt; lst_output_directive ()
       | Empty|Start  -&gt; scan_this main "\\@NewLine"
     
 </r>215 
     </m><U>let</U></b> lst_finalize inline =
      scan_this main "\\lst@forget@lastline" ;
      <b><U>if</U><r> inline || !lst_showlines </r><U>then</U></b>
        lst_output_token ()
 </r>220 
     
     
     </m>(* Process functions *)
     </w><U>let</U></b> lst_do_gobble mode n =
 </r></b>225   <b><U>if</U><r> n &gt; 1 </r><U>then</U><r>
         lst_top_mode := Gobble (mode,n-1)
       <b><U>else</U></b>
         lst_top_mode := mode
     
 </r></b>230 <b><U>let</U><r> lst_do_escape mode endchar math lb lxm =
       </r><U>if</U><r> lxm = endchar <b><U>then</U> <U>begin</U></b>
         scan_this main "\\begingroup\\lst@escapebegin" ;
         <b><U>if</U><r> math </r><U>then</U></b> scan_this main "$" ;
         scan_this main (Out.to_string lst_buff) ;
 </r></b>235     <r><b><U>if</U><r> math </r><U>then</U></b> scan_this main "$" ;
         scan_this main "\\lst@escapeend\\endgroup" ;
         lst_top_mode := mode
       <b><U>end</U> <U>else</U></b>
         Out.put_char lst_buff lxm
 </r>240 
     
     
     <b><U>let</U> <U>rec</U><r> lst_process_newline lb c =
     <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U><m>
 245   <r>Printf.fprintf stderr "lst_process_newline\n" ;
     <b><U>match</U><r> !lst_top_mode </r><U>with</U></b>
     | Skip -&gt;
         <b><U>if</U><r> !lst_nlines = !lst_first - 1 </r><U>then</U> <U>begin</U></b>
           lst_top_mode := Normal ;
 </r>250       <r>scan_this Scan.main "\\let\\old@br\\@br\\def\\@br{
     } " ;
           lst_process_newline lb c ;
           scan_this Scan.main "\\let\\@br\\old@br"
         <b><U>end</U> <U>else</U><m>
 255       <r>incr lst_nlines
     | Gobble (mode,_) -&gt;
         lst_top_mode := mode ;
         lst_process_newline lb c
     | Escape (mode,cc,math) -&gt;
 </r>260     <r>lst_do_escape (Comment Line) cc math lb c ;
         <b><U>if</U><r> !lst_top_mode = Comment Line </r><U>then</U></b>
           lst_process_newline lb c
     | Comment Line -&gt;
         lst_output_token () ;
 </r>265     <r>scan_this Scan.main "\\endgroup" ;
         lst_top_mode := Normal ;
         lst_process_newline lb c
     | mode  -&gt;
         scan_this Scan.main "\\lsthk@InitVarEOL\\lsthk@EOL" ;
 </r>270     </m><U>begin</U> <U>match</U></b> !lst_scan_mode <b><U>with</U></b>
         | Empty -&gt; lst_scan_mode := Start
         | Start -&gt; ()
         | _ -&gt;
             lst_output_token () ;
 </r>275         <r>lst_scan_mode := Start
         <b><U>end</U><r> ;
         incr lst_nlines ;
         </r><U>if</U></b> !lst_nlines &lt;= !lst_last <b><U>then</U> <U>begin</U></b>
           scan_this Scan.main
 </r>280         <r>"\\lsthk@InitVarBOL\\lsthk@EveryLine" ;
           <b><U>if</U><r> !lst_gobble &gt; 0 </r><U>then</U></b>
             lst_top_mode := Gobble (mode,!lst_gobble)
         <b><U>end</U> <U>else</U></b>
           lst_top_mode := Skip
 </r>285 
     </m><U>let</U></b> lst_process_letter lb lxm =
     <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b>  Printf.fprintf stderr "lst_process_letter: %c\n" lxm ;
     <b><U>match</U><r> !lst_top_mode </r><U>with</U></b>
     | Skip -&gt; ()
 </r></b>290 <r>| Gobble (mode,n) -&gt; lst_do_gobble mode n
     | Escape (mode,c,math) -&gt; lst_do_escape mode c math lb lxm
     | _ -&gt; <b><U>match</U><r> !lst_scan_mode </r><U>with</U></b>
       | Letter -&gt; lst_put lxm
       | Directive <b><U>true</U></b> -&gt;
 </r>295       <r>lst_put lxm
       | Directive <b><U>false</U><r> -&gt;
           lst_scan_mode := Directive </r><U>true</U></b> ;
           lst_put lxm
       | Empty|Start -&gt;
 </r>300       <r>lst_scan_mode := Letter ;
           lst_put lxm
       | Other  -&gt;
           lst_output_other () ;
           lst_scan_mode := Letter ;
 </r>305       <r>lst_put lxm
     
     <b><U>let</U><r> lst_process_digit lb lxm =
     </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U></b>
      Printf.fprintf stderr "lst_process_digit: %c\n" lxm ;
 </r>310 <b><U>match</U><r> !lst_top_mode </r><U>with</U><r>
     | Skip -&gt; ()
     | Gobble (mode,n) -&gt; lst_do_gobble mode n
     | Escape (mode,c,math) -&gt; lst_do_escape mode c math lb lxm
     | _ -&gt;  <b><U>match</U><r> !lst_scan_mode </r><U>with</U><m>
 315   <r>| Letter|Other -&gt; lst_put lxm
       | Directive _ -&gt;
           lst_output_directive () ;
           lst_scan_mode := Other ;
           lst_put lxm
 </r>320   <r>| Empty|Start  -&gt;
           lst_scan_mode := Other ;
           lst_put lxm
     
     <b><U>let</U></b> lst_process_other lb lxm =
 </r>325 </m><U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
       Printf.fprintf stderr "process_other: %c\n" lxm ;
     </r><U>match</U></b> !lst_top_mode <b><U>with</U></b>
     | Skip -&gt; ()
     | Gobble (mode,n) -&gt; lst_do_gobble mode n
 </r></b>330 <r>| Escape (mode,c,math) -&gt; lst_do_escape mode c math lb lxm
     |  _ -&gt; <b><U>match</U><r> !lst_scan_mode </r><U>with</U></b>
         | Other -&gt; lst_put lxm
         | Empty|Start -&gt;
             lst_scan_mode := Other ;
 </r>335         <r>lst_put lxm
         | Directive _ -&gt;
             lst_output_directive () ;
             lst_scan_mode := Other ;
             lst_put lxm
 </r>340     <r>| Letter -&gt;
             lst_output_letter () ;
             lst_scan_mode := Other ;
             lst_put lxm
     
 </r>345 </m>(*  Caml code for \stepcounter{lst@space}  *)
     </w><U>let</U></b> lst_output_space () = Counter.step_counter "lst@spaces"
     
     <b><U>let</U><r> lst_process_space lb lxm =
     </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U><m>
 350  <r>Printf.fprintf stderr "process_space: ``%c''\n" lxm ;
     <b><U>match</U><r> !lst_top_mode </r><U>with</U></b>
     | Skip -&gt; ()
     | Gobble (mode,n) -&gt; lst_do_gobble mode n
     | Escape (mode,c,math) -&gt; lst_do_escape mode c math lb lxm
 </r>355 <r>| _ -&gt;
         <b><U>begin</U> <U>match</U></b> !lst_scan_mode <b><U>with</U></b>
         | Other -&gt;
             lst_output_other ()  ;
             lst_scan_mode := Empty
 </r>360     <r>| Letter|Directive <b><U>true</U><r> -&gt;
             lst_output_token () ;
             lst_scan_mode := Empty
         | Empty|Directive </r><U>false</U></b> -&gt; ()
         | Start -&gt;
 </r>365         <r>lst_scan_mode := Empty
         <b><U>end</U><r> ;
         lst_output_space ()
     
     </r><U>let</U></b> lst_process_start_directive  old_process lb lxm =
 </r>370   </m><U>match</U></b> !lst_top_mode <b><U>with</U><r>
       | Normal -&gt; </r><U>begin</U> <U>match</U></b> !lst_scan_mode <b><U>with</U><r>
         | Start -&gt;
             lst_scan_mode := Directive </r><U>false</U></b>
         | _ -&gt; old_process lb lxm
 </r>375   <b><U>end</U></b></m>
       | _ -&gt;  old_process lb lxm
     
     
     
 <m>380 <b><U>exception</U></b></m> EndVerb
     
     <b><U>let</U><r> lst_process_end  endstring old_process lb lxm =
     </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
      Printf.fprintf stderr "process_end: ``%c''\n" lxm ;
 </r><m>385   </m><U>if</U></b>
         (not !input_verb || Stack.empty stack_lexbuf)
           &amp;&amp; if_next_string endstring lb <b><U>then</U> <U>begin</U></b>
         Save.skip_delim endstring lb ;
         raise EndVerb
 <m>390   <b><U>end</U> <U>else</U></b></m>
         old_process lb lxm
     
     <b><U>let</U><r> lst_init_char_table inline =
       lst_init_chars
 </r><m>395     <r>"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@_$"
         lst_process_letter ;
       lst_init_chars "!\"#%&amp;'()*+,-./:;&lt;=&gt;?[\\]^{}|`~" lst_process_other ;
       lst_init_chars "0123456789" lst_process_digit ;
       lst_init_chars " \t" lst_process_space ;
 </r>400   </m><U>if</U></b> inline <b><U>then</U><r>
         lst_init_char '\n' lst_process_space
       </r><U>else</U></b>
         lst_init_char '\n' lst_process_newline
     ;;
 <m>405 
     <w>(* TeX escapes *)
     <b><U>let</U><r> start_escape mode endchar math =
       lst_output_token () ;
       lst_top_mode := Escape (mode, endchar, math)
 </r><m>410 
     </m><U>let</U><r> lst_process_escape math ec old_process lb lxm =
     <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b>
      Printf.fprintf stderr "lst_process_escape: %c\n" lxm ;
     <b><U>match</U><r> !lst_top_mode </r><U>with</U><m>
 415 <r>| Skip -&gt; ()
     | Gobble (mode,n) -&gt; lst_do_gobble mode n
     | Escape _        -&gt; old_process lb lxm
     | mode            -&gt; start_escape mode ec math
     
 </r>420 
     <w>(* Strings *)
     <b><U>let</U> <U>rec</U><r> restore_char_table to_restore =
       <b><U>let</U> <U>rec</U></b> do_rec = <b><U>function</U><r>
         | [] -&gt; ()
 <m>425     </m>| (c,f)::rest -&gt;
             lst_init_char c f ;
             do_rec rest </r><U>in</U></b>
       do_rec to_restore
     
 <m>430 <b><U>let</U></b></m> lst_bs_string old_process lb lxm =
       old_process lb lxm ;
       <b><U>let</U><r> saved = Array.copy lst_char_table </r><U>in</U>
       <U>let</U></b> process_quoted _ lxm =
         lst_put lxm ;
 <m>435     <r>Array.blit saved 0 lst_char_table 0 (Array.length saved) <b><U>in</U><r>
       Array.fill lst_char_table 0 (Array.length lst_char_table) process_quoted
     
     
     </r><U>let</U></b> lst_init_quote s =
 </r>440   <b><U>let</U></b></m> r = ref [] <b><U>in</U>
       <U>for</U></b> i = 0 <b><U>to</U><r> String.length s-1 </r><U>do</U>
         <U>if</U></b> s.[i] = 'b' <b><U>then</U> <U>begin</U></b>
           r := ('\\',lst_char_table.(Char.code '\\')) :: !r ;
           lst_init_save_char '\\' lst_bs_string
 <m>445     <b><U>end</U>
       <U>done</U><r> ;
       !r
     
     <b><U>let</U><r> lst_process_stringizer quote old_process lb lxm = </r><U>match</U></b> !lst_top_mode </r><U>with</U></b>
 450   </m>| Normal -&gt;
           lst_output_token () ;
           <b><U>let</U><r> to_restore = lst_init_quote quote </r><U>in</U></b>
           lst_top_mode := String (lxm, to_restore) ;
           lst_save_spaces := !lst_effective_spaces ;
 <m>455       </m>lst_effective_spaces := !lst_string_spaces ;
           scan_this Scan.main "\\begingroup\\lst@string@style" ;
           old_process lb lxm
       | String (c,to_restore) <b><U>when</U></b> lxm = c -&gt;
           old_process lb lxm ;
 <m>460       </m>lst_output_token () ;
           scan_this Scan.main "\\endgroup" ;
           restore_char_table to_restore ;
           lst_effective_spaces := !lst_save_spaces ;
           lst_top_mode := Normal
 <m>465   </m>| _ -&gt; old_process lb lxm
     
     
     
     </r></b>(* Comment *)
 </w>470 
     </m><U>let</U></b> chars_string c s =
       <b><U>let</U> <U>rec</U></b> do_rec r i =
         <b><U>if</U><r> i &lt; String.length s </r><U>then</U>
           <U>if</U></b> List.mem s.[i] r <b><U>then</U><m>
 475         <r>do_rec r (i+1)
           <b><U>else</U><r>
             do_rec (s.[i]::r) (i+1)
         </r><U>else</U></b>
           r <b><U>in</U><m>
 480   <r>do_rec [c] 0
     
     <b><U>let</U><r> init_char_table_delim chars wrapper =
       List.map
         (</r><U>fun</U></b> c -&gt;
 </r>485       </m><U>let</U></b> old_process = lst_char_table.(Char.code c) <b><U>in</U></b>
           lst_init_save_char c wrapper ;
           (c,old_process))
       chars
     
 </r>490 
     </m><U>let</U></b> eat_delim k new_mode old_process lb c s =
       <b><U>let</U><r> chars = chars_string c s </r><U>in</U>
       <U>let</U></b> wrapper old_process lb c = <b><U>match</U><r> !lst_top_mode </r><U>with</U></b>
       | Delim (n,to_restore) -&gt;
 <m>495       <r>old_process lb c ;
           <b><U>if</U><r> n = 1 </r><U>then</U> <U>begin</U></b>
             lst_output_token () ;
             lst_top_mode := new_mode ;
             restore_char_table to_restore ;
 </r>500         <r>k ()
           <b><U>end</U> <U>else</U></b>
             lst_top_mode := Delim (n-1,to_restore)
       | _ -&gt; <b><U>assert</U> <U>false</U> <U>in</U>
       <U>let</U></b> to_restore = init_char_table_delim chars wrapper <b><U>in</U><m>
 505   <r>lst_top_mode := Delim (1+String.length s, to_restore) ;
       wrapper old_process lb c
     
     <b><U>let</U></b> begin_comment () =
       lst_output_token () ;
 </r>510   <r>scan_this Scan.main "\\begingroup\\lst@comment@style"
     
     <b><U>let</U><r> lst_process_BNC _ s old_process lb c =  </r><U>match</U></b> !lst_top_mode <b><U>with</U><r>
     | Normal </r><U>when</U></b> if_next_string s lb -&gt;
         begin_comment () ;
 </r>515     <r>eat_delim (<b><U>fun</U><r> () -&gt; ()) (Comment (Nested 0)) old_process lb c s
     | Comment (Nested n) </r><U>when</U></b> if_next_string s lb -&gt;
         eat_delim (<b><U>fun</U></b> () -&gt; ()) (Comment (Nested (n+1))) old_process lb c s
     | _ -&gt; old_process lb c
     
 </r>520 </m><U>and</U></b> lst_process_ENC s old_process lb c = <b><U>match</U><r> !lst_top_mode </r><U>with</U></b>
     | Comment (Nested 0) <b><U>when</U><r> if_next_string s lb -&gt;
         eat_delim
           (</r><U>fun</U></b> () -&gt; scan_this Scan.main "\\endgroup")
           Normal
 </r>525       <r>old_process
           lb c s
     |  Comment (Nested n) <b><U>when</U><r> if_next_string s lb -&gt;
         eat_delim
           (</r><U>fun</U></b> () -&gt; ())
 </r>530       <r>(Comment (Nested (n-1)))
           old_process lb c s
     | _ -&gt; old_process lb c
     
     <b><U>let</U><r> lst_process_BBC check s old_process lb c =  </r><U>match</U></b> !lst_top_mode <b><U>with</U><m>
 535 <r>| Normal <b><U>when</U><r> if_next_string s lb -&gt;
         begin_comment () ;
         eat_delim
           (</r><U>fun</U></b> () -&gt; ())
           (Comment (Balanced check))
 </r>540       <r>old_process lb c s
     | _ -&gt; old_process lb c
     
     <b><U>and</U><r> lst_process_EBC s old_process lb c = </r><U>match</U></b> !lst_top_mode <b><U>with</U><r>
     | Comment (Balanced check) </r><U>when</U><m>
 545   <r>check c s &amp;&amp; if_next_string  s lb -&gt;
          eat_delim
           (<b><U>fun</U></b> () -&gt; scan_this Scan.main "\\endgroup")
           Normal
           old_process
 </r>550       <r>lb c s
     | _ -&gt; old_process lb c
     
     <b><U>let</U><r> lst_process_LC s old_process lb c = </r><U>match</U></b> !lst_top_mode <b><U>with</U><r>
     | Normal </r><U>when</U></b> if_next_string s lb -&gt;
 </r>555     <r>begin_comment () ;
         eat_delim
           (<b><U>fun</U><r> () -&gt; ())
           (</r><U>if</U></b> !lst_texcl <b><U>then</U><r> Escape (Normal,'\n', </r><U>false</U></b>) <b><U>else</U></b> Comment Line)
           old_process lb c s
 </r>560 <r>| _ -&gt; old_process lb c
     
     }
     
     
 </r>565 <r>rule inverb = parse
     |  _
         {(<b><U>fun</U><r> put -&gt; </r><U>let</U></b> c = lexeme_char lexbuf 0 <b><U>in</U>
         <U>if</U></b> c = !verb_delim <b><U>then</U> <U>begin</U></b>
           Dest.close_group () ;
 </r>570     </m><U>end</U> <U>else</U> <U>begin</U></b>
           put c ;
           inverb lexbuf put
         <b><U>end</U></b>)}
     | eof
 </r>575     <r>{(<b><U>fun</U><r> put -&gt; </r><U>if</U></b> not (empty stack_lexbuf) <b><U>then</U>
           <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U><r>
           inverb lexbuf put
         </r><U>else</U></b>
           raise (VError ("End of file after \\verb")))}
 </r>580 
     </m><U>and</U></b> start_inverb = parse
     | _
         {(<b><U>fun</U><r> put -&gt; </r><U>let</U></b> c = lexeme_char lexbuf 0 <b><U>in</U></b>
         verb_delim := c ;
 </r>585     <r>inverb lexbuf put)}
     | eof
         {(<b><U>fun</U><r> put -&gt;
           </r><U>if</U></b> not (empty stack_lexbuf) <b><U>then</U>
             <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U><m>
 590         <r>start_inverb lexbuf put
           <b><U>else</U><r>
             raise (VError ("End of file after \\verb")))}
     
     </r><U>and</U></b> scan_byline = parse
 </r>595     <r>"\\end" [' ''\t']* '{' [^'}']+ '}'
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>let</U></b> env = env_extract lxm <b><U>in</U>
         <U>if</U></b>
           (not !input_verb || Stack.empty stack_lexbuf)
 </r>600         <r>&amp;&amp; env = !Scan.cur_env <b><U>then</U> <U>begin</U></b>
           !finish () ;
           scan_this Scan.main ("\\end"^env) ;
           Scan.top_close_block "" ;
           Scan.close_env !Scan.cur_env ;
 </r>605       <r>Scan.check_alltt_skip lexbuf
         <b><U>end</U> <U>else</U> <U>begin</U></b>
           Out.put line_buff lxm ;
           scan_byline lexbuf
         <b><U>end</U></b>}
 </r>610 <r>| '\n'
         {!process () ; scan_byline lexbuf}
     | _
         {<b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U></b>
         Out.put_char line_buff lxm ;
 </r>615     <r>scan_byline lexbuf}
     | eof
         {<b><U>if</U><r> not (Stack.empty stack_lexbuf) </r><U>then</U> <U>begin</U>
           <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U></b>
           scan_byline lexbuf
 </r>620     </m><U>end</U> <U>else</U> <U>begin</U></b>
           !finish () ;
           raise
             (Eof "scan_byline")
         <b><U>end</U></b>}
 </r>625 
     <b><U>and</U></b></m> listings = parse
     |  eof
         {<b><U>if</U><r> not (Stack.empty stack_lexbuf) </r><U>then</U> <U>begin</U>
           <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U><m>
 630       <r>listings lexbuf
         <b><U>end</U> <U>else</U> <U>begin</U></b>
           raise
             (Eof "listings")
         <b><U>end</U></b>}
 </r>635 <r>| _
         {<b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U></b>
         lst_char_table.(Char.code lxm) lexbuf lxm ;
         listings lexbuf}
     
 </r>640 </m><U>and</U></b> eat_line = parse
     | eof
         {<b><U>if</U><r> not (Stack.empty stack_lexbuf) </r><U>then</U> <U>begin</U>
           <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U><r>
           eat_line lexbuf
 </r><m>645     </m><U>end</U> <U>else</U> <U>begin</U></b>
           raise
             (Eof "eat_line")
         <b><U>end</U><r>}
     | [^'\n']  {eat_line lexbuf}
 <m>650 </m>| '\n'     {lst_process_newline lexbuf '\n'}
     
     </r><U>and</U></b> get_line = parse
     |  eof
         {<b><U>if</U><r> not (Stack.empty stack_lexbuf) </r><U>then</U> <U>begin</U><m>
 655       </m><U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U><r>
           get_line lexbuf
         </r><U>end</U> <U>else</U> <U>begin</U></b>
           raise
             (Eof "get_line")
 <m>660     <b><U>end</U></b></m>}
     | [^'\n']
         {<b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U></b>
         Out.put_char line_buff lxm ;
         get_line lexbuf}
 <m>665 <r>| '\n'     {Out.to_string line_buff}
     
     <b><U>and</U></b> do_escape = parse
     | eof {}
     | "\\esc"
 </r>670     <r>{<b><U>let</U><r> arg = save_arg lexbuf </r><U>in</U></b>
         scan_this main "\\mbox{" ;
         scan_this_arg Scan.main arg ;
         scan_this main "}" ;
         do_escape lexbuf}
 </r>675 <r>| _
         {<b><U>let</U><r> lxm = Lexing.lexeme_char lexbuf 0 </r><U>in</U></b>
         Dest.put (Dest.iso lxm) ;
         do_escape lexbuf}
     {
 </r>680 <b><U>let</U></b></m> _ = ()
     ;;
     <b><U>let</U><r> put_char_star = </r><U>function</U></b>
       | ' '|'\t' -&gt; Dest.put_char '_' ;
       | c -&gt;  Dest.put (Dest.iso c)
 <m>685 
     <b><U>and</U></b></m> put_char = <b><U>function</U><r>
       |  '\t' -&gt; Dest.put_char ' '
       | c -&gt; Dest.put (Dest.iso c)
     ;;
 </r><m>690 
     
     </m><U>let</U></b> open_verb put lexbuf =
       Dest.open_group "CODE" ;
       start_inverb lexbuf put
 <m>695 <r>;;
     
     def_code "\\verb" (open_verb (<b><U>fun</U></b> c -&gt; Dest.put (Dest.iso c)));
     def_code "\\verb*" (open_verb put_char_star);
     ();;
 </r>700 
     <b><U>let</U></b></m> put_line_buff_verb () =
       Out.iter put_char line_buff ;
       Out.reset line_buff
     
 <m>705 <b><U>and</U></b></m> put_line_buff_verb_star () =
       Out.iter put_char_star line_buff ;
       Out.reset line_buff
     ;;
     
 <m>710 <b><U>let</U></b></m> noeof lexer lexbuf =
       <b><U>try</U><r> lexer lexbuf
       </r><U>with</U></b>
       | Eof s -&gt;
         raise
 <m>715         <r>(Misc.Close
                ("End of file in environment: ``"^ !Scan.cur_env^"'' ("^s^")"))
       | EndVerb -&gt; ()
     
     <b><U>let</U></b> open_verbenv star =
 </r>720   <r>Scan.top_open_block "PRE" "" ;
       process :=
          <b><U>if</U><r> star </r><U>then</U></b>
            (<b><U>fun</U><r> () -&gt; put_line_buff_verb_star () ; Dest.put_char '\n')
          </r><U>else</U><m>
 725        <r>(<b><U>fun</U><r> () -&gt; put_line_buff_verb () ; Dest.put_char '\n') ;
       finish :=
          </r><U>if</U></b> star <b><U>then</U><r>
            put_line_buff_verb_star
          </r><U>else</U><m>
 730        <r>put_line_buff_verb
     
     <b><U>and</U><r> close_verbenv _ = Scan.top_close_block "PRE"
     
     </r><U>let</U></b> put_html () =
 </r>735   <r>Out.iter (<b><U>fun</U><r> c -&gt; Dest.put_char c) line_buff ;
       Out.reset line_buff
     ;;
     
     </r><U>let</U></b> open_rawhtml lexbuf =
 </r>740   </m><U>begin</U> <U>match</U></b> !Parse_opts.destination <b><U>with</U><r>
         | Parse_opts.Html -&gt; ()
         | _ -&gt;  Misc.warning "rawhtml detected"
       </r><U>end</U></b> ;
       process :=
 </r>745      <r>(<b><U>fun</U><r> () -&gt; put_html () ; Dest.put_char '\n') ;
       finish := put_html ;
       noeof scan_byline lexbuf
     
     </r><U>and</U></b> close_rawhtml _ = ()
 </r>750 
     </m><U>let</U></b> open_forget lexbuf =
       process := (<b><U>fun</U><r> () -&gt; Out.reset line_buff) ;
       finish := (</r><U>fun</U></b> () -&gt; Out.reset line_buff) ;
       noeof scan_byline lexbuf
 </r>755 
     <b><U>and</U></b></m> close_forget _ = ()
     
     <b><U>let</U><r> open_tofile chan lexbuf =
       process :=
 <m>760      </m>(</r><U>fun</U></b> () -&gt;
            output_string chan (Out.to_string line_buff) ;
            output_char chan '\n') ;
       finish :=
          (<b><U>fun</U><r> () -&gt;
 <m>765        </m>output_string chan (Out.to_string line_buff) ;
            close_out chan) ;
       noeof scan_byline lexbuf
     
     </r><U>and</U></b> close_tofile lexbuf = ()
 <m>770 
     
     <b><U>let</U></b></m> put_line_buff_image () =
       Out.iter (<b><U>fun</U><r> c -&gt; Image.put_char c) line_buff ;
       Out.reset line_buff
 </r><m>775 
     </m><U>let</U></b> open_verbimage lexbuf =
       process := (<b><U>fun</U><r> () -&gt; put_line_buff_image () ; Image.put_char '\n') ;
       finish := put_line_buff_image ;
       noeof scan_byline lexbuf
 </r><m>780 
     </m><U>and</U></b> close_verbimage _ = ()
     ;;
     
     
 <m>785 </m>def_code "\\verbatim"
         (<b><U>fun</U><r> lexbuf -&gt;
           open_verbenv </r><U>false</U></b> ;
           noeof scan_byline lexbuf) ;
     def_code "\\endverbatim" close_verbenv ;
 <m>790 
     
     </m>def_code "\\verbatim*"
         (<b><U>fun</U><r> lexbuf -&gt;
           open_verbenv </r><U>true</U></b> ;
 <m>795       </m>noeof scan_byline lexbuf) ;
     def_code "\\endverbatim*" close_verbenv ;
     
     def_code "\\rawhtml" open_rawhtml ;
     def_code "\\endrawhtml" close_forget ;
 <m>800 </m>def_code "\\verblatex" open_forget ;
     def_code "\\endverblatex" Scan.check_alltt_skip ;
     def_code "\\verbimage" open_verbimage ;
     def_code "\\endverbimage" Scan.check_alltt_skip ;
     ()
 <m>805 </m>;;
     
     <b><U>let</U></b> init_verbatim () =
     </r></b>(* comment clashes with the ``comment'' package *)
       <r>Latexmacros.def "\\comment"  zero_pat (CamlCode open_forget) ;
 <m>810   </m>Latexmacros.def "\\endcomment" zero_pat (CamlCode Scan.check_alltt_skip) ;
     ()
     ;;
     
     register_init "verbatim" init_verbatim
 <m>815 </m>;;
     
     </r>(* The program package for JJL  que j'aime bien *)
     
     <b><U>let</U><r> look_escape () =
 </r><m>820   </m><U>let</U><r> lexbuf = Lexing.from_string (Out.to_string line_buff) <b><U>in</U><r>
       do_escape lexbuf
     ;;
     
     </r><U>let</U></b> init_program () =
 <m>825   </m>def_code "\\program"
         (<b><U>fun</U><r> lexbuf -&gt;
           Scan.top_open_block "PRE" "" ;
           process :=
              (</r><U>fun</U></b> () -&gt; look_escape () ; Dest.put_char '\n') ;
 <m>830       </m>finish := look_escape  ;
           noeof scan_byline lexbuf) ;
       def_code "\\endprogram" close_verbenv
     ;;
     
 <m>835 </m>register_init "program" init_program
     ;;
     
     
     </r></b>(* The moreverb package *)
 </w>840 <b><U>let</U></b></m> tab_val = ref 8
     
     <b><U>let</U><r> put_verb_tabs () =
       </r><U>let</U></b> char = ref 0 <b><U>in</U><r>
       Out.iter
 <m>845     </m>(</r><U>fun</U></b> c -&gt; <b><U>match</U><r> c </r><U>with</U></b>
           | '\t' -&gt;
               <b><U>let</U><r> limit = !tab_val - !char </r><U>mod</U></b> !tab_val <b><U>in</U>
               <U>for</U></b> j = 1 <b><U>to</U><r> limit </r><U>do</U></b>
                 Dest.put_char ' ' ; incr char
 <m>850           <b><U>done</U></b></m> ;
           | c -&gt; Dest.put (Dest.iso c) ; incr char)
         line_buff ;
       Out.reset line_buff
     
 <m>855 <b><U>let</U></b></m> open_verbenv_tabs () =
       Scan.top_open_block "PRE" "" ;
       process := (<b><U>fun</U><r> () -&gt; put_verb_tabs () ; Dest.put_char '\n') ;
       finish := put_verb_tabs
     
 </r><m>860 </m><U>and</U></b> close_verbenv_tabs lexbuf =
       Scan.top_close_block "PRE" ;
       Scan.check_alltt_skip lexbuf
     ;;
     
 <m>865 <b><U>let</U></b></m> line = ref 0
     <b><U>and</U><r> interval = ref 1
     ;;
     
     
 </r><m>870 </m><U>let</U></b> output_line inter_arg star =
       <b><U>if</U><r> !line = 1 || !line </r><U>mod</U></b> inter_arg = 0 <b><U>then</U><r>
         scan_this Scan.main ("\\listinglabel{"^string_of_int !line^"}")
       </r><U>else</U></b>
         Dest.put "     " ;
 <m>875   <b><U>if</U></b></m> star <b><U>then</U><r>
         put_line_buff_verb_star ()
       </r><U>else</U></b>
         put_verb_tabs () ;
       incr line
 <m>880 
     
     <b><U>let</U></b></m> open_listing start_arg inter_arg star =
       Scan.top_open_block "PRE" "" ;
       line := start_arg ;
 <m>885   <b><U>let</U></b></m> first_line = ref <b><U>true</U> <U>in</U>
       <U>let</U></b> inter = <b><U>if</U><r> inter_arg &lt;= 0 </r><U>then</U></b> 1 <b><U>else</U><r> inter_arg </r><U>in</U></b>
       process :=
         (<b><U>fun</U><r> () -&gt;
           </r><U>if</U></b> !first_line <b><U>then</U> <U>begin</U><m>
 890         <r>first_line := <b><U>false</U><r> ;
             </r><U>if</U></b> not (Out.is_empty line_buff) <b><U>then</U><r>
               output_line inter_arg star ;
           </r><U>end</U> <U>else</U></b>
             output_line inter_arg star  ;
 </r>895       <r>Dest.put_char '\n') ;
       finish :=
          (<b><U>fun</U><r> () -&gt;
            </r><U>if</U></b> not (Out.is_empty line_buff) <b><U>then</U></b>
              output_line inter_arg star)
 </r>900 
     </m><U>and</U></b> close_listing lexbuf =
       Scan.top_close_block "PRE" ;
       Scan.check_alltt_skip lexbuf
     ;;
 <m>905 
     
     <r>register_init "moreverb"
     (<b><U>fun</U></b> () -&gt;
       def_code "\\verbatimwrite"
 </r>910     <r>(<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> name = Scan.get_prim_arg lexbuf <b><U>in</U><r>
           Scan.check_alltt_skip lexbuf ;
           </r><U>let</U></b> chan = open_out name <b><U>in</U></b>
           open_tofile chan lexbuf) ;
 </r>915 
       <r>def_code "\\endverbatimwrite" Scan.check_alltt_skip ;
     
       def_code "\\verbatimtab"
         (<b><U>fun</U></b> lexbuf -&gt;
 </r>920       <b><U>let</U></b></m> opt = Get.get_int (save_opt "\\verbatimtabsize" lexbuf) <b><U>in</U><r>
           tab_val := opt ;
           open_verbenv_tabs () ;
           Lexstate.save_lexstate () ;
           </r><U>let</U></b> first = get_line lexbuf <b><U>in</U><m>
 925       <r>Lexstate.restore_lexstate () ;
           scan_this Scan.main first ;
           Dest.put_char '\n' ;
           noeof scan_byline lexbuf) ;
       def_code "\\endverbatimtab" close_verbenv_tabs ;
 </r>930 <w>(*
       def_code "\\verbatimtabinput"
         (fun lexbuf -&gt;
           let opt = Get.get_int (save_opt "\\verbatimtabsize" lexbuf) in
           tab_val := opt ;
 </w>935       <w>let name = Scan.get_prim_arg lexbuf in
           open_verbenv_tabs () ;
           verb_input scan_byline name ;
           close_verbenv_tabs lexbuf) ;
     *)
 </w>940   <r>def_code "\\listinglabel"
         (<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> arg = Get.get_int (save_arg lexbuf) <b><U>in</U></b>
           Dest.put (Printf.sprintf "%4d " arg)) ;
     
 </r>945   <r>def_code "\\listing"
         (<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> inter = Get.get_int (save_opt "1" lexbuf) <b><U>in</U>
           <U>let</U></b> start = Get.get_int (save_arg lexbuf) <b><U>in</U></b>
           interval := inter ;
 </r>950       <r>open_listing start inter <b><U>false</U></b> ;
           noeof scan_byline lexbuf) ;
       def_code "\\endlisting" close_listing ;
     <w>(*
       def_code "\\listinginput"
 <m>955     </m>(fun lexbuf -&gt;
           let inter = Get.get_int (save_opt "1" lexbuf) in
           let start = Get.get_int (save_arg lexbuf) in
           let name = Scan.get_prim_arg lexbuf in
           interval := inter  ;
 <m>960       </m>open_listing start inter false ;
           verb_input scan_byline name ;
           close_listing lexbuf) ;
     *)
       </w>def_code "\\listingcont"
 </r>965     <r>(<b><U>fun</U><r> lexbuf -&gt;
           open_listing !line !interval </r><U>false</U></b> ;
           noeof scan_byline lexbuf) ;
       def_code "\\endlistingcont" close_listing ;
     
 </r>970   <r>def_code "\\listing*"
         (<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> inter = Get.get_int (save_opt "1" lexbuf) <b><U>in</U>
           <U>let</U></b> start = Get.get_int (save_arg lexbuf) <b><U>in</U></b>
           interval := inter ;
 </r>975       <r>open_listing start inter <b><U>true</U></b> ;
           noeof scan_byline lexbuf) ;
       def_code "\\endlisting*" close_listing ;
     
       def_code "\\listingcont*"
 </r>980     <r>(<b><U>fun</U><r> lexbuf -&gt;
           Scan.check_alltt_skip lexbuf ;
           open_listing !line !interval </r><U>false</U></b> ;
           noeof scan_byline lexbuf) ;
       def_code "\\endlistingcont*" close_listing ;
 </r>985   <r>())
     
     <w>(* The comment package *)
     
     <b><U>let</U></b></w> init_comment () =
 </r>990   <r>def_code "\\@excludecomment" open_forget ;
       def_code "\\end@excludecomment"  Scan.check_alltt_skip ;
     ;;
     
     register_init "comment" init_comment
 </r>995 <r>;;
     
     <w>(* The listings package *)
     
     (*
<m>1000   </m>Caml code for
       \def\lst@spaces
         {\whiledo{\value{lst@spaces}&gt;0}{~\addtocounter{lst@spaces}{-1}}}
     *)
     <b><U>let</U></b></w> code_spaces lexbuf =
</r>1005   </m><U>let</U></b> n = Counter.value_counter "lst@spaces" <b><U>in</U>
       <U>if</U></b> !lst_effective_spaces <b><U>then</U>
         <U>for</U></b> i = n-1 <b><U>downto</U></b> 0 </r><U>do</U></b></w></m>
           Dest.put_char '_'
         <b><U>done</U><m>
1010   </m><U>else</U>
         <U>for</U></b> i = n-1 <b><U>downto</U><r> 0 </r><U>do</U></b>
           Dest.put_nbsp ()
         <b><U>done</U><r> ;
       Counter.set_counter "lst@spaces" 0
<m>1015 </m>;;
     
     </r><U>let</U></b> code_double_comment process_B process_E lexbuf =
       <b><U>let</U><r> lxm_B = get_prim_arg lexbuf </r><U>in</U>
       <U>let</U></b> lxm_E = get_prim_arg lexbuf <b><U>in</U><m>
1020   </m><U>if</U></b> lxm_B &lt;&gt; "" &amp;&amp; lxm_E &lt;&gt; "" <b><U>then</U> <U>begin</U>
         <U>let</U></b> head_B = lxm_B.[0]
         <b><U>and</U><r> rest_B = String.sub lxm_B 1 (String.length lxm_B-1)
         </r><U>and</U></b> head_E = lxm_E.[0]
         <b><U>and</U><r> rest_E = String.sub lxm_E 1 (String.length lxm_E-1) </r><U>in</U><m>
1025     <r>lst_init_save_char head_B
           (process_B
              (<b><U>fun</U><r> c s -&gt;
                c = head_E &amp;&amp; s = rest_E)
              rest_B) ;
<m>1030     </m>lst_init_save_char head_E (process_E rest_E)
       </r><U>end</U>
     
     <U>let</U></b> code_line_comment lexbuf =
       <b><U>let</U><r> lxm_LC = get_prim_arg lexbuf </r><U>in</U><m>
1035   </m><U>if</U></b> lxm_LC &lt;&gt; "" <b><U>then</U> <U>begin</U>
         <U>let</U></b> head = lxm_LC.[0]
         <b><U>and</U><r> rest = String.sub lxm_LC 1 (String.length lxm_LC-1) </r><U>in</U></b>
         lst_init_save_char head (lst_process_LC rest)
       <b><U>end</U><m>
1040 
     </m><U>let</U></b> code_stringizer lexbuf =
       <b><U>let</U><r> mode = Scan.get_prim_arg lexbuf </r><U>in</U>
       <U>let</U></b> schars = Scan.get_prim_arg lexbuf <b><U>in</U><r>
       lst_init_save_chars schars (lst_process_stringizer mode)
<m>1045 </m>;;
     
     </r><U>let</U></b> open_lst inline keys lab =
       scan_this Scan.main ("\\lsthk@PreSet\\lstset{"^keys^"}") ;
     <w>(* For inline *)
</w></r>1050   </m><U>if</U></b> inline <b><U>then</U><r>
         scan_this Scan.main "\\lsthk@InlineUnsave" ;
     <w>(* Ignoring output *)
       </w>lst_gobble := Get.get_int (string_to_arg "\\lst@gobble") ;
       lst_first := Get.get_int (string_to_arg "\\lst@first") ;
<m>1055   </m>lst_last := Get.get_int (string_to_arg "\\lst@last") ;
       lst_nlines := 0 ;
       lst_init_char_table inline ;
       scan_this Scan.main "\\lsthk@SelectCharTable" ;
       </r><U>if</U></b> !lst_extended <b><U>then</U><m>
1060     </m><U>for</U></b> i = 128 <b><U>to</U><r> 255 </r><U>do</U></b>
           lst_init_char (Char.chr i) lst_process_letter
         <b><U>done</U><r> ;
       scan_this Scan.main "\\lsthk@Init" ;
     </r><w>(* Directives *)
<m>1065   </m></w><U>if</U></b> !lst_directives <b><U>then</U> <U>begin</U></b>
         lst_init_save_char '#' lst_process_start_directive
       <b><U>end</U><r> ;
     </r><w>(* Print key *)
       </w><U>if</U></b> not !lst_print <b><U>then</U> <U>begin</U><m>
1070     <r>lst_last := -2 ; lst_first := -1
       <b><U>end</U></b> ;
     <w>(* Strings *)
     (* Escapes to TeX *)
       <b><U>if</U><r> !lst_mathescape </r><U>then</U> <U>begin</U><m>
1075     <r>lst_init_save_char '$' (lst_process_escape <b><U>true</U><r> '$')
       </r><U>end</U></b> ;
       <b><U>let</U><r> begc = Scan.get_this_main "\\@getprintnostyle{\\lst@BET}"
       </r><U>and</U></b> endc = Scan.get_this_main "\\@getprintnostyle{\\lst@EET}" <b><U>in</U>
       <U>if</U></b> begc &lt;&gt; "" &amp;&amp; endc &lt;&gt; "" <b><U>then</U> <U>begin</U><m>
1080     <r>lst_init_save_char begc.[0] (lst_process_escape <b><U>false</U><r> endc.[0])
       </r><U>end</U></b> ;
       scan_this Scan.main "\\lsthk@InitVar" ;
       lst_scan_mode := Empty ;
       <b><U>if</U><r> inline </r><U>then</U><m>
1085     <r>lst_top_mode := Normal
       <b><U>else</U><r>
         lst_top_mode := Skip
     
     </r><U>and</U></b> close_lst inline =
</r>1090   <r>lst_finalize inline ;
       <b><U>while</U><r> !Scan.cur_env = "command-group" </r><U>do</U></b>
         scan_this Scan.main "\\endgroup"
       <b><U>done</U></b> ;
       scan_this Scan.main "\\lsthk@DeInit"
</r>1095 <r>;;
     
     <b><U>let</U><r> lst_boolean lexbuf =
       </r><U>let</U></b> b = get_prim_arg lexbuf <b><U>in</U></b>
       Dest.put
</r>1100     <r>(<b><U>match</U><r> b </r><U>with</U></b>
         | "" -&gt; "false"
         | s  <b><U>when</U></b> s.[0] = 't' || s.[0] = 'T' -&gt; "true"
         | _ -&gt; "false")
     ;;
</r>1105 
     <r>def_code "\\@callopt"
         (<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> csname = Scan.get_csname lexbuf <b><U>in</U>
           <U>let</U></b> old_raw = !raw_chars <b><U>in</U><m>
1110       </m><U>let</U></b> all_arg = get_prim_arg lexbuf <b><U>in</U>
           <U>let</U></b> lexarg = Lexing.from_string all_arg <b><U>in</U>
           <U>let</U></b> opt = Subst.subst_opt "" lexarg <b><U>in</U>
           <U>let</U></b> arg = Save.rest lexarg <b><U>in</U>
           <U>let</U></b> exec = csname^"["^opt^"]{"^arg^"}" <b><U>in</U><m>
1115       <r>scan_this  Scan.main exec)
     ;;
     <b><U>let</U></b> init_listings () =
       Scan.newif_ref "lst@print" lst_print ;
       Scan.newif_ref "lst@extendedchars" lst_extended ;
</r>1120   <r>Scan.newif_ref "lst@texcl" lst_texcl ;
       Scan.newif_ref "lst@sensitive" lst_sensitive ;
       Scan.newif_ref "lst@mathescape" lst_mathescape ;
       Scan.newif_ref "lst@directives" lst_directives ;
       Scan.newif_ref "lst@stringspaces" lst_string_spaces ;
</r>1125   <r>Scan.newif_ref "lst@showlines" lst_showlines ;
       def_code "\\lst@spaces" code_spaces ;
       def_code "\\lst@boolean" lst_boolean ;
       def_code "\\lst@def@stringizer" code_stringizer ;
       def_code "\\lst@AddTo"
</r>1130     <r>(<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> sep = Scan.get_prim_arg lexbuf <b><U>in</U>
           <U>let</U></b> name = Scan.get_csname lexbuf <b><U>in</U>
           <U>let</U></b> old =
             <b><U>try</U> <U>match</U></b> Latexmacros.find_fail name <b><U>with</U><m>
1135         <r>| _, Subst s -&gt; s
             | _,_        -&gt; ""
             <b><U>with</U><r>
             | Latexmacros.Failed -&gt; "" </r><U>in</U>
           <U>let</U></b> toadd = get_prim_arg lexbuf <b><U>in</U><m>
1140       <r>Latexmacros.def name zero_pat
             (Subst (<b><U>if</U><r> old="" </r><U>then</U></b> toadd <b><U>else</U><r> old^sep^toadd))) ;
       def_code "\\lst@lExtend"
         (</r><U>fun</U></b> lexbuf -&gt;
           <b><U>let</U><r> name = Scan.get_csname lexbuf </r><U>in</U><m>
1145       </m><U>try</U>
             <U>match</U></b> Latexmacros.find_fail name <b><U>with</U><r>
             | _, Subst body -&gt;
                 </r><U>let</U></b> toadd = Subst.subst_arg lexbuf <b><U>in</U></b>
                 Latexmacros.def name zero_pat (Subst (body^"%\n"^toadd))
</r>1150         <r>| _, _ -&gt;
                 warning ("Cannot \\lst@lExtend ``"^name^"''")
           <b><U>with</U></b>
           | Latexmacros.Failed -&gt;
                 warning ("Cannot \\lst@lExtend ``"^name^"''")) ;
</r>1155   <r>def_code "\\lstlisting"
         (<b><U>fun</U><r> lexbuf -&gt;
           Image.stop () ;
           </r><U>let</U></b> keys = Subst.subst_opt "" lexbuf <b><U>in</U>
           <U>let</U></b> lab = Scan.get_prim_arg lexbuf <b><U>in</U><m>
1160       </m><U>let</U></b> lab = <b><U>if</U><r> lab = " " </r><U>then</U></b> "" <b><U>else</U><r> lab </r><U>in</U>
           <U>if</U></b> lab &lt;&gt; "" <b><U>then</U><r>
             def "\\lst@intname" zero_pat (CamlCode (</r><U>fun</U></b> _ -&gt; Dest.put lab)) ;
           open_lst <b><U>false</U></b> keys lab ;
           scan_this Scan.main "\\lst@pre\\@open@lstbox" ;
</r>1165       <r>scan_this Scan.main "\\lst@basic@style" ;
           <w>(* Eat first line *)
           </w>save_lexstate () ;
           noeof eat_line lexbuf ;
           restore_lexstate () ;
</r>1170 <w>(* For detecting endstring, must be done after eat_line *)
           <r>lst_init_save_char '\\' (lst_process_end "end{lstlisting}") ;
           noeof listings lexbuf ;
           close_lst <b><U>false</U></b>  ;
           scan_this Scan.main "\\@close@lstbox\\lst@post" ;
<m>1175       </m>Scan.top_close_block "" ;
           Scan.close_env !Scan.cur_env ;
           Image.restart () ;
           Scan.check_alltt_skip lexbuf) ;
     </r>(* Init comments from .hva *)
</w>1180   <r>def_code "\\lst@balanced@comment"
         (<b><U>fun</U><r> lexbuf -&gt;
           code_double_comment lst_process_BBC lst_process_EBC lexbuf) ;
       def_code "\\lst@nested@comment"
         (</r><U>fun</U></b> lexbuf -&gt;
</r>1185       <r>code_double_comment lst_process_BNC lst_process_ENC lexbuf) ;
       def_code "\\lst@line@comment" code_line_comment ;
     
       def_code "\\lstinline"
         (<b><U>fun</U></b> lexbuf -&gt;
</r>1190       </m><U>let</U></b> keys = Subst.subst_opt "" lexbuf <b><U>in</U>
           <U>let</U></b> {arg=arg} = save_verbatim lexbuf <b><U>in</U><r>
           Scan.new_env "*lstinline*" ;
           scan_this main "\\mbox{" ;
           open_lst </r><U>true</U></b> keys "" ;
</r>1195       <r>Dest.open_group "CODE" ;
           <b><U>begin</U> <U>try</U></b>
             scan_this listings arg
           <b><U>with</U></b>
           | Eof _ -&gt; ()
</r>1200       </m><U>end</U></b> ;
           close_lst <b><U>true</U></b> ;
           Dest.close_group () ;
           scan_this main "}" ;
           Scan.close_env "*lstinline*") ;
</r>1205 
       <r>def_code "\\lst@definelanguage"
         (<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> dialect = get_prim_opt "" lexbuf <b><U>in</U>
           <U>let</U></b> language = get_prim_arg lexbuf <b><U>in</U><m>
1210       </m><U>let</U></b> base_dialect = get_prim_opt "!*!" lexbuf <b><U>in</U>
     
           <U>match</U></b> base_dialect <b><U>with</U><r>
           | "!*!" -&gt;
               </r><U>let</U></b> keys = subst_arg lexbuf <b><U>in</U><m>
1215           </m><U>let</U></b> _ = save_opt "" lexbuf <b><U>in</U></b>
               scan_this main
                 ("\\lst@definelanguage@{"^language^"}{"^
                  dialect^"}{"^keys^"}")
           | _  -&gt;
</r>1220           </m><U>let</U></b> base_language = get_prim_arg lexbuf <b><U>in</U>
               <U>let</U></b> keys = subst_arg lexbuf <b><U>in</U>
               <U>let</U></b> _ = save_opt "" lexbuf <b><U>in</U></b>
               scan_this main
                 ("\\lst@derivelanguage@{"^
</r>1225              <r>language^"}{"^ dialect^"}{"^
                  base_language^"}{"^base_dialect^"}{"^
                  keys^"}"))
     ;;
     
</r>1230 <r>register_init "listings" init_listings
     ;;
     
     
     <b><U>let</U></b> init_fancyvrb () =
</r>1235   <r>def_code "\\@Verbatim"
         (<b><U>fun</U><r> lexbuf -&gt;
           open_verbenv </r><U>false</U></b> ;
           noeof scan_byline lexbuf) ;
       def_code "\\@endVerbatim" close_verbenv
</r>1240 <r>;;
     
     
     register_init "fancyvrb" init_fancyvrb
     ;;
</r>1245 
     
     
     <r>def_code "\\@scaninput"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>1250     </m><U>let</U></b> pre = save_arg lexbuf <b><U>in</U>
         <U>let</U></b> file = get_prim_arg lexbuf <b><U>in</U>
         <U>let</U></b> {arg=post ; subst=post_subst} = save_arg lexbuf <b><U>in</U>
         <U>try</U>
           <U>let</U></b> true_name,chan = Myfiles.open_tex file <b><U>in</U><m>
1255       </m><U>if</U></b> !verbose &gt; 0 <b><U>then</U><r>
             message ("Scan input file: "^true_name) ;
           </r><U>let</U></b> filebuff = Lexing.from_channel chan <b><U>in</U><r>
           start_lexstate () ;
           </r><U>let</U></b> old_input = !input_verb <b><U>in</U><m>
1260       </m><U>if</U></b> old_input <b><U>then</U><r> warning "Nested \\@scaninput" ;
           input_verb := </r><U>true</U></b> ;
           Location.set true_name filebuff ;
           <b><U>begin</U> <U>try</U></b>
             record_lexbuf (Lexing.from_string post) post_subst ;
</r>1265         <r>scan_this_may_cont Scan.main filebuff top_subst
               pre ;
           <b><U>with</U></b> e -&gt;
             restore_lexstate () ;
             Location.restore () ;
</r>1270         <r>close_in chan ;
             raise e
           <b><U>end</U></b> ;
           restore_lexstate () ;
           Location.restore () ;
</r>1275       <r>close_in chan ;
           input_verb := old_input
         <b><U>with</U></b>
         | Myfiles.Except -&gt;
             warning ("Not opening file: "^file)
</r>1280     <r>| Myfiles.Error s -&gt;
             warning s)
     <b><U>end</U><r>
     }<PL><B>
<6>13 videoc.mll</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*  Christian Queinnec, Universite Paris IV                            *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
  <m>10 </m>(*                                                                     *)
     (***********************************************************************)
     (* &lt;Christian.Queinnec@lip6.fr&gt;
      The plugin for HeVeA that implements the VideoC style.
      $Id: videoc.mll,v 1.26 2001/05/25 12:37:35 maranget Exp $
  <m>15 </m>*)
     
     </w>{
     </r><U>module</U> <U>type</U></b> T =
       <b><U>sig</U><m>
  20   </m><U>end</U></b>;;
     
     <b><U>module</U></b> Make
         (Dest : OutManager.S)
         (Image : ImageManager.S)
  </r>25     <r>(Scan : Latexscan.S) =
     <b><U>struct</U>
     <U>open</U></b> Misc
     <b><U>open</U><r> Parse_opts
     </r><U>open</U></b> Lexing
  </r>30 </m><U>open</U></b> Myfiles
     <b><U>open</U><r> Lexstate
     </r><U>open</U></b> Latexmacros
     <b><U>open</U><r> Subst
     </r><U>open</U></b> Scan
  </r>35 
     
     </m><U>let</U><r> header =
       "$Id: videoc.mll,v 1.26 2001/05/25 12:37:35 maranget Exp $"
     </r></b>(* So I can synchronize my changes from Luc's ones *)
  </w></r>40 </m><U>let</U></b> qnc_header =
       "30 oct 2000"
     
     <b><U>exception</U><r> EndSnippet
     ;;
  </r><m>45 </m><U>exception</U></b> EndTeXInclusion
     ;;
     
     <w>(* Re-link with these variables inserted in latexscan. *)
     
  <m>50 </m><b><U>let</U></b></w> withinSnippet = ref <b><U>false</U><r>;;
     </r><U>let</U></b> withinTeXInclusion = ref <b><U>false</U><r>;;
     </r><U>let</U></b> endSnippetRead = ref <b><U>false</U><r>;;
     
     </r><w>(* Snippet global defaults *)
  <m>55 
     </m></w><U>let</U></b> snippetLanguage = ref "";;
     <b><U>let</U><r> enableLispComment = ref </r><U>false</U></b>;;
     <b><U>let</U><r> enableSchemeCharacters = ref </r><U>false</U></b>;;
     
  <m>60 <w>(* Snippet Environment: run a series of hooks provided they exist as
        user macros. *)
     
     <b><U>let</U><r> runHook prefix parsing name =
       </r><U>let</U><r> run name = <b><U>begin</U><m>
  65     </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("Trying to run hook " ^ name);
         </r><U>if</U></b> Latexmacros.exists name
         <b><U>then</U> <U>begin</U></b> Lexstate.scan_this parsing name; () <b><U>end</U>
       <U>end</U> <U>in</U>
       <U>let</U> <U>rec</U></b> iterate name suffix =
  <m>70     <r>run name;
         <b><U>if</U><r> suffix &lt;&gt; ""
         </r><U>then</U></b> iterate (name ^ (String.make 1 (String.get suffix 0)))
                      (String.sub suffix 1 ((String.length suffix) - 1))
       <b><U>in</U></b> iterate (prefix ^ name ^ "Hook") !snippetLanguage;;
  </r>75 
     <b><U>let</U></b></m> snippetRunHook parsing name =
       runHook "\\snippet" parsing name;;
     
     <b><U>let</U></b> snipRunHook parsing name =
  <m>80   </m>runHook "\\snip" parsing name;;
     
     </r></b>(* Hack for mutual recursion between modules: *)
     
     <b><U>let</U><r> handle_command = ref
  <m>85   </m>((</r><U>function</U><r> lexbuf -&gt; <b><U>function</U></b> s -&gt; ())
          : (Lexing.lexbuf -&gt; string -&gt; unit));;
     
     </r></b>(* Convert a reference to a hint such as "3" "annote.ann" "premier indice"
        into "3_annote_ann". This is needed for the annote tool.  *)
  </w>90 
     <b><U>let</U></b></m> compute_hint_id number filename notename =
       <b><U>let</U><r> result = number ^ "_" ^ filename </r><U>in</U>
       <U>let</U> <U>rec</U></b> convert i = <b><U>begin</U>
         <U>if</U></b> i&lt;String.length(result)
  <m>95     <b><U>then</U> <U>let</U></b></m> c = String.get result i <b><U>in</U>
              <U>if</U> <U>true</U></b> || ('a' &lt;= c &amp;&amp; c &lt;= 'z') <w>(* test *)
                 </w>|| ('A' &lt;= c &amp;&amp; c &lt;= 'z')
                 || ('0' &lt;= c &amp;&amp; c &lt;= '9')
              <b><U>then</U><r> ()
 </r><m>100          </m><U>else</U></b> String.set result i '_';
              convert (i+1);
         <b><U>end</U> <U>in</U></b>
       convert 0;
       result;;
 <m>105 
     <b><U>let</U></b></m> increment_internal_counter =
       <b><U>let</U><r> counter = ref 99 </r><U>in</U>
       <U>function</U></b> () -&gt;
         <b><U>begin</U><m>
 110       <r>counter := !counter + 1;
           !counter
         <b><U>end</U></b>;;
     
     }
 </r>115 
     </m><U>let</U></b> command_name = '\\' ((['@''A'-'Z' 'a'-'z']+ '*'?) | [^ 'A'-'Z' 'a'-'z'])
     
     rule snippetenv = parse
     | eof { () }
 <m>120 </m>| command_name
        {<b><U>let</U><r> csname = lexeme lexbuf </r><U>in</U>
         <U>let</U></b> pat,body = Latexmacros.find csname <b><U>in</U>
         <U>begin</U> <U>match</U></b> pat <b><U>with</U><r>
         | [],[] -&gt;
 <m>125       <b><U>let</U><r> args =  make_stack csname pat lexbuf </r><U>in</U>
           <U>let</U><r> cur_subst = get_subst () <b><U>in</U>
           <U>let</U></b> exec = <b><U>function</U><r>
             | Subst body -&gt;
                 </r><U>if</U></b> !verbose &gt; 2 </r><U>then</U></b>
 130               </m>prerr_endline ("user macro in snippet: "^body) ;
                 Lexstate.scan_this_may_cont Scan.main
                   lexbuf cur_subst (string_to_arg body)
             | Toks l -&gt;
                 List.iter
 <m>135               </m>(</r><U>fun</U></b> s -&gt; scan_this Scan.main s)
                   (List.rev l)
             | CamlCode f -&gt; f lexbuf <b><U>in</U><r>
           scan_body exec body args
         |  _ -&gt;
 <m>140       </m>raise (Misc.ScanError ("Command with arguments inside snippet"))
         </r><U>end</U></b> ;
         snippetenv lexbuf}
     | '\n'
         {Dest.put_tag "&lt;BR&gt;";
 <m>145      <r>Dest.put_char '\n';
          snippetRunHook Scan.main "AfterLine";
          snippetRunHook Scan.main "BeforeLine";
          snippetenv lexbuf}
     | ' '|'\t'
 </r>150     <r>{Dest.put_nbsp ();
          snippetenv lexbuf}
     | ';' +
         {Dest.put (lexeme lexbuf);
          Dest.put_char ' ';
 </r>155      <b><U>if</U></b></m> !enableLispComment
          <b><U>then</U> <U>begin</U>
             <U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
               prerr_endline "Within snippet: Lisp comment entered";
             Lexstate.withinLispComment := </r><U>true</U></b>;
 <m>160         <r>Scan.top_open_block "SPAN"
               ("class=\"" ^ !snippetLanguage ^ "Comment\"");
             snippetRunHook Scan.main "BeforeComment";
             <b><U>try</U><r> Scan.main lexbuf </r><U>with</U><w> (* until a \n is read *)
             <r>| exc -&gt; <b><U>begin</U><m>
 165             <r>snippetRunHook Scan.main "AfterComment";
                 Scan.top_close_block "SPAN";
                 Lexstate.withinLispComment := <b><U>false</U><r>;
                 </r><w>(* re-raise every exception but EndOfLispComment *)
                 </w><U>try</U></b> raise exc <b><U>with</U><m>
 170             <r>| Misc.EndOfLispComment nlnum -&gt; <b><U>begin</U>
                     <U>let</U></b> addon = (<b><U>if</U><r> !endSnippetRead </r><U>then</U></b> "\\endsnippet" <b><U>else</U><r> "") </r><U>in</U>
                     <U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
                       Printf.fprintf stderr "%d NL after LispComment %s\n"
                         nlnum ((</r><U>if</U></b> !endSnippetRead <b><U>then</U><r> "and " </r><U>else</U></b> "")^addon);
 </r>175                 </m><U>let</U></b> _ = Lexstate.scan_this snippetenv
                         ((String.make (1+nlnum) '\n')^addon) <b><U>in</U><r>
                     ()
                 </r><U>end</U></b>;
             <b><U>end</U></b>;
 </r>180      </m><U>end</U></b>;
          snippetenv lexbuf}
     | '#'
         {Dest.put_char '#';
          <b><U>if</U><r> !enableSchemeCharacters
 </r><m>185      </m><U>then</U> <U>begin</U>
             <U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
               prerr_endline "Within snippet: scheme characters enabled";
             schemecharacterenv lexbuf
          </r><U>end</U></b>;
 <m>190      <r>snippetenv lexbuf}
     | _
         {Dest.put (Dest.iso (lexeme_char lexbuf 0));
          snippetenv lexbuf}
     
 </r>195 <w>(* Scheme characters are written as #\A or #\Newspace *)
     
     <b><U>and</U><r> schemecharacterenv = parse
     | command_name
         {</r><U>let</U><r> csname = lexeme lexbuf <b><U>in</U><m>
 200      <r>Dest.put csname}
     | ""
         { () }
     
     <w>(* Swallow characters until the end of the line. *)
 </w></r>205 
     </m><U>and</U></b> skip_blanks_till_eol_included = parse
     | ' ' +
         {skip_blanks_till_eol_included lexbuf}
     | '\n'
 <m>210     </m>{ () }
     | ""
         { () }
     
     </r></b>(* Parse a succession of things separated by commas. *)
 </w>215 
     <b><U>and</U></b></m> comma_separated_values = parse
     | [ ^ ',' ] * ','
         {<b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
          <U>let</U></b> s = String.sub lxm 0 (String.length lxm - 1) <b><U>in</U><m>
 220      </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U></b> prerr_endline ("CSV" ^ s);
          s :: comma_separated_values lexbuf}
     | eof
         { [] }
     
 <m>225 <w>(* Trailer: Register local macros as global. *)
     
     <r>{
     <b><U>let</U><r> caml_print s = CamlCode (</r><U>fun</U></b> _ -&gt; Dest.put s)
     <b><U>let</U><r> snippet_def name d = Latexmacros.def name zero_pat (CamlCode d)
 </r><m>230 
     </m><U>let</U> <U>rec</U></b> do_endsnippet _ =
       <b><U>if</U><r> !Lexstate.withinLispComment </r><U>then</U> <U>begin</U></b>
         endSnippetRead := <b><U>true</U><r>;
         raise (Misc.EndOfLispComment 0)
 </r><m>235   </m><U>end</U></b>;
       <b><U>if</U><r> !Scan.cur_env = "snippet" </r><U>then</U></b>
         raise EndSnippet
       <b><U>else</U><r>
         raise (Misc.ScanError ("\\endsnippet without opening \\snippet"))
 </r><m>240 
     </m><U>and</U></b> do_texinclusion lexbuf =
       Scan.top_open_block "SPAN"
         ("class=\"" ^ !snippetLanguage ^ "Inclusion\"");
       snippetRunHook Scan.main "BeforeTeX";
 <m>245   </m>withinTeXInclusion := <b><U>true</U><r>;
       </r><U>begin</U><w> (* Until a \] is read *)
         </w><U>try</U></b> Scan.main lexbuf <b><U>with</U><r>
         | exc -&gt; </r><U>begin</U></b>
             snippetRunHook Scan.main "AfterTeX";
 <m>250         </m>Scan.top_close_block "SPAN";
             snippetRunHook Scan.main "Restart";
             </r>(* Re-raise every thing but EndTeXInclusion *)
             <b><U>try</U><r> raise exc </r><U>with</U><r>
             | EndTeXInclusion -&gt; ()
 <m>255     <b><U>end</U></b></m>;
       <b><U>end</U><r> ;
     
     </r><U>and</U></b> do_texexclusion _ =
      <b><U>if</U><r> !withinSnippet </r><U>then</U> <U>begin</U><m>
 260    </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline "\\] caught within TeX escape";
        withinTeXInclusion := </r><U>false</U></b>;
        raise EndTeXInclusion
      <b><U>end</U> <U>else</U></b>
        raise (Misc.ScanError ("\\] without opening \\[ in snippet"))
 <m>265 
     <b><U>and</U></b></m> do_backslash_newline  _ =
       Dest.put "\\\n";
       Lexstate.scan_this snippetenv "\n"
     
 <m>270 <b><U>and</U></b></m> do_four_backslashes _ = Dest.put "\\"
     
     </r></b>(* HACK: Define a macro with a body that is obtained via substitution.
        This is a kind of restricted \edef as in TeX.
        Syntax:    \@EDEF\macroName{#2#1..}                                 *)
 </w>275 
     <b><U>and</U><r> do_edef lxm lexbuf =
       </r><U>let</U><r> name = Scan.get_csname lexbuf <b><U>in</U>
       <U>let</U></b> body = subst_arg lexbuf <b><U>in</U>
       <U>if</U></b> Scan.echo_toimage () </r><U>then</U></b>
 280     </m>Image.put ("\\def"^name^"{"^body^"}\n") ;
       Latexmacros.def name zero_pat (caml_print body);
       ()
     
     </r>(* Syntax:  \@MULEDEF{\macroName,\macroName,...}{#1#3...}
 <m>285    </m>This is an awful hack extending the \@EDEF command. It locally
        rebinds the (comma-separated) \macronames to the corresponding
        (comma-separated) expansion of second argument. All \macronames
        should be a zero-ary macro. *)
     
 <m>290 <b><U>and</U><r> do_muledef lxm lexbuf =
       </r><U>let</U><r> names = subst_arg lexbuf <b><U>in</U>
       <U>let</U></b> bodies = subst_arg lexbuf <b><U>in</U>
       <U>let</U> <U>rec</U></b> bind lasti lastj =
         <b><U>try</U> <U>let</U></b> i = String.index_from names lasti ',' <b><U>in</U><m>
 295     </m><U>try</U> <U>let</U></b> j = String.index_from bodies lastj ',' <b><U>in</U>
         <U>let</U></b> name = String.sub names lasti (i - lasti) <b><U>in</U>
         <U>let</U></b> body = String.sub bodies lastj (j - lastj) <b><U>in</U>
         <U>if</U></b> !verbose &gt; 2 <b><U>then</U></b> prerr_endline (lxm ^ name ^ ";" ^ body);
         Latexmacros.def name zero_pat (caml_print body);
 </r></b>300       <r>bind (i+1) (j+1)
         <b><U>with</U><r> Not_found -&gt; failwith "Missing bodies for \\@MULEDEF"
         </r><U>with</U></b> Not_found -&gt;
           <b><U>let</U><r> name = String.sub names lasti (String.length names - lasti) </r><U>in</U>
           <U>let</U></b> body = String.sub bodies lastj (String.length bodies - lastj) <b><U>in</U><m>
 305       </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline (lxm ^ name ^ ";" ^ body);
           Latexmacros.def name zero_pat (caml_print body) ;
       </r><U>in</U></b> bind 0 0;
       ()
     
 </r>310 
     </m>(* The command that starts the \snippet inner environment: *)
     
     </w><U>and</U></b> do_snippet lexbuf =
       <b><U>if</U></b> !withinSnippet
 </r>315   <b><U>then</U></b></m> raise (Misc.ScanError "No snippet within snippet.")
       <b><U>else</U> <U>begin</U><w>
         (* Obtain the current TeX value of \snippetDefaultLanguage *)
         </w><U>let</U></b> snippetDefaultLanguage =   "\\snippetDefaultLanguage" <b><U>in</U>
         <U>let</U></b> language = get_prim_opt snippetDefaultLanguage lexbuf <b><U>in</U><m>
 320     </m><U>let</U></b> language = <b><U>if</U><r> language = "" </r><U>then</U></b> snippetDefaultLanguage
                                         <b><U>else</U><r> language </r><U>in</U></b>
         skip_blanks_till_eol_included lexbuf;
         Dest.put "&lt;BR&gt;\n";
         Scan.top_open_block "DIV" ("class=\"div" ^ language ^ "\"");
 <m>325     <r>Dest.put "\n";
         Scan.new_env "snippet";
         <w>(* Define commands local to \snippet *)
         </w>snippet_def "\\endsnippet"  do_endsnippet;
         snippet_def "\\[" do_texinclusion ;
 </r>330     <r>snippet_def "\\]" do_texexclusion ;
         snippet_def "\\\\" do_four_backslashes ;
         snippet_def "\\\n" do_backslash_newline ;
     
         snippetLanguage := language;
 </r>335     <r>enableLispComment := <b><U>false</U><r>;
         enableSchemeCharacters := </r><U>false</U></b>;
         withinSnippet := <b><U>true</U><r>;
         snippetRunHook Scan.main "Before";
         </r><U>try</U></b> snippetenv lexbuf <b><U>with</U><m>
 340       <r>exc -&gt; <b><U>begin</U><r>
             snippetRunHook Scan.main "AfterLine";
             snippetRunHook Scan.main "After";
             withinSnippet := </r><U>false</U></b>;
             Scan.close_env "snippet";
 </r>345         <r>Scan.top_close_block "DIV";
             <w>(* Re-raise all exceptions but EndSnippet *)
             <b><U>try</U></b></w> raise exc <b><U>with</U><r>
               EndSnippet -&gt; ()
           </r><U>end</U></b>;
 </r>350   </m><U>end</U>
     
     <U>and</U></b> do_enable_backslashed_chars lexbuf =
       <b><U>let</U><r> def_echo s = snippet_def s (</r><U>fun</U></b> _ -&gt; Dest.put s) <b><U>in</U>
       <U>let</U></b> chars = subst_arg lexbuf <b><U>in</U> <U>begin</U><m>
 355   </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("\\enableBackslashedChar "^chars);
       </r><U>for</U></b> i=0 <b><U>to</U><r> (String.length chars - 1) </r><U>do</U>
         <U>let</U></b> charcommandname = "\\" ^ (String.sub chars i 1) <b><U>in</U><r>
         def_echo charcommandname;
       </r><U>done</U></b>;
 </r>360   <b><U>end</U></b></m>;
       ()
     
     <b><U>and</U><r> do_enableLispComment lexbuf =
       enableLispComment := </r><U>true</U></b>;
 <m>365   <r>()
     
     <b><U>and</U><r> do_disableLispComment lexbuf =
       enableLispComment := </r><U>false</U></b>;
       ()
 </r>370 
     <b><U>and</U></b></m> do_enableSchemeCharacters lexbuf =
       enableSchemeCharacters := <b><U>true</U><r>;
       ()
     
 </r><m>375 </m><U>and</U></b> do_disableSchemeCharacters lexbuf =
       enableSchemeCharacters := <b><U>false</U><r>;
       ()
     
     </r><U>and</U></b> do_snippet_run_hook lexbuf =
 <m>380   <b><U>let</U></b></m> name = subst_arg lexbuf <b><U>in</U> <U>begin</U></b>
         snippetRunHook Scan.main name;
         ()
       <b><U>end</U><m>
     
 385 </m><U>and</U></b> do_snip_run_hook lexbuf =
       <b><U>let</U><r> name = subst_arg lexbuf </r><U>in</U> <U>begin</U></b>
         snipRunHook Scan.main name;
         ()
       <b><U>end</U><m>
 390 
     <w>(* These macros are defined in Caml since they are not nullary macros.
        They require some arguments but they cannot get them in the snippet
        environment. So I code them by hand. *)
     
 </w>395 </m><U>and</U></b> do_vicanchor lexbuf = <b><U>begin</U>
       <U>let</U></b> {arg=style} = Lexstate.save_opt "" lexbuf <b><U>in</U>
       <U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("\\vicanchor"^style);
       </r><U>let</U></b> {arg=nfn}   = Lexstate.save_opt "0,filename,notename" lexbuf <b><U>in</U>
       <U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("\\vicanchor"^style^nfn);
 </r><m>400   </m><U>let</U></b> fields =
         comma_separated_values (Lexing.from_string (nfn ^ ",")) <b><U>in</U>
       <U>match</U></b> fields <b><U>with</U><r>
       | [number;filename;notename] -&gt;
           </r><U>begin</U><m>
 405         </m><U>let</U></b> uniqueNumber = <w>(* Would be better: truncate(Unix.gettimeofday()) *)
               <r>increment_internal_counter()
             <b><U>and</U><r> hintId = compute_hint_id number filename notename </r><U>in</U></b>
             Dest.put_tag ("&lt;A id=\"a" ^ string_of_int(uniqueNumber)
                           ^ "__" ^ hintId
 <m>410                       <r>^ "\" href=\"javascript: void showMessage('"
                           ^ hintId ^ "')\" class=\"mousable\"&gt;&lt;SPAN style=\""
                           ^ style ^ "\"&gt;&lt;!-- " ^ nfn ^ " --&gt;");
             ()
           <b><U>end</U><m>
 415   <r>| _ -&gt; failwith "Missing comma-separated arguments"
     <b><U>end</U>
     
     <U>and</U></b> do_vicendanchor lexbuf = <b><U>begin</U>
       <U>let</U></b> {arg=nfn} = Lexstate.save_opt "0,filename,notename" lexbuf <b><U>in</U><m>
 420   </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("\\vicendanchor"^nfn);
       </r><U>let</U></b> fields =
         comma_separated_values (Lexing.from_string (nfn ^ ",")) <b><U>in</U>
       <U>match</U></b> fields <b><U>with</U><r>
       | [number;filename;notename] -&gt; </r><U>begin</U><m>
 425       <r>Dest.put_tag ("&lt;/SPAN&gt;&lt;/A&gt;");
           ()
       <b><U>end</U><r>
       | _ -&gt; failwith "Missing comma-separated arguments"
     </r><U>end</U><m>
 430 
     </m><U>and</U></b> do_vicindex lexbuf = <b><U>begin</U>
       <U>let</U></b> nfn = Lexstate.save_opt "0,filename,notename" lexbuf <b><U>in</U></b>
       Dest.put_char ' ';
       ()
 </r>435 </m><U>end</U></b>
     ;;
     
     
     <w>(* This is the initialization function of the plugin: *)
 <m>440 
     <b><U>let</U><r> init = </r><U>function</U><r> () -&gt;
       </r><U>begin</U></b></m>
         (* Register global TeX macros: *)
         </w>def_code "\\snippet"                    do_snippet;
 </r>445     <r>def_name_code "\\@EDEF"                 do_edef;
         def_name_code "\\@MULEDEF"              do_muledef;
     
         def_code "\\ViCEndAnchor"               do_vicendanchor;
         def_code "\\ViCAnchor"                  do_vicanchor;
 </r>450     <r>def_code "\\ViCIndex"                   do_vicindex;
     
         def_code "\\enableLispComment"          do_enableLispComment;
         def_code "\\disableLispComment"         do_disableLispComment;
         def_code "\\enableSchemeCharacters"     do_enableSchemeCharacters;
 </r>455     <r>def_code "\\disableSchemeCharacters"    do_disableSchemeCharacters;
         def_code "\\enableBackslashedChars"     do_enable_backslashed_chars;
         def_code "\\snippetRunHook"             do_snippet_run_hook;
         def_code "\\snipRunHook"                do_snip_run_hook;
         ()
 </r>460   </m><U>end</U></b>;;
     
     register_init "videoc" init
     ;;
     
 </r>465 <b><U>end</U></b></m>}<PL><B>
<6>14 auxx.mli</6>
</B></PL></r> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>val</U></b></w> rset : string -&gt; string -&gt; unit
     <b><U>val</U><r> rget : string -&gt; string
     </r><U>val</U></b> bset : string -&gt; string -&gt; unit
  <m>15 <b><U>val</U></b></m> bget : bool -&gt; string -&gt; string
     <b><U>val</U><r> init : string -&gt; unit
     </r><U>val</U></b> finalize : bool -&gt; bool
     <b><U>val</U><r> bwrite : string -&gt; string -&gt; unit
     </r><U>val</U></b> rwrite : string -&gt; string -&gt; unit
  <m>20 
     <b><U>val</U></b></m> hot_start : unit -&gt; unit
     
     <b><U>type</U><r> saved
     
  </r><m>25 </m><U>val</U></b> check : unit -&gt; saved
     <b><U>val</U><r> hot : saved -&gt; unit<PL><B>
<6>15 buff.mli</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: buff.mli,v 1.4 2001/05/28 17:28:55 maranget Exp $             *)
     (***********************************************************************)
     </w><U>type</U></b> t
     
     <b><U>val</U><r> create : unit -&gt; t
  </r><m>15 </m><U>val</U></b> put_char : t -&gt; char -&gt; unit
     <b><U>val</U><r> put : t -&gt; string -&gt; unit
     </r><U>val</U></b> to_string : t -&gt; string
     <b><U>val</U><r> reset : t -&gt; unit<PL><B>
<6>16 color.mli</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>val</U></b> compute : string -&gt; string -&gt; string
     <b><U>val</U><r> define : string -&gt; string -&gt; string -&gt; unit
     </r><U>val</U></b> define_named : string -&gt; string -&gt; string -&gt; unit
  <m>15 <b><U>val</U></b></m> retrieve : string -&gt; string
     <b><U>val</U><r> remove : string -&gt; unit
     
     </r><U>type</U></b> saved
     <b><U>val</U><r> checkpoint : unit -&gt; saved
  </r><m>20 </m><U>val</U></b> hot_start : saved -&gt; unit<PL><B>
<6>17 colscan.mli</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: colscan.mli,v 1.5 2001/05/25 12:37:20 maranget Exp $          *)
     (***********************************************************************)
     <b><U>exception</U></b></w> Error <b><U>of</U><r> string
     </r><U>val</U></b> one : Lexing.lexbuf -&gt; float
     <b><U>val</U><r> three : Lexing.lexbuf -&gt; float * float * float
  </r><m>15 </m><U>val</U></b> four : Lexing.lexbuf -&gt; float * float * float * float</TT>
<6><B>18 counter.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>type</U></b></w> saved
     <b><U>val</U><r> checkpoint : unit -&gt; saved
     </r><U>val</U></b> hot_start : saved -&gt; unit
  <m>15 
     <b><U>val</U></b></m> value_counter : string -&gt; int
     <b><U>val</U><r> def_counter: string -&gt; string -&gt; unit
     </r><U>val</U></b> set_counter: string -&gt; int -&gt; unit
     <b><U>val</U><r> add_counter:string -&gt; int -&gt; unit
  </r><m>20 </m><U>val</U></b> step_counter: string -&gt; unit
     <b><U>val</U><r> number_within: string -&gt; string -&gt; unit<PL><B>
<6>19 cross.mli</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>val</U></b> add : string -&gt; string -&gt; unit
     <b><U>val</U><r> fullname : string -&gt; string -&gt; string
     </r><U>val</U></b> change : string -&gt; string -&gt; unit<PL><B>
<6>20 element.mli</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>type</U></b></w> text =
       Style <b><U>of</U><r> string
     | Font </r><U>of</U></b> int
  <m>15 </m>| Color <b><U>of</U><r> string
     
     </r><U>val</U></b> pretty_text : text -&gt; string</TT>
<6><B>21 emisc.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: emisc.mli,v 1.1 2001/05/29 09:23:30 maranget Exp $          *)
     (***********************************************************************)
     
     <b><U>val</U></b></w> basefont : int ref
     <b><U>val</U><r> reset : unit -&gt; unit<PL><B>
<6>22 entry.mli</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     </w><U>type</U></b> key = string list * string list
     
     <b><U>exception</U><r> NoGood
     </r><U>exception</U></b> Fini
  <m>15 
     <b><U>val</U></b></m> read_key : Lexing.lexbuf -&gt; key * string option
     <b><U>val</U><r> read_indexentry : Lexing.lexbuf -&gt; string * string<PL><B>
<6>23 esponja.mli</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: esponja.mli,v 1.1 2001/05/25 12:37:21 maranget Exp $           *)
     (***********************************************************************)
     </w><U>val</U></b> pess : bool ref
     <b><U>val</U><r> move : bool ref
     
  </r><m>15 </m><U>val</U></b> process : string -&gt; in_channel -&gt; out_channel -&gt; bool
     <b><U>val</U><r> file : string -&gt; bool<PL><B>
<6>24 explode.mli</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: explode.mli,v 1.4 2001/05/28 17:28:55 maranget Exp $          *)
     (***********************************************************************)
     
     </w><U>val</U></b> trees : Lexeme.style Tree.t list -&gt; Htmltext.style Tree.t list<PL><B>
<6>25 foot.mli</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>type</U></b></w> saved
     <b><U>val</U><r> checkpoint : unit -&gt; saved
     </r><U>val</U></b> hot_start : saved -&gt; unit
  <m>15 
     
     <b><U>val</U></b></m> step_anchor : int -&gt; unit
     <b><U>val</U><r> get_anchor : int -&gt; int
     </r><U>val</U></b> register : int -&gt; string -&gt; string -&gt; unit
  <m>20 <b><U>val</U></b></m> flush : (string -&gt; unit)  -&gt; string -&gt; string -&gt; unit
     <b><U>val</U></b> some : bool ref</TT>
<6><B>26 get.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: get.mli,v 1.12 2001/05/25 12:37:22 maranget Exp $             *)
     (***********************************************************************)
     <b><U>open</U></b></w> Lexstate
     
     <b><U>exception</U><r> Error </r><U>of</U></b> string
  <m>15 
     <b><U>val</U></b></m> init :
       (string arg -&gt; string) -&gt;
       ((Lexing.lexbuf -&gt; unit) -&gt; Lexing.lexbuf -&gt; string) -&gt;
       (string -&gt; unit) -&gt; (string -&gt; unit) -&gt;
  <m>20   <r>(Lexing.lexbuf -&gt; string) -&gt;
       (Lexing.lexbuf -&gt; unit) -&gt; unit
     
     <b><U>type</U><r> saved
     </r><U>val</U></b> check : unit -&gt; saved
  </r>25 <b><U>val</U></b></m> hot : saved -&gt; unit
     
     <b><U>val</U><r> get_int : string arg -&gt; int
     </r><U>val</U></b> get_bool : string arg -&gt; bool
     <b><U>val</U><r> get_length : string -&gt; Length.t<PL><B>
<6>27 hot.mli</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: hot.mli,v 1.3 2001/05/25 12:37:23 maranget Exp $              *)
     (***********************************************************************)
     </w><U>type</U></b> saved
     
     <b><U>val</U><r> checkpoint : unit -&gt; saved
  </r><m>15 </m><U>val</U></b> start : saved -&gt; unit<PL><B>
<6>28 htmllex.mli</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: htmllex.mli,v 1.4 2001/05/28 17:28:55 maranget Exp $          *)
     (***********************************************************************)
     <b><U>exception</U></b></w> Error <b><U>of</U><r> string
     
     </r><U>val</U></b> ptop : unit -&gt; unit
  <m>15 <b><U>val</U></b></m> to_string : Lexeme.token -&gt; string
     <b><U>val</U><r> cost : Lexeme.style -&gt; int * int
     </r><U>val</U></b> reset : unit -&gt; unit
     <b><U>val</U></b> next_token : Lexing.lexbuf -&gt; Lexeme.token</TT>
<6><B>29 html.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     <b><U>open</U></b></w> Lexstate
     
         <b><U>exception</U><r> Error </r><U>of</U></b> string
         <b><U>type</U><r> block
  </r><m>15 
         </m><U>val</U></b> iso : char -&gt; string
         <b><U>val</U><r> iso_string : string -&gt; string
     
         </r><U>val</U></b> set_out : Out.t -&gt; unit
  <m>20     <b><U>val</U></b></m> stop : unit -&gt; unit
         <b><U>val</U><r> restart : unit -&gt; unit
         </r><U>val</U></b> get_last_closed : unit -&gt; block
         <b><U>val</U><r> set_last_closed : block -&gt; unit
         </r><U>val</U></b> is_empty : unit -&gt; bool
  <m>25 
         <b><U>val</U></b></m> get_fontsize : unit -&gt; int
         <b><U>val</U><r> nostyle : unit -&gt; unit
         </r><U>val</U></b> clearstyle : unit -&gt; unit
         <b><U>val</U><r> open_mod : Element.text -&gt; unit
  </r><m>30     </m><U>val</U></b> erase_mods : Element.text list -&gt; unit
         <b><U>val</U><r> par : int option -&gt; unit
         </r><U>val</U></b> forget_par : unit -&gt; int option
         <b><U>val</U><r> open_block : string -&gt; string -&gt; unit
         </r><U>val</U></b> close_block : string -&gt; unit
  <m>35     <b><U>val</U></b></m> force_block : string -&gt; string -&gt; unit
         <b><U>val</U><r> insert_block : string -&gt; string -&gt; unit
         </r><U>val</U></b> insert_attr : string -&gt; string -&gt; unit
     
         <b><U>val</U><r> open_maths : bool -&gt; unit
  </r><m>40     </m><U>val</U></b> close_maths : bool -&gt; unit
         <b><U>val</U><r> open_display : unit -&gt; unit
         </r><U>val</U></b> close_display : unit -&gt; unit
         <b><U>val</U><r> item_display : unit -&gt; unit
         </r><U>val</U></b> force_item_display : unit -&gt; unit
  <m>45     <b><U>val</U></b></m> erase_display : unit -&gt; unit
     
         <b><U>val</U><r> standard_sup_sub :
             (string arg -&gt; unit) -&gt; (unit -&gt; unit) -&gt; string arg -&gt; string arg -&gt; bool -&gt; unit
         </r><U>val</U></b> limit_sup_sub :
  <m>50         <r>(string arg -&gt; unit) -&gt; (unit -&gt; unit) -&gt; string arg -&gt; string arg -&gt; bool -&gt; unit
         <b><U>val</U></b> int_sup_sub :
             bool -&gt; int -&gt;
               (string arg -&gt; unit) -&gt; (unit -&gt; unit) -&gt; string arg -&gt; string arg -&gt; bool -&gt; unit
     
  </r>55     <b><U>val</U></b></m> over : bool -&gt; Lexing.lexbuf -&gt; unit
         <b><U>val</U><r> left : string -&gt; (int -&gt; unit) -&gt; unit
         </r><U>val</U></b> right : string -&gt; int
     
         <b><U>val</U><r> set_dcount : string -&gt; unit
  </r><m>60     </m><U>val</U></b> item  : unit -&gt; unit
         <b><U>val</U><r> nitem : unit -&gt; unit
         </r><U>val</U></b> ditem : (string -&gt; unit) -&gt; string -&gt; unit
         <b><U>val</U><r> erase_block : string -&gt; unit
         </r><U>val</U></b> open_group : string -&gt; unit
  <m>65     <b><U>val</U></b></m> open_aftergroup : (string -&gt; string) -&gt; unit
         <b><U>val</U><r> close_group : unit -&gt; unit
         </r><U>val</U></b> put : string -&gt; unit
         <b><U>val</U><r> put_char : char -&gt; unit
         </r><U>val</U></b> flush_out : unit -&gt; unit
  <m>70     <b><U>val</U></b></m> skip_line : unit -&gt; unit
     
         <b><U>val</U><r> loc_name : string -&gt; unit
     
         </r><U>val</U></b> open_chan : out_channel  -&gt; unit
  <m>75     <b><U>val</U></b></m> close_chan : unit -&gt; unit
         <b><U>val</U><r> to_string : (unit -&gt; unit) -&gt; string
         </r><U>val</U></b> to_style : (unit -&gt; unit) -&gt; Element.text list
         <b><U>val</U><r> get_current_output : unit -&gt; string
     
  </r><m>80     </m><U>val</U></b> finalize : bool -&gt; unit
     
         <b><U>val</U><r> horizontal_line : string -&gt; Length.t -&gt; Length.t -&gt; unit
         </r><U>val</U></b> put_separator : unit -&gt; unit
         <b><U>val</U><r> unskip : unit -&gt; unit
  </r><m>85     </m><U>val</U></b> put_tag : string -&gt; unit
         <b><U>val</U><r> put_nbsp : unit -&gt; unit
         </r><U>val</U></b> put_open_group : unit -&gt; unit
         <b><U>val</U><r> put_close_group : unit -&gt; unit
         </r><U>val</U></b> put_in_math : string -&gt; unit
  <m>90 
     
         <b><U>val</U></b></m> open_table : bool -&gt; string -&gt; unit
         <b><U>val</U><r> new_row : unit -&gt; unit
         </r><U>val</U></b> open_cell : Tabular.format -&gt; int -&gt; int -&gt; unit
  <m>95     <b><U>val</U></b></m> erase_cell : unit -&gt; unit
         <b><U>val</U><r> close_cell : string -&gt; unit
         </r><U>val</U></b> do_close_cell : unit -&gt; unit
         <b><U>val</U><r> open_cell_group : unit -&gt; unit
         </r><U>val</U></b> close_cell_group : unit -&gt; unit
 <m>100     <b><U>val</U></b></m> erase_cell_group : unit -&gt; unit
         <b><U>val</U><r> close_row : unit -&gt; unit
         </r><U>val</U></b> erase_row : unit -&gt; unit
         <b><U>val</U><r> close_table : unit -&gt; unit
         </r><U>val</U></b> make_border : string -&gt; unit
 <m>105     <b><U>val</U></b></m> make_inside : string -&gt; bool -&gt; unit
         <b><U>val</U><r> make_hline : int -&gt; bool -&gt; unit
     
         </r><U>val</U></b> infomenu : string -&gt; unit
         <b><U>val</U><r> infonode : string -&gt; string -&gt; string -&gt; unit
 </r><m>110     </m><U>val</U></b> infoextranode : string -&gt; string -&gt; string -&gt; unit
     
         <b><U>val</U><r> image : string -&gt; string -&gt; unit
     
         </r><U>type</U></b> saved
 <m>115     <b><U>val</U></b></m> check : unit -&gt; saved
         <b><U>val</U><r> hot : saved -&gt; unit<PL><B>
<6>30 htmlparse.mli</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: htmlparse.mli,v 1.4 2001/05/28 17:28:55 maranget Exp $        *)
     (***********************************************************************)
     </w><U>exception</U></b> Error <b><U>of</U><r> string
     
     </r><U>val</U></b> reset : unit -&gt; unit
  <m>15 <b><U>val</U></b></m> main : Lexing.lexbuf -&gt; Lexeme.style Tree.t list<PL><B>
<6>31 htmltext.mli</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: htmltext.mli,v 1.5 2001/05/28 17:28:56 maranget Exp $         *)
     (***********************************************************************)
     <b><U>exception</U></b></w> No
     
     <b><U>type</U><r> tsize = Int </r><U>of</U></b> int | Big | Small
  <m>15 <b><U>type</U></b></m> nat =
         Style <b><U>of</U><r> Lexeme.tag
       | Size </r><U>of</U></b> tsize
       | Color <b><U>of</U><r> string
       | Face </r><U>of</U></b> string
  <m>20   <r>| Other
     
     <b><U>type</U><r> t_style = { nat : nat; txt : string; ctxt : string; }
     </r><U>type</U></b> style = t_style list
     
  </r>25 <b><U>val</U></b></m> cost : style -&gt; int * int
     <b><U>exception</U><r> NoProp
     </r><U>val</U></b> get_prop : nat -&gt; (nat -&gt; bool)
     <b><U>val</U><r> is_font : nat -&gt; bool
     </r><U>val</U></b> font_props : (nat -&gt; bool) list
  <m>30 <b><U>val</U></b></m> neutral_prop : (nat -&gt; bool) -&gt; bool
     <b><U>val</U><r> same_style : t_style -&gt; t_style -&gt; bool
     
     </r><U>type</U></b> env = t_style list
     <b><U>exception</U><r> Split </r><U>of</U></b> t_style * env
  <m>35 
     <b><U>val</U></b></m> add_style : Lexeme.style -&gt; env -&gt; env
     
     
     <b><U>val</U></b> blanksNeutral : t_style -&gt; bool</TT>
<6><B>32 imageManager.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>module</U> <U>type</U></b></w> S =
       <b><U>sig</U><m>
     
  15     </m><U>val</U></b> start : unit -&gt; unit
         <b><U>val</U><r> stop : unit -&gt; unit
         </r><U>val</U></b> restart : unit -&gt; unit
     
         <b><U>val</U><r> put_char : char -&gt; unit
  </r><m>20     </m><U>val</U></b> put : string -&gt; unit
     
         <b><U>val</U><r> dump :  string -&gt; (Lexing.lexbuf -&gt; unit) -&gt; Lexing.lexbuf -&gt; unit
         </r><U>val</U></b> page : unit -&gt; unit
     
  <m>25     <b><U>val</U></b></m> finalize : bool -&gt; bool
       <b><U>end</U><w><r><PL><B>
<6>33 image.mli</6>
</B></PL></r> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>val</U></b> start : unit -&gt; unit
     <b><U>val</U><r> stop : unit -&gt; unit
     </r><U>val</U></b> restart : unit -&gt; unit
  <m>15 
     <b><U>val</U></b></m> put_char : char -&gt; unit
     
     <b><U>val</U><r> put : string -&gt; unit
     
  </r><m>20 </m><U>val</U></b> dump :  string -&gt; (Lexing.lexbuf -&gt; unit) -&gt; Lexing.lexbuf -&gt; unit
     <b><U>val</U><r> page : unit -&gt; unit
     
     </r><U>val</U></b> finalize : bool -&gt; bool<PL><B>
<6>34 index.mli</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><b><U>val</U><r> newindex : string -&gt; string -&gt; string -&gt; string -&gt; unit
     </r><U>val</U></b> changename : string -&gt; string -&gt; unit
     <b><U>val</U><r> treat:  string -&gt; string -&gt; string -&gt; string
  </r><m>15 </m><U>val</U></b> print: (string -&gt; unit) -&gt; string -&gt; unit
     <b><U>val</U><r> finalize : bool -&gt; bool<PL><B>
<6>35 info.mli</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     </w><U>open</U></b> Lexstate
     
         <b><U>exception</U><r> Error </r><U>of</U></b> string
         <b><U>type</U><r> block
  </r><m>15 
         </m><U>val</U></b> iso : char -&gt; string
         <b><U>val</U><r> iso_string : string -&gt; string
     
         </r><U>val</U></b> set_out : Out.t -&gt; unit
  <m>20     <b><U>val</U></b></m> stop : unit -&gt; unit
         <b><U>val</U><r> restart : unit -&gt; unit
         </r><U>val</U></b> get_last_closed : unit -&gt; block
         <b><U>val</U><r> set_last_closed : block -&gt; unit
         </r><U>val</U></b> is_empty : unit -&gt; bool
  <m>25 
         <b><U>val</U></b></m> get_fontsize : unit -&gt; int
         <b><U>val</U><r> nostyle : unit -&gt; unit
         </r><U>val</U></b> clearstyle : unit -&gt; unit
         <b><U>val</U><r> open_mod : Element.text -&gt; unit
  </r><m>30     </m><U>val</U></b> erase_mods : Element.text list -&gt; unit
         <b><U>val</U><r> par : int option -&gt; unit
         </r><U>val</U></b> forget_par : unit -&gt; int option
         <b><U>val</U><r> open_block : string -&gt; string -&gt; unit
         </r><U>val</U></b> close_block : string -&gt; unit
  <m>35     <b><U>val</U></b></m> force_block : string -&gt; string -&gt; unit
         <b><U>val</U><r> insert_block : string -&gt; string -&gt; unit
         </r><U>val</U></b> insert_attr : string -&gt; string -&gt; unit
     
         <b><U>val</U><r> open_maths : bool -&gt; unit
  </r><m>40     </m><U>val</U></b> close_maths : bool -&gt; unit
         <b><U>val</U><r> open_display : unit -&gt; unit
         </r><U>val</U></b> close_display : unit -&gt; unit
         <b><U>val</U><r> item_display : unit -&gt; unit
         </r><U>val</U></b> force_item_display : unit -&gt; unit
  <m>45     <b><U>val</U></b></m> erase_display : unit -&gt; unit
     
         <b><U>val</U><r> standard_sup_sub :
             (string arg -&gt; unit) -&gt; (unit -&gt; unit) -&gt; string arg -&gt; string arg -&gt; bool -&gt; unit
         </r><U>val</U></b> limit_sup_sub :
  <m>50         <r>(string arg -&gt; unit) -&gt; (unit -&gt; unit) -&gt; string arg -&gt; string arg -&gt; bool -&gt; unit
         <b><U>val</U></b> int_sup_sub :
             bool -&gt; int -&gt;
               (string arg -&gt; unit) -&gt; (unit -&gt; unit) -&gt; string arg -&gt; string arg -&gt; bool -&gt; unit
     
  </r>55     <b><U>val</U></b></m> over : bool -&gt; Lexing.lexbuf -&gt; unit
         <b><U>val</U><r> left : string -&gt; (int -&gt; unit) -&gt; unit
         </r><U>val</U></b> right : string -&gt; int
     
         <b><U>val</U><r> set_dcount : string -&gt; unit
  </r><m>60     </m><U>val</U></b> item  : unit -&gt; unit
         <b><U>val</U><r> nitem : unit -&gt; unit
         </r><U>val</U></b> ditem : (string -&gt; unit) -&gt; string -&gt; unit
         <b><U>val</U><r> erase_block : string -&gt; unit
         </r><U>val</U></b> open_group : string -&gt; unit
  <m>65     <b><U>val</U></b></m> open_aftergroup : (string -&gt; string) -&gt; unit
         <b><U>val</U><r> close_group : unit -&gt; unit
         </r><U>val</U></b> put : string -&gt; unit
         <b><U>val</U><r> put_char : char -&gt; unit
         </r><U>val</U></b> flush_out : unit -&gt; unit
  <m>70     <b><U>val</U></b></m> skip_line : unit -&gt; unit
     
         <b><U>val</U><r> loc_name : string -&gt; unit
     
         </r><U>val</U></b> open_chan : out_channel  -&gt; unit
  <m>75     <b><U>val</U></b></m> close_chan : unit -&gt; unit
         <b><U>val</U><r> to_string : (unit -&gt; unit) -&gt; string
         </r><U>val</U></b> to_style : (unit -&gt; unit) -&gt; Element.text list
         <b><U>val</U><r> get_current_output : unit -&gt; string
     
  </r><m>80     </m><U>val</U></b> finalize : bool -&gt; unit
     
         <b><U>val</U><r> horizontal_line : string -&gt; Length.t -&gt; Length.t -&gt; unit
         </r><U>val</U></b> put_separator : unit -&gt; unit
         <b><U>val</U><r> unskip : unit -&gt; unit
  </r><m>85     </m><U>val</U></b> put_tag : string -&gt; unit
         <b><U>val</U><r> put_nbsp : unit -&gt; unit
         </r><U>val</U></b> put_open_group : unit -&gt; unit
         <b><U>val</U><r> put_close_group : unit -&gt; unit
         </r><U>val</U></b> put_in_math : string -&gt; unit
  <m>90 
     
         <b><U>val</U></b></m> open_table : bool -&gt; string -&gt; unit
         <b><U>val</U><r> new_row : unit -&gt; unit
         </r><U>val</U></b> open_cell : Tabular.format -&gt; int -&gt; int -&gt; unit
  <m>95     <b><U>val</U></b></m> erase_cell : unit -&gt; unit
         <b><U>val</U><r> close_cell : string -&gt; unit
         </r><U>val</U></b> do_close_cell : unit -&gt; unit
         <b><U>val</U><r> open_cell_group : unit -&gt; unit
         </r><U>val</U></b> close_cell_group : unit -&gt; unit
 <m>100     <b><U>val</U></b></m> erase_cell_group : unit -&gt; unit
         <b><U>val</U><r> close_row : unit -&gt; unit
         </r><U>val</U></b> erase_row : unit -&gt; unit
         <b><U>val</U><r> close_table : unit -&gt; unit
         </r><U>val</U></b> make_border : string -&gt; unit
 <m>105     <b><U>val</U></b></m> make_inside : string -&gt; bool -&gt; unit
         <b><U>val</U><r> make_hline : int -&gt; bool -&gt; unit
     
         </r><U>val</U></b> infomenu : string -&gt; unit
         <b><U>val</U><r> infonode : string -&gt; string -&gt; string -&gt; unit
 </r><m>110     </m><U>val</U></b> infoextranode : string -&gt; string -&gt; string -&gt; unit
     
         <b><U>val</U><r> image : string -&gt; string -&gt; unit
     
         </r><U>type</U></b> saved
 <m>115     <b><U>val</U></b></m> check : unit -&gt; saved
         <b><U>val</U><r> hot : saved -&gt; unit<PL><B>
<6>36 latexmacros.mli</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     </w><U>open</U></b> Lexstate
     
     <b><U>exception</U><r> Failed
     
  </r><m>15 </m><U>type</U></b> saved
     <b><U>val</U><r> checkpoint : unit -&gt; saved
     </r><U>val</U></b> hot_start : saved -&gt; unit
     <b><U>val</U><r> pretty_table : unit -&gt; unit
     
  </r><m>20 </m><U>val</U></b> register_init : string -&gt; (unit -&gt; unit) -&gt; unit
     <b><U>val</U><r> exec_init : string -&gt; unit
     
     </r><U>val</U></b> open_group : unit -&gt; unit
     <b><U>val</U><r> close_group : unit -&gt; unit
  </r><m>25 </m><U>val</U></b> get_level : unit -&gt; int
     
     <b><U>val</U><r> exists : string -&gt; bool
     </r><U>val</U></b> find : string -&gt; Lexstate.pat * Lexstate.action
     <b><U>val</U><r> pretty_macro : Lexstate.pat -&gt; Lexstate.action -&gt; unit
  </r><m>30 </m><U>val</U></b> def : string -&gt; Lexstate.pat -&gt; Lexstate.action -&gt; unit
     <b><U>val</U><r> global_def : string -&gt; Lexstate.pat -&gt; Lexstate.action -&gt; unit
     
     </r><w>(******************)
     (* For inside use *)
  <m>35 </m>(******************)
     
     (* raises Failed if already defined *)
     </w><U>val</U></b> def_init : string -&gt; (Lexing.lexbuf -&gt; unit) -&gt; unit
     <w>(* raises Failed if not defined *)
  <m>40 </m><b><U>val</U></b></w> find_fail : string -&gt; Lexstate.pat * Lexstate.action
     
     <w>(*
       replace name new,
          Send back the Some (old definition for name) or None
  <m>45 
       </m>- if new is Some (def)
             then def replaces the old definition, or a definition is created
       - if new is None, then undefine the last local binding for name.
     *)
  <m>50 <b><U>val</U><r> replace : string -&gt; (Lexstate.pat * Lexstate.action) option -&gt;
       (Lexstate.pat * Lexstate.action) option
     
     
     
  </r></b>55 <b><U>val</U><r> invisible : string -&gt; bool<PL><B>
<6>37 latexscan.mli</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     </w><U>open</U><r> Lexstate
     
     <b><U>module</U> <U>type</U></b> S =
       </r><U>sig</U></b>
  15     </m>(* external entry points *)
         <b><U>val</U></b></w> no_prelude : unit -&gt; unit
         <b><U>val</U><r> main : Lexing.lexbuf -&gt; unit
         </r><U>val</U></b> print_env_pos : unit -&gt; unit
     
  <m>20     <w>(* additional resources needed for extension modules. *)
         <b><U>val</U><r> cur_env : string ref
         </r><U>val</U><r> new_env : string -&gt; unit
         <b><U>val</U><r> close_env : string -&gt; unit
         </r><U>val</U></b> echo_toimage : unit -&gt; bool
  <m>25     <b><U>val</U></b></m> echo_global_toimage : unit -&gt; bool
     
         <b><U>val</U><r> fun_register : (unit -&gt; unit) -&gt; unit
         </r><U>val</U></b> newif_ref : string -&gt; bool ref -&gt; unit
         <b><U>val</U><r> top_open_block : string -&gt; string -&gt; unit
  </r><m>30     </m><U>val</U></b> top_close_block : string -&gt; unit
         <b><U>val</U><r> check_alltt_skip : Lexing.lexbuf -&gt; unit
         </r><U>val</U></b> skip_pop : Lexing.lexbuf -&gt; unit
     </r></b>(* ``def'' functions for initialisation only *)
         <b><U>val</U><r> def_code : string -&gt; (Lexing.lexbuf -&gt; unit) -&gt; unit
  </r><m>35     </m><U>val</U><r> def_name_code : string -&gt; (string -&gt; Lexing.lexbuf -&gt; unit) -&gt; unit
         <b><U>val</U><r> def_fun : string -&gt; (string -&gt; string) -&gt; unit
         </r><U>val</U></b> get_this_main : string -&gt; string
         <b><U>val</U><r> check_this_main : string -&gt; bool
         </r><U>val</U></b> get_prim : string -&gt; string
  <m>40     <b><U>val</U></b></m> get_prim_arg : Lexing.lexbuf -&gt; string
         <b><U>val</U><r> get_prim_opt : string -&gt; Lexing.lexbuf -&gt; string
         </r><U>val</U></b> get_csname : Lexing.lexbuf -&gt; string
     <b><U>end</U><m>
     
  45 </m><U>module</U></b> Make (Dest : OutManager.S) (Image : ImageManager.S) : S<PL><B>
<6>38 length.mli</6>
</B></PL></r></b> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   </w>5 <w>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  </w>10 <w>(*  $Id: length.mli,v 1.6 2001/05/25 12:37:26 maranget Exp $           *)
     (***********************************************************************)
     <b><U>val</U><r> font : int
     
     </r><U>type</U><r> t = Char <b><U>of</U><r> int | Pixel </r><U>of</U></b> int | Percent <b><U>of</U><r> int | No </r><U>of</U></b> string | Default
  <m>15 <b><U>val</U></b></m> pretty : t -&gt; string
     
     <b><U>val</U><r> font : int
     </r><U>val</U></b> pixel_to_char : int -&gt; int
     <b><U>val</U><r> char_to_pixel : int -&gt; int
  </r><m>20 </m><U>val</U></b> main: Lexing.lexbuf -&gt; t<PL><B>
<6>39 lexeme.mli</6>
</B></PL></r></b> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   </w>5 <w>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  </w>10 <w>(*  $Id: lexeme.mli,v 1.4 2001/05/28 17:28:56 maranget Exp $           *)
     (***********************************************************************)
     <b><U>type</U><r> tag =
       | TT |I |B |BIG |SMALL
       | STRIKE | S |U |FONT
  <m>15   </m>| EM |STRONG |DFN |CODE |SAMP
       | KBD |VAR |CITE |ABBR |ACRONYM
       | Q |SUB |SUP | A | SCRIPT | SPAN
     
     </r><U>type</U><r> atag =
  <m>20   <r>| SIZE <b><U>of</U><r> string | COLOR </r><U>of</U></b> string | FACE <b><U>of</U><r> string | OTHER
     
     </r><U>type</U></b> attr = atag * string
     
     <b><U>type</U></b> attrs = attr list
  </r>25 
     <b><U>type</U></b></m> token =
       | Open <b><U>of</U><r> tag * attrs * string
       | Close </r><U>of</U></b> tag * string
       | Text <b><U>of</U><r> string
  <m>30   </m>| Blanks </r><U>of</U></b> string
       | Eof
     
     <b><U>type</U></b> style =
      {tag : tag ; attrs : attrs ; txt : string ; ctxt : string}<PL><B>
<6>40 lexstate.mli</6>
</B></PL></r></b> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   </w>5 <w>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  </w>10 <w>(***********************************************************************)
     
     
     <b><U>type</U><r> action =
       | Subst </r><U>of</U><r> string
  <m>15   <r>| Toks <b><U>of</U><r> string list
       | CamlCode </r><U>of</U></b> (Lexing.lexbuf -&gt; unit)
     <b><U>val</U></b> pretty_action : action -&gt; unit
     
     
  </r>20 <b><U>type</U></b></m> pat = string list * string list
     <b><U>val</U><r> pretty_pat : pat -&gt; unit
     </r><U>val</U></b> is_subst : action -&gt; bool
     <b><U>val</U><r> latex_pat: string list -&gt; int -&gt; pat
     </r><U>val</U></b> zero_pat : pat
  <m>25 <b><U>val</U></b></m> one_pat : pat
     
     <b><U>type</U><r> subst
     </r><U>type</U></b> 'a arg = {arg : 'a ; subst : subst }
     <b><U>val</U><r> mkarg : 'a -&gt; subst -&gt; 'a arg
  </r><m>30 </m><U>val</U></b> string_to_arg : 'a -&gt; 'a arg
     
     <b><U>val</U><r> top_subst : subst
     </r><U>val</U></b> get_subst : unit -&gt; subst
     
  <m>35 <b><U>exception</U></b></m> Error <b><U>of</U><r> string
     </r><U>type</U></b> alltt = Not | Inside | Macro
     <b><U>val</U><r> effective : alltt -&gt; bool
     
     </r><U>val</U></b> raw_chars : bool ref
  <m>40 <b><U>val</U></b></m> display : bool ref
     <b><U>val</U><r> in_math : bool ref
     </r><U>val</U></b> alltt : alltt ref
     <b><U>val</U><r> french : bool ref
     </r><U>val</U></b> optarg : bool ref
  <m>45 <b><U>val</U></b></m> styleloaded : bool ref
     <b><U>val</U><r> activebrace : bool ref
     </r><U>val</U></b> html : bool ref
     <b><U>val</U><r> text : bool ref
     </r><U>val</U></b> alltt_loaded : bool ref
  <m>50 
     <b><U>val</U></b></m> is_plain : char -&gt; bool
     <b><U>val</U><r> set_plain : char -&gt; unit
     </r><U>val</U></b> unset_plain : char -&gt; unit
     <b><U>val</U><r> plain_back : bool -&gt; char -&gt; unit
  </r><m>55 
     </m><U>val</U></b> withinLispComment : bool ref
     <b><U>val</U><r> afterLispCommentNewlines : int ref
     
     </r><U>type</U></b> case = Upper | Lower | Neutral
  <m>60 
     <b><U>val</U></b></m> case : case ref
     
     <b><U>type</U><r> closenv
     </r><U>val</U></b> top_level : unit -&gt; bool
  <m>65 <b><U>val</U></b></m> is_top : subst -&gt; bool
     
     <b><U>val</U><r> prerr_args : unit -&gt; unit
     </r><U>val</U></b> full_pretty_subst : subst -&gt; unit
     
  <m>70 <b><U>val</U></b></m> pretty_lexbuf : Lexing.lexbuf -&gt; unit
     
     
     <b><U>val</U><r> scan_arg : (string arg -&gt; 'a) -&gt; int -&gt; 'a
     </r><U>val</U></b> scan_body :
  <m>75   <r>(action -&gt; 'a) -&gt; action -&gt; subst -&gt; 'a
     
     <b><U>val</U><r> stack_lexbuf : Lexing.lexbuf Stack.t
     </r><U>val</U></b> previous_lexbuf : unit -&gt; Lexing.lexbuf
     <b><U>val</U></b> record_lexbuf : Lexing.lexbuf -&gt; subst -&gt; unit
  </r>80 <b><U>val</U></b></m> top_lexstate : unit -&gt; bool
     
     </r></b>(* Saving and restoring lexstates on a stack *)
     <b><U>val</U><r> protect_save_string : (Lexing.lexbuf -&gt; string) -&gt; Lexing.lexbuf -&gt; string
     </r><U>val</U><r> save_lexstate : unit -&gt; unit
  <m>85 <b><U>val</U></b></m> restore_lexstate : unit -&gt; unit
     <b><U>val</U><r> start_lexstate : unit -&gt; unit
     </r><U>val</U></b> start_lexstate_subst : subst -&gt; unit
     
     </r></b>(* Total checkpoint of lexstate *)
  </w>90 <b><U>type</U></b></m> saved_lexstate
     <b><U>val</U><r> check_lexstate : unit -&gt; saved_lexstate
     </r><U>val</U></b> hot_lexstate : saved_lexstate -&gt; unit
     
     <b><U>val</U><r> flushing : bool ref
  </r><m>95 </m><U>val</U></b> stack_in_math : bool Stack.t
     <b><U>val</U><r> stack_display : bool Stack.t
     </r><U>val</U></b> stack_alltt : alltt Stack.t
     
     <b><U>val</U><r> start_normal: subst -&gt; unit
 </r><m>100 </m><U>val</U></b> end_normal : unit -&gt; unit
     
     <w>(* Super/Sub-script parsing *)
       <b><U>type</U></b></w> sup_sub = {
         limits : Misc.limits option;
 <m>105     <r>sup : string arg;
         sub : string arg;
       }
     
     <b><U>val</U></b> unoption : string arg option -&gt; string arg
 </r>110 <b><U>val</U></b></m> save_sup_sub : Lexing.lexbuf -&gt; sup_sub
     <b><U>val</U><r> save_sup : Lexing.lexbuf -&gt; string arg option
     </r><U>val</U></b> save_sub : Lexing.lexbuf -&gt; string arg option
     <w>(* Argument parsing *)
     <b><U>type</U></b></w> ok = | No <b><U>of</U><r> string | Yes </r><U>of</U></b> string
 <m>115 <b><U>val</U></b></m> from_ok : ok arg -&gt; string arg
     
     <b><U>val</U><r> save_arg : Lexing.lexbuf -&gt; string arg
     </r><U>val</U></b> save_filename : Lexing.lexbuf -&gt; string arg
     <b><U>val</U><r> save_verbatim : Lexing.lexbuf -&gt; string arg
 </r><m>120 </m><U>val</U></b> save_opt : string -&gt; Lexing.lexbuf -&gt; string arg
     <b><U>val</U><r> save_opts : string list -&gt; Lexing.lexbuf -&gt; ok arg list
     </r><U>val</U></b> save_arg_with_delim : string -&gt; Lexing.lexbuf -&gt; string arg
     <b><U>val</U><r> pretty_ok : ok -&gt; string
     </r><U>val</U></b> skip_opt : Lexing.lexbuf -&gt; unit
 <m>125 <b><U>val</U></b></m> skip_csname : Lexing.lexbuf -&gt; unit
     
     <b><U>val</U><r> make_stack : string -&gt; pat -&gt; Lexing.lexbuf -&gt; subst
     
     
 </r><m>130 
     </m><U>val</U></b> scan_this : (Lexing.lexbuf -&gt; 'a ) -&gt; string -&gt; 'a
     <b><U>val</U><r> scan_this_arg : (Lexing.lexbuf -&gt; 'a ) -&gt; string arg -&gt; 'a
     </r><U>val</U></b> scan_this_may_cont :
         (Lexing.lexbuf -&gt; 'a ) -&gt; Lexing.lexbuf -&gt; subst -&gt;  string arg -&gt; 'a
 <m>135 
     <b><U>val</U></b></m> real_input_file :
         int -&gt; (Lexing.lexbuf -&gt; unit) -&gt; string -&gt; in_channel -&gt; unit
     <b><U>val</U><r> input_file : int -&gt; (Lexing.lexbuf -&gt; unit) -&gt; string -&gt; unit
     
 </r><m>140 </m><U>val</U></b> register_cell : string -&gt; bool ref -&gt; unit
     <b><U>val</U><r> unregister_cell : string -&gt; unit
     </r><U>type</U></b> saved
     
     <b><U>val</U><r> checkpoint : unit -&gt; saved
 </r><m>145 </m><U>val</U></b> hot_start : saved -&gt; unit<PL><B>
<6>41 location.mli</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>type</U></b></w> saved
     <b><U>val</U><r> check : unit -&gt; saved
     </r><U>val</U></b> hot : saved -&gt; unit
  <m>15 
     <b><U>val</U></b></m> get : unit -&gt; string
     <b><U>val</U><r> set : string -&gt; Lexing.lexbuf -&gt; unit
     </r><U>val</U></b> restore : unit -&gt; unit
     
  <m>20 <b><U>type</U></b></m> t
     <b><U>val</U><r> get_pos : unit -&gt; t
     </r><U>val</U></b> print_pos : unit -&gt; unit
     <b><U>val</U><r> print_fullpos : unit -&gt; unit
     </r><U>val</U></b> print_this_pos : t -&gt; unit
  <m>25 <b><U>val</U></b></m> print_this_fullpos : t -&gt; unit</TT>
<6><B>42 misc.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>exception</U></b></w> Fatal <b><U>of</U><r> string
     </r><U>exception</U></b> NoSupport <b><U>of</U><r> string
     </r><U>exception</U></b> Purposly <b><U>of</U><r> string
  </r><m>15 </m><U>exception</U></b> ScanError <b><U>of</U><r> string
     </r><U>exception</U></b> UserError <b><U>of</U><r> string
     </r><U>exception</U></b> EndInput
     <b><U>exception</U><r> EndDocument
     </r><U>exception</U></b> Close <b><U>of</U><r> string
  </r><m>20 </m><U>exception</U></b> EndOfLispComment <b><U>of</U><r> int </r><w>(* QNC *)
     
     </w><U>val</U></b> hot_start : unit -&gt; unit
     <b><U>val</U><r> verbose : int ref
     </r><U>val</U></b> readverb : int ref
  <m>25 <b><U>val</U></b></m> silent : bool ref
     <b><U>val</U><r> column_to_command : string -&gt; string
     </r><U>val</U></b> warning : string -&gt; unit
     <b><U>val</U><r> print_verb : int -&gt; string -&gt; unit
     </r><U>val</U></b> message : string -&gt; unit
  <m>30 <b><U>val</U></b></m> fatal : string -&gt; 'a
     <b><U>val</U><r> not_supported : string -&gt; 'a
     
     </r><w>(* Copying hash tables, not very nice at present *)
     </w><U>val</U></b> copy_hashtbl : (string, 'a) Hashtbl.t -&gt; (string, 'a) Hashtbl.t -&gt; unit
  <m>35 <b><U>val</U></b></m> clone_hashtbl : (string, 'a) Hashtbl.t -&gt; (string, 'a) Hashtbl.t
     <b><U>val</U><r> copy_int_hashtbl : (int, 'a) Hashtbl.t -&gt; (int, 'a) Hashtbl.t -&gt; unit
     </r><U>val</U></b> clone_int_hashtbl : (int, 'a) Hashtbl.t -&gt; (int, 'a) Hashtbl.t
     
     <b><U>val</U><r> start_env : string -&gt; string
  </r><m>40 </m><U>val</U></b> end_env : string -&gt; string
     
     <b><U>type</U><r> limits = Limits | NoLimits | IntLimits<PL><B>
<6>43 myfiles.mli</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>exception</U></b> Error <b><U>of</U><r> string
     </r><U>exception</U></b> Except
     
  <m>15 <b><U>val</U></b></m> open_tex : string -&gt; string * in_channel
     <b><U>val</U><r> find : string -&gt; string
     </r><U>val</U></b> changed : string -&gt; string -&gt; bool<PL><B>
<6>44 mylib.mli</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>val</U></b></w> static_libdir : string
     <b><U>val</U></b> libdir : string</TT>
<6><B>45 mysys.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>exception</U></b></w> Error <b><U>of</U><r> string
     </r><U>val</U></b> put_from_file : string -&gt; (string -&gt; unit) -&gt; unit
     <b><U>val</U><r> copy_from_lib : string -&gt; string -&gt; unit
  </r><m>15 </m><U>val</U></b> rename : string -&gt; string -&gt; unit
     <b><U>val</U><r> remove : string -&gt; unit<PL><B>
<6>46 noimage.mli</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>val</U></b> start : unit -&gt; unit
     <b><U>val</U><r> stop : unit -&gt; unit
     </r><U>val</U></b> restart : unit -&gt; unit
  <m>15 
     <b><U>val</U></b></m> put_char : char -&gt; unit
     
     <b><U>val</U><r> put : string -&gt; unit
     
  </r><m>20 </m><U>val</U></b> dump :  string -&gt; (Lexing.lexbuf -&gt; unit) -&gt; Lexing.lexbuf -&gt; unit
     <b><U>val</U><r> page : unit -&gt; unit
     
     </r><U>val</U></b> finalize : bool -&gt; bool<PL><B>
<6>47 outManager.mli</6>
</B><w><TT> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     <b><U>open</U><r> Lexstate
     </r><U>module</U> <U>type</U><r> S =
       <b><U>sig</U>
         <U>exception</U></b> Error <b><U>of</U><r> string
  </r><m>15     </m><U>type</U></b> block
     
         <b><U>val</U><r> iso : char -&gt; string
         </r><U>val</U></b> iso_string : string -&gt; string
     
  <m>20     <b><U>val</U></b></m> set_out : Out.t -&gt; unit
         <b><U>val</U><r> stop : unit -&gt; unit
         </r><U>val</U></b> restart : unit -&gt; unit
         <b><U>val</U><r> get_last_closed : unit -&gt; block
         </r><U>val</U></b> set_last_closed : block -&gt; unit
  <m>25     <b><U>val</U></b></m> is_empty : unit -&gt; bool
     
         <b><U>val</U><r> get_fontsize : unit -&gt; int
         </r><U>val</U></b> nostyle : unit -&gt; unit
         <b><U>val</U><r> clearstyle : unit -&gt; unit
  </r><m>30     </m><U>val</U></b> open_mod : Element.text -&gt; unit
         <b><U>val</U><r> erase_mods : Element.text list -&gt; unit
         </r><U>val</U></b> par : int option -&gt; unit
         <b><U>val</U><r> forget_par : unit -&gt; int option
         </r><U>val</U></b> open_block : string -&gt; string -&gt; unit
  <m>35     <b><U>val</U></b></m> close_block : string -&gt; unit
         <b><U>val</U><r> force_block : string -&gt; string -&gt; unit
         </r><U>val</U></b> insert_block : string -&gt; string -&gt; unit
         <b><U>val</U><r> insert_attr : string -&gt; string -&gt; unit
     
  </r><m>40     </m><U>val</U></b> open_maths : bool -&gt; unit
         <b><U>val</U><r> close_maths : bool -&gt; unit
         </r><U>val</U></b> open_display : unit -&gt; unit
         <b><U>val</U><r> close_display : unit -&gt; unit
         </r><U>val</U></b> item_display : unit -&gt; unit
  <m>45     <b><U>val</U></b></m> force_item_display : unit -&gt; unit
         <b><U>val</U><r> erase_display : unit -&gt; unit
     
         </r><U>val</U></b> standard_sup_sub :
             (string arg -&gt; unit) -&gt; (unit -&gt; unit) -&gt; string arg -&gt; string arg -&gt; bool -&gt; unit
  <m>50     <b><U>val</U></b></m> limit_sup_sub :
             (string arg -&gt; unit) -&gt; (unit -&gt; unit) -&gt; string arg -&gt; string arg -&gt; bool -&gt; unit
         <b><U>val</U><r> int_sup_sub :
             bool -&gt; int -&gt;
               (string arg -&gt; unit) -&gt; (unit -&gt; unit) -&gt; string arg -&gt; string arg -&gt; bool -&gt; unit
  </r><m>55 
         </m><U>val</U></b> over : bool -&gt; Lexing.lexbuf -&gt; unit
         <b><U>val</U><r> left : string -&gt; (int -&gt; unit) -&gt; unit
         </r><U>val</U></b> right : string -&gt; int
     
  <m>60     <b><U>val</U></b></m> set_dcount : string -&gt; unit
         <b><U>val</U><r> item  : unit -&gt; unit
         </r><U>val</U></b> nitem : unit -&gt; unit
         <b><U>val</U><r> ditem : (string -&gt; unit) -&gt; string -&gt; unit
         </r><U>val</U></b> erase_block : string -&gt; unit
  <m>65     <b><U>val</U></b></m> open_group : string -&gt; unit
         <b><U>val</U><r> open_aftergroup : (string -&gt; string) -&gt; unit
         </r><U>val</U></b> close_group : unit -&gt; unit
         <b><U>val</U><r> put : string -&gt; unit
         </r><U>val</U></b> put_char : char -&gt; unit
  <m>70     <b><U>val</U></b></m> flush_out : unit -&gt; unit
         <b><U>val</U><r> skip_line : unit -&gt; unit
     
         </r><U>val</U></b> loc_name : string -&gt; unit
     
  <m>75     <b><U>val</U></b></m> open_chan : out_channel  -&gt; unit
         <b><U>val</U><r> close_chan : unit -&gt; unit
         </r><U>val</U></b> to_string : (unit -&gt; unit) -&gt; string
         <b><U>val</U><r> to_style : (unit -&gt; unit) -&gt; Element.text list
         </r><U>val</U></b> get_current_output : unit -&gt; string
  <m>80 
         <b><U>val</U></b></m> finalize : bool -&gt; unit
     
         <b><U>val</U><r> horizontal_line : string -&gt; Length.t -&gt; Length.t -&gt; unit
         </r><U>val</U></b> put_separator : unit -&gt; unit
  <m>85     <b><U>val</U></b></m> unskip : unit -&gt; unit
         <b><U>val</U><r> put_tag : string -&gt; unit
         </r><U>val</U></b> put_nbsp : unit -&gt; unit
         <b><U>val</U><r> put_open_group : unit -&gt; unit
         </r><U>val</U></b> put_close_group : unit -&gt; unit
  <m>90     <b><U>val</U></b></m> put_in_math : string -&gt; unit
     
     
         <b><U>val</U><r> open_table : bool -&gt; string -&gt; unit
         </r><U>val</U></b> new_row : unit -&gt; unit
  <m>95     <b><U>val</U></b></m> open_cell : Tabular.format -&gt; int -&gt; int -&gt; unit
         <b><U>val</U><r> erase_cell : unit -&gt; unit
         </r><U>val</U></b> close_cell : string -&gt; unit
         <b><U>val</U><r> do_close_cell : unit -&gt; unit
         </r><U>val</U></b> open_cell_group : unit -&gt; unit
 <m>100     <b><U>val</U></b></m> close_cell_group : unit -&gt; unit
         <b><U>val</U><r> erase_cell_group : unit -&gt; unit
         </r><U>val</U></b> close_row : unit -&gt; unit
         <b><U>val</U><r> erase_row : unit -&gt; unit
         </r><U>val</U></b> close_table : unit -&gt; unit
 <m>105     <b><U>val</U></b></m> make_border : string -&gt; unit
         <b><U>val</U><r> make_inside : string -&gt; bool -&gt; unit
         </r><U>val</U></b> make_hline : int -&gt; bool -&gt; unit
     
         <b><U>val</U><r> infomenu : string -&gt; unit
 </r><m>110     </m><U>val</U></b> infonode : string -&gt; string -&gt; string -&gt; unit
         <b><U>val</U><r> infoextranode : string -&gt; string -&gt; string -&gt; unit
     
         </r><U>val</U></b> image : string -&gt; string -&gt; unit
     
 <m>115     <b><U>type</U></b></m> saved
         <b><U>val</U><r> check : unit -&gt; saved
         </r><U>val</U></b> hot : saved -&gt; unit
     </r><U>end</U></b></TT></w>
<6><B>48 out.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>type</U></b></w> t
     
     <b><U>val</U><r> free : t -&gt; unit
  </r><m>15 </m><U>val</U></b> create_buff : unit -&gt; t
     <b><U>val</U><r> create_chan : out_channel -&gt; t
     </r><U>val</U></b> create_null : unit -&gt; t
     <b><U>val</U><r> is_null : t -&gt; bool
     </r><U>val</U></b> is_empty : t -&gt; bool
  <m>20 
     <b><U>val</U></b></m> reset : t -&gt; unit
     <b><U>val</U><r> is_empty: t -&gt; bool
     
     </r><U>val</U></b> put : t -&gt; string -&gt; unit
  <m>25 <b><U>val</U></b></m> blit : t -&gt; Lexing.lexbuf -&gt; unit
     <b><U>val</U><r> put_char : t -&gt; char -&gt; unit
     </r><U>val</U></b> flush: t -&gt; unit
     <b><U>val</U><r> get_pos : t -&gt; int
     </r><U>val</U></b> erase_start : int -&gt; t -&gt; unit
  <m>30 
     <b><U>val</U></b></m> iter : (char -&gt; unit) -&gt; t -&gt; unit
     <b><U>val</U><r> to_string : t -&gt; string
     </r><U>val</U></b> to_chan : out_channel -&gt; t -&gt; unit
     <b><U>val</U><r> copy : t -&gt; t -&gt; unit
  </r><m>35 </m><U>val</U></b> copy_fun : (string -&gt; string) -&gt; t -&gt; t -&gt; unit
     <b><U>val</U><r> copy_no_tag : t -&gt; t -&gt; unit
     </r><U>val</U></b> close : t -&gt; unit
     
     <b><U>val</U><r> debug : out_channel -&gt; t -&gt; unit
  </r><m>40 </m><U>val</U></b> unskip : t -&gt; unit<PL><B>
<6>49 package.mli</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
   <m>5 </m>(*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     (*  $Id: package.mli,v 1.2 1999/10/13 08:21:26 maranget Exp $    *)
     
     <b><U>module</U> <U>type</U></b></w> S = <b><U>sig</U>  <U>end</U><m>
  15 
     </m><U>module</U></b> Make
         (Dest : OutManager.S) (Image : ImageManager.S)
         (Scan : Latexscan.S) : S</TT>
<6><B>50 parse_opts.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>type</U></b></w> input = File <b><U>of</U><r> string | Prog </r><U>of</U></b> string
     
     <b><U>val</U><r> symbols : bool ref
  </r><m>15 </m><U>val</U></b> iso : bool ref
     <b><U>type</U><r> language = Francais | English
     </r><U>val</U></b> language : language  ref
     <b><U>type</U><r> destination = Html | Text | Info
     </r><U>val</U></b> destination : destination ref
  <m>20 <b><U>val</U></b></m> mathml : bool ref
     <b><U>val</U><r> entities : bool ref
     </r><U>val</U></b> pedantic : bool ref
     <b><U>val</U><r> fixpoint : bool ref
     </r><U>val</U></b> optimize : bool ref
  <m>25 <b><U>val</U></b></m> width : int ref
     <b><U>val</U><r> except : string list ref
     </r><U>val</U></b> path : string list ref
     
     <b><U>val</U><r> filter : bool
  </r><m>30 </m><U>val</U></b> styles : input list
     <b><U>val</U><r> base_in : string
     </r><U>val</U></b> name_in : string
     <b><U>val</U><r> base_out : string
     </r><U>val</U></b> name_out : string<PL><B>
<6>51 pp.mli</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: pp.mli,v 1.4 2001/05/28 17:28:56 maranget Exp $               *)
     (***********************************************************************)
     <b><U>val</U></b></w> ptree : out_channel -&gt; Lexeme.style Tree.t -&gt; unit
     <b><U>val</U><r> ptrees : out_channel -&gt;  Lexeme.style Tree.t list -&gt; unit
     
  </r><m>15 </m><U>val</U></b> tree : out_channel -&gt; Htmltext.style Tree.t -&gt; unit
     <b><U>val</U></b> trees : out_channel -&gt;  Htmltext.style Tree.t list -&gt; unit</TT>
<6><B>52 save.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>val</U></b></w> if_next_char : char -&gt; Lexing.lexbuf  -&gt; bool
     <b><U>val</U><r> if_next_string : string -&gt; Lexing.lexbuf -&gt; bool
     
  </r><m>15 </m><U>exception</U></b> Error <b><U>of</U><r> string
     </r><U>exception</U></b> Delim <b><U>of</U><r> string
     </r><U>val</U></b> empty_buffs : unit -&gt; unit
     <b><U>val</U><r> set_verbose : bool -&gt; int -&gt; unit
     </r><U>val</U></b> seen_par : bool ref
  <m>20 
     <b><U>exception</U></b></m> Eof
     <b><U>exception</U><r> NoOpt
     </r><U>val</U></b> get_echo : unit -&gt; string
     <b><U>val</U><r> start_echo : unit -&gt; unit
  </r><m>25 </m><U>val</U></b> opt : Lexing.lexbuf -&gt; string
     <b><U>val</U><r> arg : Lexing.lexbuf -&gt; string
     </r><U>val</U></b> arg_verbatim : Lexing.lexbuf -&gt; string
     <b><U>val</U><r> csname : Lexing.lexbuf -&gt;
       (string -&gt; string) -&gt; (string -&gt; string) -&gt; string
  </r><m>30 </m><U>val</U></b> incsname : Lexing.lexbuf -&gt; string
     <b><U>val</U><r> cite_arg : Lexing.lexbuf -&gt; string list
     </r><U>val</U></b> rest : Lexing.lexbuf -&gt; string
     <b><U>val</U><r> num_arg : Lexing.lexbuf -&gt; (string -&gt; int) -&gt; int
     </r><U>val</U></b> skip_equal : Lexing.lexbuf -&gt; unit
  <m>35 <b><U>val</U></b></m> check_equal : Lexing.lexbuf -&gt; bool
     <b><U>val</U><r> filename : Lexing.lexbuf -&gt; string
     </r><w>(* Superscript and subscripts *)
     </w><U>val</U></b> get_limits : Lexing.lexbuf -&gt; Misc.limits option
     <b><U>val</U><r> get_sup : Lexing.lexbuf -&gt; string option
  </r><m>40 </m><U>val</U></b> get_sub : Lexing.lexbuf -&gt; string option
     
     <b><U>val</U><r> defargs : Lexing.lexbuf -&gt; string list
     </r><U>val</U></b> get_defargs : Lexing.lexbuf -&gt; string
     <b><U>val</U><r> tagout : Lexing.lexbuf -&gt; string
  </r><m>45 </m><U>val</U></b> checklimits : Lexing.lexbuf -&gt; bool
     <b><U>val</U><r> skip_delim : string -&gt; Lexing.lexbuf -&gt; unit
     </r><U>val</U></b> with_delim : string -&gt; Lexing.lexbuf -&gt; string
     <b><U>val</U><r> skip_blanks_init : Lexing.lexbuf -&gt; unit<PL><B>
<6>53 section.mli</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>val</U></b> value: string -&gt; int<PL><B>
<6>54 stack.mli</6>
</B><w><TT> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: stack.mli,v 1.8 2001/05/28 17:28:56 maranget Exp $            *)
     (***********************************************************************)
     <b><U>exception</U><r> Fatal </r><U>of</U><r> string
     
     <b><U>type</U><r> 'a t
  </r><m>15 </m><U>val</U></b> create : string -&gt;  'a t
     <b><U>val</U><r> create_init : string -&gt; 'a -&gt;  'a t
     </r><U>val</U></b> reset : 'a t -&gt; unit
     
     <b><U>val</U><r> name : 'a t -&gt; string
  </r><m>20 </m><U>val</U></b> push : 'a t -&gt; 'a -&gt; unit
     <b><U>val</U><r> pop : 'a t -&gt; 'a
     </r><U>val</U></b> top : 'a t -&gt; 'a
     <b><U>val</U><r> pretty : ('a -&gt; string) -&gt; 'a t -&gt; unit
     </r><U>val</U></b> length : 'a t -&gt; int
  <m>25 <b><U>val</U></b></m> empty : 'a t -&gt; bool
     <b><U>val</U><r> rev : 'a t -&gt; unit
     </r><U>val</U></b> map : 'a t -&gt; ('a -&gt; 'a) -&gt; unit
     
     <b><U>type</U><r> 'a saved
  </r><m>30 </m><U>val</U></b> empty_saved : 'a saved
     <b><U>val</U><r> save : 'a t -&gt; 'a saved
     </r><U>val</U></b> restore : 'a t -&gt; 'a saved -&gt; unit
     <b><U>val</U></b> finalize : 'a t -&gt; ('a -&gt; bool) -&gt; ('a -&gt; unit) -&gt; unit
     </r></b>(*
  <m>35   </m>finalize now p f
         apply f to now elements until
         now is empty or p  is true for one element
     *)</TT></w>
<6><B>55 subst.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: subst.mli,v 1.6 2001/05/25 12:37:29 maranget Exp $            *)
     (***********************************************************************)
     <b><U>open</U></b></w> Lexstate
     <b><U>val</U><r> do_subst_this : string arg -&gt; string
     </r><U>val</U></b> subst_this : string -&gt; string
  <m>15 <b><U>val</U></b></m> subst_arg : Lexing.lexbuf -&gt; string
     <b><U>val</U><r> subst_opt : string -&gt; Lexing.lexbuf -&gt; string
     </r><U>val</U></b> subst_body : Lexing.lexbuf -&gt; string<PL><B>
<6>56 symb.mli</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>val</U></b></w> put_delim : (unit -&gt; unit) -&gt; (string -&gt; unit) -&gt; string -&gt; int -&gt; unit</TT>
<6><B>57 table.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1999 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>exception</U></b></w> Empty
     <b><U>type</U><r> 'a t
     
  </r><m>15 </m><U>val</U></b> create : 'a -&gt; 'a t
     <b><U>val</U><r> reset : 'a t -&gt; unit
     
     </r><U>val</U></b> emit : 'a t -&gt; 'a -&gt; unit
     <b><U>val</U><r> apply : 'a t -&gt; ('a -&gt; unit) -&gt; unit
  </r><m>20 </m><U>val</U></b> trim : 'a t -&gt; 'a array
     <b><U>val</U><r> remove_last : 'a t -&gt; unit
     </r><U>val</U></b> get_size : 'a t -&gt; int<PL><B>
<6>58 tabular.mli</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: tabular.mli,v 1.11 2001/05/25 12:37:29 maranget Exp $         *)
     (***********************************************************************)
     <b><U>exception</U></b></w> Error <b><U>of</U><r> string
     
     </r><U>type</U></b> align =
  <m>15     <r>{hor : string ; <b><U>mutable</U><r> vert : string ; wrap : bool ;
           </r><U>mutable</U></b> pre : string ; <b><U>mutable</U><r> post : string ; width : Length.t}
     </r><U>type</U></b> format =
         Align <b><U>of</U><r> align
       | Inside </r><U>of</U></b> string
  </r>20   <r>| Border <b><U>of</U><r> string
     
     </r><U>val</U></b> border : bool ref
     
     <b><U>val</U></b> pretty_format : format -&gt; string
  </r>25 <b><U>val</U></b></m> pretty_formats : format array -&gt; unit
     
     
     <b><U>val</U></b> main : string  Lexstate.arg -&gt; format array</TT>
<6><B>59 text.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     <b><U>open</U></b></w> Lexstate
         <b><U>exception</U><r> Error </r><U>of</U></b> string
         <b><U>type</U></b> block
     
  </TT></r><m><TT>15     <b><U>val</U><r> iso : char -&gt; string
         </r><U>val</U><r> iso_string : string -&gt; string
     
         <b><U>val</U><r> set_out : Out.t -&gt; unit
         </r><U>val</U></b> stop : unit -&gt; unit
  </r></b>20     <b><U>val</U><r> restart : unit -&gt; unit
         </r><U>val</U><r> get_last_closed : unit -&gt; block
         <b><U>val</U><r> set_last_closed : block -&gt; unit
         </r><U>val</U></b> is_empty : unit -&gt; bool
     
  </r></b>25     <b><U>val</U><r> get_fontsize : unit -&gt; int
         </r><U>val</U><r> nostyle : unit -&gt; unit
         <b><U>val</U><r> clearstyle : unit -&gt; unit
         </r><U>val</U></b> open_mod : Element.text -&gt; unit
         <b><U>val</U></b> erase_mods : Element.text list -&gt; unit
  </r></b>30     <b><U>val</U><r> par : int option -&gt; unit
         </r><U>val</U><r> forget_par : unit -&gt; int option
         <b><U>val</U><r> open_block : string -&gt; string -&gt; unit
         </r><U>val</U></b> close_block : string -&gt; unit
         <b><U>val</U></b> force_block : string -&gt; string -&gt; unit
  </r></b>35     <b><U>val</U><r> insert_block : string -&gt; string -&gt; unit
         </r><U>val</U><r> insert_attr : string -&gt; string -&gt; unit
     
         <b><U>val</U><r> open_maths : bool -&gt; unit
         </r><U>val</U></b> close_maths : bool -&gt; unit
  </r></b>40     <b><U>val</U><r> open_display : unit -&gt; unit
         </r><U>val</U><r> close_display : unit -&gt; unit
         <b><U>val</U><r> item_display : unit -&gt; unit
         </r><U>val</U></b> force_item_display : unit -&gt; unit
         <b><U>val</U></b> erase_display : unit -&gt; unit
  </r></b>45 
         <b><U>val</U><r> standard_sup_sub :
             (string arg -&gt; unit) -&gt; (unit -&gt; unit) -&gt; string arg -&gt; string arg -&gt; bool -&gt; unit
         </r><U>val</U><r> limit_sup_sub :
             (string arg -&gt; unit) -&gt; (unit -&gt; unit) -&gt; string arg -&gt; string arg -&gt; bool -&gt; unit
  </r></b>50     <b><U>val</U><r> int_sup_sub :
             bool -&gt; int -&gt;
               (string arg -&gt; unit) -&gt; (unit -&gt; unit) -&gt; string arg -&gt; string arg -&gt; bool -&gt; unit
     
         </r><U>val</U><r> over : bool -&gt; Lexing.lexbuf -&gt; unit
  </r></b>55     <b><U>val</U><r> left : string -&gt; (int -&gt; unit) -&gt; unit
         </r><U>val</U><r> right : string -&gt; int
     
         <b><U>val</U><r> set_dcount : string -&gt; unit
         </r><U>val</U></b> item  : unit -&gt; unit
  </r></b>60     <b><U>val</U><r> nitem : unit -&gt; unit
         </r><U>val</U><r> ditem : (string -&gt; unit) -&gt; string -&gt; unit
         <b><U>val</U><r> erase_block : string -&gt; unit
         </r><U>val</U></b> open_group : string -&gt; unit
         <b><U>val</U></b> open_aftergroup : (string -&gt; string) -&gt; unit
  </r></b>65     <b><U>val</U><r> close_group : unit -&gt; unit
         </r><U>val</U><r> put : string -&gt; unit
         <b><U>val</U><r> put_char : char -&gt; unit
         </r><U>val</U></b> flush_out : unit -&gt; unit
         <b><U>val</U></b> skip_line : unit -&gt; unit
  </r></b>70 
         <b><U>val</U><r> loc_name : string -&gt; unit
     
         </r><U>val</U><r> open_chan : out_channel  -&gt; unit
         <b><U>val</U></b> close_chan : unit -&gt; unit
  </r></b>75     <r><b><U>val</U><r> to_string : (unit -&gt; unit) -&gt; string
         </r><U>val</U></b> to_style : (unit -&gt; unit) -&gt; Element.text list
         <b><U>val</U><r> get_current_output : unit -&gt; string
     
         </r><U>val</U></b> finalize : bool -&gt; unit
  </r>80 
         <b><U>val</U><r> horizontal_line : string -&gt; Length.t -&gt; Length.t -&gt; unit
         </r><U>val</U><r> put_separator : unit -&gt; unit
         <b><U>val</U><r> unskip : unit -&gt; unit
         </r><U>val</U></b> put_tag : string -&gt; unit
  </r></b>85     <b><U>val</U><r> put_nbsp : unit -&gt; unit
         </r><U>val</U><r> put_open_group : unit -&gt; unit
         <b><U>val</U><r> put_close_group : unit -&gt; unit
         </r><U>val</U></b> put_in_math : string -&gt; unit
     
  </r></b>90 
         <b><U>val</U><r> open_table : bool -&gt; string -&gt; unit
         </r><U>val</U><r> new_row : unit -&gt; unit
         <b><U>val</U><r> open_cell : Tabular.format -&gt; int -&gt; int -&gt; unit
         </r><U>val</U></b> erase_cell : unit -&gt; unit
  </r></b>95     <b><U>val</U><r> close_cell : string -&gt; unit
         </r><U>val</U><r> do_close_cell : unit -&gt; unit
         <b><U>val</U><r> open_cell_group : unit -&gt; unit
         </r><U>val</U></b> close_cell_group : unit -&gt; unit
         <b><U>val</U></b> erase_cell_group : unit -&gt; unit
 </r></b>100     <b><U>val</U><r> close_row : unit -&gt; unit
         </r><U>val</U><r> erase_row : unit -&gt; unit
         <b><U>val</U><r> close_table : unit -&gt; unit
         </r><U>val</U></b> make_border : string -&gt; unit
         <b><U>val</U></b> make_inside : string -&gt; bool -&gt; unit
 </r></b>105     <b><U>val</U><r> make_hline : int -&gt; bool -&gt; unit
     
         </r><U>val</U><r> infomenu : string -&gt; unit
         <b><U>val</U><r> infonode : string -&gt; string -&gt; string -&gt; unit
         </r><U>val</U></b> infoextranode : string -&gt; string -&gt; string -&gt; unit
 <m>110 
         <b><U>val</U></b></m> image : string -&gt; string -&gt; unit
     
         <b><U>type</U><r> saved
         </r><U>val</U></b> check : unit -&gt; saved
 <m>115     <b><U>val</U></b></m> hot : saved -&gt; unit<PL><B>
<6>60 thread.mli</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>val</U></b></w> setup : string -&gt; string -&gt; unit
     <b><U>val</U><r> setprev : string -&gt; string -&gt; unit
     </r><U>val</U></b> setnext : string -&gt; string -&gt; unit
  <m>15 <b><U>val</U></b></m> setprevnext : string -&gt; string -&gt; unit
     
     <b><U>val</U><r> next : string -&gt; string
     </r><U>val</U></b> prev : string -&gt; string
     <b><U>val</U><r> up   : string -&gt; string
  </r><m>20 
     </m><U>val</U></b> change : string -&gt; string -&gt; unit</TT>
<6><B>61 tree.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: tree.mli,v 1.4 2001/05/28 17:28:56 maranget Exp $             *)
     (***********************************************************************)
     <b><U>open</U></b></w> Lexeme
     
     
  <m>15 
     <b><U>type</U></b></m> 'a t =
       | Text <b><U>of</U><r> string
       | Blanks </r><U>of</U></b> string
       | Node <b><U>of</U><r> 'a * ('a t) list
  <m>20   </m>| ONode </r><U>of</U></b> string * string * ('a t) list<PL><B>
<6>62 ultra.mli</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: ultra.mli,v 1.4 2001/05/28 17:28:56 maranget Exp $            *)
     (***********************************************************************)
     
     <b><U>val</U></b></w> verbose : int ref
     <b><U>val</U></b> main : out_channel -&gt; Lexeme.style Tree.t list -&gt; unit</TT>
<6><B>63 util.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: util.mli,v 1.5 2001/05/28 17:28:56 maranget Exp $             *)
     (***********************************************************************)
     
     <b><U>val</U></b></w> cost : ('a -&gt; int * int) -&gt; 'a Tree.t -&gt; int * int
     <b><U>val</U><r> costs : ('a -&gt; int * int) -&gt; 'a Tree.t list -&gt; int * int
  </r><m>15 </m><U>val</U></b> cost_compare : int * int -&gt; int * int -&gt; int
     <b><U>val</U><r> there : Htmltext.t_style -&gt; Htmltext.style -&gt; bool
     </r><U>val</U></b> inter : Htmltext.style -&gt; Htmltext.style -&gt; Htmltext.style
     <b><U>val</U><r> union : Htmltext.style -&gt; Htmltext.style -&gt; Htmltext.style
     </r><U>val</U></b> sub : Htmltext.style -&gt; Htmltext.style -&gt; Htmltext.style
  <m>20 <b><U>val</U></b></m> neutral : Htmltext.style -&gt; Htmltext.style * Htmltext.style
     <b><U>val</U><r> is_blank : 'a Tree.t -&gt; bool
     </r><U>val</U></b> is_blanks : 'a Tree.t list -&gt; bool
     <b><U>val</U><r> nodes :
       Htmltext.style -&gt; Htmltext.style Tree.t list -&gt;  Htmltext.style Tree.t list
  </r><m>25 </m><U>val</U></b> node :
       Htmltext.style -&gt; Htmltext.style Tree.t list -&gt;  Htmltext.style Tree.t<PL><B>
<6>64 verb.mli</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: verb.mli,v 1.9 2001/05/25 12:37:32 maranget Exp $             *)
     (***********************************************************************)
     <b><U>exception</U></b></w> VError <b><U>of</U><r> string
     
     </r><U>module</U> <U>type</U></b> S = <b><U>sig</U>  <U>end</U><m>
  15 
     
     </m><U>module</U></b> Make
         (Dest : OutManager.S) (Image : ImageManager.S)
         (Scan : Latexscan.S) : S</TT>
<6><B>65 version.mli</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>val</U></b></w> version : string<PL><B>
<6>66 videoc.mli</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*  Christian Queinnec, Universite Paris IV                            *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
  <m>10 </m>(*                                                                     *)
     (***********************************************************************)
     
     (* &lt;Christian.Queinnec@lip6.fr&gt;
      The plugin for HeVeA that implements the VideoC style.
  <m>15  </m>$Id: videoc.mli,v 1.7 2001/05/25 12:37:34 maranget Exp $
     *)
     
     <b><U>module</U> <U>type</U></b></w> T =
       <b><U>sig</U><m>
  20   </m><U>end</U></b>;;
     
     <b><U>module</U></b> Make
         (Dest : OutManager.S) (Image : ImageManager.S)
         (Scan : Latexscan.S) : T</TT>
<6><B>67 auxx.ml</B></6>
</PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>open</U></b></w> Misc
     
     <b><U>let</U><r> header = "$Id: auxx.ml,v 1.14 2001/05/25 09:07:06 maranget Exp $"
  </r><m>15 
     </m><U>let</U></b> rtable = Hashtbl.create 17
     ;;
     
     </r><U>let</U><r> rset name value =
  <m>20   </m>Hashtbl.add rtable name value
     ;;
     
     
     <b><U>let</U></b> rget name =
  <m>25   <b><U>try</U><r> Hashtbl.find rtable name </r><U>with</U><r> Not_found -&gt; <b><U>begin</U><r>
         warning ("Undefined label: ``"^name^"''") ; "??"
       </r><U>end</U></b>
     ;;
     
  </r></b>30 <b><U>let</U><r> btable = Hashtbl.create 17
     ;;
     
     </r><U>let</U><r> bset name value =  Hashtbl.add btable name value
     ;;
  </r></b>35 
     <b><U>let</U><r> bget warn name =
       </r><U>let</U><r> r =
         <b><U>try</U><r> Hashtbl.find btable name </r><U>with</U></b> Not_found -&gt;
           <b><U>begin</U><m>
  40         </m><U>if</U></b> warn <b><U>then</U><r> warning ("Undefined citation: ``"^name^"''") ;
             "\\@verbarg{"^name^"}"
           </r><U>end</U> <U>in</U></b>
       r
     ;;
  </r></b>45 
     <b><U>let</U><r> auxfile = ref None
     </r><U>and</U><r> auxname = ref ""
     <b><U>and</U><r> something = ref </r><U>false</U>
     <U>and</U></b> changed = ref <b><U>false</U><m>
  50 <r>;;
     
     <b><U>let</U><r> rseen = Hashtbl.create 17
     </r><U>and</U></b> bseen = Hashtbl.create 17
     ;;
  </r>55 
     </m><U>let</U></b> init base =
       <b><U>let</U><r> filename = base^".haux" </r><U>in</U>
       <U>try</U>
         <U>let</U></b> file = open_out filename <b><U>in</U><m>
  60     <r>auxname := filename ;
         auxfile := Some file
       <b><U>with</U></b> Sys_error s -&gt;
         warning ("Cannot open out file: "^filename^" : "^s)
     
  </r>65 </m><w>(* result is true when another run is needed *)
     
     </w><U>and</U></b> finalize check =
       <b><U>match</U><r> !auxfile </r><U>with</U></b>
       | None -&gt; <b><U>false</U><m>
  70   <r>| Some file -&gt;
           close_out file ;
           <b><U>if</U><r> not !something </r><U>then</U></b>
             Mysys.remove !auxname;
           <b><U>if</U><r> check </r><U>then</U> <U>begin</U><m>
  75         </m><U>let</U></b> check_disappear table seen =
               Hashtbl.iter
                 (<b><U>fun</U><r> key _ -&gt;
                   </r><U>try</U></b> Hashtbl.find seen key
                   <b><U>with</U></b> Not_found -&gt;
  </r>80                 <r>Misc.warning ("Disappear: "^key) ;
                     changed := <b><U>true</U><r>)
                 table </r><U>in</U>
             <U>if</U></b> not !changed <b><U>then</U> <U>begin</U></b>
               check_disappear rtable rseen ;
  </r>85           <r>check_disappear btable bseen
             <b><U>end</U><r> ;
             </r><U>if</U></b> !changed <b><U>then</U></b>
               Misc.message
                 "HeVeA Warning: Label(s) may have changed. Rerun me to get cross-references right." ;
  </r>90         <r>!changed
           <b><U>end</U> <U>else</U>
             <U>false</U></b>
     ;;
     
  </r>95 </m><U>let</U></b> write table output_fun key pretty = <b><U>match</U><r> !auxfile </r><U>with</U></b>
     | None -&gt; ()
     | Some file -&gt;
         something := <b><U>true</U></b> ;
         changed :=
 </r></b>100        <r>!changed ||
            (<b><U>try</U> <U>let</U></b> olds = Hashtbl.find_all table key <b><U>in</U>
            <U>match</U></b> olds <b><U>with</U><r>
            | []    -&gt; </r><U>true</U></b>
            | [old] -&gt; pretty &lt;&gt; old
 </r>105        <r>| _     -&gt; <b><U>false</U><w> (* In that case, can't tell *)
            </w><U>with</U></b> Not_found -&gt; <b><U>true</U></b>) ;
         output_fun file
     ;;
     
 </r>110 
     <b><U>let</U><r> bcheck key =
       </r><U>try</U>
         <U>let</U><r> _ = Hashtbl.find bseen key <b><U>in</U></b>
         warning ("Multiple definitions for citation: "^key) ;
 </r></b>115     <b><U>false</U>
       <U>with</U><r>
       | Not_found -&gt;
           Hashtbl.add bseen key () ;
           <b><U>true</U><m>
 120 
     </m><U>let</U></b> rcheck key =
       <b><U>try</U>
         <U>let</U></b> _ = Hashtbl.find rseen key <b><U>in</U></b>
         warning ("Multiple definitions for label: "^key) ;
 </r></b>125     <b><U>false</U>
       <U>with</U><r>
       | Not_found -&gt;
           Hashtbl.add rseen key () ;
           <b><U>true</U><m>
 130 
     
     </m><U>let</U></b> bwrite key pretty =
       <b><U>if</U><r> bcheck key </r><U>then</U></b>
         write  btable
 </r></b>135       <r>(<b><U>fun</U></b> file -&gt;
             output_string file "\\bibcite{" ;
             output_string file key ;
             output_string file "}{" ;
             output_string file pretty ;
 </r>140         <r>output_string file "}\n") key pretty
     
     <b><U>and</U><r> rwrite key pretty =
       </r><U>if</U></b> rcheck key <b><U>then</U></b>
         write rtable
 </r>145       <r>(<b><U>fun</U></b> file -&gt;
             output_string file "\\newlabel{" ;
             output_string file key ;
             output_string file "}{{" ;
             output_string file pretty ;
 </r>150         <r>output_string file "}{X}}\n") key pretty
     ;;
     
     <b><U>type</U></b> saved =
     (string, string) Hashtbl.t * (string, unit) Hashtbl.t *
 </r>155   <r>(string, string) Hashtbl.t * (string, unit) Hashtbl.t *
       out_channel option * string * bool * bool
     
     <b><U>let</U></b> check () =
       Misc.clone_hashtbl rtable,  Misc.clone_hashtbl rseen,
 </r>160   <r>Misc.clone_hashtbl btable,  Misc.clone_hashtbl  bseen,
       !auxfile, !auxname, !something, !changed
     
     <b><U>let</U></b> hot
      (srtable, srseen, sbtable, sbseen,
 </r>165   <r>sauxfile, sauxname, ssomething, schanged) =
       Misc.copy_hashtbl srtable rtable ; Misc.copy_hashtbl srseen rseen ;
       Misc.copy_hashtbl sbtable btable ; Misc.copy_hashtbl sbseen bseen ;
       auxfile := sauxfile ;
       auxname := sauxname ;
 </r>170   <r>something := ssomething ;
       changed := schanged
     
     <w>(* Valid only juste before reading main input file *)
     <b><U>let</U></b></w> hot_start () =
 </r>175   <r>Hashtbl.clear rtable ; Hashtbl.clear rseen ;
       Hashtbl.clear btable ; Hashtbl.clear bseen ;
       auxfile :=  None ;
       auxname := "" ;
       something := <b><U>false</U></b> ;
 </r>180   <r>changed := <b><U>false</U><w><r><PL><B>
<6>68 buff.ml</6>
</B></PL></r> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: buff.ml,v 1.4 2001/05/28 17:28:55 maranget Exp $              *)
     (***********************************************************************)
     </w><U>type</U></b> t = {<b><U>mutable</U><r> t : string ; </r><U>mutable</U></b> p : int}
     ;;
     
  </r>15 </m></r><U>let</U><r> create () = {t = String.create 64 ; p = 0}
     
     <b><U>let</U> <U>rec</U></b> realloc d b =
       <b><U>let</U><r> l = String.length b.t </r><U>in</U>
       <U>if</U></b> b.p + d-1 &gt;= l <b><U>then</U> <U>begin</U><m>
  20     </m><U>let</U></b> new_t = String.create (2*l) <b><U>in</U><r>
         String.blit b.t 0 new_t 0 b.p ;
         b.t &lt;- new_t  ;
         realloc d b
       </r><U>end</U><m>
  25 
     
     </m><U>let</U></b> put_char b c =
       realloc 1 b ;
       b.t.[b.p] &lt;- c ;
  <m>30   <r>b.p &lt;- b.p + 1
     
     <b><U>let</U><r> put b s =
       </r><U>let</U></b> l = String.length s <b><U>in</U></b>
       realloc l b ;
  </r>35   <r>String.blit s 0 b.t b.p l ;
       b.p &lt;- b.p + l
     
     <b><U>let</U><r> to_string b =
       </r><U>let</U></b> r = String.sub b.t 0 b.p <b><U>in</U><m>
  40   <r>b.p &lt;- 0 ;
       r
     
     <b><U>let</U><r> reset b = b.p &lt;- 0<PL><B>
<6>69 color.ml</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>let</U></b> header = "$Id: color.ml,v 1.9 2000/01/19 20:10:58 maranget Exp $"
     
     <b><U>let</U></b> default_color = "#000000"
  </r>15 <r>;;
     
     <b><U>let</U><r> table = Hashtbl.create 17
     ;;
     </r><U>type</U></b> saved = (string, string) Hashtbl.t
  </r>20 
     </m><U>let</U></b> checkpoint () =
       <b><U>let</U><r> ctable = Hashtbl.create 17 </r><U>in</U></b>
       Misc.copy_hashtbl table ctable ;
       ctable
  </r>25 
     <b><U>and</U></b></m> hot_start ctable = Misc.copy_hashtbl ctable table
     
     <b><U>let</U><r> to_hex x =
       Printf.sprintf "%02x" (truncate (255.0 *. x))
  <m>30 </m>;;
     
     </r><U>let</U></b> cmyk_to_rgb c m y k =
       1.0 -. min 1.0 (c *. (1.0 -. k) +. k),
       1.0 -. min 1.0 (m *. (1.0 -. k) +. k),
  <m>35   <r>1.0 -. min 1.0 (y *. (1.0 -. k) +. k)
     ;;
     
     <b><U>let</U><r> hls_to_rgb h l s =
       </r><U>let</U></b> rgb q1 q2 hue =
  </r>40      <b><U>let</U></b></m> hue =
            <b><U>if</U><r> hue &gt; 360.0 </r><U>then</U></b>  hue -. 360.0
            <b><U>else</U> <U>if</U></b> hue &lt; 0.0 <b><U>then</U><r> hue +. 360.0
            </r><U>else</U></b> hue <b><U>in</U>
          <U>if</U></b> hue &lt; 60.0 <b><U>then</U><m>
  45        <r>q1 +. (q2 -. q1) /. 60.0
          <b><U>else</U> <U>if</U></b> hue &lt; 180.0 <b><U>then</U><r>
            q2
          </r><U>else</U> <U>if</U></b> hue &lt; 240.0 <b><U>then</U></b>
            q1 +. (q2 -. q1) *. (240.0 -. hue) /. 60.0
  </r>50      </m><U>else</U></b>
            q1 <b><U>in</U>
       <U>let</U></b> p2 =
         <b><U>if</U><r> l &lt;= 0.5 </r><U>then</U></b> l *. (1.0 +. s)
         <b><U>else</U><r> l +. s -. (l *. s) </r><U>in</U><m>
  55   </m><U>let</U></b> p1 = 2.0 *. l -. p2 <b><U>in</U>
       <U>if</U></b> s = 0.0 <b><U>then</U><r>
         l,l,l
       </r><U>else</U></b>
         rgb p1 p2 (h +. 100.0),
  <m>60     <r>rgb p1 p2 h,
         rgb p1 p2 (h -. 120.0)
     ;;
     
     <b><U>let</U></b> hsv_to_rgb h s v =
  </r>65   <b><U>if</U></b></m> s = 0.0 <b><U>then</U><r> v,v,v
       </r><U>else</U>
         <U>let</U></b> h = h /. 60.0 <b><U>in</U>
         <U>let</U></b> i = truncate h <b><U>in</U>
         <U>let</U></b> f = h -. float i <b><U>in</U><m>
  70     </m><U>let</U></b> p = v *. (1.0 -. s) <b><U>in</U>
         <U>let</U></b> q = v *. (1.0 -. (s *. f)) <b><U>in</U>
         <U>let</U></b> t = v *. (1.0 -. (s *. (1.0 -. f))) <b><U>in</U>
         <U>match</U></b> i <b><U>with</U><r>
         | 0 -&gt; v,t,p
  </r><m>75     <r>| 1 -&gt; q,v,p
         | 2 -&gt; p,v,t
         | 3 -&gt; p,q,v
         | 4 -&gt; t,p,v
         | 5 -&gt; v,p,q
  </r>80     <r>| _ -&gt; Misc.fatal ("Bad HSV color specification")
     ;;
     
     
     
  </r>85 </m><U>exception</U></b> Failed
     ;;
     
     <b><U>let</U><r> do_compute mdl value = </r><U>match</U></b> mdl <b><U>with</U><r>
     | "gray" -&gt;
  <m>90     <b><U>let</U><r> x = Colscan.one (Lexing.from_string value) </r><U>in</U>
         <U>let</U><r> xx = to_hex x <b><U>in</U><r>
         xx^xx^xx
     | "rgb" -&gt;
         </r><U>let</U></b> r,g,b =  Colscan.three(Lexing.from_string value) </r><U>in</U></b>
  95     </m>to_hex r^to_hex g^to_hex b
     | "cmyk" -&gt;
         </r><U>let</U></b> c,m,y,k = Colscan.four (Lexing.from_string value) <b><U>in</U>
         <U>let</U></b> r,g,b = cmyk_to_rgb c m y k <b><U>in</U><r>
         to_hex r^to_hex g^to_hex b
 <m>100 </m>| "hsv" -&gt;
         </r><U>let</U></b> h,s,v = Colscan.three (Lexing.from_string value) <b><U>in</U>
         <U>let</U></b> r,g,b = hsv_to_rgb h s v <b><U>in</U><r>
         to_hex r^to_hex g^to_hex b
     | "hls" -&gt;
 <m>105     <b><U>let</U><r> h,l,s = Colscan.three (Lexing.from_string value) </r><U>in</U>
         <U>let</U><r> r,g,b = hls_to_rgb h l s <b><U>in</U><r>
         to_hex r^to_hex g^to_hex b
     | "named" -&gt; </r><U>begin</U>
         <U>try</U></b> Hashtbl.find table ("named@"^value) </r><U>with</U></b>
 110     </m>| Not_found -&gt; </r><U>begin</U></b>
             Misc.warning ("Unkown name in the named color model: "^value) ;
             raise Failed
         <b><U>end</U>
     <U>end</U><m>
 115 <r>| _     -&gt;
         Misc.warning ("Color.compute, unknown color model: "^mdl);
         raise Failed
     
     
 </r>120 
     </m><U>let</U></b> compute mdl value =
       <b><U>try</U><r> do_compute mdl value </r><U>with</U></b> Failed -&gt; ""
     
     </r><U>let</U><r> define clr mdl value =
 </r><m>125 </m><U>try</U><r>
       Hashtbl.add table clr (do_compute mdl value)
     <b><U>with</U><r> Failed -&gt; ()
     ;;
     
 </r><m>130 </m><U>let</U></b> retrieve clr =
       <b><U>try</U><r>
         Hashtbl.find table clr
       </r><U>with</U></b> Not_found -&gt;
         Misc.warning ("Color.retrieve, unknown color: "^clr);
 <m>135     <r>default_color
     ;;
     
     
     <b><U>let</U></b> define_named name mdl value = define ("named@"^name) mdl value
 </r>140 <r>;;
     
     <b><U>let</U><r> remove clr = Hashtbl.remove table clr<PL><B>
<6>70 colscan.ml</6>
</B></PL> 
      12 "colscan.mll"
     
     </r><U>open</U></b> Lexing
     
   </r>5 <b><U>exception</U></b></m> Error <b><U>of</U><r> string
     ;;
     
     </r><U>let</U></b> buf = Out.create_buff ()
     ;;
  <m>10 <b><U>let</U></b></m> lex_tables = {
       Lexing.lex_base =
        "\000\000\001\000\255\255\003\000\012\000\027\000\039\000\002\000\
    ";
       Lexing.lex_backtrk =
        "\000\000\001\000\255\255\255\255\000\000\000\000\000\000\000\000\
    ";
  <m>15   <r>Lexing.lex_default =
        "\255\255\255\255\000\000\255\255\255\255\255\255\255\255\255\255\
    ";
       Lexing.lex_trans =
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \004\000\003\000\007\000\003\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\004\000\002\000\005\000\002\000\
    \006\000\006\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\007\000\006\000\006\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\000\000\007\000\
    \000\000\000\000\000\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\000\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    ";
       Lexing.lex_check =
  </r>20    <r>"\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\001\000\007\000\003\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\004\000\001\000\000\000\003\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\004\000\005\000\004\000\004\000\004\000\004\000\
    \004\000\004\000\004\000\004\000\004\000\004\000\255\255\006\000\
    \255\255\255\255\255\255\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\006\000\255\255\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    "
     }
     
     <b><U>let</U> <U>rec</U></b> one lexbuf = __ocaml_lex_one_rec lexbuf 0
     <b><U>and</U></b> __ocaml_lex_one_rec lexbuf state =
  </r>25   <b><U>match</U></b></m> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      23 "colscan.mll"
        </r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><r>
       float_of_string lxm)
  </r><m>30   <r>| 1 -&gt; (
      25 "colscan.mll"
           raise (Error "Syntax error in color argument"))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_one_rec lexbuf n
     
  </r>35 </m><U>and</U></b> other lexbuf = __ocaml_lex_other_rec lexbuf 1
     <b><U>and</U><r> __ocaml_lex_other_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      28 "colscan.mll"
  </r><m>40             <r>one lexbuf)
       | 1 -&gt; (
      29 "colscan.mll"
                 raise (Error "Syntax error in color argument"))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_other_rec lexbuf n
  </r>45 
     </m><U>and</U></b> three lexbuf = __ocaml_lex_three_rec lexbuf 2
     <b><U>and</U><r> __ocaml_lex_three_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
  <m>50  </m>33 "colscan.mll"
        </r><U>let</U></b> fst = one lexbuf <b><U>in</U>
       <U>let</U></b> snd = other lexbuf <b><U>in</U>
       <U>let</U></b> thrd = other lexbuf <b><U>in</U><r>
       fst,snd,thrd)
  <m>55   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_three_rec lexbuf n
     
     </r><U>and</U></b> four lexbuf = __ocaml_lex_four_rec lexbuf 2
     <b><U>and</U><r> __ocaml_lex_four_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><m>
  60     <r>0 -&gt; (
      39 "colscan.mll"
        <b><U>let</U><r> fst = one lexbuf </r><U>in</U>
       <U>let</U></b> snd = other lexbuf <b><U>in</U>
       <U>let</U></b> thrd = other lexbuf <b><U>in</U><m>
  65   </m><U>let</U></b> fourth = other lexbuf <b><U>in</U><r>
       fst,snd,thrd,fourth)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_four_rec lexbuf n
     
     ;;<PL><B>
<6>71 counter.ml</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>let</U></b> header = "$Id: counter.ml,v 1.10 2000/01/19 20:10:59 maranget Exp $"
     <b><U>type</U><r> t_counter =
         {</r><U>mutable</U></b> count : int ;
  </r>15     </m><U>mutable</U></b> within : t_counter option ;
         <b><U>mutable</U><r> related : t_counter list}
     
     </r><U>let</U></b> mk_bidon () = {count = 0 ; within = None ; related = []}
     
  <m>20 <b><U>type</U></b></m> t_checked =
         {cname : string ;
         cvalue : int ;
         cwithin : int option ;
         crelated : int list}
  <m>25 
     <b><U>let</U></b></m> cbidon = {cname = "" ; cvalue = (-1) ; cwithin = None ; crelated = []}
     
     <b><U>let</U><r> ctable = (Hashtbl.create 19 : (string,t_counter) Hashtbl.t);;
     
  </r><m>30 </m><U>type</U></b> saved =  t_checked array
     
     
     <b><U>let</U><r> prerr_cc check_ctable cc =
       prerr_endline ("counter: "^cc.cname) ;
  <m>35   </m>prerr_endline ("\tvalue = "^string_of_int cc.cvalue) ;
       prerr_endline
         ("\twithin = "^
          </r><U>begin</U> <U>match</U></b> cc.cwithin <b><U>with</U><r>
          | None -&gt; "None"
  <m>40      </m>| Some j -&gt; (check_ctable).(j).cname
          </r><U>end</U></b>) ;
       prerr_string "\trelated =" ;
       List.iter
         (<b><U>fun</U><r> j -&gt;
  </r><m>45       <r>prerr_string " " ;
           prerr_string (check_ctable).(j).cname)
         cc.crelated ;
       prerr_endline ""
     
  </r>50 </m><U>let</U></b> checkpoint () =
       <b><U>let</U> <U>module</U></b> H = <b><U>struct</U>
         <U>type</U></b> t = t_counter
         <b><U>let</U><r> equal = (==)
         </r><U>let</U></b> hash = Hashtbl.hash
  <m>55   <b><U>end</U> <U>in</U>
       <U>let</U> <U>module</U></b></m> RevHash = Hashtbl.Make (H) <b><U>in</U>
       <U>let</U></b> rev_table = RevHash.create 19
       <b><U>and</U><r> count = ref 0 </r><U>in</U></b>
       Hashtbl.iter
  <m>60     </m>(<b><U>fun</U><r> key value -&gt;
           RevHash.add rev_table value (key, !count) ;
           incr count)
         ctable ;
       </r><U>let</U></b> to_int c =
  <m>65     <b><U>try</U>
           <U>let</U><r> _,j = RevHash.find rev_table c <b><U>in</U><r>
           j
         </r><U>with</U></b>
         | Not_found -&gt; Misc.fatal "Counter.checkpoint" </r><U>in</U></b>
  70 
       <b><U>let</U><r> t = Array.create !count cbidon </r><U>in</U><r>
     
       RevHash.iter
         (<b><U>fun</U><r> {count = value ; within = within ; related = related} (name, i) -&gt;
  <m>75       </m>t.(i) &lt;-
              {cname = name ;
              cvalue = value ;
              cwithin =
                </r><U>begin</U> <U>match</U></b> within </r><U>with</U></b>
  80            </m>| None -&gt; None
                | Some c -&gt; Some (to_int c)
                <b><U>end</U><r> ;
             crelated = List.map to_int related})
         rev_table ;
  <m>85   </m>t
     
     </r><U>and</U></b> hot_start check_ctable =
     
       Hashtbl.clear ctable ;
  <m>90   <b><U>let</U> <U>rec</U><r> create_rec i =
         <b><U>let</U><r> cc = (check_ctable).(i) </r><U>in</U>
         <U>try</U></b>
           Hashtbl.find ctable cc.cname
         </r><U>with</U></b>
  95     </m>| Not_found -&gt;
             </r><U>let</U><r> c =
               {count = cc.cvalue ; within = None ; related = []} <b><U>in</U><r>
             Hashtbl.add ctable cc.cname c;
             c.within &lt;- </r><U>begin</U> <U>match</U></b> cc.cwithin <b><U>with</U><m>
 100           <r>| None -&gt; None
               | Some j -&gt; Some (create_rec j) <b><U>end</U><r> ;
             c.related &lt;- List.map create_rec cc.crelated ;
             </r><U>if</U></b> !Misc.verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
               prerr_string "Restored " ;
 </r>105           <r>prerr_cc check_ctable cc
             <b><U>end</U><r> ;
             c </r><U>in</U>
       <U>for</U></b> i = 0 <b><U>to</U><r> Array.length check_ctable - 1 </r><U>do</U>
         <U>let</U></b> _ = create_rec i <b><U>in</U></b> ()
 </r>110   </m><U>done</U></b>
     ;;
     
     <b><U>let</U><r> unkown name where =
       Misc.warning ("Unknown counter: "^name^" in "^where)
 </r><m>115 
     </m><U>let</U></b> find_counter name = Hashtbl.find ctable name
     
     
     <b><U>let</U><r> value_counter name =
 </r><m>120   </m><U>try</U>
         <U>let</U></b> {count=c} = find_counter name <b><U>in</U><r>
         c
       </r><U>with</U></b> Not_found -&gt; <b><U>begin</U><r>
         unkown name "\\value" ; 0
 </r><m>125   </m><U>end</U></b>
     ;;
     
     <b><U>let</U><r> def_counter name within =
       </r><U>try</U><m>
 130     </m><U>let</U></b> _ = Hashtbl.find ctable name <b><U>in</U><r>
         Misc.warning ("Counter "^name^" is already defined, not defining it") ;
         raise Latexmacros.Failed
       </r><U>with</U></b>
       | Not_found -&gt; <b><U>begin</U><m>
 135       </m><U>let</U></b> within_c =
             <b><U>try</U> <U>match</U></b> within <b><U>with</U><r> "" -&gt; None | _ -&gt; Some (find_counter within)
             </r><U>with</U></b> Not_found -&gt; <b><U>begin</U><r>
               unkown within ("\\newcounter{"^name^"}["^within^"]") ;
               None </r><U>end</U> <U>in</U><m>
 140       </m><U>let</U></b> c = {count=0 ; within=within_c ; related = []} <b><U>in</U><r>
           Hashtbl.add ctable name c ;
           </r><U>match</U></b> within_c <b><U>with</U><r>
           | Some d -&gt; d.related &lt;- c :: d.related
           | _ -&gt; ()
 </r><m>145   </m><U>end</U>
     
     <U>let</U></b> number_within name within =
       <b><U>try</U>
         <U>let</U></b> c = find_counter name <b><U>in</U><m>
 150     </m><U>begin</U> <U>match</U></b> c.within <b><U>with</U><r>
         | Some d -&gt;
             d.related &lt;-
                List.fold_right (</r><U>fun</U></b> e r -&gt; <b><U>if</U><r> e == c </r><U>then</U></b> r <b><U>else</U><r> e :: r)
                  d.related []
 <m>155     </m>| _ -&gt; ()
         </r><U>end</U></b> ;
         <b><U>let</U><r> d = find_counter within </r><U>in</U></b>
         c.within &lt;- Some d ;
         d.related &lt;- c :: d.related
 <m>160   <b><U>with</U></b></m> Not_found -&gt;
         unkown (name^" or "^within)  ("\\numberwithin")
     
     <b><U>let</U><r> add_counter name i =
       </r><U>try</U><m>
 165    </m><U>let</U></b> c = find_counter name <b><U>in</U><r>
        c.count &lt;- c.count + i
       </r><U>with</U></b> Not_found -&gt; unkown name "\\addtocounter"
     
     <b><U>let</U><r> set_counter name x =
 </r><m>170   </m><U>try</U>
         <U>let</U></b> c = find_counter name <b><U>in</U><r>
         c.count &lt;- x
       </r><U>with</U></b> Not_found -&gt; unkown name "\\setcounter"
     ;;
 <m>175 
     <b><U>let</U></b></m> step_counter name =
       <b><U>try</U>
       <U>let</U></b> c = find_counter name <b><U>in</U><r>
       c.count &lt;- c.count + 1;
 <m>180   </m>List.iter (</r><U>fun</U></b> c -&gt; c.count &lt;- 0) c.related
       <b><U>with</U><r> Not_found -&gt;
         unkown name ("\\stepcounter")
     ;;<PL><B>
<6>72 cross.ml</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>let</U></b> header = "$Id: cross.ml,v 1.10 2000/03/28 13:52:53 maranget Exp $"
     <b><U>let</U><r> verbose = ref 0
     ;;
  </r><m>15 
     </m><U>let</U></b> table = Hashtbl.create 37
     ;;
     
     <b><U>let</U><r> add name file =
  </r><m>20   </m><U>if</U></b> !verbose &gt; 0 <b><U>then</U><r>
           prerr_endline ("Register "^name^" in "^file) ;
       </r><U>try</U>
         <U>let</U></b> _ = Hashtbl.find table name <b><U>in</U><r>
         Location.print_pos () ;
  <m>25     </m>prerr_endline ("Warning, multiple definitions for anchor: "^name) ;
       </r><U>with</U></b>
       | Not_found -&gt;
           Hashtbl.add table name (ref file)
     ;;
  <m>30 
     
     <b><U>let</U></b></m> fullname myfilename name =
       <b><U>try</U>
         <U>let</U></b> filename = !(Hashtbl.find table name) <b><U>in</U><m>
  35     </m><U>let</U></b> newname =
           <b><U>if</U><r> myfilename = filename  </r><U>then</U></b>
           "#"^name
           <b><U>else</U><r>
             filename^"#"^name </r><U>in</U><m>
  40     </m><U>if</U></b> !verbose &gt; 0 <b><U>then</U><r>
           prerr_endline ("From "^name^" to "^newname) ;
         newname
       </r><U>with</U></b> Not_found -&gt; <b><U>begin</U><r>
         Location.print_pos () ;
  <m>45     </m>prerr_endline ("Warning, cannot find anchor: "^name) ;
         raise Not_found
       </r><U>end</U></b>
     ;;
     
  <m>50 <b><U>let</U></b></m> change oldname name =
       Hashtbl.iter
         (<b><U>fun</U><r> k x -&gt; </r><U>if</U></b> !x = oldname <b><U>then</U><r> x := name)
         table<PL><B>
<6>73 cutmain.ml</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>let</U></b> header = "$Id: cutmain.ml,v 1.15 2001/05/25 09:07:08 maranget Exp $"
     
     <b><U>exception</U><r> Error </r><U>of</U></b> string
  <m>15 </m>;;
     
     </r><U>let</U><r> filename = ref ""
     ;;
     
  <m>20 <b><U>let</U></b></m> outname = ref "index.html"
     ;;
     
     <b><U>let</U><r> main () =
       Arg.parse
  <m>25     </m>[("-o", Arg.String (</r><U>fun</U></b> s -&gt; outname := s),
            "filename, make htmlcut output go into file ``filename'' (defaults to index.html)");
          ("-francais", Arg.Unit (<b><U>fun</U><r> () -&gt; Cut.language := "fra"),
            ", French mode");
          ("-tocbis", Arg.Unit (</r><U>fun</U></b> () -&gt; Cut.tocbis := <b><U>true</U><r>),
  <m>30        </m>", Add small table of contents at the begining of files");
          ("-v", Arg.Unit (</r><U>fun</U></b> () -&gt; incr Cut.verbose),
             ", verbose flag")    ]
          (<b><U>fun</U><r> s -&gt; filename := s) ("hacha "^Version.version);
       </r><U>let</U></b> base = Filename.basename !filename <b><U>in</U><m>
  35   <r>Cut.name :=
          (<b><U>try</U><r> Filename.chop_extension base </r><U>with</U></b> Invalid_argument _ -&gt; base) ;
       <b><U>let</U><r> chan = </r><U>try</U></b> open_in !filename <b><U>with</U><r> Sys_error s -&gt; raise (Error ("File error: "^s)) </r><U>in</U>
       <U>let</U></b> buf = Lexing.from_channel chan <b><U>in</U></b>
       Location.set !filename buf ;
  </r>40   <r>Cut.start_phase !outname ;
       Cut.main buf ;
       Location.restore () ;
       <b><U>let</U><r> chan = </r><U>try</U></b> open_in !filename <b><U>with</U><r> Sys_error s -&gt; raise (Error ("File error: "^s)) </r><U>in</U>
       <U>let</U></b> buf = Lexing.from_channel chan <b><U>in</U><m>
  45   <r>Location.set !filename buf ;
       Cut.start_phase !outname ;
       Cut.main buf
     ;;
     
  </r>50 
     </m><U>let</U></b> copy_gifs () =
       <b><U>try</U></b>
         Mysys.copy_from_lib Mylib.libdir "previous_motif.gif" ;
         Mysys.copy_from_lib Mylib.libdir "next_motif.gif" ;
  </r>55     <r>Mysys.copy_from_lib Mylib.libdir "contents_motif.gif"
       <b><U>with</U></b>
       | Mysys.Error s -&gt;
           Location.print_pos () ;
           prerr_endline s
  </r>60 
     </m><U>let</U></b> _ = <b><U>try</U><r>
       main () ;
       copy_gifs ()
     </r><U>with</U><m>
  65 <r>| Error s  -&gt;
         prerr_endline s ;
         prerr_endline "Adios" ;
         exit 2
     | Cut.Error s -&gt;
  </r>70     <r>Location.print_pos () ;
         prerr_endline ("Error while reading HTML: "^s) ;
         prerr_endline "Adios" ;
         exit 2
     | Misc.Fatal s -&gt;
  </r>75     <r>Location.print_pos () ;
         prerr_endline
           ("Fatal error: "^s^" (please report to Luc.Maranget@inria.fr") ;
         prerr_endline "Adios" ;
         exit 2
  </r>80 <r>|  x -&gt;
         Location.print_pos () ;
         prerr_endline
           ("Fatal error: spurious exception "^Printexc.to_string x^
            " (please report to Luc.Maranget@inria.fr") ;
  </r>85     <r>prerr_endline "Adios" ;
         exit 2
     ;;
     
     exit 0;;<PL><B>
<6>74 cut.ml</6>
</B></PL> 
      12 "cut.mll"
     
     <b><U>open</U><r> Lexing
     </r><U>open</U></b> Stack
   </r>5 </m><U>let</U></b> header = "$Id: cut.mll,v 1.30 2001/05/25 09:07:07 maranget Exp $"
     
     <b><U>let</U><r> verbose = ref 0
     ;;
     
  </r><m>10 </m><U>let</U></b> language = ref "eng"
     ;;
     
     <b><U>let</U><r> tocbis = ref </r><U>false</U></b>
     ;;
  <m>15 
     <b><U>exception</U></b></m> Error <b><U>of</U><r> string
     
     
     </r><w>(* Accumulate all META, LINK and similar tags that appear in the preamble
  <m>20    </m>in order to output them in the preamble of every generated page. *)
     
     </w><U>let</U></b> header_buff = Out.create_buff ()
     <b><U>let</U><r> common_headers = ref "";;
     
  </r><m>25 </m><U>let</U></b> adjoin_to_header s = Out.put header_buff s
     
     <b><U>and</U><r> adjoin_to_header_char c = Out.put_char header_buff c
     
     </r><U>and</U></b> finalize_header () =
  <m>30   <r>common_headers := Out.to_string header_buff
     
     <b><U>let</U><r> html_buff = Out.create_buff ()
     </r><U>let</U></b> html_head = ref ""
     <b><U>and</U></b> html_foot = ref ""
  </r>35 
     <b><U>let</U></b></m> phase = ref (-1)
     ;;
     
     <b><U>let</U><r> name = ref "main"
  </r><m>40 </m><U>and</U></b> count = ref 0
     ;;
     
     <b><U>let</U><r> body = ref "&lt;BODY&gt;"
     </r><U>and</U></b> doctype = ref ""
  <m>45 <b><U>and</U></b></m> html = ref "&lt;HTML&gt;"
     ;;
     
     <b><U>let</U><r> changed_t = Hashtbl.create 17
     
  </r><m>50 </m><U>let</U> <U>rec</U></b> check_changed name =
       <b><U>try</U>
         <U>let</U></b> r = Hashtbl.find changed_t name <b><U>in</U><r>
         check_changed r
       </r><U>with</U><m>
  55   <r>| Not_found -&gt; name
     
     <b><U>let</U><r> new_filename () =
       incr count ;
       </r><U>let</U></b> r1 = Printf.sprintf "%s%0.3d.html" !name !count <b><U>in</U><m>
  60   </m><U>let</U></b> r2 = check_changed r1 <b><U>in</U><r>
       r2
     ;;
     
     </r><U>let</U></b> out = ref (Out.create_null ())
  </r>65 </m><U>and</U></b> out_prefix = ref (Out.create_null ())
     <b><U>and</U><r> outname = ref ""
     </r><U>and</U></b> lastclosed = ref ""
     <b><U>and</U><r> otheroutname = ref ""
     </r><U>and</U></b> flowname_stack = (Stack.create "flowname" : string Stack.t)
  <m>70 <b><U>and</U></b></m> flow_stack = (Stack.create "flow" : Out.t Stack.t)
     ;;
     
     <b><U>let</U><r> toc = ref !out
     </r><U>and</U></b> tocname = ref !outname
  <m>75 <b><U>and</U></b></m> otherout = ref !out
     ;;
     
     <b><U>let</U><r> change_name oldname name =
       </r><U>if</U></b> !phase &lt;= 0 <b><U>then</U> <U>begin</U><m>
  80     <r>Thread.change oldname name ;
         Cross.change oldname name ;
         outname := name ;
         Hashtbl.add changed_t oldname name
       <b><U>end</U><m>
  85 
     
     </m><U>let</U></b> start_phase name =
       incr phase ;
       <b><U>if</U><r> !verbose &gt; 0 </r><U>then</U><m>
  90     <r>prerr_endline ("Starting phase number: "^string_of_int !phase);
       outname := name ;
       tocname := name ;
       otheroutname := "" ;
       count := 0 ;
  </r>95   </m><U>if</U></b> !phase &gt; 0 <b><U>then</U> <U>begin</U></b>
         out := (Out.create_chan (open_out name))
       <b><U>end</U></b> ;
       toc := !out
     ;;
 </r>100 
     </m><U>let</U></b> openlist out = Out.put out "&lt;UL&gt;\n"
     <b><U>and</U><r> closelist out = Out.put out "&lt;/UL&gt;\n"
     </r><U>and</U></b> itemref filename s out =
       Out.put out "&lt;LI&gt;" ;
 <m>105   <r>Out.put out "&lt;A HREF=\"" ;
       Out.put out filename ;
       Out.put out "\"&gt;" ;
       Out.put out s ;
       Out.put out "&lt;/A&gt;\n"
 </r>110 
     <b><U>and</U></b></m> itemanchor filename label s out =
       Out.put out "&lt;LI&gt;" ;
       Out.put out "&lt;A HREF=\"" ;
       Out.put out filename ;
 <m>115   <r>Out.put_char out '#' ;
       Out.put out label ;
       Out.put out "\"&gt;" ;
       Out.put out s ;
       Out.put out "&lt;/A&gt;\n"
 </r>120 
     <b><U>and</U></b></m> putanchor label out =
       Out.put out "&lt;A NAME=\"" ;
       Out.put out label ;
       Out.put out "\"&gt;&lt;/A&gt;"
 <m>125 
     <b><U>and</U></b></m> itemlist s out =
       Out.put out "&lt;LI&gt;" ;
       Out.put out s
     ;;
 <m>130 
     <b><U>let</U></b></m> putlink out name img alt =
       Out.put out "&lt;A HREF=\"" ;
       Out.put out name ;
       Out.put out "\"&gt;&lt;IMG SRC =\"" ;
 <m>135   <r>Out.put out img ;
       Out.put out "\" ALT=\"" ;
       Out.put out alt ;
       Out.put out "\"&gt;&lt;/A&gt;\n"
     ;;
 </r>140 
     <b><U>let</U></b></m> link_buff = Out.create_buff ()
     
     <b><U>let</U><r> putlinks  name =
       </r><U>let</U></b> links_there = ref </r><U>false</U> <U>in</U></b>
 145   <b><U>if</U></b><r> !verbose &gt; 0 <b><U>then</U><r>
         prerr_endline ("putlinks: "^name) ;
       </r><U>begin</U> <U>try</U></b>
         putlink link_buff (Thread.prev name) "previous_motif.gif"
           (<b><U>if</U><r> !language = "fra" </r><U>then</U></b> "Precedent"
 <m>150        <b><U>else</U></b></m> "Previous") ;
         links_there := <b><U>true</U>
       <U>with</U></b> Not_found -&gt; () <b><U>end</U><r> ;
       </r><U>begin</U> <U>try</U></b>
         putlink link_buff (Thread.up name) "contents_motif.gif"
 <m>155       <r>(<b><U>if</U><r> !language = "fra" </r><U>then</U></b> "Index"
            <b><U>else</U><r> "Contents") ;
         links_there := </r><U>true</U>
       <U>with</U></b> Not_found -&gt; () <b><U>end</U><r> ;
       </r><U>begin</U> <U>try</U><m>
 160     <r>putlink link_buff (Thread.next name) "next_motif.gif"
           (<b><U>if</U><r> !language = "fra" </r><U>then</U></b> "Suivant"
            <b><U>else</U><r> "Next") ;
         links_there := </r><U>true</U>
       <U>with</U></b> Not_found -&gt; () <b><U>end</U></b> ;
 </r>165   </m><U>if</U></b> !links_there <b><U>then</U><r>
         Some (Out.to_string link_buff)
       </r><U>else</U></b>
         None
     
 </r>170 <b><U>let</U></b></m> putlinks_start out outname = <b><U>match</U><r> putlinks outname </r><U>with</U></b>
     | Some s -&gt;
         Out.put out s ;
         Out.put out "&lt;HR&gt;\n"
     | None -&gt; ()
 <m>175 
     <b><U>let</U></b></m> putlinks_end out outname = <b><U>match</U><r> putlinks outname </r><U>with</U></b>
     | Some s -&gt;
         Out.put out "&lt;HR&gt;\n" ;
         Out.put out s
 <m>180 <r>| None -&gt; ()
     
     
     <b><U>let</U></b> openhtml withlinks title out outname =
       Out.put out !doctype ; Out.put_char out '\n' ;
 </r>185   <r>Out.put out !html ; Out.put_char out '\n' ;
       Out.put out "&lt;HEAD&gt;\n" ;
       Out.put out !common_headers;
       Out.put out "&lt;TITLE&gt;\n" ;
       <b><U>let</U><r> title = Save.tagout (Lexing.from_string title) </r><U>in</U><m>
 190   <r>Out.put out title ;
       Out.put out "\n&lt;/TITLE&gt;\n" ;
       Out.put out "&lt;/HEAD&gt;\n" ;
       Out.put out !body;
       Out.put out "\n" ;
 </r>195   </m><U>if</U></b> withlinks <b><U>then</U></b>
         putlinks_start out outname ;
       Out.put out !html_head
     
     
 </r>200 <b><U>and</U></b></m> closehtml withlinks name out =
       Out.put out !html_foot ;
       <b><U>if</U><r> withlinks </r><U>then</U> <U>begin</U></b>
         putlinks_end out name
       <b><U>end</U><r> ;
 </r><m>205   <r>Out.put out "&lt;/BODY&gt;\n" ;
       Out.put out "&lt;/HTML&gt;\n" ;
       Out.close out
     ;;
     
 </r>210 </m><U>let</U></b> put_sec hd title hde out =
       Out.put out hd ;
       Out.put_char out '\n' ;
       Out.put out title ;
       Out.put out hde ;
 <m>215   <r>Out.put_char out '\n'
     ;;
     
     
     <b><U>let</U></b> put s = Out.put !out s
 </r>220 <b><U>and</U></b></m> put_char c = Out.put_char !out c
     ;;
     
     <b><U>let</U><r> cur_level = ref (Section.value "DOCUMENT")
     </r><U>and</U></b> chapter = ref (Section.value "CHAPTER")
 <m>225 <b><U>and</U></b></m> depth = ref 2
     ;;
     
     
     <w>(* Open all lists in toc from chapter to sec, with sec &gt; chapter *)
 </w></r>230 <b><U>let</U> <U>rec</U></b><r> do_open l1 l2 =
       <b><U>if</U><r> l1 &lt; l2 </r><U>then</U> <U>begin</U></b>
         openlist !toc ;
         <b><U>if</U><r> !tocbis </r><U>then</U></b> openlist !out_prefix ;
         do_open (l1+1) l2
 </r>235   <b><U>end</U></b><r>
     ;;
     
     <w>(* close from l1 down to l2 *)
     <b><U>let</U> <U>rec</U></b></w> do_close l1 l2 =
 </r>240   <b><U>if</U></b><r> l1 &gt; l2 <b><U>then</U> <U>begin</U></b>
          closelist !toc ;
          <b><U>if</U><r> !tocbis </r><U>then</U></b> closelist !out_prefix ;
          do_close (l1-1) l2
       <b><U>end</U> <U>else</U><m>
 245   <r>cur_level := l1
     ;;
     
     <b><U>let</U></b> anchor = ref 0
     ;;
 </r>250 
     </m><U>let</U></b> open_section sec name =
       <b><U>if</U><r> !phase &gt; 0 </r><U>then</U> <U>begin</U>
         <U>if</U></b> !cur_level &gt; sec <b><U>then</U><r> do_close !cur_level sec
         </r><U>else</U> <U>if</U></b> !cur_level &lt; sec <b><U>then</U></b> do_open  !cur_level sec ;
 </r>255     <r>incr anchor ;
         <b><U>let</U><r> label = "toc"^string_of_int !anchor </r><U>in</U></b>
         itemanchor !outname label name !toc ;
         <b><U>if</U><r> !tocbis </r><U>then</U></b> itemanchor !outname label name !out_prefix ;
         putanchor label !out ;
 </r>260     <r>cur_level := sec
       <b><U>end</U> <U>else</U></b>
         cur_level := sec
     
     <b><U>and</U></b> close_section sec =
 </r>265   <b><U>if</U><r> !phase &gt; 0 </r><U>then</U><r> do_close !cur_level sec
       <b><U>else</U><r>
         cur_level := sec
     ;;
     
 </r><m>270 </m><U>let</U></b> close_chapter () =
       <b><U>if</U><r> !verbose &gt; 0 </r><U>then</U></b>
         prerr_endline ("Close chapter out="^ !outname^" toc="^ !tocname) ;
       <b><U>if</U><r> !phase &gt; 0 </r><U>then</U> <U>begin</U></b>
         closehtml <b><U>true</U><r> !outname !out ;
 </r><m>275     </m><U>if</U></b> !tocbis <b><U>then</U> <U>begin</U>
           <U>let</U></b> real_out = open_out !outname <b><U>in</U><r>
           Out.to_chan real_out !out_prefix ;
           Out.to_chan real_out !out ;
           close_out real_out
 </r><m>280     </m><U>end</U> <U>else</U></b>
           Out.close !out ;
         out := !toc
       <b><U>end</U> <U>else</U> <U>begin</U></b>
         lastclosed := !outname ;
 <m>285     </m>outname := !tocname
       </r><U>end</U>
     
     <U>and</U><r> open_chapter name =
       outname := new_filename () ;
 </r><m>290   </m><U>if</U><r> !verbose &gt; 0 </r><U>then</U><r>
         prerr_endline
           ("Open chapter out="^ !outname^" toc="^ !tocname^
            " cur_level="^string_of_int !cur_level) ;
       </r><U>if</U><r> !phase &gt; 0 <b><U>then</U> <U>begin</U><m>
 295     </m><U>if</U></b> !tocbis <b><U>then</U> <U>begin</U></b>
           out_prefix := Out.create_buff () ;
           out := !out_prefix ;
           openhtml <b><U>true</U><r> name !out_prefix !outname
         </r><U>end</U> <U>else</U> <U>begin</U><m>
 300       <r>out := Out.create_chan (open_out !outname) ;
           openhtml <b><U>true</U><r> name !out !outname
         </r><U>end</U></b> ;
         itemref !outname name !toc ;
         cur_level := !chapter
 </r>305   </m><U>end</U> <U>else</U> <U>begin</U>
         <U>if</U></b> !verbose &gt; 0 <b><U>then</U><r>
           prerr_endline ("link prev="^ !lastclosed^" next="^ !outname) ;
         Thread.setup !outname !tocname ;
         Thread.setprevnext !lastclosed !outname ;
 <m>310     </m>cur_level := !chapter
       </r><U>end</U></b>
     ;;
     <b><U>let</U><r> setlink set target =
       </r><U>if</U></b> !phase = 0 &amp;&amp; target &lt;&gt; "" <b><U>then</U><m>
 315     <r>set !outname target
     
     <b><U>let</U><r> open_notes sec_notes =
       </r><U>if</U></b> sec_notes &lt;&gt; !chapter || !outname = !tocname <b><U>then</U> <U>begin</U></b>
         otheroutname := !outname ;
 </r>320     <r>outname := new_filename () ;
         <b><U>if</U><r> !phase &gt; 0 </r><U>then</U> <U>begin</U></b>
           otherout := !out ;
           out := Out.create_chan (open_out !outname) ;
           Out.put !out !doctype ; Out.put_char !out '\n' ;
 </r>325       <r>Out.put !out !html ; Out.put_char !out '\n' ;
           Out.put !out "&lt;HEAD&gt;&lt;TITLE&gt;Notes&lt;/TITLE&gt;\n" ;
           Out.put !out !common_headers ;
           Out.put !out "&lt;/HEAD&gt;\n" ;
           Out.put !out !body ;
 </r>330       <r>Out.put !out "\n"
         <b><U>end</U>
       <U>end</U> <U>else</U></b>
        otheroutname := ""
     
 </r>335 </m><U>and</U></b> close_notes () =
       <b><U>if</U><r> !otheroutname &lt;&gt; "" </r><U>then</U> <U>begin</U></b>
          Out.put !out "\n&lt;/BODY&gt;&lt;/HTML&gt;\n" ;
          Out.close !out ;
          outname := !otheroutname ;
 <m>340      <r>out := !otherout ;
          otheroutname := ""
       <b><U>end</U></b>
     ;;
     
 </r>345 <b><U>let</U></b></m> toc_buf = Out.create_buff ()
     <b><U>and</U><r> arg_buf = Out.create_buff ()
     ;;
     
     </r><U>let</U></b> stack = Stack.create "main"
 <m>350 <r>;;
     
     <b><U>let</U><r> save_state newchapter newdepth =
       </r><U>if</U></b> !verbose &gt; 0 <b><U>then</U></b>
         prerr_endline ("New state: "^string_of_int newchapter) ;
 </r>355   <r>push stack
         (!outname, Stack.save flowname_stack, Stack.save flow_stack,
          !chapter,!depth,!toc,!tocname,!cur_level,!lastclosed,!out_prefix) ;
       chapter := newchapter ;
       depth := newdepth ;
 </r>360   <r>tocname := !outname ;
       lastclosed := "" ;
       toc := !out
     ;;
     
 </r>365 <b><U>let</U></b></m> restore_state () =
       <b><U>if</U><r> !verbose &gt; 0 </r><U>then</U></b> prerr_endline ("Restore") ;
       <b><U>let</U><r>
         oldoutname, oldflowname, oldflow,
         oldchapter,olddepth,oldtoc,oldtocname,
 <m>370     </m>oldlevel,oldlastclosed,oldprefix  = pop stack </r><U>in</U></b>
       outname := oldoutname ;
       Stack.restore flowname_stack oldflowname ;
       Stack.restore flow_stack oldflow ;
       chapter := oldchapter ;
 <m>375   <r>depth := olddepth ;
       toc := oldtoc ;
       tocname := oldtocname ;
       lastclosed := !lastclosed ;
       cur_level := oldlevel ;
 </r>380   <r>out_prefix := oldprefix
     ;;
     
     <b><U>let</U><r> hevea_footer = ref </r><U>false</U><m>
     
 385 </m><U>let</U></b> close_top lxm =
       putlinks_end !toc !tocname ;
       <b><U>if</U><r> !hevea_footer </r><U>then</U> <U>begin</U></b>
         Out.put !out "&lt;!--FOOTER--&gt;\n" ;
         <b><U>begin</U> <U>try</U><m>
 390       <r>Mysys.put_from_file
             (Filename.concat Mylib.libdir ("cutfoot-"^ !language^".html"))
             (Out.put !out)
         <b><U>with</U><r> Mysys.Error s -&gt; </r><U>begin</U></b>
           Location.print_pos () ;
 </r>395       <r>prerr_endline s
         <b><U>end</U>
         <U>end</U>
       <U>end</U></b> ;
       Out.put !toc lxm ;
 </r>400   </m><U>if</U></b> !tocname = "" <b><U>then</U><r>
         Out.flush !toc
       </r><U>else</U></b>
        Out.close !toc
     ;;
 </r>405 
     <b><U>let</U></b></m> open_toc () = <b><U>if</U><r> !phase &gt; 0 </r><U>then</U></b> openlist !toc
     <b><U>and</U><r> close_toc () = </r><U>if</U></b> !phase &gt; 0 <b><U>then</U><r> closelist !toc
     ;;
     
 </r><m>410 </m><U>let</U></b> close_all () =
       <b><U>if</U><r> !cur_level &gt; !chapter </r><U>then</U> <U>begin</U></b>
         close_section !chapter ;
         close_chapter () ;
         close_toc ()
 <m>415   <b><U>end</U> <U>else</U> <U>if</U></b></m> !cur_level = !chapter <b><U>then</U> <U>begin</U></b>
         close_chapter () ;
         close_toc ()
       <b><U>end</U><r> ;
       cur_level := (Section.value "DOCUMENT")
 </r><m>420 
     </m><U>let</U></b> openflow title =
       <b><U>let</U><r> new_outname = new_filename () </r><U>in</U></b>
       push flowname_stack !outname ;
       outname := new_outname ;
 <m>425   <b><U>if</U></b></m> !phase &gt; 0 <b><U>then</U> <U>begin</U></b>
         push flow_stack !out ;
         out := Out.create_chan (open_out !outname) ;
         openhtml <b><U>false</U><r> title !out !outname
       </r><U>end</U><m>
 430 
     </m><U>and</U></b> closeflow () =
       <b><U>if</U><r> !phase &gt; 0 </r><U>then</U> <U>begin</U></b>
         closehtml <b><U>false</U><r> !outname !out;
         Out.close !out ;
 <m>435     </m>out := pop flow_stack
       </r><U>end</U></b> ;
       outname := pop flowname_stack
     
     
 <m>440 <b><U>let</U></b></m> lex_tables = {
       Lexing.lex_base =
        "\000\000\001\000\002\000\003\000\004\000\000\000\000\000\013\000\
    \031\000\078\000\079\000\063\000\109\000\000\000\001\000\032\000\
    \254\255\000\000\028\000\032\000\255\255\095\000\000\000\033\000\
    \000\000\005\000\016\001\252\255\253\255\014\000\061\000\014\000\
    \032\000\251\255\021\000\030\000\110\000\002\000\031\000\031\000\
    \140\000\003\000\057\000\067\000\068\000\074\000\250\255\014\000\
    \080\000\064\000\076\000\004\000\168\000\079\000\067\000\070\000\
    \089\000\253\255\083\000\067\000\094\000\080\000\085\000\108\000\
    \140\000\001\000\158\000\140\000\150\000\162\000\005\000\150\000\
    \162\000\152\000\161\000\169\000\177\000\178\000\002\000\194\000\
    \177\000\161\000\173\000\183\000\202\000\187\000\003\000\222\000\
    \074\001\203\000\185\000\173\000\186\000\166\000\200\000\007\000\
    \217\000\181\000\193\000\183\000\192\000\211\000\219\000\004\000\
    \246\000\210\000\210\000\200\000\209\000\217\000\227\000\221\000\
    \226\000\224\000\232\000\005\000\250\000\251\000\228\000\220\000\
    \231\000\133\001\192\001\012\001\000\001\240\000\005\000\234\255\
    \250\001\233\255\007\001\237\000\008\000\225\000\156\001\240\000\
    \229\000\231\000\247\000\238\255\242\000\249\000\236\255\244\000\
    \225\000\253\000\237\255\009\000\237\000\008\001\244\000\018\001\
    \235\255\062\001\029\001\042\001\026\001\023\001\086\001\098\001\
    \106\001\239\255\218\001\165\001\100\001\085\001\148\001\152\001\
    \160\001\157\001\167\001\164\001\157\001\127\001\140\001\010\000\
    \011\000\174\001\175\001\012\000\174\001\167\001\178\001\254\001\
    \203\001\189\001\006\000\248\255\175\001\185\001\223\001\224\001\
    \211\001\216\001\209\001\005\002\007\002\212\001\223\001\227\001\
    \016\002\226\001\237\001\242\001\240\001\022\002\008\002\249\001\
    \007\000\242\255\233\001\229\001\026\002\016\002\000\002\008\000\
    \241\255\250\001\255\001\020\002\023\002\025\002\009\000\246\001\
    \249\001\004\002\252\001\008\002\004\002\045\002\034\002\018\002\
    \244\255\253\001\014\002\002\002\044\002\046\002\030\002\010\000\
    \240\255\006\002\062\002\063\002\028\002\065\002\066\002\023\002\
    \021\002\017\002\033\002\020\002\072\002\060\002\045\002\011\000\
    \245\255\029\002\022\002\078\002\066\002\050\002\012\000\029\002\
    \082\002\047\002\049\002\041\002\052\002\089\002\077\002\062\002\
    \013\000\247\255\055\002\094\002\095\002\057\002\056\002\052\002\
    \099\002\100\002\054\002\051\002\068\002\055\002\107\002\108\002\
    \059\002";
       Lexing.lex_backtrk =
        "\255\255\255\255\255\255\255\255\255\255\001\000\001\000\255\255\
    \255\255\255\255\255\255\255\255\002\000\000\000\001\000\255\255\
    \255\255\001\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\001\000\255\255\255\255\003\000\003\000\003\000\
    \003\000\255\255\255\255\255\255\255\255\000\000\255\255\255\255\
    \255\255\001\000\255\255\255\255\255\255\255\255\255\255\005\000\
    \005\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\003\000\003\000\003\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\001\000\001\000\
    \255\255\255\255\255\255\255\255\001\000\255\255\000\000\000\000\
    \000\000\001\000\255\255\255\255\255\255\255\255\255\255\000\000\
    \001\000\255\255\255\255\255\255\255\255\255\255\255\255\000\000\
    \002\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\001\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\
    \021\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\012\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \005\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\007\000\255\255\255\255\255\255\255\255\004\000\
    \255\255\255\255\255\255\255\255\002\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \013\000\255\255\255\255\255\255\255\255\255\255\255\255\014\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\015\000\
    \255\255\255\255\255\255\001\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\010\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\003\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \008\000\255\255\255\255\255\255\006\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\009\000\
    \255\255";
 <m>445   <r>Lexing.lex_default =
        "\127\000\016\000\057\000\016\000\016\000\255\255\255\255\016\000\
    \016\000\027\000\046\000\027\000\255\255\255\255\255\255\016\000\
    \000\000\255\255\255\255\255\255\000\000\255\255\255\255\255\255\
    \255\255\025\000\255\255\000\000\000\000\255\255\255\255\255\255\
    \255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\095\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\110\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\
    \255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\138\000\000\000\255\255\141\000\000\000\255\255\
    \255\255\145\000\000\000\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \160\000\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\000\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\219\000\219\000\219\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255";
       Lexing.lex_trans =
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\020\000\027\000\016\000\020\000\020\000\020\000\
    \187\000\209\000\216\000\020\000\240\000\000\001\027\000\017\001\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \013\000\021\000\037\000\041\000\052\000\071\000\116\000\020\000\
    \147\000\147\000\176\000\176\000\180\000\023\000\022\000\018\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \087\000\087\000\084\000\064\000\128\000\115\000\104\000\096\000\
    \089\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\079\000\017\000\019\000\020\000\024\000\
    \044\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\066\000\047\000\028\000\042\000\021\000\
    \038\000\034\000\035\000\036\000\039\000\040\000\043\000\029\000\
    \036\000\045\000\067\000\048\000\022\000\030\000\036\000\025\000\
    \040\000\049\000\050\000\051\000\061\000\058\000\056\000\057\000\
    \059\000\060\000\026\000\026\000\020\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\031\000\
    \062\000\063\000\016\000\037\000\040\000\032\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \052\000\041\000\065\000\077\000\026\000\068\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \069\000\070\000\072\000\073\000\074\000\075\000\076\000\020\000\
    \078\000\080\000\081\000\082\000\083\000\020\000\053\000\085\000\
    \054\000\086\000\090\000\091\000\092\000\055\000\093\000\094\000\
    \129\000\057\000\255\255\255\255\057\000\255\255\095\000\255\255\
    \097\000\098\000\099\000\100\000\101\000\255\255\087\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \102\000\103\000\111\000\107\000\108\000\109\000\110\000\057\000\
    \255\255\016\000\112\000\113\000\114\000\105\000\020\000\117\000\
    \118\000\119\000\120\000\121\000\123\000\125\000\126\000\148\000\
    \143\000\140\000\137\000\138\000\153\000\139\000\141\000\142\000\
    \144\000\124\000\145\000\146\000\149\000\026\000\026\000\033\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\106\000\154\000\150\000\151\000\057\000\033\000\
    \152\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\162\000\155\000\156\000\157\000\026\000\
    \158\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\121\000\159\000\160\000\
    \161\000\021\001\007\001\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\163\000\122\000\122\000\
    \122\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
    \122\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
    \122\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
    \123\000\135\000\244\000\255\255\223\000\197\000\192\000\224\000\
    \188\000\178\000\225\000\032\001\177\000\124\000\174\000\175\000\
    \136\000\175\000\179\000\181\000\198\000\182\000\183\000\255\255\
    \185\000\255\255\163\000\186\000\189\000\255\255\190\000\191\000\
    \191\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
    \122\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
    \122\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
    \122\000\122\000\122\000\130\000\164\000\165\000\183\000\166\000\
    \167\000\193\000\168\000\194\000\195\000\196\000\169\000\196\000\
    \170\000\131\000\217\000\184\000\199\000\171\000\172\000\200\000\
    \200\000\210\000\203\000\204\000\205\000\207\000\205\000\208\000\
    \211\000\212\000\212\000\132\000\133\000\214\000\215\000\218\000\
    \219\000\220\000\134\000\206\000\221\000\241\000\221\000\213\000\
    \233\000\226\000\227\000\228\000\229\000\229\000\173\000\231\000\
    \232\000\234\000\255\255\235\000\236\000\255\255\201\000\222\000\
    \202\000\237\000\230\000\238\000\239\000\242\000\243\000\243\000\
    \245\000\246\000\246\000\001\001\249\000\250\000\251\000\252\000\
    \252\000\254\000\255\255\255\000\002\001\003\001\003\001\005\001\
    \006\001\008\001\009\001\010\001\011\001\253\000\018\001\012\001\
    \013\001\013\001\015\001\004\001\016\001\019\001\020\001\020\001\
    \022\001\023\001\024\001\025\001\025\001\027\001\014\001\028\001\
    \247\000\029\001\030\001\031\001\031\001\225\000\000\000\000\000\
    \248\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\026\001\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\255\255\000\000\000\000\255\255\
    \000\000\255\255\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000";
       Lexing.lex_check =
 </r>450    <r>"\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\024\000\065\000\078\000\086\000\103\000\126\000\
    \186\000\208\000\215\000\222\000\239\000\255\000\006\001\016\001\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \013\000\014\000\037\000\041\000\051\000\070\000\115\000\025\000\
    \132\000\147\000\175\000\176\000\179\000\022\000\014\000\017\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\007\000\047\000\000\000\001\000\002\000\003\000\
    \004\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\008\000\015\000\018\000\019\000\023\000\
    \029\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\009\000\010\000\011\000\030\000\021\000\
    \031\000\032\000\034\000\035\000\038\000\039\000\042\000\011\000\
    \043\000\044\000\009\000\010\000\021\000\011\000\036\000\012\000\
    \045\000\048\000\049\000\050\000\053\000\054\000\055\000\056\000\
    \058\000\059\000\012\000\012\000\060\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\011\000\
    \061\000\062\000\063\000\036\000\040\000\011\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \052\000\040\000\064\000\066\000\012\000\067\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \068\000\069\000\071\000\072\000\073\000\074\000\075\000\076\000\
    \077\000\079\000\080\000\081\000\082\000\083\000\052\000\084\000\
    \052\000\085\000\089\000\090\000\091\000\052\000\092\000\093\000\
    \000\000\001\000\002\000\003\000\004\000\025\000\094\000\095\000\
    \096\000\097\000\098\000\099\000\100\000\007\000\087\000\087\000\
    \087\000\087\000\087\000\087\000\087\000\087\000\087\000\087\000\
    \101\000\102\000\105\000\106\000\107\000\108\000\109\000\008\000\
    \015\000\110\000\111\000\112\000\113\000\104\000\114\000\116\000\
    \117\000\118\000\119\000\120\000\123\000\124\000\125\000\131\000\
    \133\000\135\000\136\000\137\000\130\000\138\000\140\000\141\000\
    \143\000\123\000\144\000\145\000\148\000\026\000\026\000\011\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\104\000\130\000\149\000\150\000\009\000\010\000\
    \151\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\153\000\154\000\155\000\156\000\026\000\
    \157\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\026\000\026\000\026\000\026\000\026\000\
    \026\000\026\000\026\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\121\000\158\000\159\000\
    \160\000\164\000\165\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\088\000\088\000\088\000\
    \088\000\088\000\088\000\088\000\088\000\163\000\121\000\121\000\
    \121\000\121\000\121\000\121\000\121\000\121\000\121\000\121\000\
    \121\000\121\000\121\000\121\000\121\000\121\000\121\000\121\000\
    \121\000\121\000\121\000\121\000\121\000\121\000\121\000\121\000\
    \122\000\134\000\166\000\110\000\167\000\168\000\169\000\167\000\
    \170\000\171\000\167\000\163\000\172\000\122\000\173\000\174\000\
    \134\000\177\000\178\000\180\000\168\000\181\000\182\000\138\000\
    \184\000\141\000\162\000\185\000\188\000\145\000\189\000\190\000\
    \191\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
    \122\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
    \122\000\122\000\122\000\122\000\122\000\122\000\122\000\122\000\
    \122\000\122\000\122\000\128\000\162\000\162\000\183\000\162\000\
    \162\000\192\000\162\000\193\000\194\000\195\000\162\000\196\000\
    \162\000\128\000\197\000\183\000\198\000\162\000\162\000\199\000\
    \200\000\201\000\202\000\203\000\204\000\206\000\205\000\207\000\
    \210\000\211\000\212\000\128\000\128\000\213\000\214\000\217\000\
    \218\000\219\000\128\000\205\000\220\000\223\000\221\000\212\000\
    \224\000\225\000\226\000\227\000\228\000\229\000\162\000\230\000\
    \231\000\233\000\219\000\234\000\235\000\220\000\200\000\221\000\
    \200\000\236\000\229\000\237\000\238\000\241\000\242\000\243\000\
    \244\000\245\000\246\000\247\000\248\000\249\000\250\000\251\000\
    \252\000\253\000\160\000\254\000\001\001\002\001\003\001\004\001\
    \005\001\007\001\008\001\009\001\009\001\252\000\010\001\011\001\
    \012\001\013\001\014\001\003\001\015\001\018\001\019\001\020\001\
    \021\001\022\001\023\001\024\001\025\001\026\001\013\001\027\001\
    \246\000\028\001\029\001\030\001\031\001\032\001\255\255\255\255\
    \246\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\025\001\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\219\000\255\255\255\255\220\000\
    \255\255\221\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255"
     }
     
     <b><U>let</U> <U>rec</U></b> main lexbuf = __ocaml_lex_main_rec lexbuf 0
     <b><U>and</U></b> __ocaml_lex_main_rec lexbuf state =
 </r>455   <b><U>match</U></b></m> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      454 "cut.mll"
          </r><U>let</U></b> lxm = lexeme lexbuf </r><U>in</U>
         <U>if</U><r> !phase &gt; 0 </r><U>then</U> <U>begin</U><m>
 460       <r>put lxm ;
           put ("&lt;!--HACHA command line is: ") ;
           <b><U>for</U><r> i = 0 </r><U>to</U></b> Array.length Sys.argv - 1 <b><U>do</U></b>
             put Sys.argv.(i) ;
             put_char ' '
 </r>465       </m><U>done</U><r> ;
           put "--&gt;\n"
         <b><U>end</U><r> ;
         main lexbuf)
       | 1 -&gt; (
 <m>470  </m>466 "cut.mll"
         </r><U>let</U></b> title = flowline lexbuf <b><U>in</U><r>
        openflow title ;
        main lexbuf)
       | 2 -&gt; (
 <m>475  </m>470 "cut.mll"
         linkline lexbuf ;
        main lexbuf)
       | 3 -&gt; (
      473 "cut.mll"
 <m>480     </m>closeflow () ;
        main lexbuf)
       | 4 -&gt; (
      476 "cut.mll"
          </r><U>let</U></b> name = tocline lexbuf <b><U>in</U><m>
 485     <r>change_name !outname name ;
         main lexbuf)
       | 5 -&gt; (
      480 "cut.mll"
          <b><U>let</U><r> arg = secname lexbuf </r><U>in</U><m>
 490     </m><U>let</U></b> sn =
           <b><U>if</U><r> String.uppercase arg = "NOW" </r><U>then</U></b> !chapter
           <b><U>else</U><r> Section.value arg </r><U>in</U>
         <U>let</U></b> name = tocline lexbuf <b><U>in</U>
         <U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U><m>
 495       <r>prerr_endline ("TOC "^arg^" "^name)
         <b><U>end</U><r>;
         </r><U>if</U></b> sn &lt; !chapter <b><U>then</U> <U>begin</U>
           <U>if</U></b> !cur_level &gt;= !chapter <b><U>then</U> <U>begin</U></b>
             close_section (!chapter) ;
 </r>500         <r>close_chapter () ;
             close_toc ()
           <b><U>end</U><r> ;
           cur_level := sn
         </r><U>end</U> <U>else</U> <U>if</U></b> sn = !chapter <b><U>then</U> <U>begin</U><m>
 505       </m><U>if</U></b> !cur_level &lt; sn <b><U>then</U> <U>begin</U></b>
             open_toc () ;
           <b><U>end</U> <U>else</U> <U>begin</U></b>
             close_section !chapter ;
             close_chapter  ()
 </r>510       </m><U>end</U></b> ;
           open_chapter name
         <b><U>end</U> <U>else</U> <U>if</U></b> sn &lt;= !chapter + !depth <b><U>then</U> <U>begin</U><w> (* sn &gt; !chapter *)
           </w><U>if</U></b> !cur_level &lt; !chapter <b><U>then</U> <U>begin</U></b>
             open_toc () ;
 </r>515         <r>open_chapter ""
           <b><U>end</U><r> ;
           close_section sn ;
           open_section sn name
         </r><U>end</U></b> ;
 </r>520     <r>main lexbuf)
       | 6 -&gt; (
      513 "cut.mll"
          <b><U>let</U><r> chapter = Section.value (String.uppercase (secname lexbuf)) </r><U>in</U></b>
         skip_blanks lexbuf;
 </r>525     </m><U>let</U></b> depth = intarg lexbuf <b><U>in</U><r>
         skip_endcom lexbuf ;
         save_state chapter depth ;
         cur_level := Section.value "DOCUMENT" ;
         main lexbuf)
 <m>530   </m>| 7 -&gt; (
      521 "cut.mll"
          </r><U>if</U></b> !phase &gt; 0 <b><U>then</U> <U>begin</U>
           <U>if</U></b> !tocbis &amp;&amp; !out == !out_prefix <b><U>then</U><r>
             out := Out.create_buff ()
 </r><m>535     </m><U>end</U></b> ;
         main lexbuf)
       | 8 -&gt; (
      527 "cut.mll"
          close_all () ;
 <m>540       <r>restore_state () ;
           main lexbuf)
       | 9 -&gt; (
      531 "cut.mll"
          <b><U>let</U><r> sec_notes = secname lexbuf </r><U>in</U><m>
 545     <r>skip_endcom lexbuf ;
         open_notes (Section.value sec_notes) ;
         main lexbuf)
       | 10 -&gt; (
      536 "cut.mll"
 </r>550      </m><U>if</U></b> !otheroutname &lt;&gt; "" <b><U>then</U></b>
           close_notes ();
           main lexbuf)
       | 11 -&gt; (
      540 "cut.mll"
 </r>555      <r>language := "fra" ;
           main lexbuf)
       | 12 -&gt; (
      543 "cut.mll"
          <b><U>if</U><r> !phase &gt; 0 </r><U>then</U></b> put (lexeme lexbuf) ;
 </r>560     <r>aargs lexbuf)
       | 13 -&gt; (
      546 "cut.mll"
          <b><U>let</U><r> head = save_html lexbuf </r><U>in</U>
         <U>if</U></b> !phase = 0 <b><U>then</U><m>
 565       <r>html_head := head
         <b><U>else</U></b>
           Out.put !out head;
         main lexbuf)
       | 14 -&gt; (
 </r>570  <r>553 "cut.mll"
          <b><U>let</U><r> foot =  save_html lexbuf </r><U>in</U>
         <U>if</U></b> !phase = 0 <b><U>then</U></b>
           html_foot := foot ;
         main lexbuf)
 </r>575   <r>| 15 -&gt; (
      558 "cut.mll"
          close_all () ;
           <b><U>if</U><r> !phase &gt; 0 </r><U>then</U> <U>begin</U></b>
             hevea_footer := <b><U>true</U></b> ;
 </r>580         <r>Out.put !out !html_foot
           <b><U>end</U></b> ;
           footer lexbuf)
       | 16 -&gt; (
      565 "cut.mll"
 </r>585      </m><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U>
         <U>if</U></b> !phase = 0 <b><U>then</U><r>
           doctype := lxm
         </r><U>else</U></b>
           Out.put !out lxm;
 </r>590     <r>main lexbuf)
       | 17 -&gt; (
      572 "cut.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>if</U></b> !phase = 0 <b><U>then</U><m>
 595       <r>html := lxm
         <b><U>else</U></b>
           Out.put !out lxm;
         main lexbuf)
       | 18 -&gt; (
 </r>600  <r>579 "cut.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>if</U></b> !phase = 0 <b><U>then</U><r>
           body := lxm
         </r><U>else</U> <U>begin</U><m>
 605       <r>Out.put !out lxm ;
           putlinks_start !out !outname
         <b><U>end</U></b> ;
         main lexbuf)
       | 19 -&gt; (
 </r>610  <r>588 "cut.mll"
          put (lexeme lexbuf);
           <b><U>if</U><r> !phase = 0 </r><U>then</U> <U>begin</U>
             <U>if</U></b> !verbose &gt; 0 <b><U>then</U></b> prerr_endline "Collect header" ;
             collect_header lexbuf
 </r>615       </m><U>end</U> <U>else</U></b>
             main lexbuf)
       | 20 -&gt; (
      595 "cut.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U><m>
 620     <r>close_all () ;
         <b><U>if</U><r> !phase &gt; 0 </r><U>then</U> <U>begin</U></b>
           close_top lxm
         <b><U>end</U></b>)
       | 21 -&gt; (
 </r>625  <r>601 "cut.mll"
          <b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U>
         <U>if</U></b> !phase &gt; 0 <b><U>then</U></b> put_char lxm ;
         main lexbuf)
       | 22 -&gt; (
 </r>630  <r>605 "cut.mll"
          raise (Error ("No &lt;/BODY&gt; tag in input file")))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_main_rec lexbuf n
     
     <b><U>and</U></b> save_html lexbuf = __ocaml_lex_save_html_rec lexbuf 1
 </r>635 </m><U>and</U></b> __ocaml_lex_save_html_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
      609 "cut.mll"
          <b><U>let</U><r> s = Out.to_string html_buff </r><U>in</U><m>
 640     </m><U>if</U></b> !verbose &gt; 0 <b><U>then</U></b>
           prerr_endline ("save_html -&gt; ``"^s^"''");
         s)
       | 1 -&gt; (
      614 "cut.mll"
 </r>645      </m><U>let</U></b> lxm = lexeme_char lexbuf 0 <b><U>in</U></b>
         Out.put_char html_buff lxm ;
         save_html lexbuf)
       | 2 -&gt; (
      618 "cut.mll"
 </r>650      <r>raise (Misc.Fatal ("End of file in save_html")))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_save_html_rec lexbuf n
     
     <b><U>and</U><r> collect_header lexbuf = __ocaml_lex_collect_header_rec lexbuf 2
     </r><U>and</U></b> __ocaml_lex_collect_header_rec lexbuf state =
 </r>655   <b><U>match</U></b></m> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      622 "cut.mll"
          </r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><r>
         finalize_header () ;
 </r><m>660     </m><U>if</U></b> !verbose &gt; 0 <b><U>then</U> <U>begin</U></b>
           prerr_string "Header is: ``" ;
           prerr_string !common_headers ;
           prerr_endline "''"
         <b><U>end</U><r> ;
 <m>665     </m>main lexbuf)
       | 1 -&gt; (
      632 "cut.mll"
          skip_title lexbuf ;
           collect_header lexbuf)
 <m>670   </m>| 2 -&gt; (
      635 "cut.mll"
          </r><U>let</U></b> lxm = lexeme_char lexbuf 0 <b><U>in</U><r>
         adjoin_to_header_char lxm;
         collect_header lexbuf)
 <m>675   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_collect_header_rec lexbuf n
     
     </r><U>and</U></b> skip_title lexbuf = __ocaml_lex_skip_title_rec lexbuf 3
     <b><U>and</U><r> __ocaml_lex_skip_title_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><m>
 680     <r>0 -&gt; (
      640 "cut.mll"
                          ())
       | 1 -&gt; (
      641 "cut.mll"
 </r>685                <r>skip_title lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_title_rec lexbuf n
     
     <b><U>and</U><r> footer lexbuf = __ocaml_lex_footer_rec lexbuf 4
     </r><U>and</U></b> __ocaml_lex_footer_rec lexbuf state =
 </r>690   </m><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      645 "cut.mll"
          </r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U>
         <U>if</U></b> !phase &gt; 0 <b><U>then</U> <U>begin</U><m>
 695       <r>close_top lxm
         <b><U>end</U></b>)
       | 1 -&gt; (
      649 "cut.mll"
            footer lexbuf)
 </r>700   <r>| 2 -&gt; (
      650 "cut.mll"
            raise (Misc.Fatal ("End of file in footer (no &lt;/BODY&gt; tag)")))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_footer_rec lexbuf n
     
 </r>705 </m><U>and</U></b> secname lexbuf = __ocaml_lex_secname_rec lexbuf 5
     <b><U>and</U><r> __ocaml_lex_secname_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      654 "cut.mll"
 </r><m>710      </m><U>let</U></b> r = lexeme lexbuf <b><U>in</U><r> r)
       | 1 -&gt; (
      655 "cut.mll"
           raise (Error "Bad section name syntax"))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_secname_rec lexbuf n
 <m>715 
     <b><U>and</U><r> intarg lexbuf = __ocaml_lex_intarg_rec lexbuf 6
     </r><U>and</U><r> __ocaml_lex_intarg_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
 <m>720  </m>658 "cut.mll"
                     int_of_string (lexeme lexbuf))
       | 1 -&gt; (
      659 "cut.mll"
                   !depth)
 <m>725   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_intarg_rec lexbuf n
     
     <b><U>and</U><r> tocline lexbuf = __ocaml_lex_tocline_rec lexbuf 7
     </r><U>and</U></b> __ocaml_lex_tocline_rec lexbuf state =
       <b><U>match</U></b> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
 730     </m>0 -&gt; (
      662 "cut.mll"
                       Out.to_string toc_buf)
       | 1 -&gt; (
      664 "cut.mll"
 <m>735      </m>Out.put_char toc_buf (lexeme_char lexbuf 0) ;
           tocline lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_tocline_rec lexbuf n
     
     </r><U>and</U></b> arg lexbuf = __ocaml_lex_arg_rec lexbuf 8
 <m>740 <b><U>and</U><r> __ocaml_lex_arg_rec lexbuf state =
       </r><U>match</U><r> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      668 "cut.mll"
                 Out.to_string arg_buf)
 <m>745   </m>| 1 -&gt; (
      669 "cut.mll"
                  Out.put_char arg_buf (Lexing.lexeme_char lexbuf 0) ; arg lexbuf)
       | 2 -&gt; (
      670 "cut.mll"
 <m>750              </m>raise (Misc.Fatal "Unclosed arg"))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_arg_rec lexbuf n
     
     </r><U>and</U></b> flowline lexbuf = __ocaml_lex_flowline_rec lexbuf 9
     <b><U>and</U><r> __ocaml_lex_flowline_rec lexbuf state =
 <m>755   <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><r>
         0 -&gt; (
      674 "cut.mll"
          <b><U>let</U><r> title = arg lexbuf </r><U>in</U>
         <U>let</U></b> _ = flowline lexbuf </r><U>in</U></b>
 760     </m>title)
       | 1 -&gt; (
      678 "cut.mll"
          "")
       | 2 -&gt; (
 <m>765  </m>679 "cut.mll"
            raise (Misc.Fatal "Unclosed comment"))
       | 3 -&gt; (
      680 "cut.mll"
            flowline lexbuf)
 <m>770   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_flowline_rec lexbuf n
     
     </r><U>and</U></b> linkline lexbuf = __ocaml_lex_linkline_rec lexbuf 10
     <b><U>and</U><r> __ocaml_lex_linkline_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
 775     </m>0 -&gt; (
      684 "cut.mll"
        <b><U>let</U><r> link = arg lexbuf </r><U>in</U></b>
       setlink Thread.setprev link ;
       linkline lexbuf)
 <m>780   </m>| 1 -&gt; (
      688 "cut.mll"
        <b><U>let</U><r> link = arg lexbuf </r><U>in</U></b>
       setlink Thread.setnext link ;
       linkline lexbuf)
 <m>785   </m>| 2 -&gt; (
      692 "cut.mll"
        <b><U>let</U><r> link = arg lexbuf </r><U>in</U></b>
       setlink Thread.setup link ;
       linkline lexbuf)
 <m>790   </m>| 3 -&gt; (
      696 "cut.mll"
        ())
       | 4 -&gt; (
      697 "cut.mll"
 <m>795        </m>raise (Misc.Fatal "Unclosed comment"))
       | 5 -&gt; (
      698 "cut.mll"
            linkline lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_linkline_rec lexbuf n
 <m>800 
     <b><U>and</U><r> aargs lexbuf = __ocaml_lex_aargs_rec lexbuf 11
     </r><U>and</U><r> __ocaml_lex_aargs_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
 <m>805  </m>702 "cut.mll"
        <b><U>if</U><r> !phase = 0 </r><U>then</U> <U>begin</U>
         <U>let</U></b> name = refname lexbuf <b><U>in</U></b>
         Cross.add name !outname
       </r><U>end</U> <U>else</U></b>
 810     </m>put (lexeme lexbuf) ;
       aargs lexbuf)
       | 1 -&gt; (
      709 "cut.mll"
         <b><U>if</U></b> !phase &gt; 0 </r><U>then</U> <U>begin</U><m>
 815       </m><U>let</U><r> lxm = lexeme lexbuf <b><U>in</U>
           <U>let</U></b> name = refname lexbuf <b><U>in</U>
           <U>try</U>
             <U>let</U></b> newname =
               <b><U>if</U><r> String.length name &gt; 0 &amp;&amp; String.get name 0 = '#' </r><U>then</U><m>
 820             <r>Cross.fullname !outname (String.sub name 1 (String.length name-1))
               <b><U>else</U><r> name </r><U>in</U></b>
             put lxm ;
             put "\"" ;
             put newname ;
 </r>825         <r>put "\""
           <b><U>with</U><r> Not_found -&gt; ()
         </r><U>end</U></b> ;
         aargs lexbuf)
       | 2 -&gt; (
 </r>830  <r>725 "cut.mll"
        <b><U>if</U><r> !phase &gt; 0 </r><U>then</U></b> put_char '&gt;' ;
       main lexbuf)
       | 3 -&gt; (
      728 "cut.mll"
 </r>835    </m><U>if</U></b> !phase &gt; 0 <b><U>then</U><r> put_char (lexeme_char lexbuf 0) ;
       aargs lexbuf)
       | 4 -&gt; (
      731 "cut.mll"
        raise (Error "Bad &lt;A ...&gt; tag"))
 <m>840   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_aargs_rec lexbuf n
     
     </r><U>and</U></b> refname lexbuf = __ocaml_lex_refname_rec lexbuf 12
     <b><U>and</U><r> __ocaml_lex_refname_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><m>
 845     <r>0 -&gt; (
      735 "cut.mll"
         <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
        String.sub lxm 1 (String.length lxm-2))
       | 1 -&gt; (
 </r>850  <r>738 "cut.mll"
         lexeme lexbuf)
       | 2 -&gt; (
      739 "cut.mll"
           raise (Error "Bad reference name syntax"))
 </r>855   <r>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_refname_rec lexbuf n
     
     <b><U>and</U><r> skip_blanks lexbuf = __ocaml_lex_skip_blanks_rec lexbuf 13
     </r><U>and</U></b> __ocaml_lex_skip_blanks_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><m>
 860     <r>0 -&gt; (
      742 "cut.mll"
             ())
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_blanks_rec lexbuf n
     
 </r>865 </m><U>and</U></b> skip_endcom lexbuf = __ocaml_lex_skip_endcom_rec lexbuf 14
     <b><U>and</U><r> __ocaml_lex_skip_endcom_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
      745 "cut.mll"
 </r>870                     <r>())
       | 1 -&gt; (
      746 "cut.mll"
                         raise (Error "Bad HTML comment syntax"))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_endcom_rec lexbuf n
 </r>875 
     </m><U>and</U></b> skip_aref lexbuf = __ocaml_lex_skip_aref_rec lexbuf 15
     <b><U>and</U><r> __ocaml_lex_skip_aref_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
 <m>880  </m>748 "cut.mll"
               ())
       | 1 -&gt; (
      749 "cut.mll"
               skip_aref lexbuf)
 <m>885   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_aref_rec lexbuf n
     
     ;;<PL><B>
<6>75 element.ml</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>let</U></b> header =  "$Id: element.ml,v 1.1 2000/05/30 12:30:14 maranget Exp $"
     <w>(* For text-level elements *)
     <b><U>type</U></b></w> text =
  <m>15   <r>Style <b><U>of</U><r> string
     | Font </r><U>of</U></b> int
     | Color <b><U>of</U><r> string
     
     </r><U>let</U></b> pretty_text = <b><U>function</U><m>
  20   <r>Style s -&gt; "Style: "^s
     | Font i  -&gt; "Font size: "^string_of_int i
     | Color s  -&gt; "Font color: "^s
     ;;<PL><B>
<6>76 emisc.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: emisc.ml,v 1.1 2001/05/29 09:23:30 maranget Exp $          *)
     (***********************************************************************)
     
     </w><b><U>let</U></b> basefont = ref 3
     
  </r>15 </m><U>let</U></b> reset () =
       basefont := 3<PL><B>
<6>77 entry.ml</6>
</B></PL> 
      12 "entry.mll"
     
     <b><U>open</U></b> Lexing
     
   </r>5 <b><U>let</U></b></m> header = "$Id: entry.mll,v 1.11 1999/12/07 16:12:15 maranget Exp $"
     
     <b><U>let</U><r> buff = Out.create_buff ()
     ;;
     
  </r><m>10 </m><U>let</U></b> put s =
       Out.put buff s
     <b><U>and</U><r> put_char c =
       Out.put_char buff c
     ;;
  </r><m>15 
     
     </m><U>type</U></b> res =
     | Bang <b><U>of</U><r> string * string
     | Bar </r><U>of</U></b> string * string
  <m>20 <r>| Eof <b><U>of</U><r> string * string
     ;;
     
     </r><U>let</U></b> extend r i = <b><U>match</U><r> r </r><U>with</U></b>
     | Bang (p,_) -&gt; Bang (i,p)
  </r>25 <r>| Bar (p,_) -&gt; Bar (i,p)
     | Eof (p,_) -&gt; Eof (i,p)
     ;;
     
     <b><U>type</U></b> key = string list * string list
  </r>30 
     <b><U>exception</U></b></m> Fini
     <b><U>exception</U><r> NoGood
     ;;
     
  </r><m>35 </m><U>let</U></b> lex_tables = {
       Lexing.lex_base =
        "\000\000\001\000\253\255\000\000\254\255\000\000\000\000\000\000\
    \000\000\001\000\001\000\000\000\000\000\000\000\255\255\247\255\
    \251\255\002\000\250\255\002\000\249\255\248\255\252\255";
       Lexing.lex_backtrk =
        "\255\255\255\255\255\255\002\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\008\000\255\255\008\000\255\255\255\255\255\255";
  <m>40   <r>Lexing.lex_default =
        "\015\000\002\000\000\000\255\255\000\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000\
    \000\000\255\255\000\000\255\255\000\000\000\000\000\000";
       Lexing.lex_trans =
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\016\000\017\000\004\000\014\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \018\000\000\000\002\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\019\000\003\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\007\000\008\000\010\000\000\000\
    \000\000\005\000\000\000\000\000\000\000\000\000\006\000\011\000\
    \000\000\000\000\013\000\000\000\012\000\000\000\000\000\000\000\
    \009\000\014\000\000\000\000\000\020\000\000\000\022\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \021\000\004\000\000\000";
       Lexing.lex_check =
  </r>45    <r>"\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\017\000\019\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\017\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\000\000\001\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\006\000\007\000\009\000\255\255\
    \255\255\003\000\255\255\255\255\255\255\255\255\005\000\010\000\
    \255\255\255\255\012\000\255\255\011\000\255\255\255\255\255\255\
    \008\000\013\000\255\255\255\255\000\000\255\255\017\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\001\000\255\255"
     }
     
     <b><U>let</U> <U>rec</U></b> entry lexbuf = __ocaml_lex_entry_rec lexbuf 0
     <b><U>and</U></b> __ocaml_lex_entry_rec lexbuf state =
  </r>50   <b><U>match</U></b></m> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      48 "entry.mll"
          put "\\\"" ; entry lexbuf)
       | 1 -&gt; (
  <m>55  </m>50 "entry.mll"
          put_char '!' ; entry lexbuf)
       | 2 -&gt; (
      52 "entry.mll"
          put_char '@' ; entry lexbuf)
  <m>60   </m>| 3 -&gt; (
      54 "entry.mll"
          put_char '|' ; entry lexbuf)
       | 4 -&gt; (
      55 "entry.mll"
  <m>65        </m>Bang   (Out.to_string buff,""))
       | 5 -&gt; (
      56 "entry.mll"
            </r><U>let</U></b> s = Out.to_string buff <b><U>in</U>
           <U>let</U></b> r = entry lexbuf <b><U>in</U><m>
  70       <r>extend r s)
       | 6 -&gt; (
      59 "entry.mll"
            Bar (Out.to_string buff,""))
       | 7 -&gt; (
  </r>75  <r>60 "entry.mll"
            Eof (Out.to_string buff,""))
       | 8 -&gt; (
      62 "entry.mll"
         <b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U></b> put_char lxm ; entry lexbuf)
  </r>80   <r>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_entry_rec lexbuf n
     
     <b><U>and</U><r> idx lexbuf = __ocaml_lex_idx_rec lexbuf 1
     </r><U>and</U></b> __ocaml_lex_idx_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><m>
  85     <r>0 -&gt; (
      66 "entry.mll"
           <b><U>let</U><r> key = Save.arg lexbuf </r><U>in</U>
          <U>let</U></b>  value = Save.arg lexbuf <b><U>in</U></b>
          key,value)
  </r>90   <r>| 1 -&gt; (
      69 "entry.mll"
            raise Fini)
       | 2 -&gt; (
      70 "entry.mll"
  </r>95        <r>idx lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_idx_rec lexbuf n
     
     ;;
     
 </r>100  <r>73 "entry.mll"
     
     
     <b><U>let</U></b> read_key lexbuf =
     
 </r>105   </m><U>let</U></b> bar () = <b><U>match</U><r> entry lexbuf </r><U>with</U></b>
       | Eof (s,_) -&gt;
           <b><U>begin</U> <U>match</U></b> s <b><U>with</U></b>
           | ""|"("|")" -&gt; None
           | s -&gt;
 </r>110           </m><U>if</U></b> s.[0] = '(' </r><U>then</U><r>
                 Some (String.sub s 1 (String.length s - 1))
               </r><U>else</U><r>
                 Some s
           <b><U>end</U><m>
 115   <r>| _         -&gt; raise NoGood <b><U>in</U>
     
       <U>let</U> <U>rec</U></b> get_rec () = <b><U>match</U><r> entry  lexbuf </r><U>with</U></b>
         Bang (i,p) -&gt;
           <b><U>let</U><r> l,see = get_rec () </r><U>in</U><m>
 120       <r>(i,p)::l,see
       | Bar (i,p) -&gt;
           <b><U>let</U><r> see = bar () </r><U>in</U></b>
           [i,p],see
       | Eof (i,p) -&gt; [i,p],None <b><U>in</U><m>
 125 
       </m><U>let</U></b> separe (l,see) =
         <b><U>let</U> <U>rec</U></b> sep_rec = <b><U>function</U></b>
           [] -&gt; [],[]
         | (x,y)::r -&gt;
 </r>130         </m><U>let</U></b> xs,ys = sep_rec r <b><U>in</U><r>
             x::xs,y::ys </r><U>in</U>
         <U>let</U></b> xs,ys = sep_rec l <b><U>in</U><r>
         ((xs,ys),see) </r><U>in</U><m>
     
 135   <r>separe (get_rec ())
     
     <b><U>let</U><r> read_indexentry lexbuf = idx lexbuf<PL><B>
<6>78 esponjamain.ml</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: esponjamain.ml,v 1.3 2001/05/28 17:28:55 maranget Exp $           *)
     (***********************************************************************)
     
     </w><U>open</U></b> Mysys
     <b><U>open</U></b> Esponja
  </r>15 
     </m><U>let</U></b> arg = ref []
     ;;
     
     Arg.parse
  </r>20   <r>["-u", Arg.Set pess, "pessimize" ;
       "-v", Arg.Unit (<b><U>fun</U><r> () -&gt; incr Ultra.verbose),"be verbose" ;
       "-n", Arg.Unit (</r><U>fun</U></b> () -&gt; move := <b><U>false</U><r> ; incr Ultra.verbose),
         "do not change files"]
       (</r><U>fun</U></b> s -&gt; arg :=  s :: !arg)
  </r>25   <r>("Usage: esponja [option*] &lt; infile &gt; outfile,\n or    esponja [option*] files+
     options are:")
     ;;
     
     <b><U>let</U></b> main () =
  </r>30   </m><U>try</U>
         <U>begin</U> <U>match</U></b> !arg <b><U>with</U><r>
         | [] -&gt;
             ignore (process "" stdin stdout)
         | files -&gt;
  <m>35         </m>List.iter (</r><U>fun</U></b> f -&gt; ignore (Esponja.file f)) (List.rev files)
         <b><U>end</U><r> ;
         exit 0
       </r><U>with</U></b>
       | e -&gt;
  <m>40       <r>Printf.fprintf stderr "Unexpected exception: %s\n"
             (Printexc.to_string e) ;
           exit 1
     ;;
     
  </r>45 <r>main ()
     ;;<PL><B>
<6>79 esponja.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: esponja.ml,v 1.8 2001/05/29 09:23:31 maranget Exp $           *)
     (***********************************************************************)
     
     </w><b><U>open</U></b> Mysys
     
  </r>15 <b><U>let</U></b></m> pess  = ref <b><U>false</U>
     <U>and</U></b> move  = ref <b><U>true</U><r>
     ;;
     
     
  <m>20 <b><U>let</U><r> process in_name input output =
       </r><U>let</U> <U>rec</U><r> do_rec lexbuf = <b><U>match</U><r> Htmlparse.main lexbuf </r><U>with</U></b>
       | [] -&gt; ()
       | ts -&gt;
           <b><U>if</U></b> !pess </r><U>then</U></b>
  25         </m>Pp.trees output (Explode.trees ts)
           </r><U>else</U></b>
             Ultra.main output ts ;
           do_rec lexbuf <b><U>in</U>
       <U>try</U><m>
  30     </m><U>let</U></b> lexbuf = Lexing.from_channel input <b><U>in</U><r>
         Location.set in_name lexbuf ;
         Emisc.reset () ;
         do_rec lexbuf ;
         Location.restore () ;
  <m>35     <b><U>true</U>
       <U>with</U><r>
       | Htmllex.Error s -&gt;
           <b><U>if</U><r> !Ultra.verbose &gt; 0 </r><U>then</U></b>
             output_char stderr '\n' ;
  <m>40       </m>Location.print_fullpos () ;
           Printf.fprintf stderr "Lexer error: %s\n" s ;
           Location.restore () ;
           <b><U>false</U><r>
       | Htmlparse.Error s -&gt;
  <m>45       <b><U>if</U><r> !Ultra.verbose &gt; 0 </r><U>then</U><r>
             output_char stderr '\n' ;
           Location.print_fullpos () ;
           Printf.fprintf stderr "Parser error: %s\n" s ;
           Htmllex.ptop () ;
  <m>50       </m>Htmllex.reset () ;
           Location.restore () ;
           <b><U>false</U><r>
       | e -&gt;
           Location.restore () ;
  <m>55       </m>raise e
     
     
     </r><U>let</U></b> file in_name =
       <b><U>if</U></b> !Ultra.verbose &gt; 0 </r><U>then</U> <U>begin</U></b>
  60     </m>Printf.fprintf stderr "Optimizing file: %s... " in_name ;
         flush stderr
       </r><U>end</U></b> ;
       <b><U>let</U><r> out_name =
         Filename.concat
  <m>65       </m>(Filename.dirname in_name)
           (Filename.basename in_name ^ ".esp")
       </r><U>in</U>
       <U>begin</U> <U>try</U>
         <U>let</U></b> input = open_in in_name </r><U>in</U></b>
  70     <b><U>let</U><r> out =
           </r><U>try</U><r> open_out out_name
           <b><U>with</U><r> Sys_error _ </r><U>as</U></b> e -&gt;
             close_in input ; raise e <b><U>in</U>
         <U>let</U></b> size_in = in_channel_length input </r><U>in</U></b>
  75     <b><U>let</U><r> ok =
           </r><U>try</U><r> process in_name input out <b><U>with</U><r> e -&gt;
             close_in input ; close_out out ; raise e </r><U>in</U></b>
         close_in input ;
         flush out ;
  <m>80     <b><U>let</U><r> size_out = out_channel_length out </r><U>in</U><r>
         close_out out ;
         <b><U>if</U><r> ok &amp;&amp; size_in &gt; size_out </r><U>then</U>
           <U>begin</U> <U>if</U></b> !move <b><U>then</U></b> rename out_name in_name </r><U>end</U>
         <U>else</U></b>
  85       </m>remove out_name ;
         <b><U>if</U><r> !Ultra.verbose &gt; 0  &amp;&amp; ok </r><U>then</U> <U>begin</U></b>
           Printf.fprintf stderr "saved %d -&gt; %d, %0.2f%%"
             size_in size_out
             ((float (size_in-size_out) *. 100.0) /.
  <m>90          </m>float size_in) ;
           prerr_endline ""
         <b><U>end</U></b> ;
         ok
       </r><U>with</U></b>
  95   </m>| Sys_error msg -&gt;
           Printf.fprintf stderr "File error: %s\n" msg ;
           </r><U>false</U></b>
       | e -&gt;
           remove out_name ;
 <m>100       </m>raise e
       </r><U>end</U></b></TT>
<r><B><6>80 explode.ml</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: explode.ml,v 1.6 2001/05/28 17:28:55 maranget Exp $           *)
     (***********************************************************************)
     
     <b><U>open</U></b></w> Lexeme
     <b><U>open</U><r> Htmltext
  </r><m>15 </m><U>open</U></b> Tree
     
     <b><U>let</U><r> of_styles env r = </r><U>match</U></b> env <b><U>with</U><r>
     | [] -&gt; r
     | _  -&gt; Node (env,[r])
  </r><m>20 
     
     </m><U>let</U> <U>rec</U></b> tree env t k = <b><U>match</U><r> t </r><U>with</U></b>
     | Text s -&gt;
         of_styles env (Text s)::k
  <m>25 <r>| Blanks s -&gt;
         of_styles
           (List.filter (<b><U>fun</U></b> s -&gt; not (Htmltext.blanksNeutral s)) env)
           (Blanks s)::
           k
  </r>30 <r>| Node (s,ts) -&gt;
           <b><U>begin</U> <U>try</U>
             <U>let</U></b> new_env = Htmltext.add_style s env <b><U>in</U><r>
             List.fold_right (tree new_env) ts k
           </r><U>with</U><m>
  35       <r>| Split (s,env) -&gt;
               <b><U>let</U><r> ts = List.fold_right (tree []) ts [] </r><U>in</U>
               <U>let</U></b> now =
                 <b><U>if</U><r> Util.is_blanks ts </r><U>then</U></b>
                   (List.filter (<b><U>fun</U></b> s -&gt; not (Htmltext.blanksNeutral s)) env)
  </r>40             </m><U>else</U></b>
                   env <b><U>in</U>
               <U>match</U></b> ts <b><U>with</U></b>
               | [] -&gt; k
               | _ -&gt;
  </r>45               <r>of_styles now (Node ([s],ts))::k
           <b><U>end</U></b>
     | ONode (so,sc,ts) -&gt;
         ONode
           (so,sc, List.fold_right (tree env) ts [])::k
  </r>50 
     
     <b><U>let</U></b></m> trees ts =  List.fold_right (tree []) ts []</TT>
<6><B>81 foot.ml</B></6>
<TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>let</U></b></w> header = "$Id: foot.ml,v 1.18 2001/02/20 14:10:08 maranget Exp $"
     <b><U>open</U><r> Parse_opts
     
  </r><m>15 </m><U>let</U></b> some = ref <b><U>false</U><r>
     ;;
     
     
     </r><U>let</U></b> anchor = ref 0
  <m>20 <r>;;
     
     <b><U>let</U><r> mark_to_anchor = Hashtbl.create 17
     </r><U>and</U></b> anchor_to_note = Hashtbl.create 17
     ;;
  </r>25 
     <b><U>type</U></b></m> saved =
         (int, int) Hashtbl.t
       * (int, int * string * string) Hashtbl.t * int * bool
     
  <m>30 <b><U>let</U></b></m> checkpoint () =
       Misc.clone_int_hashtbl mark_to_anchor,
       Misc.clone_int_hashtbl anchor_to_note,
       !anchor, !some
     
  <m>35 <b><U>and</U></b></m> hot_start (t1,t2,i,b) =
       Misc.copy_int_hashtbl t1 mark_to_anchor ;
       Misc.copy_int_hashtbl t2 anchor_to_note ;
       anchor := i ;
       some := b
  <m>40 
     <b><U>let</U></b></m> step_anchor mark =
       incr anchor ;
       Hashtbl.remove mark_to_anchor mark ;
       Hashtbl.add mark_to_anchor mark !anchor
  <m>45 <r>;;
     
     <b><U>let</U><r> get_anchor mark =
       </r><U>let</U></b> r =
         <b><U>try</U></b> Hashtbl.find mark_to_anchor mark
  </r>50     <b><U>with</U></b></m> Not_found -&gt; <b><U>begin</U><r>
           step_anchor mark ;
           !anchor
         </r><U>end</U> <U>in</U></b>
       r
  <m>55 <r>;;
     
     <b><U>let</U><r> register mark themark text =
       some := </r><U>true</U></b> ;
       <b><U>let</U><r> anchor = get_anchor mark </r><U>in</U><m>
  60   </m><U>begin</U> <U>try</U>
         <U>let</U></b> _ = Hashtbl.find anchor_to_note anchor <b><U>in</U><r>
         Misc.warning "erasing previous footnote" ;
         Hashtbl.remove  anchor_to_note anchor
       </r><U>with</U></b> Not_found -&gt; ()
  </r>65   <b><U>end</U></b></m> ;
       Hashtbl.add anchor_to_note anchor (mark,themark,text)
     ;;
     
     
  <m>70 <b><U>let</U></b></m> flush lexer sec_notes sec_here =
       <b><U>if</U><r> !some &amp;&amp; Section.value sec_here &lt;= Section.value sec_notes </r><U>then</U> <U>begin</U></b>
         some := <b><U>false</U><r> ;
         lexer ("\\begin{thefootnotes}{"^sec_notes^"}") ;
         </r><U>let</U></b> all = ref [] <b><U>in</U><m>
  75     <r>Hashtbl.iter
           (<b><U>fun</U></b> anchor (mark,themark,text) -&gt;
             all := ((mark,anchor),(themark,text)) :: !all)
           anchor_to_note ;
         all := Sort.list
  </r>80          <r>(<b><U>fun</U><r> ((m1,a1),_) ((m2,a2),_) -&gt;
                (a1 &lt; a2) ||
                ((a1 = a2) &amp;&amp; (m1 &lt;= m2))) !all ;
         List.iter
           (</r><U>fun</U></b> ((_,anchor),(themark,text)) -&gt;
  </r>85         <r>lexer
               ("\\item["^
                "\\@noteref{text}{note}{"^
                string_of_int anchor^
                "}{\\@print{"^themark^"}}]") ;
  </r>90         <r>lexer ("\\@print{"^text^"\n}"))
           !all ;
         lexer "\\end{thefootnotes}" ;
         Hashtbl.clear mark_to_anchor ;
         Hashtbl.clear anchor_to_note ;
  </r>95   </m><U>end</U></b>
     ;;</TT>
<6><B>82 get.ml</B></6></r>
<r><TT> 
      12 "get.mll"
     
     <b><U>open</U><r> Misc
     </r><U>open</U></b> Parse_opts
   <m>5 <r><b><U>open</U><r> Lexing
     </r><U>open</U></b> Latexmacros
     <b><U>open</U><r> Lexstate
     </r><U>open</U></b> Stack
     
  </r>10 <w>(* Compute functions *)
     <r><b><U>let</U><r> header = "$Id: get.mll,v 1.24 2001/02/12 10:05:29 maranget Exp $"
     
     </r><U>exception</U></b> Error <b><U>of</U></b> string
     
  </r></w>15 <b><U>let</U><r> sbool = </r><U>function</U><r>
       | <b><U>true</U><r> -&gt; "true"
       | </r><U>false</U></b> -&gt; "false"
     
     <b><U>let</U><r> get_this = ref (</r><U>fun</U></b> s -&gt; <b><U>assert</U> <U>false</U></b>)
  </r></b>20 <b><U>and</U><r> get_fun = ref (</r><U>fun</U><r> f lexbuf -&gt; <b><U>assert</U> <U>false</U></b>)
     <b><U>and</U><r> open_env = ref (</r><U>fun</U></b> _ -&gt; ())
     <b><U>and</U><r> close_env = ref (</r><U>fun</U></b> _ -&gt; ())
     <b><U>and</U><r> get_csname = ref (</r><U>fun</U></b> _ -&gt; <b><U>assert</U> <U>false</U></b>)
     <b><U>and</U><r> main = ref (</r><U>fun</U></b> _ -&gt; <b><U>assert</U> <U>false</U></b>)
  </r></b>25 <r>;;
     
     <b><U>let</U><r> bool_out = ref </r><U>false</U>
     <U>and</U></b> int_out = ref <b><U>false</U><m>
     
  30 </m><U>let</U></b> int_stack = Stack.create "int_stack"
     <b><U>and</U><r> bool_stack = Stack.create "bool_stack"
     </r><U>and</U></b> group_stack = Stack.create "group_stack"
     <b><U>and</U><r> just_opened = ref </r><U>false</U><m>
     
  35 </m><U>type</U></b> saved =
       bool * bool Stack.saved *
       bool * int Stack.saved *
       (unit -&gt; unit) Stack.saved * bool
     
  </r>40 <b><U>let</U><r> check () =
       !bool_out, Stack.save bool_stack,
       !int_out, Stack.save int_stack,
       Stack.save group_stack,
       !just_opened
  </r></b>45 
     <b><U>and</U><r> hot (b,bs,i,is,gs,j) =
       bool_out := b ; Stack.restore bool_stack bs ;
       int_out := i ; Stack.restore int_stack is ;
       Stack.restore group_stack gs ;
  </r></b>50   <r>just_opened := j
     
     <b><U>let</U><r> push_int x =
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U></b>
         prerr_endline ("PUSH INT: "^string_of_int x) ;
  </r>55   <r>just_opened := <b><U>false</U><r> ;
       push int_stack x
     
     </r><U>let</U></b> open_ngroups n =
       <b><U>let</U> <U>rec</U></b> open_ngroups_rec  = <b><U>function</U><m>
  60     <r>| 0 -&gt;()
         | n -&gt; push group_stack (<b><U>fun</U><r> () -&gt; ()) ; open_ngroups_rec (n-1) </r><U>in</U>
       <U>if</U></b> !verbose &gt; 2 <b><U>then</U><r>
         prerr_endline ("OPEN NGROUPS: "^string_of_int n) ;
       </r><U>if</U></b> n &gt; 0 <b><U>then</U> <U>begin</U><m>
  65     <r>just_opened := <b><U>true</U><r> ;
         open_ngroups_rec n
       </r><U>end</U>
     
     <U>let</U></b> close_ngroups n =
  </r>70   </m><U>let</U> <U>rec</U></b> close_ngroups_rec  = <b><U>function</U><r>
         | 0 -&gt; ()
         | n -&gt;
             </r><U>let</U></b> f = pop group_stack <b><U>in</U><r>
             f() ; close_ngroups_rec (n-1) </r><U>in</U><m>
  75   </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r>
         prerr_endline ("CLOSE NGROUPS: "^string_of_int n);
       close_ngroups_rec n
     
     </r><U>let</U></b> open_aftergroup f s =
  </r>80   </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r>
         prerr_endline ("OPEN AFTER: "^s) ;
       just_opened := </r><U>true</U></b> ;
       push group_stack f
     
  </r>85 <b><U>let</U><r> lex_tables = {
       Lexing.lex_base =
        "\000\000\001\000\002\000\061\000\003\000\254\255\255\255\240\255\
    \001\000\020\000\054\000\004\000\136\000\244\255\243\255\246\255\
    \247\255\144\000\245\255\164\000\250\255\000\000\000\000\239\255\
    \007\000\000\000\249\255\004\000\000\000\012\000\248\255\241\255\
    \254\000\154\000\164\000\034\000\242\255\073\001\006\000";
       Lexing.lex_backtrk =
        "\255\255\002\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \001\000\015\000\015\000\015\000\015\000\255\255\255\255\255\255\
    \255\255\002\000\255\255\015\000\255\255\015\000\015\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \014\000\002\000\003\000\255\255\255\255\004\000\001\000";
  <m>90   </m>Lexing.lex_default =
        "\007\000\002\000\255\255\004\000\255\255\000\000\000\000\000\000\
    \255\255\255\255\255\255\035\000\255\255\000\000\000\000\000\000\
    \000\000\255\255\000\000\031\000\000\000\255\255\255\255\000\000\
    \255\255\255\255\000\000\255\255\255\255\255\255\000\000\000\000\
    \255\255\255\255\255\255\035\000\000\000\255\255\255\255";
       Lexing.lex_trans =
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\008\000\038\000\000\000\000\000\006\000\000\000\
    \038\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \008\000\038\000\009\000\010\000\000\000\011\000\038\000\012\000\
    \013\000\014\000\015\000\016\000\006\000\016\000\000\000\015\000\
    \017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\
    \017\000\017\000\000\000\000\000\018\000\018\000\018\000\000\000\
    \000\000\000\000\000\000\000\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\037\000\037\000\037\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\000\000\019\000\003\000\000\000\000\000\
    \020\000\027\000\000\000\000\000\000\000\026\000\021\000\036\000\
    \036\000\036\000\036\000\036\000\036\000\036\000\036\000\036\000\
    \028\000\030\000\024\000\029\000\022\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\013\000\025\000\014\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\000\000\000\000\000\000\000\000\000\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \034\000\034\000\034\000\034\000\034\000\034\000\034\000\034\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\000\000\
    \023\000\255\255\005\000\006\000\255\255\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\000\000\
    \000\000\000\000\255\255\000\000\000\000\000\000\000\000\000\000\
    \031\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\005\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\000\000\000\000\000\000\000\000\000\000\000\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\255\255\000\000\000\000\000\000\
    \000\000\000\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000";
       Lexing.lex_check =
  <m>95    </m>"\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\000\000\008\000\255\255\255\255\011\000\255\255\
    \038\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\008\000\000\000\000\000\255\255\000\000\038\000\000\000\
    \000\000\000\000\000\000\000\000\035\000\000\000\255\255\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\255\255\255\255\000\000\000\000\000\000\255\255\
    \255\255\255\255\255\255\255\255\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\009\000\009\000\009\000\
    \009\000\009\000\009\000\255\255\000\000\001\000\255\255\255\255\
    \000\000\021\000\255\255\255\255\255\255\025\000\000\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \027\000\029\000\022\000\028\000\000\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\000\000\024\000\000\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \017\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\
    \017\000\017\000\033\000\033\000\033\000\033\000\033\000\033\000\
    \033\000\033\000\033\000\033\000\034\000\034\000\034\000\034\000\
    \034\000\034\000\034\000\034\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\255\255\
    \000\000\001\000\002\000\004\000\011\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\255\255\
    \255\255\255\255\035\000\255\255\255\255\255\255\255\255\255\255\
    \032\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\003\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\255\255\255\255\255\255\255\255\255\255\255\255\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\037\000\037\000\037\000\037\000\037\000\037\000\037\000\
    \037\000\037\000\037\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\037\000\037\000\037\000\037\000\037\000\037\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\019\000\255\255\255\255\255\255\
    \255\255\255\255\037\000\037\000\037\000\037\000\037\000\037\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255"
     }
     
     </r><U>let</U> <U>rec</U><r> result lexbuf = __ocaml_lex_result_rec lexbuf 0
     <b><U>and</U><r> __ocaml_lex_result_rec lexbuf state =
 <m>100   <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><r>
         0 -&gt; (
      101 "get.mll"
                            result lexbuf)
       | 1 -&gt; (
 <m>105  </m>102 "get.mll"
                            result lexbuf)
       | 2 -&gt; (
      105 "get.mll"
          <b><U>let</U></b> lxm = Lexing.lexeme lexbuf </r><U>in</U></b>
 110     </m>push_int (int_of_string lxm) ;
         result lexbuf)
       | 3 -&gt; (
      109 "get.mll"
          </r><U>let</U></b> lxm = lexeme lexbuf </r><U>in</U></b>
 115     <r>push_int
           (int_of_string ("0o"^String.sub lxm 1 (String.length lxm-1))) ;
         result lexbuf)
       | 4 -&gt; (
      114 "get.mll"
 </r>120      <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U><r>
         push_int
           (int_of_string ("0x"^String.sub lxm 1 (String.length lxm-1))) ;
         result lexbuf)
       | 5 -&gt; (
 <m>125  </m>119 "get.mll"
          <b><U>let</U><r> token = !get_csname lexbuf </r><U>in</U></b>
         after_quote (Lexing.from_string token) ;
         result lexbuf)
       | 6 -&gt; (
 <m>130  </m>123 "get.mll"
          push bool_stack <b><U>true</U><r> ;
         result lexbuf)
       | 7 -&gt; (
      126 "get.mll"
 <m>135      </m>push bool_stack </r><U>false</U></b> ;
         result lexbuf)
       | 8 -&gt; (
      130 "get.mll"
          <b><U>let</U></b> lxm = lexeme_char lexbuf 0 </r><U>in</U></b>
 140     </m><b><U>let</U></b> unary = !just_opened <b><U>in</U>
         <U>if</U></b> unary <b><U>then</U> <U>begin</U>
           <U>let</U></b> f = pop group_stack <b><U>in</U><r>
           open_aftergroup
             (</r><U>fun</U></b> () -&gt;
 <m>145           <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U><r>
                 prerr_endline ("UNARY: "^String.make 1 lxm) ;
                 Stack.pretty string_of_int int_stack
               <b><U>end</U><r> ;
               </r><U>let</U></b> x1 = pop int_stack </r><U>in</U></b>
 150           <b><U>let</U><r> r = </r><U>match</U><r> lxm <b><U>with</U><r>
               | '+' -&gt; x1
               | '-' -&gt; 0 - x1
               | _   -&gt; </r><U>assert</U> <U>false</U> <U>in</U></b>
               push_int r ; f()) "UNARY"
 <m>155     <b><U>end</U> <U>else</U> <U>begin</U><r>
           close_ngroups 2 ;
           open_aftergroup
             (<b><U>fun</U><r> () -&gt;
               </r><U>if</U></b> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
 160             </m>prerr_endline ("OPPADD: "^String.make 1 lxm) ;
                 Stack.pretty string_of_int int_stack
               <b><U>end</U><r> ;
               </r><U>let</U></b> x2 = pop int_stack <b><U>in</U>
               <U>let</U></b> x1 = pop int_stack </r><U>in</U></b>
 165           <b><U>let</U><r> r = </r><U>match</U><r> lxm <b><U>with</U><r>
               | '+' -&gt; x1 + x2
               | '-' -&gt; x1 - x2
               | _   -&gt; </r><U>assert</U> <U>false</U> <U>in</U></b>
               push_int r) "ADD";
 <m>170       </m>open_ngroups 1 ;
         <b><U>end</U><r> ;
         result lexbuf)
       | 9 -&gt; (
      165 "get.mll"
 <m>175      <b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U><r>
         close_ngroups 1 ;
         open_aftergroup
             (<b><U>fun</U><r> () -&gt;
               </r><U>if</U></b> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
 180             </m>prerr_endline ("MULTOP"^String.make 1 lxm) ;
                 Stack.pretty string_of_int int_stack
               </r><U>end</U></b> ;
               <b><U>let</U><r> x2 = pop int_stack </r><U>in</U>
               <U>let</U></b> x1 = pop int_stack </r><U>in</U></b>
 185           <b><U>let</U><r> r = </r><U>match</U><r> lxm <b><U>with</U><r>
               | '*' -&gt; x1 * x2
               | '/' -&gt; x1 / x2
               | _   -&gt; </r><U>assert</U> <U>false</U> <U>in</U></b>
               push_int r) "MULT";
 <m>190     </m>result lexbuf)
       | 10 -&gt; (
      183 "get.mll"
          <b><U>let</U><r> lxm = Lexing.lexeme_char lexbuf 0 </r><U>in</U></b>
         close_ngroups 3 ;
 <m>195     </m>open_aftergroup
           (<b><U>fun</U><r> () -&gt;
             </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
               prerr_endline ("COMP: "^String.make 1 lxm) ;
               Stack.pretty string_of_int int_stack
 <m>200         <b><U>end</U><r> ;
             </r><U>let</U><r> x2 = pop int_stack <b><U>in</U>
             <U>let</U></b> x1 = pop int_stack <b><U>in</U><r>
             push bool_stack
               (</r><U>match</U></b> lxm </r><U>with</U></b>
 205           </m>| '&lt;' -&gt; x1 &lt; x2
               | '&gt;' -&gt; x1 &gt; x2
               | '=' -&gt; x1 = x2
               | _   -&gt; <b><U>assert</U> <U>false</U></b>) ;
               <b><U>if</U></b> !verbose &gt; 2 </r><U>then</U></b>
 210             <r>Stack.pretty sbool bool_stack) "COMP" ;
         open_ngroups 2 ;
         result lexbuf)
       | 11 -&gt; (
      206 "get.mll"
 </r>215      <r>open_ngroups 2 ;
         result lexbuf)
       | 12 -&gt; (
      209 "get.mll"
          close_ngroups 2 ;
 </r>220     <r>result lexbuf)
       | 13 -&gt; (
      213 "get.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>let</U></b> i = Char.code (lxm.[1]) - Char.code '1' <b><U>in</U><m>
 225     <r>scan_arg (scan_this_arg result) i ;
         result lexbuf)
       | 14 -&gt; (
      218 "get.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U><m>
 230     </m><U>let</U></b> pat,body = Latexmacros.find lxm <b><U>in</U>
         <U>let</U></b> args = make_stack lxm pat lexbuf <b><U>in</U><r>
         scan_body
           (</r><U>function</U></b>
             | Subst body -&gt; scan_this result body
 </r>235         <r>| Toks l -&gt;
                 List.iter
                   (scan_this result)
                   (List.rev l)
             | CamlCode f -&gt;
 </r>240             </m><U>let</U></b> rs = !get_fun f lexbuf <b><U>in</U></b>
                 scan_this result rs)
               body args ;
         result lexbuf)
       | 15 -&gt; (
 </r>245  <r>233 "get.mll"
            raise (Error ("Bad character in Get.result: ``"^lexeme lexbuf^"''")))
       | 16 -&gt; (
      234 "get.mll"
            ())
 </r>250   <r>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_result_rec lexbuf n
     
     <b><U>and</U><r> after_quote lexbuf = __ocaml_lex_after_quote_rec lexbuf 1
     </r><U>and</U></b> __ocaml_lex_after_quote_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><m>
 255     <r>0 -&gt; (
      238 "get.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
         push_int (Char.code lxm.[1]);
         result lexbuf)
 </r>260   <r>| 1 -&gt; (
      242 "get.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
         push_int (Char.code lxm.[0]);
         result lexbuf)
 </r>265   <r>| 2 -&gt; (
      246 "get.mll"
          Misc.fatal "Cannot understand `-like numerical argument")
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_after_quote_rec lexbuf n
     
 </r>270 <r>;;
     
      247 "get.mll"
     
     <b><U>let</U></b> init latexget latexgetfun latexopenenv latexcloseenv latexcsname
 </r>275     <r>latexmain =
       get_this := latexget ;
       get_fun := latexgetfun ;
       open_env := latexopenenv ;
       close_env := latexcloseenv ;
 </r>280   <r>get_csname := latexcsname ;
       main := latexmain
     ;;
     
     <b><U>let</U></b> def_loc  name f =
 </r>285   <r>Latexmacros.def name zero_pat (CamlCode f) ;
     ;;
     
     <b><U>let</U></b> def_commands l =
       List.map
 </r>290     <r>(<b><U>fun</U><r> (name,f) -&gt;
           name,Latexmacros.replace name (Some (zero_pat,CamlCode f)))
         l
     
     </r><U>let</U></b> def_commands_int () =
 </r>295   <r>def_commands
         ["\\value",
           (<b><U>fun</U><r> lexbuf -&gt;
             </r><U>let</U></b> name = !get_this (save_arg lexbuf) <b><U>in</U></b>
             push_int (Counter.value_counter name)) ;
 </r>300       <r>"\\pushint",
             (<b><U>fun</U><r> lexbuf -&gt;
               </r><U>let</U></b> s = !get_this (save_arg lexbuf) <b><U>in</U></b>
               scan_this result s)]
     
 </r>305 </m><U>let</U></b> def_commands_bool () =
       <b><U>let</U><r> old_ints = def_commands_int () </r><U>in</U>
       <U>let</U></b> old_commands =
         def_commands
           ["\\(", (<b><U>fun</U></b> _ -&gt; open_ngroups 7) ;
 </r>310         <r>"\\)",  (<b><U>fun</U><r> _ -&gt; close_ngroups 7) ;
             "\\@fileexists",
             (</r><U>fun</U></b> lexbuf -&gt;
               <b><U>let</U><r> name = !get_this (save_arg lexbuf) </r><U>in</U></b>
               push bool_stack
 </r>315             <r>(<b><U>try</U>
                   <U>let</U></b> _ = Myfiles.open_tex name <b><U>in</U>
                   <U>true</U>
                 <U>with</U></b> Myfiles.Except | Myfiles.Error _ -&gt; <b><U>false</U></b>)) ;
             "\\@commandexists",
 </r>320         <r>(<b><U>fun</U><r> lexbuf -&gt;
               </r><U>let</U></b> name = !get_csname lexbuf <b><U>in</U><r>
               push bool_stack (Latexmacros.exists name)) ;
             "\\or",
             (</r><U>fun</U></b> _ -&gt;
 </r>325           <r>close_ngroups 7 ;
               open_aftergroup
                 (<b><U>fun</U><r> () -&gt;
                   </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
                     prerr_endline "OR" ;
 </r>330                 <r>Stack.pretty sbool bool_stack
                   <b><U>end</U><r> ;
                   </r><U>let</U></b> b1 = pop bool_stack <b><U>in</U>
                   <U>let</U></b> b2 = pop bool_stack <b><U>in</U></b>
                   push bool_stack (b1 || b2)) "OR";
 </r>335           <r>open_ngroups 6) ;
             "\\and",
             (<b><U>fun</U></b> _ -&gt;
               close_ngroups 6 ;
               open_aftergroup
 </r>340             <r>(<b><U>fun</U><r> () -&gt;
                   </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
                     prerr_endline "AND" ;
                     Stack.pretty sbool bool_stack
                   <b><U>end</U></b> ;
 </r>345               <b><U>let</U><r> b1 = pop bool_stack </r><U>in</U>
                   <U>let</U><r> b2 = pop bool_stack <b><U>in</U><r>
                   push bool_stack (b1 &amp;&amp; b2)) "AND";
               open_ngroups 5) ;
             "\\not",
 <m>350         </m>(</r><U>fun</U></b> _ -&gt;
               close_ngroups 4 ;
               open_aftergroup
                 (<b><U>fun</U><r> () -&gt;
                   </r><U>if</U></b> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
 355                 <r>prerr_endline "NOT" ;
                     Stack.pretty sbool bool_stack
                   <b><U>end</U><r> ;
                   </r><U>let</U></b> b1 = pop bool_stack <b><U>in</U></b>
                   push bool_stack (not b1)) "NOT";
 </r>360           <r>open_ngroups 3) ;
             "\\boolean",
               (<b><U>fun</U><r> lexbuf -&gt;
                 </r><U>let</U></b> name = !get_this (save_arg lexbuf) <b><U>in</U>
                 <U>let</U></b> b = <b><U>try</U><m>
 365               </m><U>let</U></b> r = !get_this
                       (string_to_arg ("\\if"^name^" true\\else false\\fi")) <b><U>in</U>
                   <U>match</U></b> r <b><U>with</U><r>
                   | "true" -&gt; </r><U>true</U></b>
                   | "false" -&gt; <b><U>false</U><m>
 370               <r>| _ -&gt; raise (Misc.Fatal ("boolean value: "^r))
                 <b><U>with</U><r>
                   Latexmacros.Failed -&gt; </r><U>true</U>  <U>in</U></b>
                 push bool_stack b) ;
             "\\isodd",
 </r>375         <r>(<b><U>fun</U><r> lexbuf -&gt;
               close_ngroups 3 ;
               open_aftergroup
                 (</r><U>fun</U></b> () -&gt;
                   <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U><m>
 380                 <r>prerr_endline ("ISODD") ;
                     Stack.pretty string_of_int int_stack
                   <b><U>end</U><r> ;
                   </r><U>let</U></b> x = pop int_stack <b><U>in</U><r>
                   push bool_stack (x </r><U>mod</U></b> 2 = 1) ;
 </r>385               </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r>
                     Stack.pretty sbool bool_stack) "ISODD" ;
               open_ngroups 2) ] </r><U>in</U>
       <U>let</U></b> old_equal =
         <b><U>try</U><r> Some (Latexmacros.find_fail "\\equal") </r><U>with</U></b> Failed -&gt; None <b><U>in</U><m>
 390 
       <r>def_loc "\\equal"
         (<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> arg1 = save_arg lexbuf <b><U>in</U>
           <U>let</U></b> arg2 = save_arg lexbuf <b><U>in</U><m>
 395       <r>scan_this !main "\\begin{@norefs}" ;
           <b><U>let</U><r> again = List.map (</r><U>fun</U></b> (name,x) -&gt; name,Latexmacros.replace name x)
               ((("\\equal",old_equal)::old_ints)@old_commands) <b><U>in</U><r>
           push bool_stack (!get_this arg1 = !get_this arg2) ;
           </r><U>let</U></b> _ =
 </r>400         <r>List.map (<b><U>fun</U><r> (name,x) -&gt; Latexmacros.replace name x) again </r><U>in</U></b>
           scan_this !main "\\end{@norefs}")
     
     
     
 </r>405 </m><U>let</U></b> first_try s =
       <b><U>let</U><r> l = String.length s </r><U>in</U>
       <U>if</U></b> l &lt;= 0 <b><U>then</U><r> raise (Failure "first_try") ;
       </r><U>let</U> <U>rec</U></b> try_rec r i =
         <b><U>if</U><r> i &gt;= l </r><U>then</U></b> r
 </r>410     </m><U>else</U> <U>match</U></b> s.[i] <b><U>with</U><r>
         | '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9' -&gt;
             try_rec (10*r + Char.code s.[i] - Char.code '0') (i+1)
         | _ -&gt; raise (Failure ("first_try")) </r><U>in</U></b>
       try_rec 0 0
 </r>415 <r>;;
     
     <b><U>let</U><r> get_int {arg=expr ; subst=subst} =
       </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U></b>
         prerr_endline ("get_int : "^expr) ;
 </r>420   </m><U>let</U></b> r =
         <b><U>try</U><r> first_try expr </r><U>with</U></b> Failure _ -&gt; <b><U>begin</U>
           <U>let</U></b> old_int = !int_out <b><U>in</U><r>
           int_out := </r><U>true</U></b> ;
           start_normal subst ;
 </r>425       </m>!open_env "*int*" ;
           <b><U>let</U><r> _ = def_commands_int () </r><U>in</U></b>
           open_ngroups 2 ;
           <b><U>begin</U> <U>try</U></b> scan_this result expr <b><U>with</U><r>
           | x -&gt;
 </r><m>430           </m><U>begin</U></b>
                 prerr_endline
                   ("Error while scanning ``"^expr^"'' for integer result");
                 raise x
               <b><U>end</U><m>
 435       </m><U>end</U></b> ;
           close_ngroups 2 ;
           !close_env "*int*" ;
           end_normal () ;
           <b><U>if</U><r> Stack.empty int_stack </r><U>then</U><m>
 440         <r>raise (Error ("``"^expr^"'' has no value as an integer"));
           <b><U>let</U><r> r = pop int_stack </r><U>in</U></b>
           int_out := old_int ;
           r <b><U>end</U> <U>in</U>
       <U>if</U></b> !verbose &gt; 1 <b><U>then</U><m>
 445     <r>prerr_endline ("get_int: "^expr^" = "^string_of_int r) ;
       r
     
     
     <b><U>let</U></b> get_bool {arg=expr ; subst=subst} =
 </r>450   </m><U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
         prerr_endline ("get_bool : "^expr) ;
       </r><U>let</U></b> old_bool = !bool_out <b><U>in</U><r>
       bool_out := </r><U>true</U></b> ;
       start_normal subst ;
 </r>455   <r>!open_env "*bool*" ;
       def_commands_bool () ;
       open_ngroups 7 ;
       <b><U>begin</U> <U>try</U></b> scan_this result expr <b><U>with</U></b>
       | x -&gt;
 </r>460       </m><U>begin</U></b>
             prerr_endline
               ("Error while scanning ``"^expr^"'' for boolean result");
             raise x
           <b><U>end</U><m>
 465   </m><U>end</U></b> ;
       close_ngroups 7 ;
       !close_env "*bool*" ;
       end_normal () ;
       <b><U>if</U><r> Stack.empty bool_stack </r><U>then</U><m>
 470     <r>raise (Error ("``"^expr^"'' has no value as a boolean"));
       <b><U>let</U><r> r = pop bool_stack </r><U>in</U>
       <U>if</U></b> !verbose &gt; 1 <b><U>then</U></b>
         prerr_endline ("get_bool: "^expr^" = "^sbool r);
       bool_out := old_bool ;
 </r>475   <r>r
     
     <b><U>let</U><r> get_length arg =
       </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U></b>
         prerr_endline ("get_length : "^arg) ;
 </r>480   </m><U>let</U></b> r = Length.main (Lexing.from_string arg) <b><U>in</U>
       <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         prerr_string ("get_length : "^arg^" -&gt; ") ;
         prerr_endline (Length.pretty r)
       <b><U>end</U><r> ;
 <m>485   </m>r<PL><B>
<6>83 hot.ml</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: hot.ml,v 1.5 2001/05/25 12:37:22 maranget Exp $               *)
     (***********************************************************************)
     </w><U>type</U></b> saved =
         Lexstate.saved * Latexmacros.saved *
           Counter.saved * Color.saved * Foot.saved
  <m>15 
     <b><U>let</U></b></m> checkpoint () =
       Lexstate.checkpoint (),
       Latexmacros.checkpoint (),
       Counter.checkpoint (),
  <m>20   <r>Color.checkpoint (),
       Foot.checkpoint ()
     
     <b><U>and</U></b> start (lexstate, latexmacros, counter, color, foot) =
       Misc.hot_start () ;
  </r>25   <r>Lexstate.hot_start lexstate ;
       Latexmacros.hot_start latexmacros ;
       Counter.hot_start counter ;
       Color.hot_start color ;
       Foot.hot_start foot ;
  </r>30   <b><U>begin</U> <U>match</U></b></m> !Parse_opts.destination <b><U>with</U><r>
       | Parse_opts.Info -&gt; InfoRef.hot_start ()
       | _ -&gt; ()
       </r><U>end</U></b><PL><B>
<6>84 htmlCommon.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><b><U>let</U><r> header = "$Id: htmlCommon.ml,v 1.35 2001/04/23 16:04:27 maranget Exp $"
     
     </r><w>(* Output function for a strange html model :
  <m>15      </m>- Text elements can occur anywhere and are given as in latex
          - A new grouping construct is given (open_group () ; close_group ())
     *)
     
     </w><U>open</U></b> Misc
  <m>20 <b><U>open</U></b></m> Element
     <b><U>open</U><r> Parse_opts
     </r><U>open</U></b> Latexmacros
     <b><U>open</U><r> Stack
     </r><U>open</U></b> Length
  <m>25 
     
     
     <b><U>type</U></b></m> block =
       | H1 | H2 | H3 | H4 | H5 | H6
  <m>30   <r>| PRE
       | TABLE | TR | TD
       | DISPLAY
       | QUOTE | BLOCKQUOTE
       | DIV
  </r>35   <r>| UL | OL | DL
       | GROUP | AFTER | DELAY | FORGET
       | INTERN
       | P
       | NADA
  </r>40   <r>| OTHER <b><U>of</U><r> string
     ;;
     
     </r><U>let</U></b> string_of_block = <b><U>function</U></b>
       | H1 -&gt; "H1"
  </r>45   <r>| H2 -&gt; "H2"
       | H3  -&gt; "H3"
       | H4 -&gt; "H4"
       | H5 -&gt; "H5"
       | H6 -&gt; "H6"
  </r>50   <r>| PRE -&gt; "PRE"
       | TABLE -&gt; "TABLE"
       | TR -&gt; "TR"
       | TD  -&gt; "TD"
       | DISPLAY -&gt; "DISPLAY"
  </r>55   <r>| QUOTE -&gt; "QUOTE"
       | BLOCKQUOTE -&gt; "BLOCKQUOTE"
       | DIV -&gt; "DIV"
       | UL -&gt; "UL"
       | OL -&gt; "OL"
  </r>60   <r>| DL -&gt; "DL"
       | GROUP -&gt; ""
       | AFTER -&gt; "AFTER"
       | DELAY -&gt; "DELAY"
       | FORGET -&gt; "FORGET"
  </r>65   <r>| P     -&gt; "P"
       | NADA  -&gt; "NADA"
       | INTERN -&gt; "INTERN"
       | OTHER s -&gt; s
     
  </r>70 <b><U>let</U></b></m> block_t = Hashtbl.create 17
     ;;
     
     <b><U>let</U><r> no_opt = </r><U>false</U></b>
     ;;
  <m>75 
     
     <b><U>let</U><r> add b =
       Hashtbl.add block_t (string_of_block b) b
     ;;
  <m>80 
     </m>add H1 ;
     add H2 ;
     add H3 ;
     add H4 ;
  <m>85 </m>add H5 ;
     add H6 ;
     add PRE ;
     add TABLE ;
     add TR ;
  <m>90 </m>add TD ;
     add DISPLAY ;
     add QUOTE ;
     add BLOCKQUOTE ;
     add DIV ;
  <m>95 </m>add UL ;
     add OL ;
     add DL ;
     </r><U>begin</U>
       <U>if</U><r> no_opt </r><U>then</U></b>
 100     </m>Hashtbl.add block_t "" INTERN
       <b><U>else</U><r>
         add GROUP
     </r><U>end</U></b> ;
     add AFTER ;
 <m>105 </m>add DELAY ;
     add FORGET ;
     add P ;
     add NADA ; ()
     ;;
 <m>110 
     
     <b><U>let</U><r> failclose s b1 b2=
       raise (Misc.Close (s^": ``"^string_of_block b1^"'' closes ``"^
                          string_of_block b2^"''"))
 <m>115 </m>;;
     
     </r><U>let</U><r> find_block s =
       <b><U>let</U><r> s = String.uppercase s </r><U>in</U>
       <U>try</U></b> Hashtbl.find block_t s </r><U>with</U></b>
 120   </m>| Not_found -&gt; OTHER s
     ;;
     
     <b><U>let</U><r> check_block_closed opentag closetag =
       </r><U>if</U></b> opentag &lt;&gt; closetag &amp;&amp; not (opentag = AFTER &amp;&amp; closetag = GROUP) <b><U>then</U><m>
 125     <r>failclose "html" closetag opentag
     ;;
     
     <w>(* output globals *)
     <b><U>type</U></b></w> t_env = {here : bool ; env : text}
 </r>130 
     </m><U>type</U></b> t_top =
         {top_pending : text list ; top_active : t_env list ;}
     
     <b><U>type</U><r> style_info =
 <m>135   </m>| Nothing </r><U>of</U></b> t_top
       | Activate <b><U>of</U><r> t_top
       | Closed </r><U>of</U></b> t_top * int
       | ActivateClosed <b><U>of</U><r> t_top
       | NotMe
 <m>140   </m>| Insert </r><U>of</U></b> bool * text list
     
     <b><U>let</U></b> get_top_lists = <b><U>function</U><r>
       | Nothing x -&gt; x | Activate x -&gt; x
       | _ -&gt; raise Not_found
 </r><m>145 
     </m><U>let</U></b> do_pretty_mods stderr f mods =
       <b><U>let</U> <U>rec</U></b> do_rec stderr = <b><U>function</U><r>
         [x]  -&gt; f stderr x
       | x::xs -&gt;
 <m>150      </m>Printf.fprintf stderr "%a; %a" f x do_rec xs
       | [] -&gt; () </r><U>in</U></b>
       Printf.fprintf stderr "[%a]" do_rec mods
     
     
 <m>155 <b><U>let</U></b></m> tbool = <b><U>function</U><r>
       | </r><U>true</U></b> -&gt; "+"
       | <b><U>false</U><r> -&gt; "-"
     
     </r><U>let</U></b> pretty_mods stderr = do_pretty_mods stderr
 <m>160     <r>(<b><U>fun</U><r> stderr text -&gt; Printf.fprintf stderr "%s" (pretty_text text))
     
     </r><U>and</U></b> pretty_tmods stderr =
       do_pretty_mods stderr
         (<b><U>fun</U></b> stderr {here=here ; env = env} -&gt;
 </r>165       <r>Printf.fprintf stderr "%s%s" (tbool here) (pretty_text env))
     
     <b><U>let</U></b> pretty_top_styles stderr {top_pending = pending ; top_active = active} =
       Printf.fprintf stderr
         "{top_pending=%a, top_active=%a}"
 </r>170     <r>pretty_mods pending
         pretty_tmods active
     
     
     <b><U>let</U><r> pretty_top stderr = </r><U>function</U><m>
 175   <r>| Nothing x -&gt; Printf.fprintf stderr "Nothing %a"  pretty_top_styles x
       | Activate x -&gt; Printf.fprintf stderr "Activate %a" pretty_top_styles x
       | Closed _ -&gt; Printf.fprintf stderr "Closed"
       | ActivateClosed _ -&gt; Printf.fprintf stderr "ActivateClosed"
       | NotMe -&gt; Printf.fprintf stderr "NotMe"
 </r>180   <r>| Insert (b,active) -&gt;
           Printf.fprintf stderr "Insert %b %a" b pretty_mods active
     
     <b><U>type</U><r> status = {
       </r><U>mutable</U></b> nostyle : bool ;
 </r>185   </m><U>mutable</U></b> pending : text list ;
       <b><U>mutable</U><r> active : t_env list ;
       </r><U>mutable</U></b> top : style_info ;
       <b><U>mutable</U></b> out : Out.t}
     ;;
 </r>190 
     <b><U>let</U></b></m> as_env  {env=env} =  env
     <b><U>let</U><r> as_envs tenvs r  =
         List.fold_right (</r><U>fun</U></b> x r -&gt; as_env x::r) tenvs r
     
 <m>195 <b><U>let</U></b></m> to_pending pending active = pending @ as_envs active []
     
     <b><U>let</U><r> with_new_out out =  {out </r><U>with</U></b> out = Out.create_buff ()}
     
     <b><U>let</U><r> free out = Out.free out.out
 </r><m>200 
     </m><U>let</U></b> cur_out =
       ref {nostyle=<b><U>false</U><r> ;
             pending = [] ; active = [] ;
             top = NotMe ;
 <m>205         </m>out = Out.create_null ()}
     ;;
     
     </r><U>type</U></b> stack_item =
       Normal <b><U>of</U><r> block * string * status
 <m>210 </m>| Freeze </r><U>of</U></b> (unit -&gt; unit)
     ;;
     
     <b><U>exception</U><r> PopFreeze
     ;;
 </r><m>215 
     </m><U>let</U></b> push_out s (a,b,c) = push s (Normal (a,b,c))
     ;;
     
     <b><U>let</U><r> pretty_stack s = Stack.pretty
 <m>220    </m>(</r><U>function</U></b> Normal (s,args,_) -&gt; "["^string_of_block s^"]-{"^args^"} "
        | Freeze _   -&gt; "Freeze ") s
     ;;
     
     <b><U>let</U> <U>rec</U></b> pop_out s = <b><U>match</U><r> pop s </r><U>with</U><m>
 225 <r>| Normal (a,b,c) -&gt; a,b,c
     | Freeze f       -&gt; raise PopFreeze
     <w>(* begin
       if !verbose &gt; 2 then begin
          prerr_string "unfreeze in pop_out" ;
 <m>230      </m>pretty_stack !s
       end ;
       f () ; pop_out s end
     *)
     </w>;;
 </r>235 
     
     </m><U>let</U></b> out_stack =
       Stack.create_init "out_stack" (Normal (NADA,"",!cur_out))
     ;;
 <m>240 
     <b><U>type</U></b></m> saved_out = status * stack_item Stack.saved
     
     <b><U>let</U><r> save_out () = !cur_out, Stack.save out_stack
     </r><U>and</U></b> restore_out (a,b) =
 <m>245   <b><U>if</U></b></m> !cur_out != a <b><U>then</U> <U>begin</U></b>
         free !cur_out ;
         Stack.finalize out_stack
           (<b><U>function</U><r>
             | Normal (_,_,x) -&gt; x == a
 <m>250         </m>| _ -&gt; </r><U>false</U></b>)
           (<b><U>function</U><r>
             | Normal (_,_,out) -&gt; free out
             | _ -&gt; ())
       </r><U>end</U></b> ;
 <m>255   <r>cur_out := a ;
       Stack.restore out_stack b
     
     <b><U>let</U><r> pblock () =
       </r><U>if</U></b> Stack.empty out_stack <b><U>then</U></b> NADA
 </r>260   <b><U>else</U>
         <U>match</U></b></m> Stack.top out_stack <b><U>with</U><r>
         | Normal (s,_,_) -&gt; s
         | _ -&gt; NADA
     ;;
 </r><m>265 
     </m><U>let</U></b> do_put_char c =
      <b><U>if</U><r> !verbose &gt; 3 </r><U>then</U></b>
         prerr_endline ("put_char: |"^String.escaped (String.make 1 c)^"|");
       Out.put_char !cur_out.out c
 <m>270 
     <b><U>and</U></b></m> do_put s =
      <b><U>if</U><r> !verbose &gt; 3 </r><U>then</U></b>
         prerr_endline ("put: |"^String.escaped s^"|");
       Out.put !cur_out.out s
 <m>275 <r>;;
     
     
     <w>(* Flags section *)
     (* Style information for caller *)
 <m>280 
     <b><U>type</U><r> flags_t = {
         </r><U>mutable</U><r> table_inside:bool;
         <b><U>mutable</U><r> in_math : bool;
         </r><U>mutable</U></b> ncols:int;
 </r></b>285     <b><U>mutable</U><r> empty:bool;
         </r><U>mutable</U><r> blank:bool;
         <b><U>mutable</U><r> pending_par: int option;
         </r><U>mutable</U></b> vsize:int;
         <b><U>mutable</U></b> nrows:int;
 </r></b>290     <b><U>mutable</U><r> table_vsize:int;
         </r><U>mutable</U><r> nitems:int;
         <b><U>mutable</U><r> dt:string;
         </r><U>mutable</U></b> dcount:string;
         <b><U>mutable</U></b> last_closed:block;
 </r></b>295     <r><b><U>mutable</U><r> in_pre:bool;
         </r><U>mutable</U></b> insert: (block * string) option;
         <b><U>mutable</U></b> insert_attr: (block * string) option;
     } ;;
     
 </r>300 <b><U>let</U><r> pretty_cur {pending = pending ; active = active ;
                    top = top} =
       Printf.fprintf stderr "pending=%a, active=%a\n"
         pretty_mods pending
         pretty_tmods active ;
 </r></b>305   <r>Printf.fprintf stderr "top = %a" pretty_top top ;
       prerr_endline ""
     
     ;;
     
 </r>310 <b><U>let</U><r> activate_top out = </r><U>match</U><r> out.top <b><U>with</U><r>
     | Nothing x -&gt; out.top &lt;- Activate x
     |  _      -&gt; ()
     
     </r><U>and</U></b> close_top n out = <b><U>match</U><r>  out.top </r><U>with</U><m>
 315 <r>| Nothing top  -&gt; out.top &lt;- Closed (top, n+Out.get_pos out.out)
     | Activate top -&gt; out.top &lt;- ActivateClosed top
     |  _       -&gt; ()
     
     <b><U>let</U><r> debug_attr stderr = </r><U>function</U><m>
 320   <r>| None -&gt; Printf.fprintf stderr "None"
       | Some (tag,attr) -&gt;
           Printf.fprintf stderr "``%s'' ``%s''"
             (string_of_block tag) attr
     
 </r>325 </m><U>let</U></b> debug_flags f =
       Printf.fprintf stderr "attr=%a\n" debug_attr f.insert_attr ;
       flush stderr
     
     
 </r>330 </m><U>let</U></b> flags = {
       table_inside = <b><U>false</U><r>;
       ncols = 0;
       in_math = </r><U>false</U></b>;
       empty = <b><U>true</U></b>;
 </r></b>335   <r>blank = <b><U>true</U></b>;
       pending_par = None;
       vsize = 0;
       nrows = 0;
       table_vsize = 0;
 </r>340   <r>nitems = 0;
       dt = "";
       dcount = "";
       last_closed = NADA;
       in_pre = <b><U>false</U></b>;
 </r>345   <r>insert = None;
       insert_attr = None;
     } ;;
     
     <b><U>let</U></b> copy_flags {
 </r>350   <r>table_inside = table_inside;
       ncols = ncols;
       in_math = in_math;
       empty = empty;
       blank = blank;
 </r>355   <r>pending_par = pending_par;
       vsize = vsize;
       nrows = nrows;
       table_vsize = table_vsize;
       nitems = nitems;
 </r>360   <r>dt = dt;
       dcount = dcount;
       last_closed = last_closed;
       in_pre = in_pre;
       insert = insert;
 </r>365   <r>insert_attr = insert_attr;
     } = {
       table_inside = table_inside;
       ncols = ncols;
       in_math = in_math;
 </r>370   <r>empty = empty;
       blank = blank;
       pending_par = pending_par;
       vsize = vsize;
       nrows = nrows;
 </r>375   <r>table_vsize = table_vsize;
       nitems = nitems;
       dt = dt;
       dcount = dcount;
       last_closed = last_closed;
 </r>380   <r>in_pre = in_pre;
       insert = insert;
       insert_attr = insert_attr;
     }
     <b><U>and</U></b> set_flags f {
 </r>385   <r>table_inside = table_inside ;
       ncols = ncols;
       in_math = in_math;
       empty = empty;
       blank = blank;
 </r>390   <r>pending_par = pending_par;
       vsize = vsize;
       nrows = nrows;
       table_vsize = table_vsize;
       nitems = nitems;
 </r>395   <r>dt = dt;
       dcount = dcount;
       last_closed = last_closed;
       in_pre = in_pre;
       insert = insert;
 </r>400   <r>insert_attr = insert_attr;
     } =
       f.table_inside &lt;- table_inside;
       f.ncols &lt;- ncols;
       f.in_math &lt;- in_math;
 </r>405   <r>f.empty &lt;- empty;
       f.blank &lt;- blank;
       f.pending_par &lt;- pending_par;
       f.vsize &lt;- vsize;
       f.nrows &lt;- nrows;
 </r>410   <r>f.table_vsize &lt;- table_vsize;
       f.nitems &lt;- nitems;
       f.dt &lt;- dt;
       f.dcount &lt;- dcount;
       f.last_closed &lt;- last_closed;
 </r>415   <r>f.in_pre &lt;- in_pre;
       f.insert &lt;- insert ;
       f.insert_attr &lt;- insert_attr ;
     ;;
     
 </r>420 
     
     </m>(* Independant stacks for flags *)
     <b><U>type</U></b></w> stack_t = {
       s_table_inside : bool Stack.t ;
 </r>425   <r>s_saved_inside : bool Stack.t ;
       s_in_math : bool Stack.t ;
       s_ncols : int Stack.t ;
       s_empty : bool Stack.t ;
       s_blank : bool Stack.t ;
 </r>430   <r>s_pending_par : int option Stack.t ;
       s_vsize : int Stack.t ;
       s_nrows : int Stack.t ;
       s_table_vsize : int Stack.t ;
       s_nitems : int Stack.t ;
 </r>435   <r>s_dt : string Stack.t ;
       s_dcount : string Stack.t ;
       s_insert : (block * string) option Stack.t ;
       s_insert_attr : (block * string) option Stack.t ;
     <w>(* Other stacks, not corresponding to flags *)
 <m>440   <r>s_active : Out.t Stack.t ;
       s_after : (string -&gt; string) Stack.t
       }
     
     <b><U>let</U></b> stacks = {
 </r>445   <r>s_table_inside = Stack.create "inside" ;
       s_saved_inside = Stack.create "saved_inside" ;
       s_in_math = Stack.create_init "in_math" <b><U>false</U><r> ;
       s_ncols = Stack.create "ncols" ;
       s_empty = Stack.create_init "empty" </r><U>false</U></b>;
 </r>450   <r>s_blank = Stack.create_init "blank" <b><U>false</U></b> ;
       s_pending_par = Stack.create "pending_par" ;
       s_vsize = Stack.create "vsize" ;
       s_nrows = Stack.create_init "nrows" 0 ;
       s_table_vsize = Stack.create_init "table_vsize" 0 ;
 </r>455   <r>s_nitems = Stack.create_init "nitems" 0 ;
       s_dt = Stack.create_init "dt" "" ;
       s_dcount = Stack.create_init "dcount" "" ;
       s_insert = Stack.create_init "insert" None;
       s_insert_attr = Stack.create_init "insert_attr" None;
 </r>460   <r>s_active = Stack.create "active" ;
       s_after = Stack.create "after"
     }
     
     <b><U>type</U></b> saved_stacks = {
 </r>465   <r>ss_table_inside : bool Stack.saved ;
       ss_saved_inside : bool Stack.saved ;
       ss_in_math : bool Stack.saved ;
       ss_ncols : int Stack.saved ;
       ss_empty : bool Stack.saved ;
 </r>470   <r>ss_blank : bool Stack.saved ;
       ss_pending_par : int option Stack.saved ;
       ss_vsize : int Stack.saved ;
       ss_nrows : int Stack.saved ;
       ss_table_vsize : int Stack.saved ;
 </r>475   <r>ss_nitems : int Stack.saved ;
       ss_dt : string Stack.saved ;
       ss_dcount : string Stack.saved ;
       ss_insert : (block * string) option Stack.saved ;
       ss_insert_attr : (block * string) option Stack.saved ;
 </r>480 </m>(* Other stacks, not corresponding to flags *)
       </w>ss_active : Out.t Stack.saved ;
       ss_after : (string -&gt; string) Stack.saved
       }
     
 <m>485 <b><U>let</U><r> save_stacks () =
     {
       ss_table_inside = Stack.save stacks.s_table_inside ;
       ss_saved_inside = Stack.save stacks.s_saved_inside ;
       ss_in_math = Stack.save stacks.s_in_math ;
 </r></b>490   <r>ss_ncols = Stack.save stacks.s_ncols ;
       ss_empty = Stack.save stacks.s_empty ;
       ss_blank = Stack.save stacks.s_blank ;
       ss_pending_par = Stack.save stacks.s_pending_par ;
       ss_vsize = Stack.save stacks.s_vsize ;
 </r>495   <r>ss_nrows = Stack.save stacks.s_nrows ;
       ss_table_vsize = Stack.save stacks.s_table_vsize ;
       ss_nitems = Stack.save stacks.s_nitems ;
       ss_dt = Stack.save stacks.s_dt ;
       ss_dcount = Stack.save stacks.s_dcount ;
 </r>500   <r>ss_insert = Stack.save stacks.s_insert ;
       ss_insert_attr = Stack.save stacks.s_insert_attr ;
       ss_active = Stack.save stacks.s_active ;
       ss_after = Stack.save stacks.s_after
     }
 </r>505 
     <b><U>and</U><r> restore_stacks
     {
       ss_table_inside = saved_table_inside ;
       ss_saved_inside = saved_saved_inside ;
 </r></b>510   <r>ss_in_math = saved_in_math ;
       ss_ncols = saved_ncols ;
       ss_empty = saved_empty ;
       ss_blank = saved_blank ;
       ss_pending_par = saved_pending_par ;
 </r>515   <r>ss_vsize = saved_vsize ;
       ss_nrows = saved_nrows ;
       ss_table_vsize = saved_table_vsize ;
       ss_nitems = saved_nitems ;
       ss_dt = saved_dt ;
 </r>520   <r>ss_dcount = saved_dcount ;
       ss_insert = saved_insert ;
       ss_insert_attr = saved_insert_attr ;
       ss_active = saved_active ;
       ss_after = saved_after
 </r>525 <r>}   =
       Stack.restore stacks.s_table_inside saved_table_inside ;
       Stack.restore stacks.s_saved_inside saved_saved_inside ;
       Stack.restore stacks.s_in_math saved_in_math ;
       Stack.restore stacks.s_ncols saved_ncols ;
 </r>530   <r>Stack.restore stacks.s_empty saved_empty ;
       Stack.restore stacks.s_blank saved_blank ;
       Stack.restore stacks.s_pending_par saved_pending_par ;
       Stack.restore stacks.s_vsize saved_vsize ;
       Stack.restore stacks.s_nrows saved_nrows ;
 </r>535   <r>Stack.restore stacks.s_table_vsize saved_table_vsize ;
       Stack.restore stacks.s_nitems saved_nitems ;
       Stack.restore stacks.s_dt saved_dt ;
       Stack.restore stacks.s_dcount saved_dcount ;
       Stack.restore stacks.s_insert saved_insert ;
 </r>540   <r>Stack.restore stacks.s_insert_attr saved_insert_attr ;
       Stack.restore stacks.s_active saved_active ;
       Stack.restore stacks.s_after saved_after
     
     
 </r>545 <b><U>let</U><r> check_stack what =
       </r><U>if</U><r> not (Stack.empty what)  &amp;&amp; not !silent <b><U>then</U> <U>begin</U></b>
         prerr_endline
           ("Warning: stack "^Stack.name what^" is non-empty in Html.finalize") ;
       </r><U>end</U></b>
 550 <r>;;
     
     <b><U>let</U><r> check_stacks () = </r><U>match</U></b> stacks <b><U>with</U></b>
     {
       s_table_inside = s_table_inside ;
 </r>555   <r>s_saved_inside = s_saved_inside ;
       s_in_math = s_in_math ;
       s_ncols = s_ncols ;
       s_empty = s_empty ;
       s_blank = s_blank ;
 </r>560   <r>s_pending_par = s_pending_par ;
       s_vsize = s_vsize ;
       s_nrows = s_nrows ;
       s_table_vsize = s_table_vsize ;
       s_nitems = s_nitems ;
 </r>565   <r>s_dt = s_dt ;
       s_dcount = s_dcount ;
       s_insert = s_insert ;
       s_insert_attr = s_insert_attr ;
       s_active = s_active ;
 </r>570   <r>s_after = s_after
     }  -&gt;
       check_stack s_table_inside ;
       check_stack s_saved_inside ;
       check_stack s_in_math ;
 </r>575   <r>check_stack s_ncols ;
       check_stack s_empty ;
       check_stack s_blank ;
       check_stack s_pending_par ;
       check_stack s_vsize ;
 </r>580   <r>check_stack s_nrows ;
       check_stack s_table_vsize ;
       check_stack s_nitems ;
       check_stack s_dt ;
       check_stack s_dcount ;
 </r>585   <r>check_stack s_insert ;
       check_stack s_insert_attr ;
       check_stack s_active ;
       check_stack s_after
     
 </r>590 <w>(*
       Full state saving
     *)
     
     </w></m><b><U>type</U><r> saved = flags_t * saved_stacks * saved_out
 <m>595 
     <b><U>let</U><r> check () =
       </r><U>let</U><r> saved_flags = copy_flags flags
       <b><U>and</U><r> saved_stacks = save_stacks ()
       </r><U>and</U></b> saved_out = save_out () </r><U>in</U></b>
 600   </m>saved_flags, saved_stacks, saved_out
     
     
     </r><U>and</U></b> hot (f,s,o) =
       set_flags flags f ;
 <m>605   </m>restore_stacks s ;
       restore_out o
     
     
     <b><U>let</U><r> sbool = </r><U>function</U> <U>true</U><r> -&gt; "true" | _ -&gt; "false"
 <m>610 </m>;;
     
     <b><U>let</U><r> prerr_flags s =
       prerr_endline ("&lt;"^string_of_int (Stack.length stacks.s_empty)^"&gt; "^s^
         " empty="^sbool flags.empty^
 <m>615     </m>" blank="^sbool flags.blank^
         " table="^sbool flags.table_inside)
     
     </r><U>let</U></b> is_header = <b><U>function</U></b>
       | H1 | H2 | H3 | H4 | H5 | H6 -&gt; </r><U>true</U><m>
 620   <r>| _ -&gt; </r><b><U>false</U><r>
     ;;
     
     </r><U>let</U><r> is_list = <b><U>function</U></b>
       UL | DL | OL -&gt; </r><U>true</U></b>
 625 <r>| _ -&gt; </r><b><U>false</U><r>
     ;;
     
     </r><U>let</U><r> string_of_par = <b><U>function</U><r>
       | Some i -&gt; "+"^string_of_int i
 <m>630   </m>| None   -&gt; "-"
     
     </r><U>let</U></b> par_val last now n =
       <b><U>let</U><r> r =
         </r><U>if</U></b> is_list last </r><U>then</U> <U>begin</U></b>
 635       <b><U>if</U><r> is_list now </r><U>then</U><r> 1 <b><U>else</U><r> 0
         </r><U>end</U>
         <U>else</U> <U>if</U></b> last = P <b><U>then</U></b>
           0
         </r><U>else</U> <U>if</U></b>
 640       <r>is_header last || last = PRE || last = BLOCKQUOTE
         <b><U>then</U><r> n-1
         </r><U>else</U> <U>if</U></b> last = DIV || last = TABLE <b><U>then</U><r> n
         </r><U>else</U></b> n+1 <b><U>in</U>
       <U>if</U></b> !verbose &gt; 2 <b><U>then</U><m>
 645     <r>Printf.fprintf stderr
           "par_val last=%s, now=%s, r=%d\n"
           (string_of_block last)
           (string_of_block now) r ;
       r
 </r>650 <r>;;
     
     <b><U>let</U><r> par  = </r><U>function</U></b>
       | Some n <b><U>as</U></b> p -&gt;
           flags.pending_par &lt;- p ;
 </r>655       </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r>
             prerr_endline
               ("par: last_close="^ string_of_block flags.last_closed^
                " r="^string_of_int n)
       | _ -&gt; ()
 <m>660 </m>;;
     
     </r><U>let</U></b> flush_par n =
       flags.pending_par &lt;- None ;
       <b><U>for</U><r> i = 1 </r><U>to</U></b> n <b><U>do</U><m>
 665     <r>do_put "&lt;BR&gt;\n"
       <b><U>done</U><r> ;
       </r><U>if</U></b> n &lt;= 0 <b><U>then</U><r> do_put_char '\n' ;
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U></b>
          prerr_endline
 </r>670        <r>("flush_par: last_closed="^ string_of_block flags.last_closed^
            " p="^string_of_int n);
       flags.vsize &lt;- flags.vsize + n;
       flags.last_closed &lt;- NADA
     ;;
 </r>675 
     </m><U>type</U></b> t_try = Wait <b><U>of</U><r> block | Now
     </r><U>let</U></b> string_of_wait = </r></m><U>function</U></b>
       | Wait b -&gt; "(Wait "^string_of_block b^")"
       | Now    -&gt; "Now"
 </r>680 
     <b><U>let</U></b></m> try_flush_par block = <b><U>match</U><r> block </r><U>with</U></b>
     | Wait GROUP -&gt; ()
     | _ -&gt;  <b><U>match</U><r> flags.pending_par </r><U>with</U></b>
       | Some n -&gt;
 <m>685       <r>flush_par
             (<b><U>match</U><r> block </r><U>with</U></b>
             | Wait b -&gt; par_val b NADA n
             | _ -&gt; par_val NADA NADA n)
       | _      -&gt; ()
 </r>690 
     
     <b><U>let</U></b></m> string_of_into = <b><U>function</U><r>
       | Some n -&gt; "+"^string_of_int n
       | None -&gt; "-"
 </r><m>695 
     </m><U>let</U></b> forget_par () =
       <b><U>let</U><r> r = flags.pending_par </r><U>in</U>
       <U>if</U></b> !verbose &gt; 2 <b><U>then</U><r>
         prerr_endline
 </r><m>700       <r>("forget_par: last_close="^ string_of_block flags.last_closed^
            " r="^string_of_into r) ;
       flags.pending_par &lt;- None ;
       r
     ;;
 </r>705 
     
     
     <w>(* styles *)
     
 </w>710 
     </m><U>let</U></b> do_close_mod = <b><U>function</U><r>
       Style m -&gt;
         </r><U>if</U></b> flags.in_math &amp;&amp; !Parse_opts.mathml <b><U>then</U>
           <U>if</U></b> m="mtext" <b><U>then</U><r> do_put ("&lt;/"^m^"&gt;")
 </r><m>715       </m><U>else</U></b> do_put "&lt;/mstyle&gt;"
         <b><U>else</U><r> do_put ("&lt;/"^m^"&gt;")
     | (Color _ | Font _)  -&gt;
         </r><U>if</U></b> flags.in_math &amp;&amp; !Parse_opts.mathml <b><U>then</U><r>
           do_put "&lt;/mstyle&gt;"
 </r><m>720     </m><U>else</U></b> do_put "&lt;/FONT&gt;"
     
     <b><U>and</U><r> do_open_mod e =
       </r><U>if</U></b> !verbose &gt; 3 <b><U>then</U><r>
           prerr_endline ("do_open_mod: "^pretty_text e) ;
 </r><m>725   </m><U>match</U></b> e <b><U>with</U><r>
       Style m -&gt;
         </r><U>if</U></b> flags.in_math &amp;&amp; !Parse_opts.mathml <b><U>then</U>
           <U>if</U></b> m="mtext" <b><U>then</U><r> do_put ("&lt;"^m^"&gt;")
           </r><U>else</U></b> do_put ("&lt;mstyle style = \""^
 <m>730      <r>(<b><U>match</U><r> m </r><U>with</U></b>
            "B" -&gt; "font-weight: bold "
          | "I" -&gt; "font-style: italic "
          | "TT" -&gt; "font-family: courier "
          | "EM" -&gt; "font-style: italic "
 </r>735      <r>| _ -&gt; m)^
          "\"&gt;")
         <b><U>else</U><r> do_put ("&lt;"^m^"&gt;")
     | Font i  -&gt;
         </r><U>if</U></b> flags.in_math &amp;&amp; !Parse_opts.mathml <b><U>then</U><m>
 740       <r>do_put ("&lt;mstyle style = \"font-size: "^string_of_int i^"\"&gt;")
         <b><U>else</U><r> do_put ("&lt;FONT SIZE="^string_of_int i^"&gt;")
     | Color s -&gt;
         </r><U>if</U></b> flags.in_math &amp;&amp; !Parse_opts.mathml <b><U>then</U></b>
           do_put ("&lt;mstyle style = \"color: "^s^"\"&gt;")
 </r>745     </m><U>else</U></b> do_put ("&lt;FONT COLOR="^s^"&gt;")
     ;;
     
     
     <b><U>let</U><r> do_close_tmod = </r><U>function</U><m>
 750   <r>| {here = <b><U>true</U><r> ; env = env} -&gt; do_close_mod env
       | _ -&gt; ()
     
     </r><U>let</U></b> close_active_mods active = List.iter do_close_tmod active
     
 </r>755 </m><U>let</U></b> do_close_mods () =
       close_active_mods !cur_out.active ;
       !cur_out.active &lt;- [] ;
       !cur_out.pending &lt;- []
     ;;
 </r>760 
     
     <b><U>let</U></b></m> do_close_mods_pred pred same_constr =
       <b><U>let</U><r> tpred {env=env} = pred env </r><U>in</U><m>
     
 765   </m><U>let</U> <U>rec</U></b> split_again = <b><U>function</U><r>
         | [] -&gt; [],None,[]
         | {here = </r><U>false</U></b> ; env=env} :: rest
           <b><U>when</U><r> same_constr env &amp;&amp; not (pred env) -&gt;
             [],Some env,rest
 <m>770     </m>| m :: rest -&gt;
             </r><U>let</U></b> to_close,to_open,to_keep = split_again rest <b><U>in</U>
             <U>match</U></b> to_open <b><U>with</U><r>
             | Some _ -&gt; m::to_close,to_open,to_keep
             | None   -&gt; to_close,to_open,m::to_keep </r><U>in</U><m>
 775 
       </m><U>let</U> <U>rec</U></b> split = <b><U>function</U><r>
         | [] -&gt; [],None,[]
         | m :: rest -&gt;
             </r><U>let</U></b> to_close,close,to_keep = split rest <b><U>in</U><m>
 780         </m><U>match</U></b> close <b><U>with</U><r>
             | None -&gt;
                 </r><U>if</U></b> tpred m <b><U>then</U>
                   <U>if</U></b> m.here <b><U>then</U><r> [],Some m.env,to_keep
                   </r><U>else</U><m>
 785                 <r>[],None,to_keep
                 <b><U>else</U><r> [], None, m::to_keep
             | Some _ -&gt;
                 m::to_close,close,to_keep </r><U>in</U><m>
     
 790   </m><U>let</U> <U>rec</U></b> filter_pred = <b><U>function</U><r>
         | [] -&gt; []
         | x :: rest -&gt;
             </r><U>if</U></b> pred x <b><U>then</U><r> filter_pred rest
             </r><U>else</U></b> x::filter_pred rest <b><U>in</U><m>
 795 
       </m><U>let</U></b> to_close,close,to_keep = split !cur_out.active <b><U>in</U></b>
     
     
       filter_pred
 </r>800     <r>(<b><U>match</U><r> close </r><U>with</U></b>
         | None -&gt; []
         | Some env -&gt;
             List.iter do_close_tmod to_close ;
             do_close_mod env ;
 </r>805         </m><U>let</U></b> (to_close_open,to_open,to_keep) = split_again to_keep <b><U>in</U>
             <U>begin</U> <U>match</U></b> to_open <b><U>with</U></b>
             | None -&gt;
                 !cur_out.active &lt;- to_keep ;
                 as_envs to_close []
 <m>810         </m>| Some env -&gt;
                 !cur_out.active &lt;- to_keep ;
                 List.iter do_close_tmod to_close_open ;
                 as_envs to_close
                   (as_envs to_close_open [env])
 <m>815         <b><U>end</U><r>),
       close
     
     
     </r><U>let</U><r> close_mods () = do_close_mods ()
 <m>820 </m>;;
     
     
     <b><U>let</U><r> is_style = </r><U>function</U></b>
       Style _ -&gt; </r><U>true</U></b>
 825 </m>| _ -&gt; <b><U>false</U></b>
     
     <b><U>and</U><r> is_font = </r><U>function</U></b>
       Font _ -&gt; <b><U>true</U><r>
     | _ -&gt; </r><U>false</U><m>
 830 
     </m><U>and</U></b> is_color = <b><U>function</U><r>
       Color _ -&gt; </r><U>true</U></b>
     | _ -&gt; <b><U>false</U><r>
     ;;
 </r><m>835 
     </m><U>let</U></b> do_open_these_mods do_open_mod pending =
       <b><U>let</U> <U>rec</U></b> do_rec color size = <b><U>function</U><r>
         |   [] -&gt; []
         | Color _ </r><U>as</U></b> e :: rest  -&gt;
 <m>840         <b><U>if</U></b></m> color <b><U>then</U>
               <U>let</U></b> rest = do_rec <b><U>true</U><r> size rest </r><U>in</U></b>
               {here=<b><U>false</U><r> ; env=e}::rest
             </r><U>else</U> <U>begin</U>
               <U>let</U></b> rest = do_rec <b><U>true</U><r> size rest </r><U>in</U><m>
 845           <r>do_open_mod e ;
               {here=<b><U>true</U><r> ; env=e}::rest
             </r><U>end</U></b>
         | Font _ <b><U>as</U><r> e :: rest -&gt;
             </r><U>if</U></b> size <b><U>then</U><m>
 850           </m><U>let</U></b> rest = do_rec color <b><U>true</U><r> rest </r><U>in</U></b>
               {here=<b><U>false</U><r> ; env=e}::rest
             </r><U>else</U>
               <U>let</U></b> rest = do_rec color <b><U>true</U><r> rest </r><U>in</U></b>
               do_open_mod e ;
 </r>855           <r>{here=<b><U>true</U><r> ; env=e}::rest
         | e :: rest -&gt;
             </r><U>let</U></b> rest = do_rec color size rest <b><U>in</U><r>
             do_open_mod e ;
             {here=</r><U>true</U></b> ; env=e} :: rest <b><U>in</U><m>
 860   <r>do_rec
         <b><U>false</U>
         <U>false</U></b>
         pending
     
 </r>865 </m><U>let</U></b> activate caller pending =
       <b><U>let</U><r> r = do_open_these_mods (</r><U>fun</U></b> _ -&gt; ()) pending <b><U>in</U>
       <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         prerr_string ("activate: ("^caller^")") ;
         pretty_mods stderr pending ; prerr_string " -&gt; " ;
 </r>870     <r>pretty_tmods stderr r ;
         prerr_endline ""
       <b><U>end</U></b> ;
       r
     
 </r>875 </m><U>let</U></b> get_top_active = <b><U>function</U><r>
       | Nothing {top_active = active} -&gt; active
       | Activate {top_pending = pending ; top_active = active} -&gt;
           activate "get_top_active" pending @ active
       | _ -&gt; []
 </r><m>880 
     </m><U>let</U></b> all_to_pending out =
       <b><U>try</U>
         <U>let</U></b> top = get_top_lists out.top <b><U>in</U><r>
         to_pending out.pending out.active @
 <m>885     </m>to_pending top.top_pending top.top_active
       </r><U>with</U></b>
       | Not_found -&gt;
         to_pending out.pending out.active
     
 <m>890 <b><U>let</U></b></m> all_to_active out = activate "all_to_active" (all_to_pending out)
     
     <w>(* Clear styles *)
     <b><U>let</U><r> clearstyle () =
       close_active_mods !cur_out.active ;
 </r><m>895   <r>close_active_mods (get_top_active !cur_out.top) ;
       close_top 0 !cur_out ;
       !cur_out.pending &lt;- [] ;
       !cur_out.active &lt;- []
     ;;
 </r>900 
     <w>(* Avoid styles *)
     <b><U>let</U><r> nostyle () =
       clearstyle () ;
       !cur_out.nostyle &lt;- </r><U>true</U><m>
 905 <r>;;
     
     <w>(* Create new statuses, with appropriate pending lists *)
     
     <b><U>let</U></b></w> create_status_from_top out = <b><U>match</U><r> out.top </r><U>with</U><m>
 910 <r>| NotMe|Closed _|ActivateClosed _|Insert (_,_) -&gt;
        {nostyle=out.nostyle ; pending = []  ; active = []  ;
        top =
          Nothing
            {top_pending = out.pending ; top_active = out.active} ;
 </r>915    <r>out = Out.create_buff ()}
     | Nothing {top_pending = top_pending ; top_active=top_active} -&gt;
         <b><U>assert</U></b> (out.active=[]) ;
         {nostyle=out.nostyle ; pending = [] ; active = [] ;
         top =
 </r>920       <r>Nothing
             {top_pending = out.pending @ top_pending ;
             top_active = top_active} ;
         out = Out.create_buff ()}
     | Activate {top_pending = top_pending ; top_active=top_active} -&gt;
 </r>925     <r>{nostyle=out.nostyle ; pending = [] ; active = [] ;
         top=
           Nothing
             {top_pending = out.pending ;
             top_active = out.active @ activate "top" top_pending @ top_active} ;
 </r>930     <r>out=Out.create_buff ()}
     
     
     <b><U>let</U></b> create_status_from_scratch nostyle pending =
        {nostyle=nostyle ;
 </r>935    <r>pending =pending  ; active = []  ;
        top=NotMe ;
        out = Out.create_buff ()}
     
     <b><U>let</U></b> do_open_mods () =
 </r>940   </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         prerr_string "=&gt; do_open_mods: " ;
         pretty_cur !cur_out
       <b><U>end</U></b> ;
     
 </r>945   </m><U>let</U><r> now_active =
         do_open_these_mods do_open_mod !cur_out.pending <b><U>in</U><r>
       activate_top !cur_out ;
       !cur_out.active &lt;- now_active @ !cur_out.active ;
       !cur_out.pending &lt;- [] ;
 </r><m>950 
       </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         prerr_string "&lt;= do_open_mods: " ;
         pretty_cur !cur_out
       <b><U>end</U><m>
 955 
     
     
     
     </m><U>let</U></b> do_pending () =
 <m>960   <b><U>begin</U> <U>match</U></b></m> flags.pending_par <b><U>with</U><r>
       | Some n -&gt;
           flush_par (par_val flags.last_closed (pblock()) n)
       | _ -&gt; ()
       </r><U>end</U></b> ;
 <m>965   <r>flags.last_closed &lt;- NADA ;
       do_open_mods ()
     ;;
     
     
 </r>970 <b><U>let</U></b></m> one_cur_size pending active =
       <b><U>let</U> <U>rec</U></b> cur_size_active = <b><U>function</U><r>
         | [] -&gt; raise Not_found
         | {here=</r><U>true</U></b> ; env=Font i}::_ -&gt; i
         | _::rest -&gt; cur_size_active rest <b><U>in</U><m>
 975 
       </m><U>let</U> <U>rec</U></b> cur_size_pending = <b><U>function</U><r>
         | [] -&gt; cur_size_active active
         | Font i::_ -&gt; i
         | _::rest -&gt; cur_size_pending rest </r><U>in</U><m>
 980   <r>cur_size_pending pending
     ;;
     
     <b><U>let</U><r> cur_size out =
       </r><U>try</U></b> one_cur_size out.pending out.active
 </r>985   </m><U>with</U></b> Not_found -&gt;
         <b><U>try</U>
           <U>let</U></b> top_out = get_top_lists out.top <b><U>in</U><r>
           one_cur_size top_out.top_pending top_out.top_active
         </r><U>with</U></b> Not_found -&gt; 3
 <m>990 
     <b><U>let</U></b></m> one_first_same x same_constr pending active =
       <b><U>let</U> <U>rec</U></b> same_active = <b><U>function</U><r>
         | {here=</r><U>true</U></b> ; env=y} :: rest -&gt;
             <b><U>if</U><r> same_constr y </r><U>then</U></b> x=y
 <m>995         <b><U>else</U></b></m> same_active rest
         | _::rest -&gt; same_active rest
         | [] -&gt; raise Not_found <b><U>in</U>
       <U>let</U> <U>rec</U></b> same_pending = <b><U>function</U><r>
         | [] -&gt; same_active active
<m>1000     </m>| y::rest -&gt;
             </r><U>if</U></b> same_constr y <b><U>then</U><r> x=y
             </r><U>else</U></b> same_pending rest <b><U>in</U><r>
       same_pending pending
     ;;
</r><m>1005 
     </m><U>let</U></b> first_same x same_constr out =
       <b><U>try</U><r>
         one_first_same x same_constr out.pending out.active
       </r><U>with</U></b> Not_found -&gt;
<m>1010     <b><U>try</U>
           <U>let</U></b></m> top_out = get_top_lists out.top <b><U>in</U><r>
           one_first_same x same_constr top_out.top_pending top_out.top_active
         </r><U>with</U></b>
         | Not_found -&gt; <b><U>false</U><m>
1015 
     </m><U>let</U></b> already_here = <b><U>function</U><r>
     | Font i -&gt;
        i = cur_size !cur_out
     | x -&gt;
<m>1020   </m>first_same x
        (</r><U>match</U></b> x <b><U>with</U><r>
          Style _ -&gt;  is_style
        | Font _ -&gt; is_font
        | Color _ -&gt; is_color)
<m>1025    </m>!cur_out
     ;;
     
     </r><U>let</U></b> ok_pre x = <b><U>match</U><r> x </r><U>with</U></b>
     | Color _ | Font _ | Style "SUB" | Style "SUP" -&gt;  not !Parse_opts.pedantic
<m>1030 <r>| _ -&gt; <b><U>true</U><r>
     ;;
     
     </r><U>let</U> <U>rec</U></b> filter_pre = <b><U>function</U></b>
       [] -&gt; []
</r>1035 <r>| e::rest -&gt;
        <b><U>if</U><r> ok_pre e </r><U>then</U></b> e::filter_pre rest
        <b><U>else</U></b> filter_pre rest
     ;;
     
</r>1040 <b><U>let</U></b></m> ok_mod e =
       (not flags.in_pre || ok_pre e) &amp;&amp;
       (not (already_here e))
     ;;
     
<m>1045 <b><U>let</U><r> get_fontsize () = cur_size !cur_out
     
     
     </r><U>let</U> <U>rec</U><r> erase_rec pred = <b><U>function</U><r>
       [] -&gt; None
<m>1050 </m>| s::rest -&gt;
        </r><U>if</U></b> pred s <b><U>then</U><r>
          Some rest
        </r><U>else</U>
          <U>match</U></b> erase_rec pred rest </r><U>with</U></b>
1055      </m>| Some rest -&gt; Some (s::rest)
          | None -&gt; None
     ;;
     
     
<m>1060 <b><U>let</U><r> erase_mod_pred pred same_constr =
       </r><U>if</U><r> not !cur_out.nostyle <b><U>then</U> <U>begin</U>
         <U>match</U></b> erase_rec pred !cur_out.pending <b><U>with</U><r>
         | Some pending -&gt;
             !cur_out.pending &lt;- pending
<m>1065     </m>| None -&gt;
             </r><U>let</U></b> re_open,<b><U>closed</U><r> = do_close_mods_pred pred same_constr </r><U>in</U>
             <U>match</U> <U>closed</U> <U>with</U></b>
             | Some _ -&gt;
                 !cur_out.pending &lt;- !cur_out.pending @ re_open
<m>1070         </m>| None -&gt;
                 activate_top !cur_out ;
                 <b><U>try</U>
                   <U>let</U></b> tops = get_top_lists !cur_out.top <b><U>in</U><r>
                   !cur_out.active &lt;-
<m>1075                  </m>!cur_out.active @
                      activate "erase" tops.top_pending @
                      tops.top_active ;
                   close_top 0 !cur_out ;
                   </r><U>let</U></b> re_open,_ = do_close_mods_pred pred same_constr </r><U>in</U></b>
1080               </m>!cur_out.pending &lt;- !cur_out.pending @ re_open
                 <b><U>with</U><r>
                 | Not_found -&gt; ()
       </r><U>end</U></b>
     ;;
<m>1085 
     <b><U>let</U><r> same_env = </r><U>function</U><r>
       | Style s1 -&gt; (<b><U>function</U><r> | Style s2 -&gt; s1 = s2 | _ -&gt; </r><U>false</U></b>)
       | Font i1 -&gt;
           (<b><U>function</U><r> | Font i2 -&gt; i1 = i2 | _ -&gt; </r><U>false</U></b>)
<m>1090   </m>| Color s1 -&gt;
           (<b><U>function</U><r> | Color s2 -&gt; s1 = s2 | _ -&gt; </r><U>false</U></b>)
     
     <b><U>and</U><r> same_constr = </r><U>function</U></b>
       | Color _ -&gt; is_color
<m>1095   </m>| Font _ -&gt; is_font
       | Style _ -&gt; is_style
     
     <b><U>let</U><r> erase_mods ms =
       </r><U>let</U> <U>rec</U></b> erase_rec = </r><U>function</U></b>
1100     </m>| [] -&gt; ()
         | m :: ms -&gt;
             erase_mod_pred (same_env m) (same_constr m) ;
             erase_rec ms <b><U>in</U><r>
       erase_rec ms
<m>1105 </m>;;
     
     </r><U>let</U></b> open_mod  m =
       <b><U>if</U><r> not !cur_out.nostyle </r><U>then</U> <U>begin</U>
         <U>if</U></b> !verbose &gt; 3 <b><U>then</U> <U>begin</U><m>
1110       <r>prerr_endline ("open_mod: "^pretty_text m^" ok="^sbool (ok_mod m)) ;
           pretty_cur !cur_out
         <b><U>end</U><r> ;
         </r><U>begin</U> <U>match</U></b> m <b><U>with</U></b>
         | Style "EM" -&gt;
</r>1115         </m><U>if</U></b> already_here m <b><U>then</U><r>
               erase_mods [m]
             </r><U>else</U></b>
               !cur_out.pending &lt;- m :: !cur_out.pending
         | _ -&gt;
<m>1120         <b><U>if</U><r> ok_mod m </r><U>then</U> <U>begin</U><r>
               !cur_out.pending &lt;- m :: !cur_out.pending
             </r><U>end</U>
         <U>end</U>
       <U>end</U></b>
1125 </m>;;
     
     <b><U>let</U> <U>rec</U></b> open_mods = <b><U>function</U></b>
       m::rest -&gt; open_mods rest ; open_mod m
     | []      -&gt; ()
<m>1130 </m>;;
     
     
     
     </r></b>(* Blocks *)
</w>1135 
     </m><U>let</U><r> pstart = <b><U>function</U><r>
       |  H1 | H2 | H3 | H4 | H5 | H6
       | PRE
       | DIV
<m>1140   </m>| BLOCKQUOTE
       | UL | OL | DL
       | TABLE -&gt; </r><U>true</U></b>
       | _ -&gt; <b><U>false</U><r>
     ;;
</r><m>1145 
     </m><U>let</U></b> is_group = <b><U>function</U><r>
       | GROUP -&gt; </r><U>true</U></b>
       | _ -&gt; <b><U>false</U><m>
     
1150 </m><U>and</U></b> is_pre = <b><U>function</U><r>
       | PRE -&gt; </r><U>true</U></b>
       | _ -&gt; <b><U>false</U>
     
     <U>let</U> <U>rec</U></b> do_try_open_block s args =
<m>1155   <b><U>if</U></b></m> !verbose &gt; 2 <b><U>then</U><r>
         prerr_flags ("=&gt; try open ``"^string_of_block s^"''");
       </r><U>if</U></b> s = DISPLAY <b><U>then</U> <U>begin</U></b>
         do_try_open_block TABLE args ;
         do_try_open_block TR "VALIGN=middle" ;
<m>1160   <b><U>end</U> <U>else</U> <U>begin</U></b></m>
         push stacks.s_empty flags.empty ; push stacks.s_blank flags.blank ;
         push stacks.s_insert flags.insert ;
         flags.empty &lt;- <b><U>true</U><r> ; flags.blank &lt;- </r><U>true</U></b> ;
         flags.insert &lt;- None ;
<m>1165     <b><U>begin</U> <U>match</U></b></m> s <b><U>with</U><r>
         | PRE -&gt; flags.in_pre &lt;- </r><U>true</U><w> (* No stack, cannot nest *)
         <r>| TABLE -&gt;
           push stacks.s_table_vsize flags.table_vsize ;
           push stacks.s_vsize flags.vsize ;
<m>1170       <r>push stacks.s_nrows flags.nrows ;
           flags.table_vsize &lt;- 0 ;
           flags.vsize &lt;- 0 ;
           flags.nrows &lt;- 0
         |  TR -&gt;
</r>1175       <r>flags.vsize &lt;- 1
         |  TD -&gt;
           push stacks.s_vsize flags.vsize ;
           flags.vsize &lt;- 1
         | _ -&gt;
</r>1180         <b><U>if</U></b></m> is_list s <b><U>then</U> <U>begin</U></b>
               push stacks.s_nitems flags.nitems;
               flags.nitems &lt;- 0 ;
               <b><U>if</U><r> s = DL </r><U>then</U> <U>begin</U></b>
                 push stacks.s_dt flags.dt ;
<m>1185             </m>push stacks.s_dcount flags.dcount;
                 flags.dt &lt;- "";
                 flags.dcount &lt;- ""
               <b><U>end</U>
             <U>end</U><m>
1190     </m><U>end</U>
       <U>end</U></b> ;
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U></b>
         prerr_flags ("&lt;= try open ``"^string_of_block s^"''")
           ;;
<m>1195 
     <b><U>let</U><r> try_open_block s args =
       push stacks.s_insert_attr flags.insert_attr ;
       </r><U>begin</U> <U>match</U><r> flags.insert_attr <b><U>with</U><r>
       | Some (TR,_) </r><U>when</U></b> s &lt;&gt; TR -&gt; ()
<m>1200   </m>| _ -&gt; flags.insert_attr &lt;- None
       <b><U>end</U><r> ;
       do_try_open_block s args
     
     </r><U>let</U></b> do_do_open_block s args =
<m>1205   <b><U>if</U><r> s = TR || is_header s </r><U>then</U><r>
         do_put "\n";
       do_put_char '&lt;' ;
       do_put (string_of_block s) ;
       <b><U>if</U></b> args &lt;&gt; "" </r><U>then</U> <U>begin</U></b>
1210     <b><U>if</U><r> args.[0] &lt;&gt; ' ' </r><U>then</U><r> do_put_char ' ' ;
         do_put args
       <b><U>end</U><r> ;
       do_put_char '&gt;'
     
<m>1215 <b><U>let</U> <U>rec</U><r> do_open_block insert s args = <b><U>match</U><r> s </r><U>with</U></b>
     | GROUP|DELAY|FORGET|AFTER|INTERN -&gt;
        <b><U>begin</U> <U>match</U></b> insert <b><U>with</U><r>
        | Some (tag,iargs) -&gt; do_do_open_block tag iargs
        | _ -&gt; ()
<m>1220    <b><U>end</U><r>
     | DISPLAY -&gt;
        do_open_block insert TABLE args ;
        do_open_block None TR "VALIGN=middle"
     | _  -&gt; </r><U>begin</U> <U>match</U><r> insert </r><U>with</U></b>
1225   </m>| Some (tag,iargs) -&gt;
           </r><U>if</U></b> is_list s || s = TABLE <b><U>then</U> <U>begin</U></b>
             do_do_open_block tag iargs ;
             do_do_open_block s args
           </r><U>end</U> <U>else</U> <U>begin</U></b>
1230         </m>do_do_open_block s args ;
             do_do_open_block tag iargs
           </r><U>end</U></b>
       | _ -&gt; do_do_open_block s args
     </r><U>end</U></b>
1235 
     <b><U>let</U> <U>rec</U><r> do_try_close_block s =
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U></b>
         prerr_flags ("=&gt; try close ``"^string_of_block s^"''") ;
       <b><U>if</U></b> s = DISPLAY </r><U>then</U> <U>begin</U></b>
1240     </m>do_try_close_block TR ;
         do_try_close_block TABLE
       <b><U>end</U> <U>else</U> <U>begin</U>
         <U>let</U></b> ehere = flags.empty <b><U>and</U><r> ethere = pop  stacks.s_empty </r><U>in</U></b>
         flags.empty &lt;- (ehere &amp;&amp; ethere) ;
<m>1245     <b><U>let</U><r> bhere = flags.blank </r><U>and</U><r> bthere = pop  stacks.s_blank <b><U>in</U><r>
         flags.blank &lt;- (bhere &amp;&amp; bthere) ;
         flags.insert &lt;- pop  stacks.s_insert ;
         </r><U>begin</U> <U>match</U></b> s <b><U>with</U></b>
         | PRE   -&gt; flags.in_pre &lt;- </r><U>false</U><w> (* PRE cannot nest *)
</w></b>1250     </m>| TABLE -&gt;
           <b><U>let</U><r> p_vsize = pop stacks.s_vsize </r><U>in</U></b>
           flags.vsize &lt;- max
            (flags.table_vsize + (flags.nrows)/3) p_vsize ;
           flags.nrows &lt;- pop  stacks.s_nrows ;
<m>1255       </m>flags.table_vsize &lt;- pop stacks.s_table_vsize
         |  TR -&gt;
             <b><U>if</U><r> ehere </r><U>then</U> <U>begin</U></b>
               flags.vsize &lt;- 0
             <b><U>end</U><r> ;
<m>1260         </m>flags.table_vsize &lt;- flags.table_vsize + flags.vsize;
             </r><U>if</U></b> not ehere <b><U>then</U><r> flags.nrows &lt;- flags.nrows + 1
         | TD -&gt;
             </r><U>let</U></b> p_vsize = pop stacks.s_vsize <b><U>in</U><r>
             flags.vsize &lt;- max p_vsize flags.vsize
<m>1265     </m>| _ -&gt;
             </r><U>if</U></b> is_list s <b><U>then</U> <U>begin</U></b>
               flags.nitems &lt;- pop stacks.s_nitems ;
               <b><U>if</U><r> s = DL </r><U>then</U> <U>begin</U></b>
                 flags.dt &lt;- pop stacks.s_dt ;
<m>1270             </m>flags.dcount &lt;- pop  stacks.s_dcount
               <b><U>end</U>
             <U>end</U>
         <U>end</U>
       <U>end</U></b> ;
<m>1275   <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U><r>
         prerr_flags ("&lt;= try close ``"^string_of_block s^"''")
     
     <b><U>let</U><r> try_close_block s =
       </r><U>begin</U> <U>match</U></b> flags.insert_attr </r><U>with</U></b>
1280   </m>| Some (tag,_) <b><U>when</U><r> tag = s -&gt;
           flags.insert_attr &lt;- pop stacks.s_insert_attr
       | _ -&gt; </r><U>match</U></b> pop stacks.s_insert_attr <b><U>with</U><r>
         | None -&gt; ()
         | Some (_,_) </r><U>as</U></b> x -&gt; flags.insert_attr &lt;- x
<m>1285   <b><U>end</U><r> ;
       do_try_close_block s
     
     </r><U>let</U><r> do_do_close_block s =
       do_put "&lt;/" ;
<m>1290   </m>do_put (string_of_block s) ;
       do_put_char '&gt;' ;
       <b><U>match</U><r> s </r><U>with</U></b> TD -&gt; do_put_char '\n' | _ -&gt; ()
     
     <b><U>let</U> <U>rec</U></b> do_close_block insert s = <b><U>match</U></b> s </r><U>with</U></b>
1295 </m>|  GROUP|DELAY|FORGET|AFTER|INTERN -&gt;
        <b><U>begin</U> <U>match</U></b> insert <b><U>with</U></b>
        | Some (tag,_) -&gt; do_do_close_block tag
        | _ -&gt; ()
        </r><U>end</U></b>
1300 </m>| DISPLAY -&gt;
         do_close_block None TR ;
         do_close_block insert TABLE
     | s  -&gt; <b><U>begin</U> <U>match</U></b> insert <b><U>with</U></b>
       | Some (tag,_) -&gt;
<m>1305       <b><U>if</U><r> is_list s || s = TABLE </r><U>then</U> <U>begin</U><r>
             do_do_close_block s;
             do_do_close_block tag
           <b><U>end</U> <U>else</U> <U>begin</U></b>
             do_do_close_block tag;
<m>1310         </m>do_do_close_block s
           <b><U>end</U></b>
       | _ -&gt; do_do_close_block s
     </r><U>end</U></b>
     
1315 <b><U>let</U><r> check_empty () = flags.empty
     
     </r><U>and</U><r> make_empty () =
       flags.empty &lt;- <b><U>true</U><r> ; flags.blank &lt;- </r><U>true</U></b> ;
       !cur_out.top &lt;- NotMe ;
<m>1320   </m>!cur_out.pending &lt;-  to_pending !cur_out.pending !cur_out.active ;
       !cur_out.active &lt;- []
     ;;
     
     <b><U>let</U> <U>rec</U></b> open_top_styles = </r><U>function</U></b>
1325   </m>| NotMe|Insert (_,_) -&gt; </r>(* Real block, inserted block *)
             </w><U>begin</U> <U>match</U></b> !cur_out.top <b><U>with</U><r>
             | Nothing tops -&gt;
                 </r><U>let</U></b> mods =
                   to_pending !cur_out.pending !cur_out.active @
<m>1330               </m>to_pending tops.top_pending tops.top_active <b><U>in</U>
                 <U>assert</U></b> (!cur_out.active=[]) ;
                 close_active_mods tops.top_active ;
                !cur_out.top &lt;- Closed (tops,Out.get_pos !cur_out.out);
                 Some mods
<m>1335         </m>| Activate tops -&gt;
                 !cur_out.top &lt;- ActivateClosed tops ;
                 <b><U>let</U><r> mods =
                   to_pending !cur_out.pending !cur_out.active @
                   to_pending tops.top_pending tops.top_active </r><U>in</U><m>
1340             <r>close_active_mods !cur_out.active ;
                 close_active_mods (activate "open_top_styles" tops.top_pending) ;
                 close_active_mods tops.top_active ;
                 Some mods
             | _ -&gt;
</r>1345             </m><U>let</U></b> mods = to_pending !cur_out.pending !cur_out.active <b><U>in</U><r>
                 close_active_mods !cur_out.active ;
                 Some mods
             </r><U>end</U></b>
       | Closed (_,n) -&gt; </r></b>(* Group that closed top_styles (all of them) *)
<m>1350       </m></w><b><U>let</U><r> out = !cur_out </r><U>in</U>
           <U>let</U></b> mods = all_to_pending out <b><U>in</U><r>
           close_top n out ;
           Some mods
       | Nothing _ -&gt; <w>(* Group with nothing to do *)
<m>1355       </m></w>None
       | Activate _ -&gt; <w>(* Just activate styles *)
           </w>do_open_mods () ;
           None
       | ActivateClosed tops -&gt;
<m>1360       </m>do_open_mods () ;
           </r><U>let</U></b> r = open_top_styles (Closed (tops,Out.get_pos !cur_out.out)) <b><U>in</U><r>
           r
     
     
</r><m>1365 </m><U>let</U> <U>rec</U></b> force_block s content =
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
         prerr_endline ("=&gt; force_block: ["^string_of_block s^"]");
         pretty_cur !cur_out
       <b><U>end</U><r> ;
</r><m>1370   </m><U>let</U></b> was_empty = flags.empty <b><U>in</U>
       <U>if</U></b> s = FORGET <b><U>then</U> <U>begin</U></b>
         make_empty () ;
       <b><U>end</U> <U>else</U> <U>if</U></b> flags.empty <b><U>then</U> <U>begin</U></b>
         flags.empty &lt;- <b><U>false</U><r>; flags.blank &lt;- </r><U>false</U></b> ;
<m>1375     <r>do_open_mods () ;
         do_put content
       <b><U>end</U><r> ;
       </r><U>if</U></b> s = TABLE || s=DISPLAY <b><U>then</U><r> flags.table_inside &lt;- </r><U>true</U></b>;
     <w>(*  if s = PRE then flags.in_pre &lt;- false ; *)
<m>1380   <b><U>let</U><r> true_s = </r><U>if</U><r> s = FORGET <b><U>then</U><r> pblock() </r><U>else</U></b> s <b><U>in</U>
       <U>let</U></b> insert = flags.insert
       <b><U>and</U><r> insert_attr = flags.insert_attr
       </r><U>and</U></b> was_nostyle = !cur_out.nostyle
       <b><U>and</U><r> was_top = !cur_out.top </r><U>in</U><m>
1385 
       <r>do_close_mods () ;
       try_close_block true_s ;
       do_close_block insert true_s ;
       <b><U>let</U><r> ps,args,pout = pop_out out_stack </r><U>in</U><m>
1390   <r>check_block_closed ps true_s ;
       <b><U>let</U><r> old_out = !cur_out </r><U>in</U></b>
       cur_out := pout ;
       <b><U>if</U><r> s = FORGET </r><U>then</U></b> free old_out
       <b><U>else</U> <U>if</U></b> ps &lt;&gt; DELAY <b><U>then</U> <U>begin</U><m>
1395     </m><U>let</U></b> mods = open_top_styles was_top <b><U>in</U><r>
     
         do_open_block insert s
           (</r><U>match</U></b> insert_attr <b><U>with</U><r>
           | Some (this_tag,attr) </r><U>when</U></b> this_tag = s -&gt; args^" "^attr
</r>1400       <r>| _ -&gt; args) ;
     
         <b><U>begin</U> <U>match</U></b> was_top <b><U>with</U></b>
         | Insert (_,mods) -&gt;
             ignore (do_open_these_mods do_open_mod mods)
</r>1405     <r>| _ -&gt; ()
         <b><U>end</U><r> ;
     <w>(*
         prerr_endline "****** NOW *******" ;
         pretty_cur !cur_out ;
<m>1410     </m>prerr_endline "\n**********" ;
     *)
         <b><U>if</U><r> ps = AFTER </r><U>then</U> <U>begin</U>
           <U>let</U><r> f = pop stacks.s_after <b><U>in</U></b>
           Out.copy_fun f old_out.out !cur_out.out
<m>1415     <b><U>end</U> <U>else</U> <U>begin</U><r>
           Out.copy old_out.out !cur_out.out
         <b><U>end</U><r> ;
         free old_out ;
         </r><U>begin</U> <U>match</U></b> mods </r><U>with</U></b>
1420     </m>| Some mods -&gt;
             !cur_out.active  &lt;- [] ;
             !cur_out.pending &lt;- mods
         | _ -&gt; ()
         </r><U>end</U><m>
1425   </m><U>end</U> <U>else</U> <U>begin</U></b> (* ps = DELAY *)
         </w>raise (Misc.Fatal ("html: unflushed DELAY"))
       </r><U>end</U></b> ;
       <b><U>if</U><r> not was_empty &amp;&amp; true_s &lt;&gt; GROUP &amp;&amp; true_s &lt;&gt; AFTER </r><U>then</U></b>
         flags.last_closed &lt;- true_s ;
</r>1430 
       </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         prerr_endline ("&lt;= force_block: ["^string_of_block s^"]");
         pretty_cur !cur_out
       <b><U>end</U></b> ;
</r>1435 
     
     </m><U>and</U></b> close_block_loc pred s =
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U></b>
         prerr_string ("close_block_loc: ``"^string_of_block s^"'' = ");
</r></b>1440   <b><U>if</U><r> not (pred ()) </r><U>then</U> <U>begin</U>
         <U>if</U><r> !verbose &gt; 2 <b><U>then</U><r> prerr_endline "do it" ;
         force_block s "";
         </r><U>true</U>
       <U>end</U> <U>else</U> <U>begin</U><m>
1445     </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline "forget it" ;
         force_block FORGET "";
         </r><U>false</U>
       <U>end</U><m>
     
1450 </m><U>and</U></b> open_block s args =
      <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
        prerr_endline ("=&gt; open_block ``"^string_of_block s^"''");
        pretty_cur !cur_out ;
      <b><U>end</U></b> ;
</r></b>1455  <r>try_flush_par (Wait s);
     
      push_out out_stack (s,args,!cur_out) ;
      cur_out :=
         <b><U>begin</U> <U>if</U></b> is_group s <b><U>then</U><m>
1460       <r>create_status_from_top !cur_out
         <b><U>else</U><r>
           create_status_from_scratch
             !cur_out.nostyle
             (</r><U>let</U></b> cur_mods = all_to_pending !cur_out <b><U>in</U><m>
1465         </m><U>if</U></b> flags.in_pre || is_pre s <b><U>then</U><r> filter_pre cur_mods </r><U>else</U></b> cur_mods)
         <b><U>end</U><r> ;
      try_open_block s args ;
      </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
        prerr_endline ("&lt;= open_block ``"^string_of_block s^"''");
</r>1470    <r>pretty_cur !cur_out ;
      <b><U>end</U></b> ;
     ;;
     
     
</r>1475 </m><U>let</U></b> insert_block tag arg =
       <b><U>begin</U> <U>match</U></b> !cur_out.top <b><U>with</U><r>
       | Nothing {top_pending=pending ; top_active=active} -&gt;
           !cur_out.pending &lt;- !cur_out.pending @ to_pending pending active ;
           </r><U>assert</U></b> (!cur_out.active = []) ;
</r>1480       <r>!cur_out.top &lt;- Insert (<b><U>false</U><r>,[])
       | Activate {top_pending=pending ; top_active=active} -&gt;
           </r><U>let</U></b> add_active = activate "insert_block" pending @ active <b><U>in</U><r>
           !cur_out.active &lt;- !cur_out.active @ add_active ;
           !cur_out.top &lt;- Insert (</r><U>true</U></b>,to_pending [] add_active)
</r>1485   <r>| Closed (_,n) -&gt;
           Out.erase_start n !cur_out.out ;
           !cur_out.top &lt;- Insert (<b><U>false</U><r>,[])
       | ActivateClosed {top_active=active ; top_pending=pending}-&gt;
           !cur_out.top &lt;- Insert (</r><U>false</U></b>,to_pending pending active)
</r>1490   <r>| NotMe -&gt; ()
       | Insert _ -&gt; ()
       <b><U>end</U></b> ;
       flags.insert &lt;- Some (tag,arg)
     
</r>1495 <b><U>let</U><r> insert_attr tag attr =
       </r><U>match</U><r> tag,flags.insert_attr <b><U>with</U></b>
       | TD, Some (TR,_) -&gt; ()
       | _, _ -&gt; flags.insert_attr &lt;- Some (tag,attr)
     
</r></b>1500 <b><U>let</U><r> close_block  s =
       </r><U>let</U><r> _ = close_block_loc check_empty s <b><U>in</U></b>
       ()
     ;;
     
</r></b>1505 <b><U>let</U><r> erase_block s =
       </r><U>if</U><r> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "erase_block: %s" (string_of_block s);
         prerr_newline ()
       <b><U>end</U></b> ;
</r></b>1510   <r>try_close_block s ;
       <b><U>let</U><r> ts,_,tout = pop_out out_stack </r><U>in</U>
       <U>if</U></b> ts &lt;&gt; s &amp;&amp; not (s = GROUP &amp;&amp; ts = INTERN) <b><U>then</U></b>
         failclose "erase_block" s ts;
       free !cur_out ;
</r>1515   <r>cur_out := tout
     ;;
     
     
     <b><U>let</U></b> open_group ss =
</r>1520   <b><U>let</U><r> e = Style ss </r><U>in</U>
       <U>if</U><r> no_opt || (ss  &lt;&gt; "" &amp;&amp; (not flags.in_pre || (ok_pre e))) <b><U>then</U> <U>begin</U></b>
         open_block INTERN "" ;
         <b><U>if</U><r> ss &lt;&gt; "" </r><U>then</U></b>
           !cur_out.pending &lt;- !cur_out.pending @ [e]
</r></b>1525   <b><U>end</U> <U>else</U><r>
         open_block GROUP ""
     
     <b><U>and</U><r> open_aftergroup f =
       open_block AFTER "" ;
<m>1530   </m>flags.empty &lt;- </r><U>false</U></b> ;
       push stacks.s_after f
     
     <b><U>and</U><r> close_group () =
       </r><U>match</U></b> pblock () </r><U>with</U></b>
1535   <r>| INTERN -&gt; close_block INTERN
       | AFTER  -&gt; force_block AFTER ""
       | _      -&gt; close_block GROUP
     ;;
     
</r>1540 
     
     </m>(* output requests  *)
     <b><U>let</U></b></w> is_blank = <b><U>function</U><r>
        ' ' | '\n' -&gt; </r><U>true</U><m>
1545 <r>| _ -&gt; <b><U>false</U><r>
     ;;
     
     </r><U>let</U></b> put s =
       <b><U>let</U><r> block = pblock () </r><U>in</U><m>
1550   </m><U>match</U></b> block <b><U>with</U><r>
       | TABLE|TR -&gt; ()
       | _ -&gt;
           </r><U>let</U></b> s_blank =
             <b><U>let</U><r> r = ref </r><U>true</U> <U>in</U><m>
1555         </m><U>for</U></b> i = 0 <b><U>to</U><r> String.length s - 1 </r><U>do</U></b>
               r := !r &amp;&amp; is_blank (String.unsafe_get s i)
             <b><U>done</U><r> ;
             !r </r><U>in</U>
           <U>let</U></b> save_last_closed = flags.last_closed <b><U>in</U><m>
1560       <r>do_pending () ;
           flags.empty &lt;- <b><U>false</U><r>;
           flags.blank &lt;- s_blank &amp;&amp; flags.blank ;
           do_put s ;
           </r><U>if</U></b> s_blank <b><U>then</U></b> flags.last_closed &lt;- save_last_closed
</r>1565 <r>;;
     
     <b><U>let</U><r> put_char c =
       </r><U>let</U></b> s = pblock () <b><U>in</U>
       <U>match</U></b> s <b><U>with</U><m>
1570   <r>| TABLE|TR -&gt; ()
       | _ -&gt;
           <b><U>let</U><r> save_last_closed = flags.last_closed </r><U>in</U>
           <U>let</U></b> c_blank = is_blank c <b><U>in</U></b>
           do_pending () ;
</r>1575       <r>flags.empty &lt;- <b><U>false</U><r>;
           flags.blank &lt;- c_blank &amp;&amp; flags.blank ;
           do_put_char c ;
           </r><U>if</U></b> c_blank <b><U>then</U></b> flags.last_closed &lt;- save_last_closed
     ;;
</r>1580 
     
     </m><U>let</U></b> flush_out () =
       Out.flush !cur_out.out
     ;;
</r>1585 
     </m><U>let</U></b> skip_line () =
       flags.vsize &lt;- flags.vsize + 1 ;
       put "&lt;BR&gt;\n"
     ;;
</r>1590 
     </m><U>let</U></b> put_length which  = <b><U>function</U></b>
       | Pixel x -&gt; put (which^string_of_int x)
       | Char x -&gt; put (which^string_of_int (Length.font * x))
       | Percent x  -&gt; put (which^"\""^string_of_int x^"%\"")
</r>1595   <r>| Default    -&gt; ()
       | No s       -&gt; raise (Misc.Fatal ("No-length ``"^s^"'' in outManager"))
     
     <b><U>let</U></b> horizontal_line attr width height =
       open_block GROUP "" ;
</r>1600   <r>nostyle () ;
       put "&lt;HR" ;
       <b><U>begin</U> <U>match</U></b> attr <b><U>with</U><r> "" -&gt; () | _ -&gt; put_char ' ' ; put attr </r><U>end</U></b> ;
       put_length " WIDTH=" width ;
       put_length " SIZE=" height ;
</r>1605   <r>put_char '&gt;' ;
       close_block GROUP
     ;;
     
     <b><U>let</U></b> line_in_table h =
</r>1610   <b><U>let</U></b></m> pad = (h-1)/2 <b><U>in</U><r>
       put "&lt;TABLE BORDER=0 WIDTH=\"100%\" CELLSPACING=0 CELLPADDING=" ;
       put (string_of_int pad) ;
       put "&gt;&lt;TR&gt;&lt;TD&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;"
     
</r><m>1615 </m><U>let</U></b> freeze f =
       push out_stack (Freeze f) ;
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
         prerr_string "freeze: stack=" ;
         pretty_stack out_stack
<m>1620   <b><U>end</U></b></m>
     ;;
     
     <b><U>let</U><r> flush_freeze () = </r><U>match</U></b> top out_stack <b><U>with</U><r>
       Freeze f -&gt;
</r><m>1625     </m><U>let</U></b> _ = pop out_stack <b><U>in</U>
         <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
           prerr_string "flush_freeze" ;
           pretty_stack out_stack
         <b><U>end</U><r> ;
<m>1630     </m>f () ; </r><U>true</U></b>
     | _ -&gt; <b><U>false</U><r>
     ;;
     
     </r><U>let</U></b> pop_freeze () = <b><U>match</U><r> top  out_stack </r><U>with</U><m>
1635   <r>Freeze f -&gt;
         <b><U>let</U><r> _ = pop out_stack </r><U>in</U></b>
         f,<b><U>true</U><r>
     | _ -&gt; (</r><U>fun</U></b> () -&gt; ()),<b><U>false</U></b>
     ;;
</r>1640 
     
     </m><U>let</U></b> try_open_display () =
       push stacks.s_ncols flags.ncols ;
       push stacks.s_table_inside flags.table_inside ;
<m>1645   <r>push stacks.s_saved_inside <b><U>false</U><r> ;
       flags.table_inside &lt;- </r><U>false</U></b> ;
       flags.ncols &lt;- 0
     
     <b><U>and</U></b> try_close_display () =
</r>1650   <r>flags.ncols &lt;- pop stacks.s_ncols ;
       flags.table_inside &lt;- pop stacks.s_saved_inside || flags.table_inside ;
       flags.table_inside &lt;- pop stacks.s_table_inside || flags.table_inside
     ;;
     
</r>1655 
     <b><U>let</U></b></m> close_flow_loc s =
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U></b>
         prerr_endline ("close_flow_loc: "^string_of_block s) ;
     
<m>1660   <b><U>let</U></b></m> active  = !cur_out.active
       <b><U>and</U><r> pending = !cur_out.pending </r><U>in</U>
       <U>if</U></b> close_block_loc check_empty s <b><U>then</U> <U>begin</U></b>
         !cur_out.pending &lt;- to_pending pending active ;
         <b><U>true</U><m>
1665   </m><U>end</U> <U>else</U> <U>begin</U></b>
         !cur_out.pending &lt;- to_pending pending active ;
         <b><U>false</U>
       <U>end</U></b>
     ;;
<m>1670 <b><U>let</U></b></m> close_flow s =
       <b><U>assert</U><r> (s &lt;&gt; GROUP) ;
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r>
         prerr_flags ("=&gt; close_flow ``"^string_of_block s^"''");
       </r><U>let</U></b> _ = close_flow_loc s <b><U>in</U><m>
1675   </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r>
         prerr_flags ("&lt;= close_flow ``"^string_of_block s^"''")
     ;;
     
     
</r><m>1680 </m><U>let</U></b> get_block s args =
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
         prerr_flags "=&gt; get_block";
       <b><U>end</U><r> ;
       do_close_mods () ;
</r><m>1685   </m><U>let</U></b> pempty = top stacks.s_empty
       <b><U>and</U><r> pblank = top stacks.s_blank
       </r><U>and</U></b> pinsert = top stacks.s_insert <b><U>in</U><r>
       try_close_block (pblock ()) ;
       flags.empty &lt;- pempty ; flags.blank &lt;- pblank ; flags.insert &lt;- pinsert;
<m>1690   </m>do_close_block None s ;
       </r><U>let</U></b> _,_,pout = pop_out out_stack <b><U>in</U>
       <U>let</U></b> old_out = !cur_out <b><U>in</U><r>
       cur_out := with_new_out pout ;
       </r><U>let</U></b> mods = as_envs !cur_out.active !cur_out.pending <b><U>in</U><m>
1695   <r>do_close_mods () ;
       do_open_block None s args ;
       Out.copy old_out.out !cur_out.out ;
       free old_out ;
       !cur_out.pending &lt;- mods ;
</r>1700   </m><U>let</U></b> r = !cur_out <b><U>in</U><r>
       cur_out := pout ;
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         Out.debug stderr r.out ;
         prerr_endline "";
<m>1705     <r>prerr_flags "&lt;= get_block"
       <b><U>end</U><r> ;
       r
     
     </r><U>let</U></b> hidden_to_string f =
</r>1710 <w>(*
       prerr_string "to_string: " ;
       Out.debug stderr !cur_out.out ;
       prerr_endline "" ;
     *)
</w>1715   <b><U>let</U></b></m> old_flags = copy_flags flags <b><U>in</U>
       <U>let</U></b> _ = forget_par () <b><U>in</U><r>
       open_block INTERN "" ;
       f () ;
       do_close_mods () ;
</r><m>1720   </m><U>let</U></b> flags_now = copy_flags flags <b><U>in</U>
       <U>let</U></b> r = Out.to_string !cur_out.out <b><U>in</U><r>
       flags.empty &lt;- </r><U>true</U></b> ;
       close_block INTERN ;
       set_flags flags old_flags ;
<m>1725   <r>r,flags_now
     ;;
     
     <b><U>let</U><r> to_string f =
       </r><U>let</U></b> r,_ = hidden_to_string f <b><U>in</U><m>
1730   <r>r<PL><B>
<6>85 htmllex.ml</6>
</B></PL> 
      12 "htmllex.mll"
     
     <b><U>open</U><r> Lexing
     </r><U>open</U></b> Lexeme
   </r>5 </m><U>open</U></b> Buff
     
     <b><U>let</U><r> txt_level = ref 0
     </r><U>and</U></b> txt_stack = Stack.create "htmllex"
     
  </r>10 <b><U>exception</U></b></m> Error <b><U>of</U><r> string
     ;;
     
     
     </r><U>let</U></b> error msg lb =
  <m>15   <r>raise (Error msg)
     
     
     <b><U>let</U></b> init table (s,t)= Hashtbl.add table s t
     ;;
  </r>20 
     <b><U>let</U></b></m> block = Hashtbl.create 17
     ;;
     
     List.iter (init block)
  <m>25   <r>["CENTER", () ; "DIV", (); "BLOCKQUOTE", () ;
       "H1", () ; "H2", () ;"H3", () ;"H4", () ;"H5", () ;"H6", () ;
       "PRE", () ; "TABLE", () ; "TR",() ; "TD", () ; "TH",() ;
       "OL",() ; "UL",(); "P",() ; "LI",() ;
       "DL",() ; "DT", () ; "DD",() ;
  </r>30   <r>]
     ;;
     
     <b><U>let</U><r> ptop () =
       </r><U>if</U></b> not (Stack.empty txt_stack) <b><U>then</U> <U>begin</U><m>
  35     </m><U>let</U></b> pos = Stack.top txt_stack <b><U>in</U><r>
         Location.print_this_fullpos pos ;
         prerr_endline "This opening tag is pending"
       </r><U>end</U><m>
     
  40 </m><U>let</U></b> warnings = ref <b><U>true</U>
     
     <U>let</U></b> check_nesting lb name =
       <b><U>try</U></b>
         Hashtbl.find block (String.uppercase name) ;
  </r>45     <b><U>if</U></b></m> !txt_level &lt;&gt; 0 &amp;&amp; !warnings <b><U>then</U> <U>begin</U></b>
           Location.print_fullpos () ;
           prerr_endline
             ("Warning, block level element: "^name^" nested inside text-level element") ;
           ptop ()
  <m>50     <b><U>end</U>
       <U>with</U></b></m>
       |  Not_found -&gt; ()
     
     <b><U>let</U><r> text = Hashtbl.create 17
  </r><m>55 <r>;;
     
     
     List.iter (init text)
       ["TT",TT ; "I",I ; "B",B ; "BIG",BIG ; "SMALL",SMALL ;
  </r>60    <r>"STRIKE",STRIKE ; "S",S ; "U",U ; "FONT",FONT ;
        "EM",EM ; "STRONG",STRONG ; "DFN",DFN ; "CODE",CODE ; "SAMP",SAMP ;
        "KBD",KBD ; "VAR",VAR ; "CITE",CITE ; "ABBR",ABBR ; "ACRONYM",ACRONYM ;
        "Q",Q ; "SUB",SUB ; "SUP",SUP ; "A", A ; "SPAN", SPAN ; "SCRIPT", SCRIPT]
     ;;
  </r>65 
     </m><U>let</U></b> is_textlevel name =
       <b><U>try</U>
         <U>let</U></b> _ = Hashtbl.find text (String.uppercase name) <b><U>in</U>
         <U>true</U><m>
  70   </m><U>with</U></b>
       | Not_found -&gt; <b><U>false</U>
     
     <U>let</U></b> is_br name = "BR" = (String.uppercase name)
     <b><U>let</U><r> is_basefont name = "BASEFONT" = (String.uppercase name)
  </r><m>75 
     </m><U>let</U></b> set_basefont attrs lb =
       List.iter
         (<b><U>fun</U><r> (name,v,_) -&gt; </r><U>match</U></b> String.uppercase name,v <b><U>with</U><r>
         | "SIZE",Some s -&gt;
  </r><m>80         </m><U>begin</U> <U>try</U></b>
               Emisc.basefont := int_of_string s
             <b><U>with</U><r>
             | _ -&gt; error "BASEFONT syntax" lb
             </r><U>end</U><m>
  85     <r>| _ -&gt; ())
         attrs
     
     <b><U>let</U><r> get_value lb = </r><U>function</U></b>
       | Some s -&gt; s
  </r>90   <r>| _ -&gt; error "Bad attribute syntax" lb
     
     <b><U>let</U><r> norm_attrs lb attrs =
        List.map
             (</r><U>fun</U></b> (name,value,txt) -&gt;
  </r>95           </m><U>match</U></b> String.uppercase name <b><U>with</U><r>
               | "SIZE" -&gt;  SIZE (get_value lb value),txt
               | "COLOR" -&gt; COLOR (get_value lb value),txt
               | "FACE" -&gt; FACE (get_value lb value),txt
               | _      -&gt; OTHER, txt)
 <m>100     </m>attrs
     
     </r><U>let</U></b> print_attrs s attrs =
       print_string s ; print_string ":" ;
       List.iter
 <m>105     <r>(<b><U>fun</U><r> x -&gt; </r><U>match</U></b>  x <b><U>with</U><r>
         | name,Some value </r><U>when</U></b> name=s -&gt;
             print_char ' ' ;
             print_string value
         | _ -&gt; ())
 </r>110     <r>attrs ;
       print_char '\n'
     
     <b><U>let</U><r> ouvre lb name attrs txt =
       </r><U>let</U></b> uname = String.uppercase name <b><U>in</U><m>
 115   </m><U>try</U>
         <U>let</U></b> tag = Hashtbl.find text uname <b><U>in</U>
         <U>let</U></b> attrs = norm_attrs lb attrs <b><U>in</U></b>
         incr txt_level ;
         Stack.push txt_stack (Location.get_pos ()) ;
 </r>120     <r>Open (tag, attrs,txt)
       <b><U>with</U><r>
       | Not_found -&gt; </r><U>assert</U> <U>false</U>
     
     <U>and</U></b> ferme lb name txt =
 </r>125   <b><U>try</U>
         <U>let</U></b></m> tag = Hashtbl.find text (String.uppercase name) <b><U>in</U><r>
         decr txt_level ;
         </r><U>begin</U> <U>if</U></b> not (Stack.empty txt_stack) <b><U>then</U>
           <U>let</U></b> _  = Stack.pop txt_stack <b><U>in</U><r> ()
 </r><m>130     </m><U>end</U></b> ;
         Close (tag,txt)
       <b><U>with</U><r>
       | Not_found -&gt; Text txt
     
 </r><m>135 
     
     
     
     </m><U>let</U></b> unquote s =
 <m>140   <b><U>let</U></b></m> l = String.length s <b><U>in</U><r>
       String.sub s 1 (l-2)
     ;;
     
     </r><U>let</U></b> buff = Buff.create ()
 <m>145 <b><U>and</U></b></m> abuff = Buff.create ()
     
     <b><U>let</U><r> put s = Buff.put buff s
     </r><U>and</U></b> putc c = Buff.put_char buff c
     
 <m>150 <b><U>let</U></b></m> aput s = Buff.put abuff s
     <b><U>and</U><r> aputc c = Buff.put_char abuff c
     
     
     
 </r><m>155 </m><U>let</U></b> lex_tables = {
       Lexing.lex_base =
        "\000\000\001\000\000\000\114\000\002\000\215\000\082\000\019\000\
    \254\255\000\000\253\255\000\000\004\000\255\255\255\255\003\000\
    \040\001\020\000\120\001\116\000\007\000\009\000\198\001\249\255\
    \122\000\018\000\000\000\250\255\001\000\251\255\013\000\032\000\
    \018\000\022\000\032\000\140\000\026\000\039\000\023\000\027\000\
    \033\000";
       Lexing.lex_backtrk =
        "\255\255\001\000\000\000\003\000\001\000\002\000\255\255\255\255\
    \255\255\001\000\255\255\255\255\000\000\255\255\255\255\255\255\
    \255\255\255\255\001\000\255\255\000\000\000\000\001\000\255\255\
    \000\000\006\000\003\000\255\255\002\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\000\000\255\255\255\255\255\255\255\255\
    \255\255";
 <m>160   <r>Lexing.lex_default =
        "\023\000\013\000\255\255\255\255\255\255\255\255\008\000\008\000\
    \000\000\255\255\000\000\255\255\255\255\000\000\000\000\015\000\
    \255\255\017\000\255\255\255\255\255\255\255\255\255\255\000\000\
    \255\255\255\255\255\255\000\000\255\255\000\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255";
       Lexing.lex_trans =
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\024\000\024\000\019\000\019\000\024\000\013\000\019\000\
    \020\000\020\000\021\000\021\000\020\000\000\000\021\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \024\000\028\000\019\000\000\000\000\000\013\000\025\000\020\000\
    \000\000\021\000\000\000\000\000\000\000\011\000\030\000\029\000\
    \002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
    \002\000\002\000\008\000\013\000\026\000\255\255\012\000\020\000\
    \009\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
    \002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
    \002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
    \002\000\002\000\002\000\035\000\035\000\000\000\000\000\000\000\
    \000\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
    \002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
    \002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
    \002\000\002\000\002\000\021\000\021\000\019\000\019\000\021\000\
    \031\000\019\000\032\000\035\000\035\000\033\000\034\000\035\000\
    \037\000\038\000\039\000\040\000\000\000\000\000\000\000\000\000\
    \014\000\000\000\021\000\000\000\019\000\035\000\035\000\000\000\
    \000\000\035\000\035\000\000\000\000\000\000\000\000\000\022\000\
    \036\000\000\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\035\000\000\000\000\000\000\000\
    \010\000\020\000\036\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\015\000\016\000\000\000\000\000\000\000\017\000\000\000\
    \027\000\255\255\018\000\255\255\018\000\018\000\000\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\000\000\010\000\255\255\000\000\000\000\000\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\000\000\000\000\000\000\000\000\018\000\000\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\010\000\018\000\000\000\018\000\018\000\000\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\000\000\000\000\000\000\000\000\018\000\
    \000\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\000\000\018\000\018\000\000\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\000\000\000\000\000\000\000\000\018\000\
    \000\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\022\000\000\000\000\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\000\000\000\000\000\000\000\000\000\000\000\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000";
       Lexing.lex_check =
 </r>165    <r>"\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\004\000\004\000\000\000\012\000\004\000\
    \020\000\020\000\021\000\021\000\020\000\255\255\021\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\026\000\004\000\255\255\255\255\015\000\000\000\020\000\
    \255\255\021\000\255\255\255\255\255\255\009\000\028\000\026\000\
    \002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
    \002\000\002\000\030\000\017\000\000\000\001\000\011\000\004\000\
    \007\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
    \002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
    \002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
    \002\000\002\000\002\000\034\000\040\000\255\255\255\255\255\255\
    \255\255\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
    \002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
    \002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
    \002\000\002\000\002\000\003\000\003\000\019\000\019\000\003\000\
    \025\000\019\000\031\000\024\000\024\000\032\000\033\000\024\000\
    \036\000\037\000\038\000\039\000\255\255\255\255\255\255\255\255\
    \006\000\255\255\003\000\255\255\019\000\035\000\035\000\255\255\
    \255\255\035\000\024\000\255\255\255\255\255\255\255\255\003\000\
    \024\000\255\255\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\035\000\255\255\255\255\255\255\
    \003\000\019\000\035\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\005\000\005\000\255\255\255\255\255\255\005\000\255\255\
    \000\000\001\000\005\000\015\000\005\000\005\000\255\255\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\255\255\007\000\017\000\255\255\255\255\255\255\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\255\255\255\255\255\255\255\255\005\000\255\255\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\006\000\016\000\255\255\016\000\016\000\255\255\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\255\255\255\255\255\255\255\255\016\000\
    \255\255\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\018\000\255\255\018\000\018\000\255\255\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\255\255\255\255\255\255\255\255\018\000\
    \255\255\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\022\000\255\255\255\255\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\255\255\255\255\255\255\255\255\255\255\255\255\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\022\000\022\000\022\000\022\000\022\000\022\000\022\000\
    \022\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255"
     }
     
     <b><U>let</U> <U>rec</U></b> main lexbuf = __ocaml_lex_main_rec lexbuf 0
     <b><U>and</U></b> __ocaml_lex_main_rec lexbuf state =
 </r>170   <b><U>match</U></b></m> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      171 "htmllex.mll"
                          Blanks (lexeme lexbuf))
       | 1 -&gt; (
 <m>175  </m>173 "htmllex.mll"
        put (lexeme lexbuf) ;
       in_comment lexbuf ;
       Text (Buff.to_string buff))
       | 2 -&gt; (
 <m>180  </m>177 "htmllex.mll"
        put (lexeme lexbuf) ;
       in_tag lexbuf ;
       Text (Buff.to_string buff))
       | 3 -&gt; (
 <m>185  </m>181 "htmllex.mll"
          putc '&lt;' ;
         </r><U>let</U></b> tag = read_tag lexbuf <b><U>in</U>
         <U>if</U></b> is_textlevel tag <b><U>then</U> <U>begin</U>
           <U>let</U></b> attrs = read_attrs lexbuf <b><U>in</U><m>
 190       <r>ouvre lexbuf tag attrs (Buff.to_string buff)
         <b><U>end</U> <U>else</U> <U>if</U></b> is_basefont tag <b><U>then</U> <U>begin</U>
           <U>let</U></b> attrs = read_attrs lexbuf <b><U>in</U></b>
           set_basefont attrs lexbuf ;
           Text (Buff.to_string buff)
 </r>195     </m><U>end</U> <U>else</U> <U>begin</U></b>
           check_nesting lexbuf tag ;
           in_tag lexbuf ;
           <b><U>let</U><r> txt = Buff.to_string buff </r><U>in</U>
           <U>if</U></b> is_br tag <b><U>then</U><m>
 200         <r>Blanks txt
           <b><U>else</U><r>
             Text txt
         </r><U>end</U></b>)
       | 4 -&gt; (
 </r>205  <r>200 "htmllex.mll"
          put "&lt;/" ;
         <b><U>let</U><r> tag = read_tag lexbuf </r><U>in</U></b>
         in_tag lexbuf ;
         ferme lexbuf tag (Buff.to_string buff))
 </r>210   <r>| 5 -&gt; (
      204 "htmllex.mll"
             Eof)
       | 6 -&gt; (
      206 "htmllex.mll"
 </r>215      <r>putc (lexeme_char lexbuf 0) ;
         text lexbuf ;
         Text (Buff.to_string buff))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_main_rec lexbuf n
     
 </r>220 </m><U>and</U></b> text lexbuf = __ocaml_lex_text_rec lexbuf 1
     <b><U>and</U><r> __ocaml_lex_text_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      212 "htmllex.mll"
 </r><m>225    <r>putc (lexeme_char lexbuf 0) ; text lexbuf)
       | 1 -&gt; (
      213 "htmllex.mll"
           ())
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_text_rec lexbuf n
 </r>230 
     </m><U>and</U></b> read_tag lexbuf = __ocaml_lex_read_tag_rec lexbuf 2
     <b><U>and</U><r> __ocaml_lex_read_tag_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
 <m>235  </m>217 "htmllex.mll"
          </r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><r>
         put lxm ; lxm)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_read_tag_rec lexbuf n
     
 </r><m>240 </m><U>and</U></b> read_attrs lexbuf = __ocaml_lex_read_attrs_rec lexbuf 3
     <b><U>and</U><r> __ocaml_lex_read_attrs_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      222 "htmllex.mll"
 <m>245      </m>aput (lexeme lexbuf) ; read_attrs lexbuf)
       | 1 -&gt; (
      224 "htmllex.mll"
        </r><U>let</U></b> name = lexeme lexbuf <b><U>in</U><r>
       aput name ;
 </r><m>250   </m><U>let</U></b> v = read_avalue lexbuf <b><U>in</U>
       <U>let</U></b> atxt = Buff.to_string abuff <b><U>in</U><r>
       put atxt ;
       (name,v,atxt)::read_attrs lexbuf)
       | 2 -&gt; (
 <m>255  </m>230 "htmllex.mll"
            put_char buff '&gt;' ; [])
       | 3 -&gt; (
      231 "htmllex.mll"
            error "Attribute syntax" lexbuf)
 <m>260   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_read_attrs_rec lexbuf n
     
     </r><U>and</U></b> read_avalue lexbuf = __ocaml_lex_read_avalue_rec lexbuf 4
     <b><U>and</U><r> __ocaml_lex_read_avalue_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><m>
 265     <r>0 -&gt; (
      235 "htmllex.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
         aput lxm ;
         Some (read_aavalue lexbuf))
 </r>270   <r>| 1 -&gt; (
      238 "htmllex.mll"
           None)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_read_avalue_rec lexbuf n
     
 </r>275 </m><U>and</U></b> read_aavalue lexbuf = __ocaml_lex_read_aavalue_rec lexbuf 5
     <b><U>and</U><r> __ocaml_lex_read_aavalue_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      243 "htmllex.mll"
 </r><m>280      </m><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><r>
         aput lxm ;
         unquote lxm)
       | 1 -&gt; (
      247 "htmllex.mll"
 </r><m>285      </m><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><r>
         aput lxm ;
         lxm)
       | 2 -&gt; (
      250 "htmllex.mll"
 <m>290       </m>error "Attribute syntax" lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_read_aavalue_rec lexbuf n
     
     </r><U>and</U></b> in_tag lexbuf = __ocaml_lex_in_tag_rec lexbuf 6
     <b><U>and</U><r> __ocaml_lex_in_tag_rec lexbuf state =
 </r><m>295   </m><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      253 "htmllex.mll"
            putc (lexeme_char lexbuf 0))
       | 1 -&gt; (
 <m>300  </m>254 "htmllex.mll"
            putc (lexeme_char lexbuf 0) ; in_tag lexbuf)
       | 2 -&gt; (
      255 "htmllex.mll"
            error "End of file in tag" lexbuf)
 <m>305   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_in_tag_rec lexbuf n
     
     </r><U>and</U></b> in_comment lexbuf = __ocaml_lex_in_comment_rec lexbuf 7
     <b><U>and</U><r> __ocaml_lex_in_comment_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><m>
 310     <r>0 -&gt; (
      259 "htmllex.mll"
        put (lexeme lexbuf))
       | 1 -&gt; (
      261 "htmllex.mll"
 </r>315     <r>putc (lexeme_char lexbuf 0) ; in_comment lexbuf)
       | 2 -&gt; (
      263 "htmllex.mll"
          error "End of file in comment" lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_in_comment_rec lexbuf n
 </r>320 
     <r>;;
     
      265 "htmllex.mll"
     
 </r>325 
     </m><U>let</U></b> to_string = <b><U>function</U><r>
       | Open (_,_,txt)  | Close (_,txt)  | Text txt  | Blanks txt -&gt; txt
       | Eof -&gt; "Eof"
     
 </r><m>330 </m><U>let</U> <U>rec</U></b> cost = <b><U>function</U><r>
       | {tag=FONT ; attrs=attrs} -&gt; (1,List.length attrs)
       | _          -&gt; (1,0)
     
     </r><U>let</U></b> tok_buff = ref None
 <m>335 <r>;;
     
     <b><U>let</U></b> txt_buff = Buff.create ()
     ;;
     
 </r>340 <b><U>let</U> <U>rec</U></b></m> read_tokens blanks lb =
       <b><U>let</U><r> t = main lb </r><U>in</U>
       <U>match</U></b> t <b><U>with</U><r>
       | Text txt -&gt; Buff.put txt_buff txt ; read_tokens </r><U>false</U></b> lb
       | Blanks txt -&gt; Buff.put txt_buff txt ; read_tokens blanks lb
 <m>345   <r>| _ -&gt;
           <b><U>let</U><r> txt = Buff.to_string txt_buff </r><U>in</U>
           <U>match</U></b> txt <b><U>with</U></b>
           | "" -&gt; t
           | _  -&gt;
 </r>350           <r>tok_buff := Some t ;
               <b><U>if</U><r> blanks </r><U>then</U></b>
                 Blanks txt
               <b><U>else</U></b>
                 Text txt
 </r>355 
     <b><U>let</U></b></m> reset () =
       txt_level := 0 ;
       Stack.reset txt_stack ;
       Buff.reset txt_buff ;
 <m>360   <r>Buff.reset buff ;
       Buff.reset abuff
     
     <b><U>let</U><r> next_token lb =
       </r><U>try</U> <U>match</U></b> !tok_buff <b><U>with</U><m>
 365   <r>| Some t -&gt; tok_buff := None ; t
       | None   -&gt; read_tokens <b><U>true</U><r> lb
       </r><U>with</U></b>
       | e -&gt;
           reset () ;
 </r>370       <r>raise e<PL><B>
<6>86 htmlMath.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><b><U>let</U></b> header = "$Id: htmlMath.ml,v 1.21 2000/10/31 08:25:14 maranget Exp $"
     
     
  </r>15 </m><U>open</U></b> Misc
     <b><U>open</U><r> Parse_opts
     </r><U>open</U></b> Element
     <b><U>open</U><r> HtmlCommon
     </r><U>open</U></b> Stack
  </r>20 
     
     
     <b><U>let</U></b></m> delay_stack = Stack.create "delay_stack"
     ;;
  <m>25 <w>(* delaying output .... *)
     
     <b><U>let</U><r> delay f =
       </r><U>if</U><r> !verbose &gt; 2 <b><U>then</U><r> prerr_flags "=&gt; delay" ;
       push stacks.s_vsize flags.vsize ;
  <m>30   </m>flags.vsize &lt;- 0;
       push delay_stack f ;
       open_block DELAY "" ;
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_flags "&lt;= delay"
     ;;
  </r><m>35 
     </m><U>let</U></b> flush x =
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U></b>
         prerr_flags ("=&gt; flush arg is ``"^string_of_int x^"''");
       try_close_block DELAY ;
  <m>40   <b><U>let</U></b></m> ps,_,pout = pop_out out_stack <b><U>in</U>
       <U>if</U></b> ps &lt;&gt; DELAY <b><U>then</U><r>
         raise (Misc.Fatal ("html: Flush attempt on: "^string_of_block ps)) ;
       </r><U>let</U></b> mods = as_envs !cur_out.active !cur_out.pending <b><U>in</U></b>
       do_close_mods () ;
  <m>45   <b><U>let</U><r> old_out = !cur_out </r><U>in</U><r>
       cur_out := pout ;
       <b><U>let</U><r> f = pop delay_stack </r><U>in</U></b>
       f x ;
       Out.copy old_out.out !cur_out.out ;
  <m>50   </m>flags.empty &lt;- <b><U>false</U><r> ; flags.blank &lt;- </r><U>false</U></b> ;
       free old_out ;
       !cur_out.pending &lt;- mods ;
       flags.vsize &lt;- max (pop stacks.s_vsize) flags.vsize ;
       <b><U>if</U></b> !verbose &gt; 2 </r><U>then</U></b>
  55     </m>prerr_flags "&lt;= flush"
     ;;
     
     </r></b>(* put functions *)
     
  </w>60 <b><U>let</U></b></m> put  = HtmlCommon.put
     <b><U>and</U><r> put_char = HtmlCommon.put_char
     ;;
     
     </r><U>let</U></b> put_in_math s =
  <m>65   <b><U>if</U></b></m> flags.in_pre &amp;&amp; !pedantic <b><U>then</U><r>
         put s
       </r><U>else</U> <U>begin</U></b>
         put "&lt;I&gt;";
         put s;
  <m>70     <r>put "&lt;/I&gt;";
         flags.empty &lt;- <b><U>false</U><r>; flags.blank &lt;- </r><U>false</U></b>;
       <b><U>end</U></b>
     ;;
     
  </r>75 <w>(*----------*)
     (* DISPLAYS *)
     (*----------*)
     
     <b><U>let</U><r> open_center () =  open_block DIV "ALIGN=center"
  </r><m>80 </m><U>and</U><r> close_center () = close_block DIV
     ;;
     
     <b><U>let</U><r> display_arg  verbose =
       </r><U>if</U></b> verbose &gt; 1 <b><U>then</U><m>
  85     <r>"BORDER=1 CELLSPACING=0 CELLPADDING=0"
       <b><U>else</U></b>
         "CELLSPACING=0 CELLPADDING=0"
     ;;
     
  </r>90 
     
     
     </m><U>let</U></b> begin_item_display f is_freeze =
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U><m>
  95     <r>Printf.fprintf stderr "begin_item_display: ncols=%d empty=%s" flags.ncols (sbool flags.empty) ;
         prerr_newline ()
       <b><U>end</U></b> ;
       open_block TD "NOWRAP";
       open_block INTERN "" ;
 </r>100   </m><U>if</U></b> is_freeze </r><U>then</U></b>(* push out_stack (Freeze f) ;*)<r>freeze f;
     
     
     <b><U>and</U><r> end_item_display () =
       </r><U>let</U></b> f,is_freeze = pop_freeze () <b><U>in</U><m>
 105   </m><U>let</U></b> _ = close_flow_loc INTERN <b><U>in</U>
       <U>if</U></b> close_flow_loc TD <b><U>then</U><r>
         flags.ncols &lt;- flags.ncols + 1;
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "end_item_display: ncols=%d stck: " flags.ncols;
 <m>110     <r>pretty_stack out_stack
       <b><U>end</U></b>;
       flags.vsize,f,is_freeze
     ;;
     
 </r>115 <b><U>let</U></b></m> open_display () =
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "open_display: "
       <b><U>end</U><r> ;
       try_open_display () ;
 <m>120   </m>open_block DISPLAY (display_arg !verbose) ;
       open_block TD "NOWRAP" ;
       open_block INTERN "" ;
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         pretty_cur !cur_out ;
 <m>125     <r>prerr_endline ""
       <b><U>end</U><r>
     ;;
     
     </r><U>let</U></b> close_display () =
 </r>130   <b><U>if</U></b></m> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         prerr_flags "=&gt; close_display"
       <b><U>end</U><r> ;
       </r><U>if</U></b> not (flush_freeze ()) <b><U>then</U> <U>begin</U></b>
         close_flow INTERN ;
 <m>135     <b><U>let</U></b></m> n = flags.ncols <b><U>in</U>
         <U>if</U></b> !verbose &gt; 2 <b><U>then</U><r>
           Printf.fprintf stderr "=&gt; close_display, ncols=%d\n" n ;
         </r><U>if</U></b> (n = 0 &amp;&amp; not flags.blank) <b><U>then</U> <U>begin</U>
           <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U><m>
 140         <r>prerr_string "No Display n=0" ;
             (Out.debug stderr !cur_out.out);
             prerr_endline ""
           <b><U>end</U><r>;
           </r><U>let</U></b> active = !cur_out.active <b><U>and</U><r> pending = !cur_out.pending </r><U>in</U><m>
 145       <r>do_close_mods () ;
           <b><U>let</U><r> ps,_,pout = pop_out out_stack </r><U>in</U>
           <U>if</U></b> ps &lt;&gt; TD <b><U>then</U></b>
             failclose "close_display" ps TD ;
           do_close_mods () ;
 </r>150       <r>try_close_block TD ;
           <b><U>let</U><r> ps,_,ppout = pop_out out_stack </r><U>in</U>
           <U>if</U></b> ps &lt;&gt; DISPLAY <b><U>then</U></b>
             failclose "close_display" ps DISPLAY ;
           try_close_block DISPLAY ;
 </r>155       </m><U>let</U></b> old_out = !cur_out <b><U>in</U><r>
           cur_out := ppout ;
           do_close_mods () ;
           Out.copy old_out.out !cur_out.out ;
           flags.empty &lt;- </r><U>false</U></b> ; flags.blank &lt;- <b><U>false</U></b> ;
 </r>160       <r>free old_out ; free pout ;
           !cur_out.pending &lt;- as_envs active pending
         <b><U>end</U> <U>else</U> <U>if</U></b> (n=1 &amp;&amp; flags.blank) <b><U>then</U> <U>begin</U>
           <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
             prerr_string "No display n=1";
 </r>165         <r>(Out.debug stderr !cur_out.out);
             prerr_endline "" ;
           <b><U>end</U><r>;
           close_flow FORGET ;
           </r><U>let</U></b> active = !cur_out.active <b><U>and</U><r> pending = !cur_out.pending </r><U>in</U><m>
 170       </m><U>let</U></b> ps,_,pout = pop_out out_stack <b><U>in</U>
           <U>if</U></b> ps &lt;&gt; DISPLAY <b><U>then</U><r>
             failclose "close_display" ps DISPLAY ;
           try_close_block DISPLAY ;
           </r><U>let</U></b> old_out = !cur_out <b><U>in</U><m>
 175       <r>cur_out := pout ;
           do_close_mods () ;
           Out.copy_no_tag old_out.out !cur_out.out ;
           flags.empty &lt;- <b><U>false</U><r> ; flags.blank &lt;- </r><U>false</U></b> ;
           free old_out ;
 </r>180       <r>!cur_out.pending &lt;- as_envs active pending
         <b><U>end</U> <U>else</U> <U>begin</U>
           <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
             prerr_string ("One Display n="^string_of_int n) ;
             (Out.debug stderr !cur_out.out);
 </r>185         <r>prerr_endline ""
           <b><U>end</U></b>;
           flags.empty &lt;- flags.blank ;
           close_flow TD ;
           close_flow DISPLAY
 </r>190     </m><U>end</U></b> ;
         try_close_display ()
       <b><U>end</U><r> ;
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U></b>
         prerr_flags ("&lt;= close_display")
 </r>195 <r>;;
     
     
     <b><U>let</U><r> do_item_display force =
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U><m>
 200     <r>prerr_endline ("Item Display ncols="^string_of_int flags.ncols^" table_inside="^sbool flags.table_inside)
       <b><U>end</U><r> ;
       </r><U>let</U></b> f,is_freeze = pop_freeze () <b><U>in</U>
       <U>if</U></b> (force &amp;&amp; not flags.empty) || flags.table_inside <b><U>then</U> <U>begin</U></b>
         push stacks.s_saved_inside
 </r>205       <r>(pop stacks.s_saved_inside || flags.table_inside) ;
         flags.table_inside &lt;- <b><U>false</U><r> ;
         </r><U>let</U></b> active  = !cur_out.active
         <b><U>and</U><r> pending = !cur_out.pending </r><U>in</U></b>
         flags.ncols &lt;- flags.ncols + 1 ;
 </r>210     </m><U>let</U></b> save = get_block TD "NOWRAP" <b><U>in</U>
         <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
           Out.debug stderr !cur_out.out ;
           prerr_endline "To be copied"
         <b><U>end</U></b>;
 </r>215     </m><U>if</U></b> close_flow_loc TD <b><U>then</U><r> flags.ncols &lt;- flags.ncols + 1;
         </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
           Out.debug stderr !cur_out.out ;
           prerr_endline "Was copied"
         <b><U>end</U><r>;
 <m>220     </m>Out.copy save.out !cur_out.out ;
         flags.empty &lt;- </r><U>false</U></b> ; flags.blank &lt;- <b><U>false</U><r> ;
         free save ;
         !cur_out.pending &lt;- as_envs active pending ;
         !cur_out.active &lt;- [] ;
 </r><m>225     </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
           Out.debug stderr !cur_out.out ;
           prerr_endline ("Some Item")
         <b><U>end</U><r>;
         open_block TD "NOWRAP" ;
 <m>230     </m>open_block INTERN ""
       </r><U>end</U> <U>else</U> <U>begin</U>
         <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
           Out.debug stderr !cur_out.out ;
           prerr_endline "No Item" ;
 <m>235       <r>prerr_endline ("flags: empty="^sbool flags.empty^" blank="^sbool flags.blank)
         <b><U>end</U><r>;
         close_flow INTERN ;
         </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
           Out.debug stderr !cur_out.out ;
 </r>240       <r>prerr_endline "No Item" ;
           prerr_endline ("flags: empty="^sbool flags.empty^" blank="^sbool flags.blank)
         <b><U>end</U><r>;
         open_block INTERN ""
       </r><U>end</U></b> ;
 </r>245   <b><U>if</U></b></m> is_freeze <b><U>then</U><r> push out_stack (Freeze f) ;
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         prerr_string ("out item_display -&gt; ncols="^string_of_int flags.ncols) ;
         pretty_stack out_stack
       <b><U>end</U><r> ;
 <m>250 </m>;;
     
     </r><U>let</U></b> item_display () = do_item_display <b><U>false</U>
     <U>and</U></b> force_item_display () = do_item_display <b><U>true</U><r>
     ;;
 </r><m>255 
     
     </m><U>let</U></b> erase_display () =
       erase_block INTERN ;
       erase_block TD ;
 <m>260   <r>erase_block DISPLAY ;
       try_close_display ()
     ;;
     
     
 </r>265 <b><U>let</U></b></m> open_maths display =
       <b><U>if</U><r> display </r><U>then</U></b> open_center ();
       push stacks.s_in_math flags.in_math;
       flags.in_math &lt;- <b><U>true</U><r>;
       </r><U>if</U></b> display <b><U>then</U><r> open_display ()
 </r><m>270   </m><U>else</U></b> open_group "";
     ;;
     
     <b><U>let</U><r> close_maths display =
       </r><U>if</U></b> display <b><U>then</U><r> close_display ()
 </r><m>275   </m><U>else</U></b> close_group ();
       flags.in_math &lt;- pop stacks.s_in_math ;
     
       <b><U>if</U><r> display </r><U>then</U></b> close_center ()
     ;;
 <m>280 
     
     
     <w>(* vertical display *)
     
 </w>285 <b><U>let</U></b></m> open_vdisplay display =
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b>
         prerr_endline "open_vdisplay";
       <b><U>if</U><r> not display </r><U>then</U></b>
         raise (Misc.Fatal ("VDISPLAY in non-display mode"));
 <m>290   <r>open_block TABLE (display_arg !verbose)
     
     <b><U>and</U><r> close_vdisplay () =
       </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U></b>
         prerr_endline "close_vdisplay";
 </r>295   <r>close_block TABLE
     
     <b><U>and</U><r> open_vdisplay_row s =
       </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U></b>
         prerr_endline "open_vdisplay_row";
 </r>300   <r>open_block TR "" ;
       open_block TD s ;
       open_display ()
     
     <b><U>and</U></b> close_vdisplay_row () =
 </r>305   <b><U>if</U></b></m> !verbose &gt; 1 <b><U>then</U></b>
         prerr_endline "close_vdisplay_row";
       close_display () ;
       force_block TD "&amp;nbsp;" ;
       close_block TR
 <m>310 </m>;;
     
     
     
     </r>(* Sup/Sub stuff *)
 </w>315 
     <b><U>let</U></b></m> get_script_font () =
       <b><U>let</U><r> n = get_fontsize () </r><U>in</U>
       <U>if</U></b> n &gt;= 3 <b><U>then</U><r> Some (n-1) </r><U>else</U></b> None
     ;;
 <m>320 
     <b><U>let</U></b></m> open_script_font () =
       <b><U>if</U><r> not !pedantic </r><U>then</U>
         <U>match</U></b> get_script_font () <b><U>with</U><r>
         | Some m -&gt; open_mod (Font m)
 <m>325     </m>| _ -&gt; ()
     ;;
     
     
     </r><U>let</U></b> put_sup_sub display scanner (arg : string Lexstate.arg) =
 <m>330   <b><U>if</U></b></m> display <b><U>then</U><r> open_display () </r><U>else</U></b> open_block INTERN "" ;
       open_script_font () ;
       scanner arg ;
       <b><U>if</U><r> display </r><U>then</U></b> close_display () <b><U>else</U><r> close_block INTERN ;
     ;;
 </r><m>335 
     </m><U>let</U></b> reput_sup_sub tag = <b><U>function</U><r>
       | "" -&gt; ()
       | s  -&gt;
           open_block INTERN "" ;
 <m>340       </m>clearstyle () ;
           </r><U>if</U></b> not  (flags.in_pre &amp;&amp; !pedantic) <b><U>then</U> <U>begin</U></b>
             put_char '&lt;' ;
             put tag ;
             put_char '&gt;'
 <m>345       <b><U>end</U></b></m> ;
           put s ;
           <b><U>if</U><r> not  (flags.in_pre &amp;&amp; !pedantic) </r><U>then</U> <U>begin</U></b>
             put "&lt;/" ;
             put tag ;
 <m>350         <r>put_char '&gt;'
           <b><U>end</U></b> ;
           close_block INTERN
     
     
 </r>355 <b><U>let</U></b></m> standard_sup_sub scanner what sup sub display =
       <b><U>let</U><r> sup,fsup =
         hidden_to_string (</r><U>fun</U></b> () -&gt; put_sup_sub display scanner sup)
       <b><U>in</U>
       <U>let</U></b> sub,fsub =
 <m>360     <r>hidden_to_string (<b><U>fun</U><r> () -&gt; put_sup_sub display scanner sub) </r><U>in</U>
     
       <U>if</U></b> display &amp;&amp; (fsub.table_inside || fsup.table_inside) <b><U>then</U> <U>begin</U></b>
         force_item_display () ;
         open_vdisplay display ;
 </r>365     <b><U>if</U></b></m> sup &lt;&gt; "" <b><U>then</U> <U>begin</U></b>
           open_vdisplay_row "NOWRAP" ;
           clearstyle () ;
           put sup ;
           close_vdisplay_row ()
 <m>370     <b><U>end</U></b></m> ;
         open_vdisplay_row "" ;
         what ();
         close_vdisplay_row () ;
         <b><U>if</U><r> sub &lt;&gt; "" </r><U>then</U> <U>begin</U><m>
 375       <r>open_vdisplay_row "NOWRAP" ;
           clearstyle () ;
           put sub ;
           close_vdisplay_row ()
         <b><U>end</U></b> ;
 </r>380     <r>close_vdisplay () ;
         force_item_display ()
       <b><U>end</U> <U>else</U> <U>begin</U></b>
         what ();
         reput_sup_sub "SUB" sub ;
 </r>385     <r>reput_sup_sub "SUP" sup
       <b><U>end</U></b>
     ;;
     
     
 </r>390 </m><U>let</U></b> limit_sup_sub scanner what sup sub display =
       <b><U>let</U><r> sup = to_string (</r><U>fun</U></b> () -&gt; put_sup_sub display scanner sup)
       <b><U>and</U><r> sub = to_string (</r><U>fun</U></b> () -&gt; put_sup_sub display scanner sub) <b><U>in</U>
       <U>if</U></b> sup = "" &amp;&amp; sub = "" <b><U>then</U><r>
         what ()
 </r><m>395   </m><U>else</U> <U>begin</U></b>
         force_item_display () ;
         open_vdisplay display ;
         open_vdisplay_row "ALIGN=center" ;
         put sup ;
 <m>400     <r>close_vdisplay_row () ;
         open_vdisplay_row "ALIGN=left" ;
         what () ;
         close_vdisplay_row () ;
         open_vdisplay_row "ALIGN=center" ;
 </r>405     <r>put sub ;
         close_vdisplay_row () ;
         close_vdisplay () ;
         force_item_display ()
       <b><U>end</U><m>
 410 <r>;;
     
     <b><U>let</U><r> int_sup_sub something vsize scanner what sup sub display =
       </r><U>let</U></b> sup = to_string (<b><U>fun</U><r> () -&gt; put_sup_sub display scanner sup)
       </r><U>and</U></b> sub = to_string (<b><U>fun</U><r> () -&gt; put_sup_sub display scanner sub) </r><U>in</U><m>
 415   </m><U>if</U></b> something <b><U>then</U> <U>begin</U></b>
         force_item_display () ;
         what () ;
         force_item_display ()
       <b><U>end</U></b> ;
 </r>420   </m><U>if</U></b> sup &lt;&gt; "" || sub &lt;&gt; "" <b><U>then</U> <U>begin</U></b>
         open_vdisplay display ;
         open_vdisplay_row "ALIGN=left NOWRAP" ;
         put sup ;
         close_vdisplay_row () ;
 </r>425     <r>open_vdisplay_row "ALIGN=left" ;
         <b><U>for</U><r> i = 2 </r><U>to</U></b> vsize <b><U>do</U><r>
           skip_line ()
         </r><U>done</U></b> ;
         close_vdisplay_row () ;
 </r>430     <r>open_vdisplay_row "ALIGN=left NOWRAP" ;
         put sub ;
         close_vdisplay_row () ;
         close_vdisplay () ;
         force_item_display ()
 </r>435   <b><U>end</U></b></m>
     ;;
     
     
     <b><U>let</U><r> insert_vdisplay open_fun =
 </r><m>440   </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         prerr_flags "=&gt; insert_vdisplay" ;
       <b><U>end</U><r> ;
       </r><U>try</U>
         <U>let</U></b> mods = to_pending !cur_out.pending !cur_out.active <b><U>in</U><m>
 445     </m><U>let</U></b> bs,bargs,bout = pop_out out_stack <b><U>in</U>
         <U>if</U></b> bs &lt;&gt; INTERN <b><U>then</U><r>
           failclose "insert_vdisplay" bs INTERN ;
         </r><U>let</U></b> ps,pargs,pout = pop_out out_stack <b><U>in</U>
         <U>if</U></b> ps &lt;&gt; TD <b><U>then</U><m>
 450       <r>failclose "insert_vdisplay" ps TD ;
         <b><U>let</U><r> pps,ppargs,ppout = pop_out out_stack  </r><U>in</U>
         <U>if</U></b> pps &lt;&gt; DISPLAY <b><U>then</U><r>
           failclose "insert_vdisplay" pps DISPLAY ;
         </r><U>let</U></b> new_out = create_status_from_scratch <b><U>false</U><r> [] </r><U>in</U><m>
 455     <r>push_out out_stack (pps,ppargs,new_out) ;
         push_out out_stack (ps,pargs,pout) ;
         push_out out_stack (bs,bargs,bout) ;
         close_display () ;
         cur_out := ppout ;
 </r>460     <r>open_fun () ;
         do_put (Out.to_string new_out.out) ;
         flags.empty &lt;- <b><U>false</U><r> ; flags.blank &lt;- </r><U>false</U></b> ;
         free new_out ;
         <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U><m>
 465       <r>prerr_string "insert_vdisplay -&gt; " ;
           pretty_mods stderr mods ;
           prerr_newline ()
         <b><U>end</U><r> ;
         </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U><m>
 470       <r>prerr_flags "&lt;= insert_vdisplay" ;
         mods
       <b><U>with</U></b> PopFreeze -&gt;
         raise (UserError "\\over should be properly parenthesized")
     ;;
 </r>475 
     
     
     </m><U>let</U></b> over display lexbuf =
       <b><U>if</U><r> display </r><U>then</U> <U>begin</U><m>
 480     </m><U>let</U></b> mods = insert_vdisplay
             (<b><U>fun</U><r> () -&gt;
               open_vdisplay display ;
               open_vdisplay_row "NOWRAP ALIGN=center") </r><U>in</U></b>
         close_vdisplay_row () ;
 </r>485 <w>(*
         open_vdisplay_row "" ;
         close_mods () ;
         horizontal_line  "NOSHADE" Length.Default (Length.Pixel 2);
     *)
 </w>490     <r>open_vdisplay_row "BGCOLOR=black" ;
         close_mods () ;
         line_in_table 3 ;
         close_vdisplay_row () ;
         open_vdisplay_row "NOWRAP ALIGN=center" ;
 </r>495     <r>close_mods () ;
         open_mods mods ;
         freeze
           (<b><U>fun</U></b> () -&gt;
             close_vdisplay_row () ;
 </r>500         <r>close_vdisplay ();)
       <b><U>end</U> <U>else</U> <U>begin</U></b>
         put "/"
       <b><U>end</U></b>
     ;;
 </r>505 
     
     <w>(* Gestion of left and right delimiters *)
     
     <b><U>let</U><r> put_delim delim i =
 </r><m>510   </m><U>if</U><r> !verbose &gt; 1 <b><U>then</U><r>
         prerr_endline
          ("put_delim: ``"^delim^"'' ("^string_of_int i^")") ;
       </r><U>if</U></b> delim &lt;&gt; "." <b><U>then</U> <U>begin</U></b>
         begin_item_display (<b><U>fun</U><r> () -&gt; ()) </r><U>false</U></b> ;
 <m>515     <r>Symb.put_delim skip_line put delim i ;
         <b><U>let</U><r> _ = end_item_display () </r><U>in</U></b> ()
       <b><U>end</U></b>
     ;;
     
 </r>520 <b><U>let</U></b></m> left delim k =
       <b><U>let</U><r> _,f,is_freeze = end_item_display () </r><U>in</U></b>
       delay
         (<b><U>fun</U><r> vsize -&gt;
           put_delim delim vsize ;
 <m>525       </m>begin_item_display (</r><U>fun</U></b> () -&gt; ()) <b><U>false</U><r> ;
           k vsize ;
           </r><U>let</U></b> _ = end_item_display () <b><U>in</U><r>
           ()) ;
       begin_item_display f is_freeze
 <m>530 </m>;;
     
     </r><U>let</U></b> right delim =
       <b><U>let</U><r> vsize,f,is_freeze = end_item_display () </r><U>in</U></b>
       put_delim delim vsize;
 <m>535   </m>flush vsize ;
       begin_item_display f is_freeze ;
       vsize
     ;;<PL><B>
<6>87 html.ml</6>
</B></PL></r></b> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   </w>5 <w>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  </w>10 <w>(***********************************************************************)
     
     
     <b><U>let</U><r> header = "$Id: html.ml,v 1.84 2001/04/02 18:06:15 maranget Exp $"
     
  </r><m>15 <w>(* Output function for a strange html model :
          - Text elements can occur anywhere and are given as in latex
          - A new grouping construct is given (open_group () ; close_group ())
     *)
     
  </w>20 </m><U>open</U><r> Misc
     <b><U>open</U><r> Parse_opts
     </r><U>open</U></b> Latexmacros
     <b><U>open</U><r> HtmlCommon
     
  </r><m>25 </m><U>exception</U></b> Error <b><U>of</U><r> string
     ;;
     
     </r><U>type</U></b> block = HtmlCommon.block
     ;;
  <m>30 
     
     <b><U>let</U></b></m> r_quote = String.create 1
     ;;
     
  <m>35 <b><U>let</U></b></m> quote_char = <b><U>function</U><r>
     | '&lt;' -&gt; "&amp;lt;"
     | '&gt;' -&gt; "&amp;gt;"
     | '&amp;' -&gt; "&amp;amp;"
     | c   -&gt; (r_quote.[0] &lt;- c ; r_quote)
  <m>40 </m>;;
     
     </r><U>let</U></b> r_translate = String.create 1
     ;;
     
  <m>45 <b><U>let</U></b></m> iso_translate = <b><U>function</U><r>
     | '&lt;' -&gt; "&amp;lt;"
     | '&gt;' -&gt; "&amp;gt;"
     | '&amp;' -&gt; "&amp;amp;"
     | '' -&gt; "&amp;nbsp;"
  <m>50 </m>| '' -&gt; "&amp;iexcl;"
     | '' -&gt; "&amp;cent;"
     | '' -&gt; "&amp;pound;"
     | '' -&gt; "&amp;curren;"
     | '' -&gt; "&amp;yen;"
  <m>55 </m>| '' -&gt; "&amp;brvbar;"
     | '' -&gt; "&amp;sect;"
     | '' -&gt; "&amp;uml;"
     | '' -&gt; "&amp;copy;"
     | '' -&gt; "&amp;ordf;"
  <m>60 </m>| '' -&gt; "&amp;laquo;"
     | '' -&gt; "&amp;not;"
     | '' -&gt; "&amp;shy;"
     | '' -&gt; "&amp;reg;"
     | '' -&gt; "&amp;macr;"
  <m>65 </m>| '' -&gt; "&amp;deg;"
     | '' -&gt; "&amp;plusmn;"
     | '' -&gt; "&amp;sup2;"
     | '' -&gt; "&amp;sup3;"
     | '' -&gt; "&amp;acute;"
  <m>70 </m>| '' -&gt; "&amp;micro;"
     | '' -&gt; "&amp;para;"
     | '' -&gt; "&amp;middot;"
     | '' -&gt; "&amp;cedil;"
     | '' -&gt; "&amp;sup1;"
  <m>75 </m>| '' -&gt; "&amp;ordm;"
     | '' -&gt; "&amp;raquo;"
     | '' -&gt; "&amp;frac14;"
     | '' -&gt; "&amp;frac12;"
     | '' -&gt; "&amp;frac34;"
  <m>80 </m>| '' -&gt; "&amp;iquest;"
     | 'A' -&gt; "&amp;Agrave;"
     | '' -&gt; "&amp;Aacute;"
     | 'A' -&gt; "&amp;Acirc;"
     | '' -&gt; "&amp;Atilde;"
  <m>85 </m>| '' -&gt; "&amp;Auml;"
     | '' -&gt; "&amp;Aring;"
     | '' -&gt; "&amp;AElig;"
     | 'C' -&gt; "&amp;Ccedil;"
     | 'E' -&gt; "&amp;Egrave;"
  <m>90 </m>| 'E' -&gt; "&amp;Eacute;"
     | 'E' -&gt; "&amp;Ecirc;"
     | 'E' -&gt; "&amp;Euml;"
     | '' -&gt; "&amp;Igrave;"
     | '' -&gt; "&amp;Iacute;"
  <m>95 </m>| 'I' -&gt; "&amp;Icirc;"
     | 'I' -&gt; "&amp;Iuml;"
     | '' -&gt; "&amp;ETH;"
     | '' -&gt; "&amp;Ntilde;"
     | '' -&gt; "&amp;Ograve;"
 <m>100 </m>| '' -&gt; "&amp;Oacute;"
     | 'O' -&gt; "&amp;Ocirc;"
     | '' -&gt; "&amp;Otilde;"
     | '' -&gt; "&amp;Ouml;"
     | '' -&gt; "&amp;times;"
 <m>105 </m>| '' -&gt; "&amp;Oslash;"
     | '' -&gt; "&amp;Ugrave;"
     | '' -&gt; "&amp;Uacute;"
     | 'U' -&gt; "&amp;Ucirc;"
     | 'U' -&gt; "&amp;Uuml;"
 <m>110 </m>| '' -&gt; "&amp;Yacute;"
     | '' -&gt; "&amp;THORN;"
     | '' -&gt; "&amp;szlig;"
     | 'a' -&gt; "&amp;agrave;"
     | '' -&gt; "&amp;aacute;"
 <m>115 </m>| 'a' -&gt; "&amp;acirc;"
     | '' -&gt; "&amp;atilde;"
     | '' -&gt; "&amp;auml;"
     | '' -&gt; "&amp;aring;"
     | '' -&gt; "&amp;aelig;"
 <m>120 </m>| 'c' -&gt; "&amp;ccedil;"
     | 'e' -&gt; "&amp;egrave;"
     | 'e' -&gt; "&amp;eacute;"
     | 'e' -&gt; "&amp;ecirc;"
     | 'e' -&gt; "&amp;euml;"
 <m>125 </m>| '' -&gt; "&amp;igrave;"
     | '' -&gt; "&amp;iacute;"
     | 'i' -&gt; "&amp;icirc;"
     | 'i' -&gt; "&amp;iuml;"
     | '' -&gt; "&amp;eth;"
 <m>130 </m>| '' -&gt; "&amp;ntilde;"
     | '' -&gt; "&amp;ograve;"
     | '' -&gt; "&amp;oacute;"
     | 'o' -&gt; "&amp;ocirc;"
     | '' -&gt; "&amp;otilde;"
 <m>135 </m>| '' -&gt; "&amp;ouml;"
     | '' -&gt; "&amp;divide;"
     | '' -&gt; "&amp;oslash;"
     | '' -&gt; "&amp;ugrave;"
     | '' -&gt; "&amp;uacute;"
 <m>140 </m>| 'u' -&gt; "&amp;ucirc;"
     | 'u' -&gt; "&amp;uuml;"
     | '' -&gt; "&amp;yacute;"
     | '' -&gt; "&amp;thorn;"
     | '' -&gt; "&amp;yuml;"
 <m>145 </m>| c   -&gt; (r_translate.[0] &lt;- c ; r_translate)
     ;;
     
     
     </r><U>let</U></b> iso c =
 <m>150   <b><U>if</U></b></m> !Lexstate.raw_chars <b><U>then</U><r>
         (r_translate.[0] &lt;- c ; r_translate)
       </r><U>else</U> <U>if</U></b> !Parse_opts.iso <b><U>then</U><r>
         quote_char c
       </r><U>else</U><m>
 155     <r>iso_translate c
     ;;
     
     <b><U>let</U></b> iso_buff = Out.create_buff ()
     
 </r>160 </m><U>let</U></b> iso_string s =
       <b><U>if</U><r> not !Parse_opts.iso </r><U>then</U> <U>begin</U>
         <U>for</U></b> i = 0 <b><U>to</U><r> String.length s - 1 </r><U>do</U></b>
           Out.put iso_buff (iso_translate s.[i])
         <b><U>done</U><r> ;
 <m>165     </m>Out.to_string iso_buff
       </r><U>end</U> <U>else</U></b>
         s
     </r></b>(* Calls to other modules that are in the interface *)
     
 </w>170 </m><U>let</U></b>
       over,
       erase_display,
       begin_item_display,
       end_item_display,
 </r>175   <r>force_item_display,
       item_display,
       close_display,
       open_display,
       close_maths,
 </r>180   <r>open_maths,
       put_in_math,
       math_put,
       math_put_char,
       left,
 </r>185   <r>right
         =
       <b><U>if</U><r> !Parse_opts.mathml </r><U>then</U> <U>begin</U></b>
         MathML.over,
         MathML.erase_display,
 </r>190     <r>MathML.begin_item_display,
         MathML.end_item_display,
         MathML.force_item_display,
         MathML.item_display,
         MathML.close_display,
 </r>195     <r>MathML.open_display,
         MathML.close_maths,
         MathML.open_maths,
         MathML.put_in_math,
         MathML.put,
 </r>200     <r>MathML.put_char,
         MathML.left,
         MathML.right
       <b><U>end</U> <U>else</U> <U>begin</U></b>
         HtmlMath.over,
 </r>205     <r>HtmlMath.erase_display,
         HtmlMath.begin_item_display,
         HtmlMath.end_item_display,
         HtmlMath.force_item_display,
         HtmlMath.item_display,
 </r>210     <r>HtmlMath.close_display,
         HtmlMath.open_display,
         HtmlMath.close_maths,
         HtmlMath.open_maths,
         HtmlMath.put_in_math,
 </r>215     <r>HtmlMath.put,
         HtmlMath.put_char,
         HtmlMath.left,
         HtmlMath.right
       <b><U>end</U><m>
 220 <r>;;
     
     <b><U>let</U></b>
       int_sup_sub,
       limit_sup_sub,
 </r>225   <r>standard_sup_sub
         =
       <b><U>if</U><r> !Parse_opts.mathml </r><U>then</U></b>
         MathML.int_sup_sub,
         MathML.limit_sup_sub,
 </r>230     <r>MathML.standard_sup_sub
       <b><U>else</U></b>
         HtmlMath.int_sup_sub,
         HtmlMath.limit_sup_sub,
         HtmlMath.standard_sup_sub
 </r>235 <r>;;
     
     
     
     <b><U>let</U></b> set_out out =  !cur_out.out &lt;- out
 </r>240 </m><U>and</U></b> stop () =
       Stack.push stacks.s_active !cur_out.out ;
       Stack.push stacks.s_pending_par flags.pending_par ;
       !cur_out.out &lt;- Out.create_null () ;
       flags.pending_par &lt;- None
 </r>245 
     </m><U>and</U></b> restart () =
       !cur_out.out &lt;- Stack.pop stacks.s_active ;
       flags.pending_par &lt;- Stack.pop stacks.s_pending_par
     ;;
 </r>250 
     
     <w>(* acces to flags *)
     <b><U>let</U><r> is_empty () = flags.empty
     </r><U>and</U><r> get_last_closed () = flags.last_closed
 <m>255 <b><U>and</U></b></m> set_last_closed s = flags.last_closed &lt;- s
     ;;
     
     
     
 <m>260 <b><U>let</U></b></m> debug m =
       Printf.fprintf stderr "%s : table_vsize=%d vsize=%d" m flags.table_vsize flags.vsize ;
       prerr_newline ()
     ;;
     
 <m>265 <b><U>let</U></b></m> debug_empty f =
       prerr_string (<b><U>if</U><r> f.empty </r><U>then</U></b> "empty=true" <b><U>else</U><r> "empty=false")
     ;;
     
     
 </r><m>270 
     
     
     
     </m><U>let</U></b> put s =
 <m>275   <b><U>if</U></b></m> flags.in_math <b><U>then</U><r> math_put s
       </r><U>else</U></b> HtmlCommon.put s
     ;;
     
     <b><U>let</U><r> put_char c =
 </r><m>280   </m><U>if</U></b> flags.in_math <b><U>then</U><r> math_put_char c
       </r><U>else</U></b> HtmlCommon.put_char c
     ;;
     
     <b><U>let</U><r> set_dt s = flags.dt &lt;- s
 </r><m>285 </m><U>and</U></b> set_dcount s = flags.dcount &lt;- s
     ;;
     
     <b><U>let</U><r> item () =
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U><m>
 290     <r>prerr_string "item: stack=" ;
         pretty_stack out_stack
       <b><U>end</U><r> ;
       </r><U>let</U></b> mods = all_to_pending !cur_out <b><U>in</U></b>
       clearstyle () ;
 </r>295   <r>!cur_out.pending &lt;- mods ;
       <b><U>let</U><r> saved =
         </r><U>if</U></b> flags.nitems = 0 <b><U>then</U> <U>begin</U>
           <U>let</U></b> _ = forget_par () <b><U>in</U></b> () ;
           Out.to_string !cur_out.out
 </r>300     </m><U>end</U> <U>else</U></b>  "" <b><U>in</U><r>
       flags.nitems &lt;- flags.nitems+1;
       try_flush_par Now ;
       do_put "&lt;LI&gt;" ;
       do_put saved
 <m>305 </m>;;
     
     </r><U>let</U></b> nitem = item
     ;;
     
 <m>310 <b><U>let</U></b></m> ditem scan arg =
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
         prerr_string "ditem: stack=" ;
         pretty_stack out_stack
       <b><U>end</U><r> ;
 </r><m>315   </m><U>let</U></b> mods = all_to_pending !cur_out <b><U>in</U><r>
       clearstyle () ;
       !cur_out.pending &lt;- mods ;
       </r><U>let</U></b> true_scan =
         <b><U>if</U><r> flags.nitems = 0 </r><U>then</U> <U>begin</U><m>
 320       </m><U>let</U></b> _ = forget_par () <b><U>in</U><r> () ;
           </r><U>let</U></b> saved = Out.to_string !cur_out.out <b><U>in</U><r>
           (</r><U>fun</U></b> arg -&gt; do_put saved ; scan arg)
         <b><U>end</U> <U>else</U></b> scan <b><U>in</U><r>
       try_flush_par Now ;
 <m>325   </m>do_put "&lt;DT&gt;" ;
       !cur_out.pending &lt;- mods ;
       flags.nitems &lt;- flags.nitems+1;
       open_block INTERN "" ;
       </r><U>if</U></b> flags.dcount &lt;&gt; "" <b><U>then</U><r> scan ("\\refstepcounter{"^ flags.dcount^"}") ;
 </r><m>330   <r>true_scan ("\\makelabel{"^arg^"}") ;
       close_block INTERN ;
       do_put "&lt;DD&gt;"
     ;;
     
 </r>335 
     </m><U>let</U></b> loc_name _ = ()
     
     
     </r></b>(* freeze everyting and change output file *)
 </w>340 
     </m><U>let</U></b> open_chan chan =
       open_group "" ;
       free !cur_out ;
       !cur_out.out &lt;- Out.create_chan chan ;
 <m>345 <r>;;
     
     <b><U>let</U></b> close_chan () =
       Out.close !cur_out.out ;
       !cur_out.out &lt;- Out.create_buff () ;
 </r>350   <r>close_group ()
     ;;
     
     
     <b><U>let</U></b> to_style f =
 </r>355   <b><U>let</U></b></m> old_flags = copy_flags flags <b><U>in</U>
       <U>let</U></b> _ = forget_par () <b><U>in</U><r>
       open_block INTERN "" ;
       clearstyle () ;
       f () ;
 </r><m>360   </m><U>let</U></b> r = to_pending !cur_out.pending !cur_out.active <b><U>in</U><r>
       erase_block INTERN ;
       set_flags flags old_flags ;
       r
     ;;
 </r><m>365 
     </m><U>let</U></b> get_current_output () = Out.to_string !cur_out.out
     
     
     <b><U>let</U><r> finalize check =
 </r><m>370   </m><U>if</U></b> check <b><U>then</U> <U>begin</U></b>
         check_stacks ()
       <b><U>end</U> <U>else</U> <U>begin</U><w>
         (* Flush output in case of fatal error *)
         </w><U>let</U> <U>rec</U></b> close_rec () =
 <m>375       <b><U>if</U></b></m> not (Stack.empty out_stack) <b><U>then</U> <U>begin</U>
             <U>match</U></b> Stack.pop out_stack <b><U>with</U><r>
             | Freeze _ -&gt; close_rec ()
             | Normal (_,_,pout) -&gt;
                 Out.copy !cur_out.out pout.out ;
 <m>380             </m>cur_out := pout ;
                 close_rec ()
           </r><U>end</U> <U>in</U></b>
         close_rec ()
       <b><U>end</U><r> ;
 </r><m>385   <r>Out.close !cur_out.out ;
       !cur_out.out &lt;- Out.create_null ()
     ;;
     
     
 </r>390 </m><U>let</U></b> put_separator () =
       put "\n"
     ;;
     
     <b><U>let</U><r> unskip () =
 <m>395   </m>Out.unskip !cur_out.out;
       </r><U>if</U></b> flags.blank <b><U>then</U><r>
         flags.empty &lt;- </r><U>true</U></b>;
     ;;
     
 <m>400 <b><U>let</U></b></m> put_tag tag =
       put tag
     ;;
     
     <b><U>let</U><r> put_nbsp () =
 </r><m>405   </m><U>if</U></b> flags.in_math &amp;&amp; !Parse_opts.mathml <b><U>then</U><r>
         put " "
       </r><U>else</U></b>
         put "&amp;nbsp;"
     ;;
 <m>410 
     <b><U>let</U></b></m> put_open_group () =
       put_char '{'
     ;;
     
 <m>415 <b><U>let</U></b></m> put_close_group () =
       put_char '}'
     ;;
     
     
 <m>420 
     <b><U>let</U></b></m> open_table border htmlargs =
       <b><U>let</U><r> table,arg_b, arg =
         </r><U>if</U></b> flags.in_math &amp;&amp; !Parse_opts.mathml <b><U>then</U><r>
           "mtable","frame = \"solid\"",""
 </r><m>425     </m><U>else</U></b> "TABLE","BORDER=1",htmlargs
       <b><U>in</U>
       <U>if</U></b> border <b><U>then</U><r> open_block TABLE (arg_b^" "^arg)
       </r><U>else</U></b> open_block TABLE arg
     ;;
 <m>430 
     <b><U>let</U></b></m> new_row () =
       <b><U>if</U><r> flags.in_math &amp;&amp; !Parse_opts.mathml </r><U>then</U></b>
         open_block (OTHER "mtr") ""
       <b><U>else</U><r> open_block TR ""
 <m>435 </m>;;
     
     
     </r><U>let</U></b> attribut name = <b><U>function</U><r>
       | "" -&gt; ""
 <m>440   </m>| s  -&gt; " "^name^"="^s
     </r><U>and</U></b> as_colspan = <b><U>function</U><r>
       |  1  -&gt; ""
       |  n -&gt; " COLSPAN="^string_of_int n
     </r><U>and</U></b> as_colspan_mathml = <b><U>function</U><m>
 445   <r>|  1  -&gt; ""
       |  n -&gt; " columnspan= \""^string_of_int n^"\""
     
     <b><U>let</U><r> as_align f span = </r><U>match</U></b> f <b><U>with</U></b>
       Tabular.Align {Tabular.vert=v ; Tabular.hor=h ; Tabular.wrap=w ; Tabular.width=size} -&gt;
 </r>450     <r>attribut "VALIGN" v^
         attribut "ALIGN" h^
         (<b><U>if</U><r> w </r><U>then</U></b> "" <b><U>else</U></b> " NOWRAP")^
         as_colspan span
     | _       -&gt;  raise (Misc.Fatal ("as_align"))
 </r>455 <r>;;
     
     <b><U>let</U><r> as_align_mathml f span = </r><U>match</U></b> f <b><U>with</U></b>
       Tabular.Align {Tabular.vert=v ; Tabular.hor=h ; Tabular.wrap=w ; Tabular.width=size} -&gt;
         attribut "rowalign" ("\""^v^"\"")^
 </r>460     <r>attribut "columnalign" ("\""^h^"\"")^
         as_colspan_mathml span
     | _       -&gt;  raise (Misc.Fatal ("as_align_mathml"))
     ;;
     
 </r>465 </m><U>let</U></b> open_direct_cell attrs span =
       <b><U>if</U><r> flags.in_math &amp;&amp; !Parse_opts.mathml </r><U>then</U> <U>begin</U></b>
         open_block (OTHER "mtd") (attrs^as_colspan_mathml span);
         open_display ()
       <b><U>end</U> <U>else</U></b> open_block TD (attrs^as_colspan span)
 <m>470 
     <b><U>let</U></b></m> open_cell format span i=
       <b><U>if</U><r> flags.in_math &amp;&amp; !Parse_opts.mathml </r><U>then</U> <U>begin</U></b>
         open_block (OTHER "mtd") (as_align_mathml format span);
         open_display ()
 <m>475   <b><U>end</U> <U>else</U><r> open_block TD (as_align format span)
     ;;
     
     <b><U>let</U><r> erase_cell () =
       </r><U>if</U></b> flags.in_math &amp;&amp; !Parse_opts.mathml </r><U>then</U> <U>begin</U></b>
 480     </m>erase_display ();
         erase_block (OTHER "mtd")
       <b><U>end</U> <U>else</U></b> erase_block TD
     <b><U>and</U><r> close_cell content =
       </r><U>if</U></b> flags.in_math &amp;&amp; !Parse_opts.mathml <b><U>then</U> <U>begin</U><m>
 485     <r>close_display ();
         force_block (OTHER "mtd") ""
       <b><U>end</U> <U>else</U></b> force_block TD content
     <b><U>and</U><r> do_close_cell () =
         </r><U>if</U></b> flags.in_math &amp;&amp; !Parse_opts.mathml <b><U>then</U> <U>begin</U><m>
 490       <r>close_display ();
           close_block (OTHER "mtd")
         <b><U>end</U> <U>else</U></b> close_block TD
     <b><U>and</U><r> open_cell_group () = open_group ""
     </r><U>and</U></b> close_cell_group () = close_group ()
 </r>495 </m><U>and</U></b> erase_cell_group () = erase_block GROUP
     ;;
     
     
     <b><U>let</U></b> erase_row () =
 </r>500   </m><U>if</U></b> flags.in_math &amp;&amp; !Parse_opts.mathml <b><U>then</U><r>
         erase_block (OTHER "mtr")
       </r><U>else</U></b> erase_block TR
     <b><U>and</U><r> close_row () =
       </r><U>if</U></b> flags.in_math &amp;&amp; !Parse_opts.mathml <b><U>then</U><m>
 505     <r>close_block (OTHER "mtr")
       <b><U>else</U><r> close_block TR
     ;;
     
     </r><U>let</U></b> close_table () =
 </r>510   </m><U>if</U></b> flags.in_math &amp;&amp; !Parse_opts.mathml <b><U>then</U><r>
         close_block (OTHER "mtable")
       </r><U>else</U></b> close_block TABLE
     ;;
     <b><U>let</U><r> make_border s = ()
 <m>515 </m>;;
     
     
     </r><U>let</U></b> center_format =
       Tabular.Align  {Tabular.hor="center" ; Tabular.vert = "top" ;
 <m>520      </m>Tabular.wrap = <b><U>false</U><r> ; Tabular.pre = "" ;
          Tabular.post = "" ; Tabular.width = Length.Default}
     ;;
     
     </r><U>let</U></b> make_inside s multi =
 <m>525   <b><U>if</U><r> not (multi) </r><U>then</U> <U>begin</U>
         <U>if</U><r> pblock ()=TD || pblock() = (OTHER "mtd") <b><U>then</U> <U>begin</U></b>
           close_cell "&amp;nbsp;";
           open_cell center_format 1 0;
           put s;
 <m>530     <b><U>end</U> <U>else</U> <U>begin</U><r>
           open_cell center_format 1 0;
           put s;
           close_cell "&amp;nbsp;"
         <b><U>end</U><r>;
 <m>535   <b><U>end</U><r>
     ;;
     
     
     </r><U>let</U><r> make_hline w noborder =
 <m>540   <b><U>if</U><r> noborder </r><U>then</U> <U>begin</U><r>
         new_row ();
         <b><U>if</U><r> not (flags.in_math &amp;&amp; !Parse_opts.mathml) </r><U>then</U> <U>begin</U></b>
           open_direct_cell "BGCOLOR=black" w ;
           close_mods () ;
 <m>545       </m>line_in_table 3 ;
         <b><U>end</U> <U>else</U> <U>begin</U></b>
           open_cell center_format w 0;
           close_mods () ;
           put "&lt;mo stretchy=\"true\" &gt; &amp;horbar; &lt;/mo&gt;";
 <m>550       </m>force_item_display ();
         <b><U>end</U></b>;
         close_cell "" ;
         close_row ();
       </r><U>end</U></b>
 555 </m>;;
     
     <b><U>let</U><r> infomenu arg = ()
     </r><U>and</U></b> infonode opt num arg = ()
     <b><U>and</U><r> infoextranode num arg text = ()
 <m>560 </m>;;
     
     
     </r><U>let</U></b> image arg n =
       <b><U>if</U></b> flags.in_pre &amp;&amp; !Parse_opts.pedantic </r><U>then</U> <U>begin</U></b>
 565     </m>warning "Image tag inside preformatted block, ignored"
       </r><U>end</U> <U>else</U> <U>begin</U></b>
         put "&lt;IMG " ;
         <b><U>if</U><r> arg &lt;&gt; "" </r><U>then</U> <U>begin</U></b>
           put arg;
 <m>570       </m>put_char ' '
         <b><U>end</U><r> ;
         put "SRC=\"" ;
         put n ;
         </r><U>if</U></b> !Parse_opts.pedantic </r><U>then</U> <U>begin</U></b>
 575       </m>put "\" ALT=\"" ;
           put n
         <b><U>end</U></b> ;
         put "\"&gt;"
       </r><U>end</U></b>
 580 </m>;;
     
     <b><U>type</U></b> saved = HtmlCommon.saved
     
     <b><U>let</U><r> check = HtmlCommon.check
 </r><m>585 </m><U>and</U><r> hot = HtmlCommon.hot
     
     <b><U>let</U><r> skip_line = skip_line
     </r><U>and</U></b> flush_out = flush_out
     <b><U>and</U><r> close_group = close_group
 </r><m>590 </m><U>and</U></b> open_aftergroup = open_aftergroup
     <b><U>and</U><r> open_group = open_group
     </r><U>and</U></b> erase_block s = erase_block (find_block s)
     <b><U>and</U><r> insert_block s = insert_block (find_block s)
     </r><U>and</U></b> insert_attr s = insert_attr (find_block s)
 <m>595 <b><U>and</U></b></m> force_block s = force_block (find_block s)
     <b><U>and</U><r> close_block s = close_block (find_block s)
     </r><U>and</U></b> open_block s = open_block (find_block s)
     <b><U>and</U><r> forget_par = forget_par
     </r><U>and</U></b> par = par
 <m>600 <b><U>and</U></b></m> erase_mods = erase_mods
     </r><U>and</U><r> open_mod = open_mod
     </r><U>and</U><r> clearstyle = clearstyle
     <b><U>and</U><r> nostyle = nostyle
     </r><U>and</U></b> get_fontsize = get_fontsize
 <m>605 <b><U>and</U></b></m> horizontal_line = horizontal_line
     <b><U>and</U><r> to_string = to_string
     ;;<PL><B>
<6>88 htmlparse.ml</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: htmlparse.ml,v 1.5 2001/05/28 17:28:55 maranget Exp $         *)
     (***********************************************************************)
     </w><U>open</U></b> Lexeme
     <b><U>open</U><r> Htmllex
     </r><U>open</U></b> Tree
  <m>15 
     <b><U>exception</U></b></m> Error <b><U>of</U><r> string
     
     </r><U>let</U></b> error msg lb =
       raise (Error msg)
  <m>20 <r>;;
     
     <b><U>let</U><r> buff = ref None
     
     </r><U>let</U></b> next_token lexbuf = <b><U>match</U><r> !buff </r><U>with</U><m>
  25 <r>| Some tok -&gt; buff := None ; tok
     | None -&gt; Htmllex.next_token lexbuf
     
     <b><U>and</U><r> put_back lexbuf tok = </r><U>match</U></b> !buff <b><U>with</U></b>
     | None -&gt; buff := Some tok
  </r>30 <r>| _    -&gt; error "Put back" lexbuf
     
     <b><U>let</U><r> txt_buff = Buff.create ()
     
     </r><U>let</U> <U>rec</U></b> to_close tag lb = <b><U>match</U><r> next_token lb </r><U>with</U><m>
  35 <r>|  Close (t,txt) <b><U>when</U><r> t=tag -&gt;
         Buff.put txt_buff txt
     | Open (t,_,txt) </r><U>when</U></b> t=tag -&gt;
         Buff.put txt_buff txt ;
         to_close tag lb ;
  </r>40     <r>to_close tag lb
     | Eof -&gt; error ("Eof in to_close") lb
     | tok -&gt;
         Buff.put txt_buff (Htmllex.to_string tok);
         to_close tag lb
  </r>45 
     </m><U>let</U> <U>rec</U></b> tree lexbuf =
       <b><U>match</U><r> next_token lexbuf </r><U>with</U></b>
       | (Eof|Close (_,_)) <b><U>as</U></b> tok-&gt; put_back lexbuf tok ; None
       | Open (SCRIPT,_,txt) -&gt;
  </r>50       <r>Buff.put txt_buff txt ;
           to_close SCRIPT lexbuf ;
           Some (Text (Buff.to_string txt_buff))
       | Open (tag,attrs,txt) -&gt;
           <b><U>let</U><r> fils = trees lexbuf </r><U>in</U><m>
  55       </m><U>begin</U> <U>match</U></b> next_token lexbuf <b><U>with</U><r>
           | Close (ctag,ctxt) </r><U>when</U></b> tag=ctag -&gt;
               Some
                 (<b><U>match</U><r> tag </r><U>with</U></b>
                 | A -&gt;
  </r>60                 <r>ONode (txt,ctxt,fils)
                 | _ -&gt;
                   Node
                    ({tag=tag ; attrs=attrs ; txt=txt ; ctxt=ctxt},fils))
           | tok -&gt;
  </r>65           <r>error (Htmllex.to_string tok ^ " closes "^txt) lexbuf
           <b><U>end</U></b>
       | Lexeme.Text txt -&gt; Some (Text txt)
       | Lexeme.Blanks txt -&gt; Some (Blanks txt)
     
  </r>70 </m><U>and</U></b> trees lexbuf = <b><U>match</U><r> tree lexbuf </r><U>with</U></b>
     | None -&gt; []
     | Some t -&gt; t::trees lexbuf
     
     <b><U>let</U> <U>rec</U></b> do_main lexbuf = <b><U>match</U><r> tree lexbuf </r><U>with</U><m>
  75 <r>| None -&gt;
         <b><U>begin</U> <U>match</U></b> next_token lexbuf <b><U>with</U><r>
         | Eof -&gt;  []
         | tok  -&gt; error ("Unexpected " ^ to_string tok) lexbuf
         </r><U>end</U><m>
  80 <r>| Some (Text _ <b><U>as</U><r> last) -&gt; [last]
     | Some t -&gt; t :: do_main lexbuf
     
     </r><U>let</U></b> reset () =  Buff.reset txt_buff
     
  </r>85 </m><U>let</U></b> main lexbuf =
       <b><U>try</U><r>
         do_main lexbuf
       </r><U>with</U></b>
       | e -&gt; reset () ; raise e<PL><B>
<6>89 htmltext.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: htmltext.ml,v 1.9 2001/06/06 16:52:41 maranget Exp $          *)
     (***********************************************************************)
     </w><b><U>open</U><r> Emisc
     </r><U>open</U></b> Lexeme
     
  </r>15 </m><U>type</U></b> tsize = Int <b><U>of</U><r> int | Big | Small
     
     </r><U>type</U></b> nat =
       | Style <b><U>of</U><r> tag
       | Size </r><U>of</U></b> tsize
  </r>20   <r>| Color <b><U>of</U><r> string
       | Face </r><U>of</U></b> string
       | Other
     
     <b><U>type</U></b> t_style = {nat : nat ; txt : string ; ctxt : string}
  </r>25 <b><U>type</U></b></m> style = t_style list
     
     <b><U>let</U> <U>rec</U></b> do_cost seen_font r1 r2 = <b><U>function</U><r>
       | [] -&gt; r1,r2
       | {nat=(Size (Int _)|Color _|Face _)}::rem -&gt;
  <m>30       </m>do_cost </r><U>true</U></b> (<b><U>if</U><r> seen_font </r><U>then</U></b> r1 <b><U>else</U><r> 1+r1) (1+r2) rem
       | _::rem -&gt; do_cost seen_font (1+r1) r2 rem
     
     </r><U>let</U></b> cost ss = do_cost <b><U>false</U><r> 0 0 ss
     
  </r><m>35 </m><U>exception</U></b> No
     
     <b><U>let</U><r> add_size d = </r><U>match</U></b> !basefont + d <b><U>with</U><r>
     | 1|2|3|4|5|6|7 </r><U>as</U></b> x -&gt; x
     | _ -&gt; raise No
  <m>40 
     <b><U>let</U></b></m> size_val = <b><U>function</U><r>
       | "+1" -&gt; add_size 1
       | "+2" -&gt; add_size 2
       | "+3" -&gt; add_size 3
  <m>45   </m>| "+4" -&gt; add_size 4
       | "+5" -&gt; add_size 5
       | "+6" -&gt; add_size 6
       | "-1" -&gt; add_size (-1)
       | "-2" -&gt; add_size (-2)
  <m>50   </m>| "-3" -&gt; add_size (-3)
       | "-4" -&gt; add_size (-4)
       | "-5" -&gt; add_size (-5)
       | "-6" -&gt; add_size (-6)
       | "1" -&gt; 1
  <m>55   </m>| "2" -&gt; 2
       | "3" -&gt; 3
       | "4" -&gt; 4
       | "5" -&gt; 5
       | "6" -&gt; 6
  <m>60   </m>| "7" -&gt; 7
       | _   -&gt; raise No
     
     </r><U>let</U></b> color_val s = <b><U>match</U><r> String.lowercase s </r><U>with</U></b>
     | "#000000" -&gt; "black"
  <m>65 </m>| "#c0c0c0" -&gt; "silver"
     | "#808080" -&gt; "gray"
     | "#ffffff" -&gt; "white"
     | "#800000" -&gt; "maroon"
     | "#ff0000" -&gt; "red"
  <m>70 </m>| "#800080" -&gt; "purple"
     | "#ff00ff" -&gt; "fuschia"
     | "#008000" -&gt; "green"
     | "#00ff00" -&gt; "lime"
     | "#808000" -&gt; "olive"
  <m>75 </m>| "#000080" -&gt; "navy"
     | "#0000ff" -&gt; "blue"
     | "#008080" -&gt; "teal"
     | "#00ffff" -&gt; "aqua"
     | s -&gt; s
  <m>80 
     <b><U>let</U><r> same_style s1 s2 = </r><U>match</U><r> s1.nat, s2.nat <b><U>with</U><r>
     | Style t1, Style t2 -&gt; t1=t2
     | Other, Other -&gt; s1.txt = s2.txt
     | Size s1, Size s2 -&gt; s1=s2
  <m>85 </m>| Color c1, Color c2 -&gt; c1=c2
     | Face f1, Face f2 -&gt; f1=f2
     | _,_ -&gt; </r><U>false</U>
     
     <U>let</U></b> is_color = </r><U>function</U></b>
  90   </m>| Color _ -&gt; <b><U>true</U><r>
       | _ -&gt; </r><U>false</U>
     
     <U>and</U></b> is_size = <b><U>function</U></b>
       | Size _ -&gt; </r><U>true</U><m>
  95   <r>| _ -&gt; <b><U>false</U>
     
     <U>and</U></b> is_face = <b><U>function</U><r>
       | Face _ -&gt; </r><U>true</U></b>
       | _ -&gt; <b><U>false</U><m>
 100 
     </m><U>exception</U></b> NoProp
     
     <b><U>let</U><r> get_prop = </r><U>function</U></b>
       | Size _ -&gt; is_size
 </r>105   <r>| Face _ -&gt; is_face
       | Color _ -&gt; is_color
       | _       -&gt; raise NoProp
     
     <b><U>let</U></b> neutral_prop p = p (Color "")
 </r>110 
     </m><U>let</U><r> is_font = <b><U>function</U><r>
       | Size (Int _) | Face _ | Color _ -&gt; </r><U>true</U></b>
       | _ -&gt; <b><U>false</U><m>
     
 115 </m><U>let</U></b> font_props = [is_size ; is_face ; is_color]
     
     <b><U>exception</U><r> Same
     
     </r><U>let</U> <U>rec</U></b> rem_prop p = <b><U>function</U><m>
 120   <r>| s::rem -&gt;
           <b><U>if</U><r> p s.nat </r><U>then</U></b> rem
           <b><U>else</U>
             <U>let</U></b> rem = rem_prop p rem <b><U>in</U></b>
             s::rem
 </r>125   <r>| [] -&gt; raise Same
     
     <b><U>let</U> <U>rec</U></b> rem_style s = <b><U>function</U><r>
       | os::rem -&gt;
           </r><U>if</U></b> same_style s os <b><U>then</U></b> rem
 </r>130       </m><U>else</U>
             <U>let</U></b> rem = rem_style s rem <b><U>in</U></b>
             os::rem
       | [] -&gt; raise Same
     
 <m>135 <b><U>let</U><r> there s env =  List.exists (</r><U>fun</U><r> t -&gt; same_style s t) env
     
     <b><U>type</U><r> env = t_style list
     
     </r><U>exception</U></b> Split <b><U>of</U><r> t_style * env
 <m>140 
     <b><U>let</U><r> add s env =
       </r><U>let</U><r> new_env =
         <b><U>try</U>
           <U>let</U></b> p = get_prop s.nat </r><U>in</U></b>
 145       <b><U>try</U><r>
             s::rem_prop p env
           </r><U>with</U><r>
           |  Same -&gt;
               <b><U>match</U></b> s.nat </r><U>with</U></b>
 150           </m>| Size (Int x) </r><U>when</U></b> x = !basefont -&gt; env
               | _ -&gt; s::env
         <b><U>with</U></b>
         | NoProp -&gt;
             </r><U>try</U></b>
 155           <r>s::rem_style s env
             <b><U>with</U><r>
             | Same -&gt;
                 s::env </r><U>in</U>
       <U>match</U></b> s.nat <b><U>with</U><m>
 160   <r>| Other -&gt;
           <b><U>begin</U> <U>match</U></b> new_env <b><U>with</U><r>
           | _::env -&gt; raise (Split (s,env))
           | _ -&gt; </r><U>assert</U> <U>false</U>
           <U>end</U><m>
 165   <r>| _ -&gt; new_env
     
     
     
     
 </r>170 </m><U>let</U></b> add_fontattr txt ctxt a env =
       <b><U>let</U><r> nat = </r><U>match</U></b> a <b><U>with</U></b>
       | SIZE s  -&gt; Size (Int (size_val s))
       | COLOR s -&gt; Color (color_val s)
       | FACE s  -&gt; Face s
 </r>175   <r>| OTHER   -&gt; raise No <b><U>in</U><r>
       add {nat=nat ; txt=txt ; ctxt=ctxt} env
     
     </r><U>let</U></b>  add_fontattrs txt ctxt attrs env = <b><U>match</U><r> attrs </r><U>with</U></b>
     | []  -&gt; env
 </r>180 <r>| _   -&gt;
         <b><U>let</U> <U>rec</U></b> do_rec = <b><U>function</U></b>
           | [] -&gt; env
           | (a,atxt)::rem -&gt;
               add_fontattr
 </r>185             <r>atxt
                 ctxt
                 a
                 (do_rec rem) <b><U>in</U>
         <U>try</U></b> do_rec attrs <b><U>with</U><m>
 190     <r>| No -&gt; add {nat=Other ; txt=txt ; ctxt=ctxt} env
     
     
     <b><U>let</U></b> add_style
         {Lexeme.tag=tag ; Lexeme.attrs=attrs ; Lexeme.txt=txt ; Lexeme.ctxt=ctxt}
 </r>195     <r>env
         =
       <b><U>match</U><r> tag </r><U>with</U></b>
       | FONT -&gt; add_fontattrs txt ctxt attrs env
       | A    -&gt; <b><U>assert</U> <U>false</U><m>
 200   <r>| BIG -&gt;
           <b><U>if</U><r> attrs=[] </r><U>then</U></b>
             add {nat=Size Big ; txt=txt ; ctxt=ctxt} env
           <b><U>else</U></b>
             add {nat=Other ; txt=txt ; ctxt=ctxt} env
 </r>205   <r>| SMALL -&gt;
           <b><U>if</U><r> attrs=[] </r><U>then</U></b>
             add {nat=Size Small ; txt=txt ; ctxt=ctxt} env
           <b><U>else</U></b>
             add {nat=Other ; txt=txt ; ctxt=ctxt} env
 </r>210   <r>| _ -&gt;
           <b><U>if</U><r> attrs=[] </r><U>then</U></b>
             add {nat=Style tag ; txt=txt ; ctxt=ctxt} env
           <b><U>else</U></b>
             add {nat=Other ; txt=txt ; ctxt=ctxt} env
 </r>215 
     </m><U>let</U></b> blanksNeutral s = <b><U>match</U><r> s.nat </r><U>with</U></b>
     | Size _ | Style (U|TT|CODE|SUB|SUP) | Other -&gt; <b><U>false</U><r>
     | _ -&gt; </r><U>true</U></b><PL><B>
<6>90 image.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><b><U>let</U><r> header = "$Id: image.ml,v 1.26 2001/05/25 09:07:11 maranget Exp $"
     </r><U>open</U></b> Misc
     
  </r>15 </m><U>let</U></b> base = Parse_opts.base_out
     ;;
     
     <b><U>let</U></b> count = ref 0
     ;;
  </r>20 
     </m><U>let</U></b> buff = ref (Out.create_null ())
     ;;
     
     <b><U>let</U><r> active = ref </r><U>false</U><m>
  25 <r>;;
     
     <b><U>let</U><r> start () =
       active := </r><U>true</U></b> ;
       count := 0 ;
  </r>30   <r>buff := Out.create_buff ()
     ;;
     
     <b><U>let</U></b> active_stack = Stack.create "Image.active"
     
  </r>35 </m><U>let</U></b> stop () =
       Stack.push active_stack !active ;
       active := <b><U>false</U>
     
     <U>and</U></b> restart () =
  </r>40   </m></r><U>if</U><r> Stack.empty active_stack <b><U>then</U><r>
         active := </r><U>true</U>
       <U>else</U></b>
         active := Stack.pop active_stack
     
  <m>45 <r><b><U>let</U><r> put s = </r><U>if</U></b> !active <b><U>then</U><r> Out.put !buff s
     </r><U>and</U></b> put_char c = <b><U>if</U><r> !active </r><U>then</U></b> Out.put_char !buff c
     ;;
     
     <b><U>let</U></b> tmp_name =
  </r>50   <b><U>if</U><r> Parse_opts.filter </r><U>then</U><r> "" <b><U>else</U><r> base ^ ".image.tex.new"
     
     </r><U>let</U></b> open_chan () =
       <b><U>let</U><r> chan = open_out tmp_name </r><U>in</U></b>
       Out.to_chan chan !buff ;
  </r></b>55   <r>buff := Out.create_chan chan
     
     
     <b><U>and</U></b> close_chan () = Out.close !buff
     ;;
  </r>60 
     
     <b><U>let</U><r> my_string_of_int n = Printf.sprintf "%03d" n
     ;;
     
  </r></b>65 
     <b><U>let</U><r> page () =
       </r><U>let</U><r> n = !count <b><U>in</U>
       <U>if</U></b> !verbose &gt; 0 <b><U>then</U> <U>begin</U></b>
         Location.print_pos ();
  </r></b>70     <r>Printf.fprintf stderr "dump image number %d" (n+1) ;
         prerr_endline ""
       <b><U>end</U><r> ;
       </r><U>if</U></b> n = 0 <b><U>then</U></b> open_chan () ;
       incr count ;
  </r>75   <r>put ("\n\\clearpage% page: "^string_of_int n^"\n")
     ;;
     
     <b><U>let</U></b> dump s_open image  lexbuf =
       Out.put !buff s_open ;
  </r>80   <r>image lexbuf
     ;;
     
     <b><U>let</U><r> finalize check =
       active := </r><U>false</U></b> ;
  </r>85   <b><U>if</U><r> !count &gt; 0 </r><U>then</U> <U>begin</U><r>
         close_chan() ;
         <b><U>if</U><r> check </r><U>then</U> <U>begin</U>
           <U>let</U></b> true_name = Filename.chop_suffix tmp_name ".new" <b><U>in</U>
           <U>if</U></b> Myfiles.changed tmp_name true_name <b><U>then</U> <U>begin</U><m>
  90         <r>Mysys.rename tmp_name true_name ;
             Misc.message
               ("HeVeA Warning: images may have changed, run ``imagen "^base^"''");
             <b><U>true</U>
           <U>end</U> <U>else</U> <U>begin</U><m>
  95         <r>Mysys.remove tmp_name ;
             <b><U>false</U>
           <U>end</U>
         <U>end</U> <U>else</U>
           <U>false</U><m>
 100   </m><U>end</U> <U>else</U>
         <U>false</U></b><PL><B>
<6>91 index.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>let</U></b></w> header = "$Id: index.ml,v 1.40 2001/05/25 09:07:12 maranget Exp $"
     <b><U>open</U><r> Misc
     </r><U>open</U></b> Parse_opts
  </r>15 </m><U>open</U></b> Entry
     
     
     <b><U>let</U></b> missing_index tag =
       Misc.warning
  </r>20     <r>("Index structure not found, missing "^
         (<b><U>match</U><r> tag </r><U>with</U></b>
         | "default" -&gt; "\\makeindex"
         | _  -&gt; "\\newindex{"^tag^"}.."))
     ;;
  </r>25 
     
     </m><U>type</U></b> entry_t = {key : key ; see : string option ; item : string}
     ;;
     
  </r></b>30 <b><U>type</U><r> entry =
       | Good </r><U>of</U><r> entry_t
       | Bad
     
     <b><U>let</U><r> first_key = </r><U>function</U><m>
  35   <r>| (x::_),_ -&gt; x
       | _ -&gt; raise (Misc.Fatal ("Empty key in first_key"))
     
     <b><U>let</U><r> pretty_key (l,p) =
      </r><U>let</U> <U>rec</U></b> p_rec l p = <b><U>match</U><r> l,p </r><U>with</U><m>
  40    <r>[],[] -&gt; ""
      | [x],[""]-&gt; x
      | [x],[y]-&gt; x^"@"^y
      | x::xs,""::ys -&gt; x^"!"^p_rec xs ys
      | x::xs,y::ys -&gt; x^"@"^y^"!"^p_rec xs ys
  </r>45  <r>|  _,_ -&gt; <b><U>assert</U> <U>false</U> <U>in</U></b>
      p_rec l p
     ;;
     
     <b><U>let</U></b> pretty_entry (k,_) = pretty_key k
  </r>50 <r>;;
     
     <b><U>type</U><r> t_index =
       {</r><U>mutable</U></b> name : string ;
       <b><U>mutable</U></b> onebad : bool ;
  </r>55   <r>sufin : string ; sufout : string ;
       from_file : entry array option ;
       from_doc : entry Table.t ;
       out : Out.t}
     
  </r>60 </m><U>let</U></b> itable = Hashtbl.create 17
     ;;
     
     
     <b><U>let</U></b> read_index_file name file =
  </r>65   </m><U>let</U></b> lexbuf = Lexing.from_channel file <b><U>in</U>
       <U>let</U></b> r = Table.create Bad <b><U>in</U>
       <U>let</U> <U>rec</U></b> do_rec () =
         <b><U>try</U>
           <U>let</U></b> arg1,arg2 = read_indexentry lexbuf <b><U>in</U><m>
  70       </m><U>let</U></b> entry =
             <b><U>try</U>
               <U>let</U></b> k,see = read_key (Lexing.from_string arg1) <b><U>in</U><r>
               Good {key=k ; see=see ; item = arg2}
             </r><U>with</U></b> Entry.NoGood -&gt;
  </r></b>75           <r>Misc.warning
               ("Bad index arg syntax in file: "^name^
                ", index entry is ``"^arg1^"''") ;
               Bad <b><U>in</U></b>
           Table.emit r entry ;
  </r>80       <r>do_rec ()
         <b><U>with</U><r>
         | Entry.Fini -&gt; Table.trim r </r><U>in</U>
     
       <U>let</U></b> r = do_rec () <b><U>in</U><m>
  85   </m><U>if</U></b> !verbose &gt; 0 <b><U>then</U><r>
         prerr_endline ("Index file: "^name^" succesfully read");
       Some r
     
     </r><U>let</U></b> find_index tag = Hashtbl.find itable tag
  </r>90 
     <b><U>let</U><r> changename tag name =
       </r><U>try</U>
         <U>let</U><r> idx = find_index  tag <b><U>in</U></b>
         idx.name &lt;- name
  </r></b>95   </m></r><U>with</U><r> Not_found -&gt; missing_index tag
     
     <b><U>let</U><r> index_lbl tag i = "@"^tag^string_of_int i
     </r><U>let</U></b> index_filename suff = Parse_opts.base_out^".h"^suff
     
 <m>100 <b><U>let</U></b></m> treat tag arg refvalue =
     <w>(*  prerr_endline ("Index treat: "^tag^", "^arg^", "^refvalue) ; *)
       <b><U>try</U>
         <U>if</U></b></w> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("Index.treat with arg: "^arg) ;
         </r><U>let</U></b> {from_doc = from_doc ; out = out} <b><U>as</U><r> idx =  find_index tag </r><U>in</U><m>
 105     </m><U>let</U></b> lbl = index_lbl tag (Table.get_size from_doc) <b><U>in</U>
         <U>let</U></b> refvalue = <b><U>match</U><r> refvalue </r><U>with</U></b> "" -&gt; "??" | s -&gt; s <b><U>in</U>
         <U>let</U></b> item = "\\@locref{"^lbl^"}{"^refvalue^"}" <b><U>in</U><r>
         Out.put out "\\indexentry{" ;
         Out.put out arg ;
 <m>110     </m>Out.put out "}{" ;
         Out.put out item ;
         Out.put out "}\n" ;
     
         </r><U>let</U></b> lexbuf = Lexing.from_string arg <b><U>in</U><m>
 115     </m><U>let</U></b> entry =
           <b><U>try</U>
             <U>let</U></b> key,see = read_key lexbuf <b><U>in</U><r>
             Good {key = key ; see = see ; item = item}
           </r><U>with</U><m>
 120       <r>| Entry.NoGood -&gt;
               idx.onebad &lt;- <b><U>true</U><r> ;
               Misc.warning ("Bad index syntax: ``"^arg^"''") ;
               Bad </r><U>in</U></b>
         Table.emit from_doc entry ;
 </r>125     <r>lbl
       <b><U>with</U></b>
       | Not_found -&gt; missing_index tag ; ""
     ;;
     
 </r>130 
     <w>(* Compare function for keys *)
     
     
     <b><U>let</U><r> is_alpha c =  ('A' &lt;= c &amp;&amp; c &lt;= 'Z') || ('a' &lt;= c &amp;&amp; c &lt;= 'z')
 </r><m>135 
     </m><U>let</U><r> compare_char c1 c2 =
       <b><U>if</U><r> is_alpha c1 &amp;&amp; is_alpha c2 </r><U>then</U>
         <U>let</U></b> r = compare (Char.uppercase c1) (Char.uppercase c2) <b><U>in</U>
         <U>if</U><r> r &lt;&gt; 0 </r><U>then</U></b> r
 <m>140     <b><U>else</U></b></m> compare c1 c2
       <b><U>else</U> <U>if</U></b> is_alpha c1 <b><U>then</U><r> 1
       </r><U>else</U> <U>if</U></b> is_alpha c2 <b><U>then</U><r> -1
       </r><U>else</U></b> compare c1 c2
     
 <m>145 <b><U>exception</U></b></m> Result <b><U>of</U><r> int
     
     </r><U>let</U></b> compare_string s1 s2 =
       <b><U>let</U><r> i = ref 0
       </r><U>and</U></b> l1 = String.length s1
 <m>150   <b><U>and</U></b></m> l2 = String.length s2 <b><U>in</U>
       <U>begin</U> <U>try</U>
         <U>while</U> <U>true</U> <U>do</U>
           <U>begin</U> <U>if</U></b> !i &gt;= l1 <b><U>then</U>
             <U>if</U></b> !i &gt;= l2 <b><U>then</U><r> raise (Result 0)
 </r><m>155         </m><U>else</U></b> raise (Result (-1))
           <b><U>else</U> <U>if</U></b> !i &gt;= l2 <b><U>then</U><r> raise (Result 1)
           </r><U>else</U>
             <U>let</U></b> c = compare_char s1.[!i] s2.[!i] <b><U>in</U>
             <U>if</U></b> c &lt;&gt; 0 <b><U>then</U><r> raise (Result c)
 </r><m>160       </m><U>end</U></b> ;
           i := !i + 1
         <b><U>done</U><r> ;
         0
       </r><U>with</U><r> Result x -&gt; x
 <m>165   <b><U>end</U>
     
     <U>let</U><r> comp (l1,p1) (l2,p2) =
     
       <b><U>let</U> <U>rec</U></b> c_rec l1 l2 p1 p2 = <b><U>match</U></b> l1,l2 </r><U>with</U></b>
 170   </m>| [],[] -&gt; 0
       | [],_  -&gt; -1
       | _,[]  -&gt; 1
       | x1::r1,x2::r2 -&gt;
           <b><U>let</U><r> t = compare_string x1 x2 </r><U>in</U><m>
 175       </m><U>if</U></b> t&lt;&gt; 0 <b><U>then</U><r> t
           </r><U>else</U> <U>begin</U>
             <U>match</U></b> p1,p2 <b><U>with</U><r>
             | y1::p1, y2::p2 -&gt;
                 </r><U>let</U></b> t = compare_string y1 y2 <b><U>in</U><m>
 180             </m><U>if</U></b> t &lt;&gt; 0 <b><U>then</U><r> t
                 </r><U>else</U></b>
                   c_rec r1 r2 p1 p2
             | _,_ -&gt; <b><U>assert</U> <U>false</U>
           <U>end</U> <U>in</U><m>
 185   <r>c_rec l1 l2 p1 p2
     ;;
     
     <b><U>module</U><r> OrderedKey = </r><U>struct</U>
       <U>type</U></b> t = key
 </r>190   </m><U>let</U></b> compare = comp
     </r><U>end</U></b>
     ;;
     
     <b><U>module</U><r> KeySet =  Set.Make(OrderedKey)
 <m>195 </m>;;
     
     </r><U>open</U></b> KeySet
     
     
 <m>200 <b><U>let</U> <U>rec</U></b></m> common e1 e2 = <b><U>match</U><r> e1,e2 </r><U>with</U></b>
       ([],_),_        -&gt; e1,e2
     | _,([],_)        -&gt; e1,e2
     | ([_],_),([_],_) -&gt; e1,e2
     | (_::_,_),([_],_) -&gt; e1,e2
 <m>205 <r>| (x1::r1,_::p1),(x2::r2,_::p2) -&gt;
         <b><U>if</U><r> x1=x2 </r><U>then</U></b>
           common (r1,p1) (r2,p2)
         <b><U>else</U></b>
           e1,e2
 </r>210 <r>|  _ -&gt; <b><U>assert</U> <U>false</U></b>
     ;;
     
     <b><U>let</U> <U>rec</U></b> close_prev out = <b><U>function</U></b>
       [],_ | [_],_ -&gt; ()
 </r>215 <r>| _::r,_::p    -&gt;
         Out.put out "\\end{indexenv}\n" ;
         close_prev out (r,p)
     |  _ -&gt; <b><U>assert</U> <U>false</U></b>
     ;;
 </r>220 
     <b><U>let</U> <U>rec</U></b></m> open_this out k = <b><U>match</U><r> k </r><U>with</U></b>
       [],_ -&gt; ()
     | k::r,p::rp -&gt;
         Out.put out "\\indexitem " ;
 <m>225     <b><U>let</U></b></m> tag = <b><U>if</U><r> p &lt;&gt; "" </r><U>then</U></b> p <b><U>else</U><r> k </r><U>in</U></b>
         Out.put out tag  ;
         <b><U>begin</U> <U>match</U></b> r <b><U>with</U><r>
           [] -&gt; ()
         | _  -&gt; Out.put out "\\begin{indexenv}\n" ;
 </r><m>230     </m><U>end</U></b> ;
         open_this out (r,rp)
     |  _ -&gt; <b><U>assert</U> <U>false</U></b>
     ;;
     
 <m>235 <b><U>let</U></b></m> start_change s1 s2 = <b><U>match</U><r> s1,s2 </r><U>with</U></b>
     | "",_ -&gt; <b><U>false</U><r>
     | _,"" -&gt; </r><U>false</U></b>
     | _,_  -&gt; Char.uppercase s1.[0] &lt;&gt; Char.uppercase s2.[0]
     
 <m>240 <b><U>let</U></b></m> print_entry out tag entries bk k xs  =
       <b><U>let</U><r> rp,rt = common bk k </r><U>in</U></b>
       close_prev out rp ;
       <b><U>if</U><r> fst rp = [] </r><U>then</U></b>
         Out.put out "\\begin{indexenv}\n"
 <m>245   <b><U>else</U> <U>begin</U>
         <U>let</U></b></m> top_prev = first_key bk
         <b><U>and</U><r> top_now = first_key k </r><U>in</U>
         <U>if</U></b> start_change top_prev top_now <b><U>then</U><r>
           Out.put out "\\indexspace\n"
 <m>250   <b><U>end</U><r> ;
       open_this out rt ;
     
       </r><U>let</U> <U>rec</U><r> prints = <b><U>function</U><r>
         [] -&gt; Out.put_char out '\n'
 <m>255   </m>| i::r -&gt;
           Out.put out ", " ;
           </r><U>begin</U> <U>match</U></b> entries.(i) <b><U>with</U><r>
           | Good e -&gt;
               </r><U>begin</U> <U>match</U></b> e.see </r><U>with</U></b>
 260           </m>| None     -&gt;  Out.put out e.item
               | Some see -&gt;  Out.put out ("\\"^see^"{"^e.item^"}")
               </r><U>end</U></b> ;
           | Bad -&gt; ()
           <b><U>end</U><r> ;
 <m>265       </m>prints r </r><U>in</U></b>
     
        prints (List.rev xs)
     ;;
     
 <m>270 
     <b><U>let</U><r> make_index t =
       </r><U>let</U><r> table = Hashtbl.create 17
       <b><U>and</U><r> all = ref KeySet.empty </r><U>in</U>
       <U>for</U></b> i = 0 <b><U>to</U></b> Array.length t - 1 </r><U>do</U></b>
 275     <b><U>match</U><r> t.(i) </r><U>with</U><r>
         | Good e -&gt;
             all := KeySet.add e.key !all ;
             Hashtbl.add table e.key i
         | Bad -&gt; ()
 <m>280   <b><U>done</U><r> ;
       !all,table
     
     
     </r><U>let</U><r> output_index tag entries out =
 <m>285   <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U><r> prerr_endline ("Print index ``"^tag^"''") ;
       <b><U>let</U><r> all_keys,table = make_index entries </r><U>in</U>
       <U>let</U></b> prev = ref ([],[]) <b><U>in</U><r>
       KeySet.iter (</r><U>fun</U></b> k -&gt;
         <b><U>if</U></b> !verbose &gt; 2 </r><U>then</U></b>
 290       </m>prerr_endline ("Print_entry: "^pretty_key k);
         print_entry out tag entries !prev k (Hashtbl.find_all table k) ;
         prev := k)
         all_keys ;
       <b><U>let</U></b> pk,_ = !prev </r><U>in</U></b>
 295   </m>List.iter (<b><U>fun</U><r> _ -&gt; Out.put out "\\end{indexenv}\n") pk
     
     
     </r><U>let</U></b> create_hind t tag sufout =
       <b><U>let</U></b> outname = index_filename sufout </r><U>in</U></b>
 300   <b><U>try</U>
         <U>let</U><r> chan = open_out outname <b><U>in</U></b>
         output_index tag t (Out.create_chan chan) ;
         close_out chan
       </r><U>with</U></b>
 305   </m>| Sys_error s -&gt;
           Misc.warning ("File error for "^outname^": "^s)
     
     <b><U>let</U></b> newindex tag sufin sufout name =
     </r></b>(*  prerr_endline ("New index: "^tag) ; *)
 </w>310   <r>Hashtbl.remove itable tag ;
       <b><U>let</U><r> from_file =
         </r><U>try</U>
           <U>let</U></b> filename = index_filename sufin <b><U>in</U>
           <U>let</U></b> file = open_in filename <b><U>in</U><m>
 315       <r>read_index_file filename file
         <b><U>with</U><r> Sys_error _ -&gt; None </r><U>in</U>
       <U>begin</U> <U>match</U></b> from_file <b><U>with</U></b>
       | None -&gt; ()
       | Some t -&gt; create_hind t tag sufout
 </r>320   </m><U>end</U></b> ;
       Hashtbl.add itable tag
         {name = name ;
         onebad = <b><U>false</U></b> ;
         sufin = sufin ; sufout = sufout ;
 </r>325     <r>from_file = from_file ;
         from_doc = Table.create Bad ;
         out = Out.create_buff ()}
     
     <b><U>let</U></b> print main tag =
 </r>330   </m><U>try</U>
         <U>let</U></b> idx = find_index tag <b><U>in</U><r>
         main ("\\@indexsection{"^idx.name^"}") ;
         </r><U>let</U></b> indname = index_filename idx.sufout <b><U>in</U>
         <U>begin</U> <U>match</U></b> idx.from_file <b><U>with</U><m>
 335     <r>| None -&gt;
             create_hind  (Table.trim idx.from_doc) tag idx.sufout
         | _ -&gt; ()
         <b><U>end</U></b> ;
         main ("\\input{"^indname^"}")
 </r>340   </m><U>with</U></b>
       | Not_found -&gt; missing_index tag
     
     <b><U>let</U><r> diff_entries e1 e2 =
       </r><U>let</U></b> l1 = Array.length e1 <b><U>and</U><r> l2 = Array.length e2 </r><U>in</U><m>
 345   </m><U>if</U></b> l1 &lt;&gt; l2 <b><U>then</U> <U>true</U>
       <U>else</U>
         <U>let</U> <U>rec</U></b> diff_rec i =
           </r><U>if</U><r> i &gt;= l1 <b><U>then</U> <U>false</U>
           <U>else</U><m>
 350         <r>e1.(i) &lt;&gt; e2.(i) || diff_rec (i+1) <b><U>in</U><r>
         diff_rec 0
     
     </r><U>let</U></b> finalize check =
       <b><U>if</U><r> check </r><U>then</U> <U>begin</U><m>
 355     </m><U>let</U></b> top_changed = ref <b><U>false</U> <U>in</U></b>
         Hashtbl.iter
           (<b><U>fun</U><r> tag idx -&gt;
     </r><w>(*        prerr_endline ("Check index changed: "^tag) ; *)
             </w><U>let</U></b> entries = Table.trim idx.from_doc <b><U>in</U><m>
 360         </m><U>let</U></b> changed =
               <b><U>match</U><r> idx.from_file </r><U>with</U></b>
               | Some t -&gt; diff_entries t entries
               | None   -&gt; Array.length entries &lt;&gt; 0 <b><U>in</U>
             <U>if</U></b> changed || idx.onebad <b><U>then</U> <U>begin</U><m>
 365           <r>top_changed := !top_changed || changed ;
               <b><U>let</U><r> idxname = index_filename idx.sufin </r><U>in</U>
               <U>try</U>
                 <U>if</U></b> Array.length entries = 0 &amp;&amp; not idx.onebad <b><U>then</U></b>
                   Mysys.remove idxname
 </r>370             </m><U>else</U> <U>begin</U>
                   <U>let</U></b> chan = open_out idxname <b><U>in</U><r>
                   Out.to_chan chan idx.out ;
                   close_out chan
                 </r><U>end</U><m>
 375           </m><U>with</U></b>
               | Sys_error s -&gt;
                   Misc.warning
                     ("File error on "^idxname^": "^s)
             <b><U>end</U></b>)
 </r>380       <r>itable ;
         <b><U>if</U><r> !top_changed </r><U>then</U></b>
           Misc.message
             "HeVeA Warning: Index(es) may have changed. Rerun me to get them right." ;
         !top_changed
 </r>385   </m><U>end</U> <U>else</U> <U>false</U></b><PL><B>
<6>92 info.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     
     <b><U>let</U></b></w> header = "$Id: info.ml,v 1.29 2001/05/25 09:07:14 maranget Exp $"
     
  <m>15 <b><U>open</U></b></m> Misc
     <b><U>open</U><r> Text
     </r><U>open</U></b> InfoRef
     
     <b><U>exception</U><r> Error </r><U>of</U></b> string
  <m>20 <b><U>type</U></b></m> block = Text.block
     
     
     <b><U>let</U><r> iso =Text.iso;;
     </r><U>let</U></b> iso_string =Text.iso_string;;
  <m>25 <b><U>let</U></b></m> set_out=Text.set_out;;
     <b><U>let</U><r> stop = Text.stop;;
     </r><U>let</U></b> restart = Text.restart;;
     <b><U>let</U><r> get_last_closed=Text.get_last_closed;;
     </r><U>let</U></b> set_last_closed=Text.set_last_closed;;
  <m>30 <b><U>let</U></b></m> is_empty=Text.is_empty;;
     
     <b><U>let</U><r> get_fontsize=Text.get_fontsize;;
     </r><U>let</U></b> nostyle=Text.nostyle;;
     <b><U>let</U><r> clearstyle=Text.clearstyle;;
  </r><m>35 </m><U>let</U></b> open_mod=open_mod;;
     <b><U>let</U><r> erase_mods=Text.erase_mods;;
     </r><U>let</U></b> par=Text.par;;
     <b><U>let</U><r> forget_par =Text.forget_par;;
     
  </r><m>40 
     </m><U>let</U></b> open_block =Text.open_block;;
     <b><U>let</U><r> close_block =Text.close_block;;
     </r><U>let</U></b> force_block =Text.force_block;;
     <b><U>let</U><r> insert_block =Text.insert_block;;
  </r><m>45 </m><U>let</U></b> insert_attr =Text.insert_attr;;
     
     <b><U>let</U><r> open_maths = Text.open_maths
     </r><U>and</U></b> close_maths = Text.close_maths ;;
     <b><U>let</U><r> open_display =Text.open_display;;
  </r><m>50 </m><U>let</U></b> close_display =Text.close_display;;
     <b><U>let</U><r> item_display =Text.item_display;;
     </r><U>let</U></b> force_item_display =Text.force_item_display;;
     <b><U>let</U><r> erase_display =Text.erase_display
     </r><U>and</U></b> standard_sup_sub = Text.standard_sup_sub
  <m>55 <b><U>and</U></b></m> limit_sup_sub = Text.limit_sup_sub
     <b><U>and</U><r> int_sup_sub = Text.int_sup_sub
     </r><U>and</U></b> over = Text.over
     <b><U>and</U><r> left = Text.left
     </r><U>and</U></b> right = Text.right
  <m>60 <r>;;
     
     <b><U>let</U><r> set_dcount =Text.set_dcount;;
     </r><U>let</U></b> item = Text.item;;
     <b><U>let</U></b> nitem = Text.nitem;;
  </r>65 <b><U>let</U></b></m> ditem = Text.ditem;;
     <b><U>let</U><r> erase_block =Text.erase_block;;
     </r><U>let</U></b> open_group =Text.open_group;;
     <b><U>let</U><r> open_aftergroup =Text.open_aftergroup;;
     </r><U>let</U></b> close_group =Text.close_group;;
  <m>70 
     <b><U>let</U></b></m> put s = Text.put s
     ;;
     
     <b><U>let</U><r> put_char c = Text.put_char c;;
  </r><m>75 
     </m><U>let</U></b> flush_out =Text.flush_out;;
     <b><U>let</U><r> skip_line =Text.skip_line;;
     
     </r><w>(* Gestion des references *)
  <m>80 <b><U>let</U><r> loc_name=InfoRef.loc_name;;
     
     
     
     </r><U>let</U><r> open_chan=Text.open_chan;;
  </r></b>85 <b><U>let</U><r> close_chan=Text.close_chan;;
     </r><U>let</U><r> to_string=Text.to_string;;
     <b><U>let</U><r> to_style=Text.to_style;;
     </r><U>let</U></b> get_current_output =Text.get_current_output;;
     
  </r></b>90 </m>(* Finalisation du fichier info *)
     </w><U>let</U></b> finalize check =
       <b><U>if</U><r> check </r><U>then</U> <U>begin</U>
         <U>if</U></b> !verbose&gt;1 <b><U>then</U><r> prerr_endline "Beginning of second phase.";
         InfoRef.finalize_nodes ();
  <m>95     </m>Text.finalize check ;
         </r><U>let</U></b> name,buf =
           <b><U>if</U><r> Parse_opts.filter </r><U>then</U>
             <U>let</U></b> texte = get_current_output () <b><U>in</U><r>
             "",Lexing.from_string texte
 </r><m>100       </m><U>else</U><w>
           (* changer de nom de fichier (renommer ?) *)
             </w><U>let</U></b> f = Parse_opts.name_out^".tmp" </r><U>in</U><r>
             f,Lexing.from_channel  (open_in f)
         </r><U>in</U><m>
 105     <r>InfoRef.dump buf ;
         <b><U>if</U><r> not Parse_opts.filter &amp;&amp; !verbose &lt;= 0 </r><U>then</U></b> Mysys.remove name
       <b><U>end</U> <U>else</U></b>
         Text.finalize <b><U>false</U></b>
     ;;
 </r>110 
     </m><U>let</U><r> horizontal_line =Text.horizontal_line;;
     <b><U>let</U><r> put_separator =Text.put_separator;;
     </r><U>let</U></b> unskip = Text.unskip;;
     <b><U>let</U><r> put_tag =Text.put_tag;;
 </r><m>115 </m><U>let</U></b> put_nbsp =Text.put_nbsp;;
     <b><U>let</U><r> put_open_group =Text.put_open_group;;
     </r><U>let</U></b> put_close_group =Text.put_close_group;;
     <b><U>let</U><r> put_in_math =Text.put_in_math;;
     
 </r><m>120 
     </m><U>let</U></b> open_table =Text.open_table;;
     <b><U>let</U><r> new_row =Text.new_row;;
     </r><U>let</U></b> open_cell =Text.open_cell;;
     <b><U>let</U><r> erase_cell =Text.erase_cell;;
 </r><m>125 </m><U>let</U></b> close_cell =Text.close_cell;;
     <b><U>let</U><r> do_close_cell = Text.do_close_cell;;
     </r><U>let</U></b> open_cell_group = Text.open_cell_group;;
     <b><U>let</U><r> close_cell_group = Text.close_cell_group;;
     </r><U>let</U></b> erase_cell_group = Text.erase_cell_group;;
 <m>130 <b><U>let</U></b></m> close_row =Text.close_row;;
     <b><U>let</U><r> erase_row =Text.erase_row;;
     </r><U>let</U></b> close_table =Text.close_table;;
     <b><U>let</U><r> make_border = Text.make_border;;
     </r><U>let</U></b> make_inside = Text.make_inside;;
 <m>135 <b><U>let</U></b></m> make_hline = Text.make_hline;;
     
     <b><U>let</U><r> infonode = InfoRef.infonode;;
     </r><U>let</U></b> infoextranode = InfoRef.infoextranode;;
     <b><U>let</U><r> infomenu = InfoRef.infomenu;;
 </r><m>140 
     </m><U>let</U></b> image = Text.image;;
     
     <b><U>type</U><r> saved = Text.saved
     
 </r><m>145 </m><U>let</U></b> check = Text.check
     <b><U>and</U><r> hot = Text.hot<PL><B>
<6>93 infoRef.ml</6>
</B></PL> 
      12 "infoRef.mll"
     
     </r><U>let</U></b> header = "$Id: infoRef.mll,v 1.22 2001/05/25 09:07:15 maranget Exp $"
     ;;
   <m>5 
     
     <b><U>open</U></b></m> Lexing
     <b><U>open</U><r> Misc
     
  </r><m>10 </m><U>let</U></b> compat_mem tbl key =
       <b><U>try</U> <U>let</U></b> _ = Hashtbl.find tbl key <b><U>in</U> <U>true</U> <U>with</U></b> Not_found -&gt; <b><U>false</U><r>
     ;;
     
     
  </r><m>15 </m><U>exception</U></b> Error <b><U>of</U><r> string
     
     </r><U>type</U></b> node_t = {
         <b><U>mutable</U><r> name : string;
         </r><U>mutable</U></b> comment : string;
  <m>20     <b><U>mutable</U></b></m> previous : node_t option;
         <b><U>mutable</U><r> next : node_t option;
         </r><U>mutable</U></b> up : node_t option;
         <b><U>mutable</U><r> pos : int;
       }
  <m>25 </m>;;
     
     </r><U>type</U></b> menu_t = {
         <b><U>mutable</U><r> num : int;
         </r><U>mutable</U></b> nom : string;
  <m>30     <b><U>mutable</U></b></m> nod : node_t option;
         <b><U>mutable</U><r> nodes : node_t list;
       }
     ;;
     
  </r><m>35 
     </m><U>let</U></b> menu_list = ref [];;
     
     <b><U>let</U><r> nodes = Hashtbl.create 17;;
     </r><U>let</U></b> delayed  = ref [];;
  <m>40 <b><U>let</U></b></m> current_node = ref None;;
     
     <b><U>let</U><r> menu_num = ref 0
     ;;
     
  </r><m>45 </m><U>let</U></b> counter = ref 0
     <b><U>and</U><r> pos_file = ref 0
     ;;
     
     </r><U>let</U></b> abs_pos () = !counter + !pos_file
  <m>50 <r>;;
     
     
     <b><U>let</U></b> cur_file = ref (Parse_opts.name_out)
     ;;
  </r>55 
     <b><U>let</U></b></m> file_number = ref 1
     ;;
     
     <b><U>type</U><r> label_t = {
  </r><m>60     </m><U>mutable</U></b> lab_name : string;
         <b><U>mutable</U><r> noeud : node_t option;
       };;
     
     </r><U>let</U></b> labels_list = ref [];;
  <m>65 
     <b><U>let</U></b></m> files = ref [];;
     <b><U>let</U><r> top_node = ref </r><U>false</U></b>;;
     
     <b><U>let</U><r> hot_start () =
  <m>70   </m>menu_list :=  [];
       Hashtbl.clear nodes ;
       current_node := None ;
       menu_num := 0 ;
       counter := 0 ;
  <m>75   </m>pos_file := 0 ;
       cur_file := Parse_opts.name_out ;
       files := [] ;
       top_node := </r><U>false</U></b> ;
       file_number :=  1 ;
  <m>80   <r>labels_list := []
     ;;
     
     <b><U>let</U></b> infomenu arg =
       menu_num:=!menu_num+1;
  </r>85   <r>menu_list := {
         num = !menu_num;
         nom = arg;
         nod = !current_node;
         nodes = [];
  </r>90   <r>} ::!menu_list;
       Text.open_block "INFOLINE" "";
       Text.put ("\\@menu"^string_of_int !menu_num^"\n");
       Text.close_block "INFOLINE"
     ;;
  </r>95 
     <b><U>let</U> <U>rec</U></b></m> cherche_menu m = <b><U>function</U><r>
       | [] -&gt; raise (Error ("Menu ``"^m^"'' not found"))
       | menu::r -&gt;
           </r><U>if</U></b> menu.nom = m <b><U>then</U><r> menu
 </r><m>100       </m><U>else</U></b> cherche_menu m r
     ;;
     
     <b><U>let</U> <U>rec</U></b> cherche_menu_par_num n = <b><U>function</U><r>
       | [] -&gt; raise (Error ("Menu not found"))
 <m>105   </m>| menu::r -&gt;
           </r><U>if</U></b> menu.num = n <b><U>then</U><r> menu
           </r><U>else</U></b> cherche_menu_par_num n r
     ;;
     
 <m>110 <b><U>let</U></b></m> ajoute_node_dans_menu n m =
       <b><U>try</U>
       <U>let</U></b> menu = cherche_menu m !menu_list <b><U>in</U><r>
       menu.nodes &lt;- n :: menu.nodes;
       menu.nod
 </r><m>115   </m><U>with</U></b> _ -&gt; None
     ;;
     
     
     <b><U>let</U><r> verifie name =
 </r><m>120   </m><U>let</U></b> nom = String.copy name <b><U>in</U>
       <U>for</U></b> i = 0 <b><U>to</U><r> String.length name -1 </r><U>do</U>
         <U>match</U></b> nom.[i] </r><U>with</U></b>
         | '\t' -&gt; nom.[i] &lt;- ' '
         | ',' -&gt; nom.[i] &lt;- ' '
 <m>125     <r>| '.' -&gt; nom.[i] &lt;- '-'
         | '\n' -&gt; nom.[i] &lt;- ' '
         |  _ -&gt; ()
       <b><U>done</U></b>;
       nom
 </r>130 <r>;;
     
     
     
     
 </r>135 <w>(* References *)
     
     <b><U>let</U> <U>rec</U><r> cherche_label s = <b><U>function</U><r>
       | [] -&gt; raise Not_found
       | l::r -&gt; </r><U>if</U></b> l.lab_name=s <b><U>then</U><r> l.noeud </r><U>else</U></b> cherche_label s r
 <m>140 <r>;;
     
     <b><U>let</U> <U>rec</U></b> change_label s = <b><U>function</U></b>
       |  [] -&gt; Misc.warning ("Cannot change label: ``"^s^"''")
       | l::r -&gt;
 </r>145       <b><U>if</U></b></m> l.lab_name = s <b><U>then</U><r>
             l.noeud &lt;- !current_node
           </r><U>else</U></b>
             change_label s r
     
 <m>150 <b><U>let</U></b></m> loc_name s1 = </r></b>(* pose un label *)
       <b><U>let</U><r> _ =
         </r><U>try</U>
           <U>let</U><r> _ = cherche_label s1 !labels_list <b><U>in</U><r>
           Misc.warning ("Multiple use of label: "^s1)
 </r><m>155     </m><U>with</U></b> Not_found -&gt; ()
       <b><U>in</U>
     
       <U>let</U></b> l = {
         lab_name = s1;
 <m>160     </m>noeud = !current_node ;
       } <b><U>in</U><r>
     
       labels_list := l:: !labels_list;
       Text.open_block "INFO" "" ;
 <m>165   </m>Text.put "\\@name{" ;
       Text.put s1 ;
       Text.put "}" ;
       Text.close_block "INFO" ;
       </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U></b> prerr_endline ("InfoRef.loc_name, label="^s1);
 <m>170 </m>;;
     
     
     
     </r></b>(* Sortie du fichier final *)
 </w>175 
     <b><U>let</U></b></m> out_cur = ref (Out.create_null ())
     ;;
     
     <b><U>let</U><r> set_out chan =
 </r><m>180   </m><U>if</U></b> !verbose &gt;3 <b><U>then</U><r> prerr_endline "Set_out";
       out_cur := chan
     ;;
     
     </r><U>let</U></b> set_out_file s =
 <m>185   <b><U>if</U></b></m> !verbose &gt;3 <b><U>then</U><r> prerr_endline ("Set_out_file :"^s);
       cur_file := s
     ;;
     
     </r><U>let</U></b> put s =
 <m>190   <b><U>if</U></b></m> !verbose &gt;3 <b><U>then</U><r>
         prerr_endline ("put :"^s);
       counter:=!counter + String.length s;
       Out.put !out_cur s
     ;;
 </r><m>195 
     </m><U>let</U></b> put_char c =
       <b><U>if</U><r> !verbose &gt;3 </r><U>then</U></b>
         prerr_endline ("put_char :"^String.make 1 c);
       counter:=!counter +1;
 <m>200   </m>Out.put_char !out_cur c
     ;;
     
     <b><U>let</U></b> put_credits () =
       put "\n\n-------------------------------------\nThis file has been translated from LaTeX by HeVeA.\n\n";
 <m>205 
     </m><b><U>and</U><r> put_header () =
       put "This file has been translated from LaTeX by HeVeA.\n"
     ;;
     
 </r><m>210 </m><U>let</U></b> next_file () =
       Out.close !out_cur ;
       file_number := !file_number +1;
       cur_file := Parse_opts.name_out ^ "-" ^ string_of_int !file_number ;
       <b><U>if</U><r> !verbose &gt; 0 </r><U>then</U><m>
 215     <r>prerr_endline ("Change file to "^ !cur_file) ;
       set_out (Out.create_chan (open_out !cur_file)) ;
       files := (!cur_file,abs_pos ()) :: !files ;
       pos_file := abs_pos () ;
       put_header () ;
 </r>220   <r>counter := 0
     
     ;;
     
     
 </r>225 
     
     </m><U>let</U></b> noeud_name n = n.name
     ;;
     
 <m>230 
     <b><U>let</U><r> affiche_menu num =
       </r><U>let</U><r> menu = cherche_menu_par_num num !menu_list <b><U>in</U>
       <U>if</U></b> menu.nodes &lt;&gt; [] <b><U>then</U> <U>begin</U></b>
         put "* Menu:\n\n";
 </r></b>235     <r><b><U>let</U> <U>rec</U></b> affiche_items = <b><U>function</U></b>
           | [] -&gt; ()
           | n::reste -&gt;
        put ("* "^noeud_name n^"::\t"^n.comment^"\n");
        affiche_items reste;
 </r>240     <b><U>in</U><r>
         affiche_items (List.rev menu.nodes);
         </r><U>if</U><r> !verbose &gt;1 <b><U>then</U><r>
           prerr_endline ("Menu :"^menu.nom);
       </r><U>end</U><m>
 245 <r>;;
     
     
     <b><U>let</U><r>  do_affiche_tag_table s =
       put ("\n\nTag table:\n"^(</r><U>if</U></b> s&lt;&gt; "" <b><U>then</U><r> s^"\n" </r><U>else</U></b> "")) ;
 </r>250   <r>Hashtbl.iter
         (<b><U>fun</U></b> nom n -&gt;
           put ("Node: "^noeud_name n^""^string_of_int n.pos^"\n")) nodes;
       put "\nEnd tag table\n";
     ;;
 </r>255 
     
     </m><U>let</U></b> affiche_tag_table ()=
       <b><U>match</U><r> !files </r><U>with</U></b>
       | [_] -&gt;
 </r></b>260     <r>do_affiche_tag_table ""
       | _   -&gt;
         <b><U>let</U> <U>rec</U></b> do_indirect = <b><U>function</U></b>
           | [] -&gt; ()
           | (f,p)::reste -&gt;
 </r>265           <r>put (f^": "^string_of_int p^"\n");
        do_indirect reste
         <b><U>in</U></b>
         Out.close !out_cur ;
         set_out (Out.create_chan (open_out Parse_opts.name_out)) ;
 </r>270     <r>put_header () ;
         put "\nIndirect:\n";
         do_indirect (List.rev !files);
         do_affiche_tag_table "(Indirect)"
     ;;
 </r>275 
     
     <b><U>let</U><r> affiche_node nom =
       </r><U>if</U><r> !top_node <b><U>then</U> <U>begin</U></b>
         put_credits () ;
 </r></b>280     <r>top_node := <b><U>false</U>
       <U>end</U></b> ;
       <b><U>let</U><r> noeud =
         </r><U>try</U></b> Hashtbl.find nodes nom
         <b><U>with</U></b> Not_found -&gt;  raise (Error ("Node not found :"^nom))
 </r>285   </m><b><U>in</U>
       <U>if</U></b> not Parse_opts.filter &amp;&amp; !counter &gt; 50000 <b><U>then</U> <U>begin</U></b>
         next_file ()
       <b><U>end</U><r>;
       noeud.pos &lt;- abs_pos ();
 <m>290   </m>put "\n";
       put ("Node: "^noeud_name noeud);
       (</r><U>match</U></b> noeud.next <b><U>with</U><r>
       | None -&gt; ()
       | Some n -&gt; put (",\tNext: "^noeud_name n));
 <m>295   </m>(</r><U>match</U></b> noeud.previous <b><U>with</U><r>
       | None -&gt; ()
       | Some n -&gt; put (",\tPrev: "^noeud_name n));
       (</r><U>match</U></b> noeud.up <b><U>with</U><r>
       | None -&gt;
 </r><m>300       </m><U>if</U></b> noeud.name = "Top" <b><U>then</U> <U>begin</U></b>
             put ",\tUp: (dir)." ;
             top_node := <b><U>true</U>
           <U>end</U></b>
       | Some n -&gt; put (",\tUp: "^noeud_name n));
 <m>305   <r>put_char '\n';
       <b><U>if</U><r> !verbose &gt;1 </r><U>then</U></b>
         prerr_endline ("Node : "^noeud_name noeud);
     
     ;;
 </r>310 
     <b><U>let</U><r> affiche_ref key =
       </r><U>try</U>
         <U>let</U><r> l =  cherche_label key !labels_list <b><U>in</U>
         <U>match</U></b> l <b><U>with</U><m>
 315     <r>| None -&gt; ()
         | Some node -&gt; put ("*Note "^noeud_name node^"::")
       <b><U>with</U></b>
       | Not_found -&gt; () <w>(* A warning has already been given *)
     </w>;;
 </r>320 
     </m><U>let</U></b> footNote_label = ref ""
     ;;
     
     <b><U>let</U></b> lex_tables = {
 </r></b>325   <r>Lexing.lex_base =
        "\000\000\001\000\002\000\003\000\004\000\254\255\000\000\253\255\
    \000\000\000\000\000\000\000\000\000\000\255\255\005\000\006\000\
    \007\000\008\000\017\000\027\000\250\255\021\000\251\255\002\000\
    \001\000\002\000\002\000\002\000\004\000\000\000\005\000\005\000\
    \001\000\006\000\001\000\008\000\008\000\017\000\018\000\002\000\
    \252\255\010\000\004\000";
       Lexing.lex_backtrk =
        "\255\255\255\255\255\255\255\255\255\255\255\255\001\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\001\000\255\255\
    \001\000\255\255\000\000\000\000\255\255\005\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255";
       Lexing.lex_default =
 </r>330    <r>"\020\000\005\000\016\000\014\000\005\000\000\000\255\255\000\000\
    \255\255\255\255\255\255\255\255\255\255\000\000\015\000\015\000\
    \017\000\017\000\255\255\255\255\000\000\255\255\000\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\255\255\255\255";
       Lexing.lex_trans =
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\005\000\000\000\000\000\000\000\
    \000\000\013\000\013\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\000\000\000\000\000\000\000\000\000\000\
    \008\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\023\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\021\000\000\000\000\000\000\000\
    \006\000\010\000\000\000\035\000\033\000\012\000\041\000\027\000\
    \028\000\029\000\031\000\034\000\037\000\011\000\009\000\024\000\
    \025\000\036\000\030\000\032\000\026\000\038\000\005\000\039\000\
    \042\000\013\000\000\000\013\000\007\000\040\000\000\000\000\000\
    \005\000\000\000\013\000\013\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \022\000\255\255\255\255\255\255\007\000\255\255\255\255\255\255\
    \255\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000";
       Lexing.lex_check =
        "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\002\000\255\255\255\255\255\255\
    \255\255\016\000\017\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\001\000\255\255\255\255\255\255\255\255\255\255\
    \006\000\018\000\018\000\018\000\018\000\018\000\018\000\018\000\
    \018\000\018\000\018\000\019\000\019\000\019\000\019\000\019\000\
    \019\000\019\000\019\000\019\000\019\000\021\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\000\000\255\255\255\255\255\255\
    \004\000\009\000\255\255\025\000\032\000\011\000\024\000\026\000\
    \027\000\028\000\030\000\033\000\036\000\010\000\008\000\023\000\
    \023\000\025\000\029\000\031\000\023\000\035\000\037\000\038\000\
    \041\000\042\000\255\255\012\000\034\000\039\000\255\255\255\255\
    \003\000\255\255\014\000\015\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\001\000\002\000\003\000\004\000\014\000\015\000\016\000\
    \017\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255"
 </r>335 <r>}
     
     <b><U>let</U> <U>rec</U></b> main lexbuf = __ocaml_lex_main_rec lexbuf 0
     <b><U>and</U><r> __ocaml_lex_main_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><m>
 340     <r>0 -&gt; (
      339 "infoRef.mll"
     
       <b><U>let</U><r> num = numero lexbuf </r><U>in</U></b>
       affiche_menu num;
 </r>345   <r>main lexbuf)
       | 1 -&gt; (
      344 "infoRef.mll"
     
       <b><U>let</U><r> nom = finitLigne lexbuf </r><U>in</U><m>
 350   <r>affiche_node nom;
       main lexbuf)
       | 2 -&gt; (
      349 "infoRef.mll"
     
 </r>355   </m><U>let</U></b> key = arg lexbuf <b><U>in</U></b>
       affiche_ref key;
       main lexbuf)
       | 3 -&gt; (
      354 "infoRef.mll"
 </r>360    </m><U>let</U></b> _ = arg lexbuf <b><U>in</U></b>
       main lexbuf)
       | 4 -&gt; (
      357 "infoRef.mll"
          affiche_tag_table ())
 </r>365   <r>| 5 -&gt; (
      360 "infoRef.mll"
          <b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U></b>
         put_char lxm;
         main lexbuf)
 </r>370   <r>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_main_rec lexbuf n
     
     <b><U>and</U><r> numero lexbuf = __ocaml_lex_numero_rec lexbuf 1
     </r><U>and</U></b> __ocaml_lex_numero_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><m>
 375     <r>0 -&gt; (
      366 "infoRef.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
         int_of_string lxm)
       | 1 -&gt; (
 </r>380  <r>368 "infoRef.mll"
          raise (Error "Syntax error in info temp file"))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_numero_rec lexbuf n
     
     <b><U>and</U></b> finitLigne lexbuf = __ocaml_lex_finitLigne_rec lexbuf 2
 </r>385 </m><U>and</U></b> __ocaml_lex_finitLigne_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
      372 "infoRef.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U><m>
 390     <r>String.sub lxm 0 ((String.length lxm) -1))
       | 1 -&gt; (
      374 "infoRef.mll"
          raise ( Error "Syntax error in info temp file: no node name."))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_finitLigne_rec lexbuf n
 </r>395 
     </m><U>and</U></b> arg lexbuf = __ocaml_lex_arg_rec lexbuf 3
     <b><U>and</U><r> __ocaml_lex_arg_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
 </r>400  <r>378 "infoRef.mll"
          <b><U>let</U><r> lxm= lexeme lexbuf </r><U>in</U></b>
         String.sub lxm 0 ((String.length lxm) -1))
       | 1 -&gt; (
      380 "infoRef.mll"
 </r>405      <r>raise (Error "Syntax error in info temporary file: invalid reference."))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_arg_rec lexbuf n
     
     <b><U>and</U><r> labels lexbuf = __ocaml_lex_labels_rec lexbuf 4
     </r><U>and</U></b> __ocaml_lex_labels_rec lexbuf state =
 </r>410   <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><r>
         0 -&gt; (
      384 "infoRef.mll"
          <b><U>let</U><r> key = arg lexbuf </r><U>in</U></b>
         key::labels lexbuf)
 </r></b>415   <r>| 1 -&gt; (
      386 "infoRef.mll"
          labels lexbuf)
       | 2 -&gt; (
      387 "infoRef.mll"
 </r>420        <r>[])
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_labels_rec lexbuf n
     
     ;;
     
 </r>425  <r>390 "infoRef.mll"
     
     <b><U>let</U><r> do_infonode opt num arg =
     
       </r><U>let</U></b> n = {
 </r>430     <r>name = verifie num;
         comment = arg;
         previous = None;
         next = None;
         up = None;
 </r>435     <r>pos = 0;
       } <b><U>in</U>
       <U>if</U></b> compat_mem nodes n.name <b><U>then</U><r>
         raise (Error ("Duplicate node name: "^n.name));
       n.up &lt;- (</r><U>match</U></b> opt <b><U>with</U><m>
 440     <r>"" -&gt; None
       | m -&gt;  ajoute_node_dans_menu n m);
       Hashtbl.add nodes n.name n;
       Text.open_block "INFOLINE" "";
       Text.put ("\\@node"^n.name^"\n");
 </r>445   <r>Text.close_block "INFOLINE";
       current_node := Some n;
       <b><U>if</U><r> !verbose&gt;1 </r><U>then</U></b> prerr_endline ("Node added :"^n.name^", "^n.comment)
     
     <b><U>let</U></b> infoextranode num nom text =
 </r>450   <r>delayed := (num,nom,text) :: !delayed
     
     <b><U>and</U><r> flushextranodes () =
       </r><U>let</U> <U>rec</U></b> flush_rec = <b><U>function</U></b>
         | [] -&gt; ()
 </r>455     <r>| (num,nom,text) :: rest -&gt;
             do_infonode "" num nom ;
             Text.open_block "INFO" "" ;
             Text.put text ;
             Text.close_block "INFO" ;
 </r>460         </m><U>let</U></b> labs = labels (Lexing.from_string text) <b><U>in</U><r>
             List.iter (</r><U>fun</U></b> lab -&gt; change_label lab !labels_list) labs ;
             flush_rec rest <b><U>in</U></b>
       flush_rec !delayed ;
       delayed := []
 </r>465 <r>;;
     
     <b><U>let</U></b> infonode opt num arg =
       flushextranodes () ;
       do_infonode opt num arg
 </r>470 
     
     <w>(* finalisation des liens entre les noeuds *)
     </w></m><b><U>let</U> <U>rec</U></b> do_finalize_nodes suivant = <b><U>function</U><r>
       | [] -&gt; ()
 <m>475   </m>| n::reste -&gt;
           </r><U>if</U></b> !verbose&gt;2 <b><U>then</U><r> prerr_endline ("node :"^n.name);
           n.next &lt;- suivant;
           (</r><U>match</U></b>  suivant <b><U>with</U><r>
           | None -&gt; ()
 <m>480       </m>| Some suiv -&gt; suiv.previous &lt;- Some n );
           do_finalize_nodes (Some n) reste
     ;;
     
     </r><U>let</U> <U>rec</U></b> do_finalize_menus = <b><U>function</U><m>
 485   <r>| [] -&gt; ()
       | m::reste -&gt;
           <b><U>if</U><r> m.nodes &lt;&gt; [] </r><U>then</U> <U>begin</U></b>
      do_finalize_nodes
        (<b><U>match</U><r> m.nod </r><U>with</U><m>
 490      <r>None -&gt; None
        | Some n -&gt; n.next)
        m.nodes;
      (<b><U>match</U><r> m.nod </r><U>with</U></b>
        None -&gt; ()
 </r>495  <r>|  Some n -&gt;
          <b><U>let</U><r> first_node = List.hd (List.rev m.nodes) </r><U>in</U></b>
          n.next &lt;- Some first_node;
          first_node.previous &lt;- Some n;
        <w>(* On descend dans l'arborescence des menus *)
 <m>500      <b><U>let</U><r> last_node = List.hd m.nodes </r><U>in</U><r>
          (<b><U>match</U><r> last_node.next </r><U>with</U></b>
          | None -&gt; ()
          | Some suiv -&gt; suiv.previous &lt;- Some n);
               <w>(* On remonte les menus au meme niveau *)
 <m>505    <r>);
      do_finalize_menus reste;
           <b><U>end</U></b>
     ;;
     
 </r>510 <b><U>let</U><r> finalize_nodes () =
       </r><U>if</U><r> !verbose&gt;2 <b><U>then</U><r> prerr_endline "finalizing nodes";
       flushextranodes () ;
       do_finalize_menus (List.rev !menu_list);
       </r><U>if</U></b> !verbose&gt;2 <b><U>then</U></b> prerr_endline "finalizing done.";
 </r></b>515 <r>;;
     
     <b><U>let</U><r> dump buff =
       </r><U>let</U></b> name,out_chan = <b><U>match</U><r> Parse_opts.name_out </r><U>with</U></b>
       | "" -&gt; "", Out.create_chan stdout
 </r>520   <r>| s  -&gt;
           <b><U>let</U><r> name = s^"-1" </r><U>in</U></b>
           name, Out.create_chan (open_out name) <b><U>in</U>
       <U>if</U></b> !verbose &gt; 0 <b><U>then</U></b>
         prerr_endline ("Final dump in "^name) ;
 </r>525   <r>set_out out_chan ;
       set_out_file name ;
       put_header () ;
       files := [name,abs_pos ()] ;
       main buff ;
 </r>530   <r>Out.close !out_cur ;
       <b><U>if</U><r> !file_number = 1 </r><U>then</U></b>
         Mysys.rename !cur_file Parse_opts.name_out<PL><B>
<6>94 latexmacros.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><b><U>let</U><r> header = "$Id: latexmacros.ml,v 1.64 2000/06/02 15:23:26 maranget Exp $"
     </r><U>open</U></b> Misc
     <b><U>open</U></b> Parse_opts
  </r>15 <b><U>open</U><r> Symb
     </r><U>open</U><r> Lexstate
     
     <b><U>exception</U></b> Failed
     
  </r></b>20 <b><U>module</U><r> OString = </r><U>struct</U>
       <U>type</U><r> t = string
       <b><U>let</U><r> compare = Pervasives.compare
     </r><U>end</U><m>
     
  25 </m><U>module</U></b> Strings = Set.Make (OString)
     
     <w>(* Data structures for TeX macro  model *)
     <b><U>let</U></b></w> local_table = Hashtbl.create 97
     <b><U>and</U></b> global_table = Hashtbl.create 97
  </r></b>30 <b><U>and</U><r> prim_table = Hashtbl.create 5
     
     </r><U>let</U><r> purge = ref Strings.empty
     <b><U>and</U><r> purge_stack = Stack.create "purge"
     </r><U>and</U></b> group_level = ref 0
  </r></b>35 
     </m>(* Hot start *)
     <b><U>type</U></b></w> ctable = (string, pat * action) Hashtbl.t
     <b><U>type</U><r> ptable = (string, (unit -&gt; unit)) Hashtbl.t
     </r><U>type</U></b> saved =
  </r></b>40     <r>int * Strings.t * Strings.t Stack.saved *
         ptable * ctable * ctable
     
     
     <b><U>let</U></b> pretty_macro n acs =
  </r>45   <r>pretty_pat n ;
       prerr_string " -&gt; " ;
       pretty_action acs
     
     <b><U>let</U></b> hidden_pretty_table cmdtable =
  </r>50   <b><U>let</U><r> t = Hashtbl.create 97
       </r><U>and</U><r> count = ref 0 <b><U>in</U>
       <U>let</U></b> incr k =
         incr count ;
         <b><U>let</U></b> r =
  </r></b>55       <b><U>try</U><r> Hashtbl.find t k </r><U>with</U><r>
           | Not_found -&gt;
               <b><U>let</U><r> r = ref 0 </r><U>in</U></b>
               Hashtbl.add t k r ;
               r <b><U>in</U><m>
  60     <r>incr r <b><U>in</U><r>
       Hashtbl.iter (</r><U>fun</U></b> k (n,acc) -&gt;
         Printf.fprintf stderr "%s -&gt; " k ;
         pretty_macro n acc ;
         prerr_endline "" ;
  </r>65     <r>incr k) cmdtable ;
       Printf.fprintf stderr
           "Table size: %d\n" !count ;
       Hashtbl.iter
         (<b><U>fun</U></b> k r -&gt;
  </r>70       </m><U>if</U></b> !r &gt; 1 <b><U>then</U></b>
             Printf.fprintf stderr "%s: %d\n" k !r)
         t ;
       flush stderr
     
  </r></b>75 <b><U>let</U><r> pretty_table () =
       Printf.fprintf stderr "Macro tables, level=%d\n" !group_level ;
       prerr_endline "Global table" ;
       hidden_pretty_table global_table ;
       prerr_endline "Local table" ;
  </r></b>80   <r>hidden_pretty_table local_table
     
     <b><U>let</U></b> checkpoint () =
       !group_level, !purge, Stack.save purge_stack,
       clone_hashtbl prim_table,
  </r>85   <r>clone_hashtbl global_table, clone_hashtbl local_table
     
     <b><U>and</U></b> hot_start (level_checked, purge_checked, purge_stack_checked,
                    prim_checked,
                    global_checked, local_checked) =
  </r>90   <r>group_level := level_checked ;
       purge := purge_checked ;
       Stack.restore purge_stack purge_stack_checked ;
       Misc.copy_hashtbl prim_checked prim_table ;
       Misc.copy_hashtbl global_checked global_table ;
  </r>95   <r>Misc.copy_hashtbl local_checked local_table
     
     <w>(* Controlling scope *)
     <b><U>let</U><r> open_group () =
       incr group_level ;
 <m>100   </m>Stack.push purge_stack !purge ;
       purge := Strings.empty
     
     </r><U>and</U><r> close_group () =
       <b><U>if</U></b> !group_level &gt; 0 </r><U>then</U></b> (* Undo bindings created at the closed level *)
 <m>105     <r>Strings.iter
           (<b><U>fun</U></b> name -&gt; Hashtbl.remove local_table name)
           !purge ;
       decr group_level ;
       purge := Stack.pop purge_stack
 </r>110 
     <b><U>let</U><r> get_level () = !group_level
     
     </r><w>(* Remove one local definition in advance ... *)
     </w><U>let</U><r> pre_purge name purge =
 </r></b>115   <b><U>if</U><r> Strings.mem name purge </r><U>then</U> <U>begin</U><r>
         Hashtbl.remove local_table name ;
         Strings.remove name purge
       <b><U>end</U> <U>else</U></b>
         purge
 </r></b>120 
     </m>(* Definitions *)
     <b><U>let</U><r> hidden_global_def name x =
       </r><U>if</U><r> !group_level &gt; 0 &amp;&amp; Hashtbl.mem local_table name </r><U>then</U> <U>begin</U></b>
         (*
 <m>125       </m>global definition of a localy defined macro,
           undo all local bindings
         *)
         </w>purge := pre_purge name !purge ;
         Stack.map purge_stack (<b><U>fun</U></b> purge -&gt; pre_purge name purge)
 </r>130   <b><U>end</U><r> ;
       Hashtbl.remove global_table name ;
       Hashtbl.add global_table name x
     
     </r><U>let</U><r> hidden_local_def name x =
 </r></b>135   <b><U>if</U><r> !group_level &gt; 0 </r><U>then</U> <U>begin</U><w> (* indeed local *)
         </w><U>if</U><r> Strings.mem name !purge <b><U>then</U><w> (* redefinition *)
           <r>Hashtbl.remove local_table name
         <b><U>else</U><w> (* creation (at the current level) *)
           <r>purge := Strings.add name !purge ;
 <m>140     </m>Hashtbl.add local_table name x
       <b><U>end</U> <U>else</U> <U>begin</U><w> (* same as global *)
         <r>Hashtbl.remove global_table name ;
         Hashtbl.add global_table name x
       <b><U>end</U><m>
 145 
     </m><U>let</U></b> hidden_find name =
       <b><U>if</U><r> !group_level &gt; 0 </r><U>then</U> <U>begin</U>
         <U>try</U></b> Hashtbl.find local_table name <b><U>with</U><r>
         | Not_found -&gt; Hashtbl.find global_table name
 </r><m>150   </m><U>end</U> <U>else</U></b>
         Hashtbl.find global_table name
     
     </r>(* Primitives *)
     </w><U>let</U></b> register_init name f =
 <m>155   <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U><r>
         prerr_endline ("Registering primitives for package: "^name);
       <b><U>try</U>
         <U>let</U></b> _ = Hashtbl.find prim_table name <b><U>in</U></b>
         fatal
 </r></b>160       <r>("Attempt to initlialize primitives for package "^name^" twice")
       <b><U>with</U><r>
       | Not_found -&gt;  Hashtbl.add prim_table name f
     
     </r><U>and</U></b> exec_init name =
 </r>165    <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U><r>
          prerr_endline ("Initializing primitives for package: "^name) ;
       <b><U>try</U>
         <U>let</U></b> f = Hashtbl.find prim_table name <b><U>in</U>
         <U>try</U></b> f () </r><U>with</U></b>
 170       <r>Failed -&gt;
             Misc.warning
              ("Bad trip while initializing primitives for package: "^name)
       <b><U>with</U></b> Not_found -&gt; ()
     ;;
 </r>175 
     
     </m></r>(* Interface *)
     
     </w><U>let</U></b> exists name =
 <m>180   <b><U>try</U>
         <U>let</U></b></m> _ = hidden_find name <b><U>in</U> <U>true</U>
       <U>with</U></b>
       | Not_found -&gt; <b><U>false</U><m>
     
 185 
     </m><U>let</U></b> find name =
       <b><U>try</U><r> hidden_find name </r><U>with</U></b>
       | Not_found -&gt;
           warning ("Command not found: "^name) ;
 <m>190       <r>([],[]),Subst ""
     
     <b><U>and</U><r> find_fail name =
       </r><U>try</U></b> hidden_find name <b><U>with</U></b>
       | Not_found -&gt; raise Failed
 </r>195 
     <b><U>let</U></b></m> def name pat action =
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "def %s = " name;
         pretty_macro pat action ;
 <m>200     <r>prerr_endline ""
       <b><U>end</U><r> ;
       hidden_local_def name (pat,action)
     
     </r><U>and</U></b> global_def name pat action =
 </r>205   <b><U>if</U></b></m> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "global def %s = " name;
         pretty_macro pat action ;
         prerr_endline ""
       <b><U>end</U><r> ;
 <m>210   </m>hidden_global_def name (pat,action)
     
     ;;
     
     </r><U>let</U></b> def_init name f =
 <m>215   <b><U>if</U></b></m> exists name <b><U>then</U><r>
         fatal ("Command: "^name^" defined at initialisation") ;
       def name zero_pat (CamlCode f)
     
     </r><U>let</U></b> pretty_arg = <b><U>function</U><m>
 220   <r>| None -&gt; prerr_string "&lt;None&gt;"
       | Some (n,acc) -&gt; pretty_macro n acc
     
     <b><U>let</U></b> pretty_replace s name old new_def =
       Printf.fprintf stderr "%s: %s\n\told=" s name ;
 </r>225   <r>pretty_arg old ;
       Printf.fprintf stderr "\n\tnew=" ;
       pretty_arg new_def ;
       prerr_endline ""
     
 </r>230 </m><U>let</U></b> replace name new_def =
       <b><U>let</U><r> old_def =
         </r><U>try</U></b> Some (hidden_find name) <b><U>with</U><r>
         | Not_found -&gt; None </r><U>in</U><w>
     (*
 <m>235   </m>pretty_replace "replace" name old_def new_def ;
       Printf.fprintf stderr "level=%d\n" !group_level ;
     *)
       </w><U>begin</U> <U>match</U></b> new_def <b><U>with</U><r>
       | Some d -&gt; hidden_local_def name d
 <m>240   </m>| None -&gt; </r><U>match</U></b> old_def <b><U>with</U></b>
         | None -&gt; ()
         | Some _ -&gt; </r>(* what will happen if binging was global ??? *)
             </w><U>if</U></b> !group_level &gt; 0 <b><U>then</U></b>
               purge := pre_purge name !purge
 </r></b>245         <b><U>else</U><r>
               Hashtbl.remove global_table name
       </r><U>end</U><r> ;
       old_def
     
 </r></b>250 
     
     
     </m>(* macro static properties *)
     
 <m>255 <b><U>let</U><r> invisible = </r><U>function</U><r>
       "\\nofiles"
     | "\\pagebreak" | "\\nopagebreak" | "\linebreak"
     | "\\nolinebreak" | "\\label" | "\\index"
     | "\\vspace" | "\\glossary" | "\\marginpar"
 </r></b>260 <r>| "\\figure" | "\\table"
     | "\\nostyle" | "\\rm" | "\\tt"
     | "\\bf" | "\\em" | "\\it" | "\\sl"
     | "\\tiny" | "\\footnotesize" | "\\scriptsize"
     | "\\small" | "\\normalsize" | "\\large" | "\\Large" | "\\LARGE"
 </r>265 <r>| "\\huge" | "\\Huge"
     | "\\purple" | "\\silver" | "\\gray" | "\\white"
     | "\\maroon" | "\\red" | "\\fuchsia" | "\\green"
     | "\\lime" | "\\olive" | "\\yellow" | "\\navy"
     | "\\blue" | "\\teal" | "\\aqua" | "\\else" | "\\fi"
 </r>270 <r>| "\\char" -&gt; <b><U>true</U><r>
     | name -&gt;
         (String.length name &gt;= 3 &amp;&amp; String.sub name 0 3 = "\\if")
     ;;<PL><B>
<6>95 latexmain.ml</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>let</U></b> header = "$Id: latexmain.ml,v 1.69 2001/05/25 12:37:25 maranget Exp $"
     
     <b><U>open</U></b> Misc
  </r>15 <b><U>open</U><r> Parse_opts
     
     
     </r><U>let</U><r>
       scan_main, no_prelude, scan_print_env_pos,
  </r></b>20   <r>dest_finalize,image_finalize =
     
       <b><U>match</U><r> !Parse_opts.destination </r><U>with</U></b>
       | Html <b><U>when</U><r> name_in &lt;&gt; "" -&gt;
           </r><U>let</U> <U>module</U></b> Scan = Latexscan.Make (Html) (Image) <b><U>in</U><m>
  25       </m><U>let</U> <U>module</U></b> MakeIt = Zyva.Make (Html) (Image) (Scan) <b><U>in</U>
           <U>let</U> <U>module</U></b> Rien = MakeIt (Videoc.Make) <b><U>in</U>
           <U>let</U> <U>module</U></b> RienBis  = MakeIt (Package.Make) <b><U>in</U>
           <U>let</U> <U>module</U></b> RienTer = MakeIt (Verb.Make) <b><U>in</U></b>
           Scan.main, Scan.no_prelude, Scan.print_env_pos,
  </r>30       <r>Html.finalize, Image.finalize
       | Html  -&gt;
           <b><U>let</U> <U>module</U></b> Scan = Latexscan.Make (Html) (Noimage) <b><U>in</U>
           <U>let</U> <U>module</U></b> Otherscan = Videoc.Make (Html) (Noimage) (Scan) <b><U>in</U>
           <U>let</U> <U>module</U></b> Verbscan = Verb.Make  (Html) (Noimage) (Scan) <b><U>in</U><m>
  35       </m><U>let</U> <U>module</U></b> OptScan = Package.Make  (Html) (Image) (Scan) <b><U>in</U><r>
           Scan.main, Scan.no_prelude, Scan.print_env_pos,
           Html.finalize, Noimage.finalize
       | Text -&gt;
           </r><U>let</U> <U>module</U></b> Scan = Latexscan.Make (Text) (Noimage) <b><U>in</U><m>
  40       </m><U>let</U> <U>module</U></b> Verbscan = Verb.Make  (Text) (Noimage) (Scan) <b><U>in</U>
           <U>let</U> <U>module</U></b> OptScan = Package.Make (Text) (Image) (Scan)  <b><U>in</U></b>
           Scan.main, Scan.no_prelude, Scan.print_env_pos,
           Text.finalize,Noimage.finalize
       | Info -&gt;
  </r>45       <b><U>let</U> <U>module</U><r> Scan = Latexscan.Make (Info) (Noimage) <b><U>in</U>
           <U>let</U> <U>module</U></b> Verbscan = Verb.Make  (Info) (Noimage) (Scan) <b><U>in</U>
           <U>let</U> <U>module</U></b> OptScan = Package.Make (Info) (Image) (Scan) <b><U>in</U></b>
           Scan.main, Scan.no_prelude, Scan.print_env_pos,
           Info.finalize, Noimage.finalize
  </r></b>50 <r>;;
     
     <b><U>let</U><r> prerr_error msg  =
       Location.print_pos () ;
       </r><U>if</U></b> msg &lt;&gt; "" <b><U>then</U></b> prerr_endline msg
  </r>55 <r>;;
     
     <b><U>let</U></b> prerr_bug msg =
       prerr_error msg ;
       prerr_endline
  </r>60   <r>"    (if input is plain LaTeX, please report to Luc.Maranget@inria.fr)"
     
     <b><U>and</U></b> prerr_not_supported msg =
       prerr_error msg ;
       prerr_endline "You ran into hevea limitations, sorrry"
  </r>65 <r>;;
     
     
     <b><U>let</U><r> finalize check =
       </r><U>try</U><m>
  70     </m><U>let</U></b> changed = Auxx.finalize check <b><U>in</U>
         <U>let</U></b> changed = Index.finalize check || changed  <b><U>in</U>
         <U>let</U></b> image_changed = image_finalize check <b><U>in</U><r>
         dest_finalize check ;
         </r><U>if</U></b> !verbose &gt; 0 &amp;&amp; Parse_opts.name_out &lt;&gt; "" <b><U>then</U> <U>begin</U><m>
  75       <r>prerr_endline ("Output is in file: "^Parse_opts.name_out)
         <b><U>end</U><r> ;
         changed,image_changed
       </r><U>with</U></b> e -&gt;
         <b><U>if</U><r> check </r><U>then</U></b> raise e
  </r>80     </m><U>else</U> <U>begin</U></b>
           prerr_bug ("Uncaught exception in finalize: "^Printexc.to_string e) ;
           prerr_endline "Adios" ;
           exit 2
         <b><U>end</U><m>
  85 
     <r>;;
     
     <b><U>let</U><r> read_style name =
       </r><U>let</U></b> oldverb = !verbose <b><U>in</U><m>
  90   </m><U>if</U></b> !verbose &gt; 0 <b><U>then</U><r> verbose := 1;
       </r><U>begin</U> <U>try</U>
         <U>let</U></b> name,chan =  Myfiles.open_tex name <b><U>in</U>
         <U>if</U></b> !verbose &gt; 0 <b><U>then</U> <U>begin</U></b>
            prerr_endline ("read_style: "^name)
  </r>95     </m><U>end</U></b> ;
         <b><U>let</U><r> buf = Lexing.from_channel chan </r><U>in</U></b>
         Location.set name buf;
         <b><U>begin</U> <U>try</U></b> scan_main buf <b><U>with</U><r> Misc.EndInput -&gt; () </r><U>end</U></b> ;
         close_in chan ;
 </r>100     <r>Location.restore ()
       <b><U>with</U><r>
       | Myfiles.Except-&gt; ()
       </r><U>end</U></b> ;
       verbose := oldverb
 </r>105 <r>;;
     
     <b><U>let</U><r> read_prog prog =
       </r><U>try</U>
         <U>let</U></b> real_prog = Myfiles.find prog
 </r>110     <b><U>and</U><r> name = Filename.temp_file "hevea" ".hva" </r><U>in</U>
         <U>begin</U> <U>match</U><r> Sys.command (real_prog^" &gt;"^name) <b><U>with</U></b>
         | 0 -&gt; read_style name
         | _ -&gt;
             warning ("Could not exec program file: "^real_prog)
 </r></b>115     <b><U>end</U><r> ;
         Mysys.remove name
       </r><U>with</U><r>
       | Not_found -&gt;
           warning ("Could not find program file: "^prog)
 </r></b>120 
     <b><U>let</U><r> read_tex name_in =
       Save.set_verbose !silent !verbose ;
       </r><U>begin</U> <U>try</U>
         <U>match</U><r> name_in <b><U>with</U><m>
 125     <r>| "" -&gt; Lexstate.real_input_file !verbose scan_main "" stdin
         | _  -&gt; Lexstate.input_file !verbose scan_main name_in
       <b><U>with</U><r>
       | Misc.EndDocument -&gt; ()
       </r><U>end</U><m>
 130 
     </m><U>let</U></b> main () =
     
         verbose := !readverb ;
         read_style "hevea.hva" ;
 </r>135 
         </m><U>let</U> <U>rec</U></b> do_rec = <b><U>function</U></b>
           [] -&gt; ()
         | File x::rest -&gt;
            do_rec rest ;
 </r></b>140        <r>read_style x
         | Prog x::rest -&gt;
            do_rec rest ;
            read_prog x <b><U>in</U><m>
     
 145     </m><U>let</U></b> styles =  Parse_opts.styles <b><U>in</U><r>
     
         do_rec styles ;
     
         </r><U>if</U></b> Parse_opts.filter <b><U>then</U></b>  no_prelude () ;
 </r>150 
         <b><U>if</U><r> !Parse_opts.fixpoint </r><U>then</U> <U>begin</U>
           <U>let</U><r> image_changed = ref <b><U>false</U> <U>in</U>
           <U>let</U></b> saved = Hot.checkpoint () <b><U>in</U>
           <U>let</U> <U>rec</U></b> do_rec i =
 <m>155         </m>read_tex name_in ;
             <b><U>let</U><r> changed,image_changed_now = finalize </r><U>true</U> <U>in</U></b>
             image_changed := !image_changed || image_changed_now ;
             <b><U>if</U><r> changed </r><U>then</U> <U>begin</U></b>
               Hot.start saved ;
 <m>160           </m>Auxx.hot_start () ;
               Misc.message ("Run, run, again...") ;
               do_rec (i+1)
             <b><U>end</U> <U>else</U> <U>begin</U></b>
               Misc.message
 <m>165             </m>("Fixpoint reached in "^string_of_int i^" step(s)") ;
               <b><U>if</U><r> !image_changed </r><U>then</U> <U>begin</U></b>
                 Misc.message
                   ("Now, I am running imagen for you") ;
                 <b><U>let</U><r> _ = Sys.command("imagen "^base_out) </r><U>in</U></b> ()
 <m>170           <b><U>end</U>
             <U>end</U> <U>in</U><r>
           do_rec 1
         <b><U>end</U> <U>else</U> <U>begin</U></b>
           read_tex name_in ;
 <m>175       <b><U>let</U><r> _ = finalize </r><U>true</U> <U>in</U><r> ()
         <b><U>end</U><r> ;
     
     </r><w>(* Optimisation *)
         </w><U>if</U></b> !optimize </r><U>then</U> <U>begin</U></b>
 180       <b><U>match</U><r> !destination </r><U>with</U><r>
           | Html <b><U>when</U><r> name_in &lt;&gt; "" -&gt;
               Ultra.verbose := !Misc.verbose ;
               </r><U>if</U></b> not (Esponja.file name_out) <b><U>then</U><r>
                 warning "Esponja failed, optimisation not performed"
 <m>185       </m>| _ -&gt; ()
         </r><U>end</U></b> ;
         exit 0
     ;;
     <w>(*
 <m>190 </m>let _ =
       Dynlink.init () ;
       begin try
         Dynlink.add_interfaces ["Pervasives"] ["/usr/local/lib/ocaml"] ;
         Dynlink.loadfile "a.cmo" ;
 <m>195   </m>with Dynlink.Error e -&gt; prerr_endline (Dynlink.error_message e)
       end
     *)
     <b><U>let</U></b></w> _ =
       </r><U>begin</U> <U>try</U></b>
 200     </m>main () ;
         exit 0
       <b><U>with</U><r>
         | Misc.Close s -&gt;
             prerr_error s ;
 <m>205         </m>scan_print_env_pos ()
         | Html.Error s -&gt;
             prerr_error ("Error while writing HTML:\n\t"^s)
         | Text.Error s -&gt;
             prerr_error ("Error while writing Text:\n\t"^s)
 <m>210     </m>| Info.Error s -&gt;
             prerr_error ("Error while writing Info:\n\t"^s)
         | InfoRef.Error s -&gt;
             prerr_error ("Error while writing Info:\n\t"^s)
         | Misc.ScanError s -&gt;
 <m>215         </m>prerr_error ("Error while reading LaTeX:\n\t"^s)
         | Lexstate.Error s -&gt;
             prerr_error ("Error while reading LaTeX:\n\t"^s)
         | Verb.VError s -&gt;
             prerr_error ("Error while reading verbatim LaTeX:\n\t"^s)
 <m>220     </m>| Colscan.Error s -&gt;
             prerr_error ("Error while reading LaTeX style colors:\n\t"^s)
         | Save.Error s -&gt;
             prerr_error ("Error while reading LaTeX macros arguments:\n\t"^s)
         | Tabular.Error s -&gt;
 <m>225         </m>prerr_error ("Error while reading table format:\n\t"^s)
         | Get.Error s -&gt;
             prerr_error ("Error while getting a value:\n\t"^s)
         | Misc.UserError s -&gt;
             prerr_error ("User error:\n\t"^s)
 <m>230     </m>| Myfiles.Error s -&gt;
             prerr_error ("File error:\n\t"^s)
         |  Misc.NoSupport s -&gt;
             prerr_not_supported s
         |  Misc.Fatal s -&gt;
 <m>235         </m>prerr_bug ("Fatal error: "^s)
         |  Stack.Fatal s -&gt;
             prerr_bug ("Fatal stack error, "^s)
     </r><w>(*
         |  x -&gt;
 <m>240         </m>prerr_bug
               ("Fatal error, spurious exception:\n\t"^Printexc.to_string x)
     *)
       </w><U>end</U></b> ;
       <b><U>let</U></b> _ = finalize </r><U>false</U> <U>in</U></b>
 245   </m>prerr_endline "Adios" ;
       exit 2
     ;;<PL><B>
<6>96 latexscan.ml</6>
</B></PL> 
      15 "latexscan.mll"
     
     <b><U>module</U> <U>type</U></b> S =
       </r><U>sig</U></b>
   5     </m>(* external entry points *)
         <b><U>val</U></b></w> no_prelude : unit -&gt; unit
         <b><U>val</U><r> main : Lexing.lexbuf -&gt; unit
         </r><U>val</U></b> print_env_pos : unit -&gt; unit
     
  </r>10     <w>(* additional resources needed for extension modules. *)
         </w></m><U>val</U></b> cur_env : string ref
         <b><U>val</U><r> new_env : string -&gt; unit
         </r><U>val</U></b> close_env : string -&gt; unit
         <b><U>val</U></b> echo_toimage : unit -&gt; bool
  </r>15     </m><U>val</U></b> echo_global_toimage : unit -&gt; bool
     
         <b><U>val</U><r> fun_register : (unit -&gt; unit) -&gt; unit
         </r><U>val</U></b> newif_ref : string -&gt; bool ref -&gt; unit
         <b><U>val</U><r> top_open_block : string -&gt; string -&gt; unit
  </r><m>20     </m><U>val</U></b> top_close_block : string -&gt; unit
         <b><U>val</U><r> check_alltt_skip : Lexing.lexbuf -&gt; unit
         </r><U>val</U></b> skip_pop : Lexing.lexbuf -&gt; unit
     <w>(* ``def'' functions for initialisation only *)
         <b><U>val</U></b></w> def_code : string -&gt; (Lexing.lexbuf -&gt; unit) -&gt; unit
  <m>25     <b><U>val</U><r> def_name_code : string -&gt; (string -&gt; Lexing.lexbuf -&gt; unit) -&gt; unit
         </r><U>val</U><r> def_fun : string -&gt; (string -&gt; string) -&gt; unit
         <b><U>val</U><r> get_this_main : string -&gt; string
         </r><U>val</U></b> check_this_main : string -&gt; bool
         <b><U>val</U></b> get_prim : string -&gt; string
  </r></b>30     <b><U>val</U><r> get_prim_arg : Lexing.lexbuf -&gt; string
         </r><U>val</U><r> get_prim_opt : string -&gt; Lexing.lexbuf -&gt; string
         <b><U>val</U><r> get_csname : Lexing.lexbuf -&gt; string
       </r><U>end</U><m>
     
  35 </m><U>module</U></b> Make
       (Dest : OutManager.S) (Image : ImageManager.S) =
     <b><U>struct</U>
     <U>open</U></b> Misc
     <b><U>open</U></b> Parse_opts
  </r></b>40 <b><U>open</U><r> Element
     </r><U>open</U><r> Lexing
     <b><U>open</U><r> Myfiles
     </r><U>open</U></b> Latexmacros
     <b><U>open</U></b> Save
  </r></b>45 <b><U>open</U><r> Tabular
     </r><U>open</U><r> Lexstate
     <b><U>open</U><r> Stack
     </r><U>open</U></b> Subst
     
  </r></b>50 <b><U>let</U><r> sbool = </r><U>function</U><r>
       | <b><U>false</U><r> -&gt; "false"
       | </r><U>true</U></b>  -&gt; "true"
     
     
  </r></b>55 
     <b><U>let</U><r> last_letter name =
       </r><U>let</U><r> c = String.get name (String.length name-1) <b><U>in</U></b>
       ('a' &lt;= c &amp;&amp; c &lt;= 'z') || ('A' &lt;= c &amp;&amp; c &lt;= 'Z')
     ;;
  </r></b>60 
     <b><U>let</U><r> top_par n =
       </r><U>if</U><r> not (!display || !in_math) <b><U>then</U></b> Dest.par n
     ;;
     
  </r></b>65 <b><U>let</U><r> if_level = ref 0
     ;;
     
     </r><U>let</U><r> cur_env = ref ""
     <b><U>and</U></b> after = ref []
  </r></b>70 <b><U>and</U><r> stack_env = Stack.create "stack_env"
     ;;
     
     </r><U>let</U><r> echo_toimage () =  get_level () = 0 &amp;&amp; top_level ()
     <b><U>and</U></b> echo_global_toimage () = top_level ()
  </r></b>75 
     <b><U>let</U><r> stack_env_pretty () =  Stack.pretty (</r><U>fun</U><r> (x,_,_) -&gt; x) stack_env
     
     <b><U>let</U><r> fun_register f =
       </r><U>if</U></b> get_level () &gt; 0 <b><U>then</U></b> after := f :: !after
  </r></b>80 <r>;;
     
     
     <b><U>let</U><r> inc_size i =
       </r><U>let</U></b> n = Dest.get_fontsize () <b><U>in</U><m>
  85   </m><U>let</U></b> new_size =
         <b><U>if</U><r> n+i &lt;= 1 </r><U>then</U></b> 1
         <b><U>else</U> <U>if</U></b> n+i &gt;= 7 <b><U>then</U><r> 7
         </r><U>else</U></b> n+i <b><U>in</U></b>
       Dest.open_mod (Font new_size)
  </r>90 <r>;;
     
     <b><U>let</U></b> big_size () =  Dest.open_mod (Font 7)
     ;;
     
  </r>95 <w>(* Horizontal display *)
     
     </w></m><b><U>let</U><r> top_open_display () =
       </r><U>if</U></b> !display <b><U>then</U> <U>begin</U>
         <U>if</U></b> !verbose &gt; 1 <b><U>then</U><m>
 100        <r>prerr_endline "open display" ;
         Dest.open_display ()
       <b><U>end</U>
     
     <U>and</U></b> top_item_display () =
 </r>105   </m><U>if</U></b> !display <b><U>then</U> <U>begin</U></b>
         Dest.item_display ()
       <b><U>end</U><r>
     ;;
     
 </r><m>110 </m><U>let</U></b> top_close_display () =
       <b><U>if</U><r> !display </r><U>then</U> <U>begin</U></b>
         Dest.close_display ()
       <b><U>end</U><m>
     
 115 
     </m><w>(* Latex environment stuff *)
     
     </w><U>let</U></b> print_env_pos () =
       <b><U>let</U><r> _,_,pos = Stack.pop stack_env </r><U>in</U><m>
 120   <r>Location.print_this_pos pos ;
       prerr_endline ("Latex environment ``"^ !cur_env^"'' is pending")
     ;;
     
     <b><U>let</U></b> new_env env =
 </r>125   <r>Latexmacros.open_group () ;
       push stack_env (!cur_env, !after, Location.get_pos ()) ;
       cur_env := env ;
       after := [] ;
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U> <U>begin</U><m>
 130     <r>Location.print_pos () ;
         Printf.fprintf stderr "Begin : %s &lt;%d&gt;" env (get_level ());
         prerr_endline ""
       <b><U>end</U><m>
     
 135 </m><U>let</U></b> error_env close_e open_e =
       raise
         (Misc.Close
            ("Latex env error: ``"^close_e^"'' closes ``"^open_e^"''"))
     
 </r>140 </m><U>let</U></b> close_env env  =
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "End: %s &lt;%d&gt;" env (get_level ());
         prerr_endline  ""
       <b><U>end</U></b> ;
 </r>145   </m><U>if</U></b> env = !cur_env <b><U>then</U> <U>begin</U>
         <U>let</U></b> e,a,_ = pop stack_env <b><U>in</U><r>
         List.iter (</r><U>fun</U></b> f -&gt; f ()) !after ;
         cur_env := e ;
         after := a ;
 <m>150     <r>Latexmacros.close_group ()
       <b><U>end</U> <U>else</U></b>
         error_env env !cur_env
     ;;
     
 </r>155 <b><U>let</U></b></m> env_check () = !cur_env, !after, Stack.save stack_env
     <b><U>and</U></b> env_hot (e,a,s) =
       cur_env := e ;
       after := a ;
       Stack.restore stack_env s
 <m>160 
     
     <w>(* Top functions for blocks *)
     
     <b><U>type</U><r> array_type = {math : bool ; border : bool}
 <m>165 <b><U>type</U><r> in_table = Table </r><U>of</U><r> array_type | NoTable | Tabbing
     ;;
     
     <b><U>let</U><r> cur_format = ref [||]
     </r><U>and</U></b> stack_format = Stack.create "stack_format"
 <m>170 <b><U>and</U><r> cur_col = ref 0
     </r><U>and</U><r> stack_col = Stack.create "stack_col"
     <b><U>and</U><r> in_table = ref NoTable
     </r><U>and</U></b> stack_table = Stack.create_init "stack_table" NoTable
     <b><U>and</U></b> first_col = ref </r><U>false</U></b>
 175 <b><U>and</U><r> first_border = ref </r><U>false</U>
     <U>and</U><r> stack_first = Stack.create "stack_first"
     <b><U>and</U><r> stack_first_b = Stack.create "stack_first_b"
     </r><U>and</U></b> in_multi = ref <b><U>false</U>
     <U>and</U></b> stack_multi_flag = Stack.create "stack_multi_flag"
 <m>180 <b><U>and</U><r> stack_multi = Stack.create "stack_multi"
     ;;
     
     
     </r><U>let</U><r> pretty_array_type = </r><U>function</U></b>
 185   </m>| Table {math = m ; border = b} -&gt;
           "Table math="^(<b><U>if</U><r> m </r><U>then</U></b> "+" <b><U>else</U><r> "-")^
           " border="^(</r><U>if</U></b> b <b><U>then</U><r> "+" </r><U>else</U></b> "-")
       | NoTable -&gt; "NoTable"
       | Tabbing -&gt; "Tabbing"
 <m>190 
     <b><U>let</U><r> prerr_array_state () =
       prerr_endline (pretty_array_type !in_table) ;
       prerr_string "  format:";
       pretty_formats !cur_format ;
 <m>195   </m>prerr_endline "" ;
       prerr_endline ("  cur_col="^string_of_int !cur_col) ;
       prerr_endline ("  first_col="^
           (</r><U>if</U><r> !first_col <b><U>then</U><r> "true" </r><U>else</U></b> "false"))
     ;;
 <m>200 
     <b><U>let</U><r> save_array_state () =
       push stack_format !cur_format ;
       push stack_col !cur_col ;
       push stack_table !in_table ;
 <m>205   </m>push stack_first !first_col;
       push stack_first_b !first_border;
       push stack_multi_flag !in_multi ;
       in_multi := </r><U>false</U><r> ;
       <b><U>if</U></b> !verbose &gt; 1 </r><U>then</U> <U>begin</U></b>
 210     </m>prerr_endline "Save array state:" ;
         prerr_array_state ()
       <b><U>end</U>
     
     <U>and</U></b> restore_array_state () =
 <m>215   </m>in_table := pop stack_table ;
       cur_col := pop stack_col ;
       cur_format := pop stack_format ;
       first_col := pop stack_first ;
       first_border := pop stack_first_b;
 <m>220   </m>in_multi := pop stack_multi_flag ;
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U> <U>begin</U></b>
         prerr_endline "Restore array state:" ;
         prerr_array_state ()
       </r><U>end</U></b>
 225 </m>;;
     
     <b><U>let</U><r> top_open_block block args =
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("Top open: "^block);
       push stack_table !in_table ;
 <m>230   </m>in_table := NoTable ;
       </r><U>begin</U> <U>match</U></b> block <b><U>with</U><r>
       | "PRE" -&gt;
           push stack_display !display ;
           </r><U>if</U></b> !display </r><U>then</U> <U>begin</U></b>
 235         </m>Dest.item_display () ;
             display := <b><U>false</U>
           <U>end</U></b> ;
           Dest.open_block "PRE" args
       | "DISPLAY" -&gt;
 <m>240       </m>push stack_display !display ;
           display := <b><U>true</U><r> ;
           Dest.open_display ()
       | "TABLE" -&gt;
           save_array_state () ;
 <m>245       </m>in_table := NoTable ;
           top_item_display () ;
           Dest.open_block "TABLE" args
       | "TR" -&gt;
           Dest.open_block "TR" args
 <m>250   </m>| "TD" -&gt;
           Dest.open_block "TD" args ;
           top_open_display ()
       | _ -&gt;
           </r><U>if</U></b> !display </r><U>then</U> <U>begin</U></b>
 255         </m>Dest.item_display () ; Dest.open_block block args ;
             Dest.open_display ()
           </r><U>end</U> <U>else</U><r>
             Dest.open_block block args
       </r><U>end</U></b></w>
 260 
     <b><U>and</U><r> top_close_block_aux close_fun block =
       </r><U>if</U><r> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("Top close: "^block) ;
       in_table := pop stack_table ;
       </r><U>begin</U> <U>match</U></b> block </r><U>with</U></b>
 265   </m>| "PRE" -&gt;
           display := pop stack_display ;
           close_fun block ;
           top_item_display ()
       | "DISPLAY" -&gt;
 <m>270       <r>Dest.close_display () ;
           display := pop stack_display
       | "TABLE" -&gt;
           close_fun "TABLE" ;
           top_item_display () ;
 </r>275       <r>restore_array_state ()
       | "TR" -&gt;
           close_fun "TR"
       | "TD" -&gt;
           top_close_display () ;
 </r>280       <r>close_fun "TD"
       | _ -&gt;
           <b><U>if</U><r> !display </r><U>then</U> <U>begin</U></b>
             Dest.close_display () ; close_fun block ; Dest.item_display ()
           <b><U>end</U> <U>else</U><m>
 285         <r>close_fun block
       <b><U>end</U><r>
     ;;
     
     </r><U>let</U></b> top_close_block block = top_close_block_aux Dest.close_block block
 </r>290 </m><U>and</U></b> top_erase_block block = top_close_block_aux Dest.erase_block block
     
     <b><U>let</U></b> top_open_group () =
       top_open_block "" "" ; new_env ""
     
 </r>295 <b><U>and</U><r> top_close_group () =
       </r><U>if</U><r> !cur_env = "*mbox" <b><U>then</U> <U>begin</U></b>
         top_close_block "" ;
         in_math := pop stack_in_math ; display := pop stack_display ;
         <b><U>if</U><r> !display </r><U>then</U></b> Dest.item_display () ;
 </r></b>300     <r>close_env "*mbox"
       <b><U>end</U> <U>else</U> <U>begin</U></b>
         top_close_block "" ;
         close_env ""
       <b><U>end</U><m>
 305 <r>;;
     
     <b><U>let</U><r> start_mbox () =
       push stack_table !in_table ; in_table := NoTable ;
       push stack_in_math !in_math ; in_math := </r><U>false</U></b> ;
 </r>310   </m><U>if</U></b> !display <b><U>then</U><r> Dest.item_display () ;
       push stack_display !display ; display := </r><U>false</U></b> ;
       Dest.open_block "" "" ;
       new_env "*mbox"
     ;;
 </r>315 
     <b><U>let</U><r> get_fun_result f lexbuf =
        </r><U>if</U><r> !verbose &gt; 1 <b><U>then</U><r>
         prerr_endline ("get_fun") ;
       </r><U>let</U></b> r = Dest.to_string (<b><U>fun</U></b> () -&gt;
 </r></b>320     <r>top_open_group () ;
         Dest.nostyle () ;
         f lexbuf ;
         top_close_group ()) <b><U>in</U>
       <U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U><m>
 325     <r>prerr_endline ("get_fun -&gt; ``"^r^"''")
       <b><U>end</U></b> ;
       r
     
     
 </r>330 </m><U>let</U></b> do_get_this start_lexstate restore_lexstate
         make_style  lexfun {arg=s ; subst=subst} =
       <b><U>let</U><r> par_val = Dest.forget_par () </r><U>in</U></b>
       start_lexstate subst;
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U><m>
 335     <r>prerr_endline ("get_this : ``"^s^"''") ;
       verbose := !verbose - 1;
       <b><U>let</U><r> lexer = Lexing.from_string s </r><U>in</U>
       <U>let</U></b> r = Dest.to_string (<b><U>fun</U><r> () -&gt;
         </r><U>if</U></b> !display <b><U>then</U></b>  Dest.open_display () ;
 </r>340     <r>top_open_group () ;
         make_style () ;
         lexfun lexer ;
         top_close_group () ;
         <b><U>if</U><r> !display </r><U>then</U></b> Dest.close_display ()) <b><U>in</U><m>
 345 
       </m><U>let</U></b> _ = Dest.forget_par () <b><U>in</U><r>
       verbose := !verbose + 1 ;
       </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
         prerr_endline ("get_this ``"^s^"'' -&gt; ``"^r^"''")
 </r>350   </m><U>end</U></b> ;
       restore_lexstate () ;
       Dest.par par_val ;
       r
     
 </r>355 <b><U>let</U><r> get_this_arg =
       do_get_this start_lexstate_subst restore_lexstate (</r><U>fun</U><r> () -&gt; ())
     
     <b><U>and</U><r> get_this_string main s =
       do_get_this start_lexstate_subst restore_lexstate (</r><U>fun</U></b> () -&gt; ())
 </r></b>360     <r>main (string_to_arg s)
     
     <b><U>let</U></b> more_buff = Out.create_buff ()
     ;;
     
 </r>365 <b><U>let</U><r> default_format =
       Tabular.Align
         {hor="left" ; vert = "" ; wrap = </r><U>false</U><r> ;
           pre = "" ; post = "" ; width = Length.Default}
     
 </r></b>370 <b><U>and</U><r> center_format =
       Tabular.Align
         {hor="center" ; vert = "top" ; wrap = </r><U>false</U><r> ;
           pre = "" ; post = "" ; width = Length.Default}
     ;;
 </r></b>375 
     
     <b><U>let</U><r> is_table = </r><U>function</U><r>
       | Table _ -&gt; <b><U>true</U><r>
       | _       -&gt; </r><U>false</U><m>
 380 
     </m><U>and</U></b> is_noborder_table = <b><U>function</U><r>
       | Table {border = b} -&gt; not b
       | _                  -&gt; </r><U>false</U><m>
     
 385 </m><U>and</U></b> is_tabbing = <b><U>function</U><r>
       | Tabbing -&gt; </r><U>true</U></b>
       | _ -&gt; <b><U>false</U>
     
     <U>and</U></b> math_table = <b><U>function</U><m>
 390   <r>| Table {math = m} -&gt; m
       | _ -&gt; raise (Misc.Fatal "Array construct outside an array")
     ;;
     
     
 </r>395 </m><U>exception</U></b> EndInside
     ;;
     <b><U>exception</U></b> NoMulti
     ;;
     
 </r></b>400 <b><U>let</U><r> attribut name = </r><U>function</U><r>
       | "" -&gt; ""
       | s  -&gt; " "^name^"="^s
     
     <b><U>and</U><r> as_colspan = </r><U>function</U><m>
 405   <r>|  1  -&gt; ""
       |  n -&gt; " COLSPAN="^string_of_int n
     
     <b><U>let</U><r> is_inside = </r><U>function</U></b>
         Tabular.Inside _ -&gt; <b><U>true</U><m>
 410   <r>| _ -&gt; <b><U>false</U>
     
     <U>let</U></b> is_border = <b><U>function</U><r>
       | Tabular.Border _ -&gt; </r><U>true</U></b>
       | _ -&gt; <b><U>false</U><m>
 415 
     </m><U>and</U></b> as_wrap = <b><U>function</U><r>
       | Tabular.Align {wrap = w} -&gt; w
       | _ -&gt; </r><U>false</U><m>
     
 420 </m><U>and</U></b> as_pre = <b><U>function</U><r>
       | Tabular.Align {pre=s} -&gt; s
       | _ -&gt; raise (Misc.Fatal "as_pre")
     
     </r><U>and</U></b> as_post = <b><U>function</U><m>
 425   <r>| Tabular.Align {post=s} -&gt; s
       | f -&gt; raise (Misc.Fatal ("as_post "^pretty_format f))
     ;;
     
     <b><U>let</U></b> get_col format i =
 </r>430   </m><U>let</U></b> r =
         <b><U>if</U><r> i &gt;= Array.length format+1 </r><U>then</U></b>
           raise (Misc.ScanError ("This array/tabular column has no specification"))
         <b><U>else</U> <U>if</U></b> i = Array.length format <b><U>then</U><r> default_format
         </r><U>else</U></b> format.(i) <b><U>in</U><m>
 435   </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
        Printf.fprintf stderr "get_col : %d: " i ;
        prerr_endline (pretty_format r) ;
        prerr_string " &lt;- " ;
        pretty_formats format ;
 </r>440    <r>prerr_newline ()
       <b><U>end</U></b> ;
       r
     ;;
     
 </r>445 </m><w>(* Paragraph breaks are different in tables *)
     </w><U>let</U></b> par_val t =
       <b><U>if</U><r> is_table t </r><U>then</U>
         <U>match</U></b> get_col !cur_format !cur_col <b><U>with</U><r>
         | Tabular.Align {wrap=</r><U>false</U></b>} -&gt; None
 </r>450     <r>| _                          -&gt; Some 0
       <b><U>else</U><r>
         Some 1
     
     </r><U>let</U></b> show_inside main format i closing =
 </r>455 <w>(*
       if !verbose &gt; -1 then begin
         prerr_string ("show_inside: "^string_of_int i)
       end ;
     *)
 </w>460   </m><U>let</U></b> t = ref i <b><U>in</U>
       <U>begin</U> <U>try</U> <U>while</U> <U>true</U> <U>do</U>
         <U>begin</U> <U>match</U></b> get_col format !t <b><U>with</U><r>
           Tabular.Inside s -&gt;
             </r><U>let</U></b> saved_table = !in_table <b><U>in</U><m>
 465         </m><U>if</U></b> math_table saved_table <b><U>then</U><r>
               scan_this main "$"
             </r><U>else</U></b>
               scan_this main "{" ;
             <b><U>let</U><r> s = get_this_string main s </r><U>in</U><m>
 470         </m><U>if</U></b> math_table saved_table <b><U>then</U><r>
               scan_this main "$"
             </r><U>else</U></b>
               scan_this main "}" ;
      Dest.make_inside s !in_multi;
 </r></b>475     <r>| Tabular.Border s -&gt;
      Dest.make_border s;
      <b><U>if</U><r> !first_border </r><U>then</U></b> first_border := <b><U>false</U><r>;
         | _ -&gt; raise EndInside
         </r><U>end</U></b> ;
 </r>480     <r>t := !t+1
       <b><U>done</U> <U>with</U></b> EndInside -&gt;
         <b><U>if</U><r> (!t = i) &amp;&amp; (closing || !first_border)  </r><U>then</U></b>
           Dest.make_border " ";
       <b><U>end</U></b> ;
 </r>485 <w>(*
       if !verbose &gt; -1 then
         prerr_endline (" -&gt; "^string_of_int !t) ;
     *)
       <r>!t
 </r></w>490 <r>;;
     
     <b><U>let</U> <U>rec</U></b> eat_inside format i b insides =
       <b><U>if</U><r> i &gt;= Array.length format </r><U>then</U></b> (i , b , insides)
       <b><U>else</U> <U>begin</U><m>
 495     </m><U>let</U></b> f = get_col format i <b><U>in</U>
         <U>if</U></b> is_inside f <b><U>then</U><r>
           eat_inside format (i+1) b (insides+1)
         </r><U>else</U> <U>if</U></b> is_border f <b><U>then</U></b>
           eat_inside format (i+1) (b+1) insides
 </r>500     <b><U>else</U><r> i, b, insides
       </r><U>end</U><r>
     ;;
     
     <b><U>let</U> <U>rec</U></b> find_end n format i b insides = <b><U>match</U><r> n </r><U>with</U><m>
 505   <r>0 -&gt; eat_inside format i b insides
     | _ -&gt;
        <b><U>let</U><r> f = get_col format i </r><U>in</U>
        <U>if</U></b> is_inside f <b><U>then</U></b>
          find_end n format (i+1) b (insides +1)
 </r>510    </m><U>else</U> <U>if</U></b> is_border f <b><U>then</U><r>
          find_end n format (i+1) (b+1) insides
        </r><U>else</U></b>
          find_end (n-1) format (i+1) b insides
     ;;
 </r></b>515 
     
     <r><b><U>let</U><r> find_start i = </r><U>if</U></b> !first_border <b><U>then</U><r> 0 </r><U>else</U></b> i
     
     <b><U>let</U></b> find_align format =
 </r>520   <b><U>let</U><r> t = ref 0 </r><U>in</U>
       <U>while</U><r> (is_inside (get_col format !t)) || (is_border (get_col format !t)) <b><U>do</U><r>
         t := !t+1
       </r><U>done</U></b> ;
       !t
 </r></b>525 <r>;;
     
     <b><U>let</U><r> next_no_border format n =
       </r><U>let</U></b> t = ref n <b><U>in</U>
       <U>while</U></b> is_border (get_col format !t) <b><U>do</U><m>
 530     <r>t:= !t+1
       <b><U>done</U></b>;
       !t
     ;;
     
 </r>535 </m><U>let</U></b> do_open_col main format span insides =
       <b><U>let</U><r> save_table = !in_table </r><U>in</U></b>
       Dest.open_cell format span insides;
       <b><U>if</U><r> not (as_wrap format) &amp;&amp; math_table !in_table </r><U>then</U> <U>begin</U></b>
         display  := <b><U>true</U></b> ;
 </r>540     <r>Dest.open_display ()
       <b><U>end</U><r> ;
       </r><U>if</U></b> math_table !in_table &amp;&amp; not (as_wrap format) <b><U>then</U> <U>begin</U></b>
         scan_this main "$"
       <b><U>end</U> <U>else</U><m>
 545     <r>scan_this main "{" ;
       scan_this main (as_pre format) ;
       in_table := save_table
     
     <b><U>let</U></b> open_col main  =
 </r>550   </m><U>let</U></b> _ = Dest.forget_par () <b><U>in</U><r>
       Dest.open_cell_group () ;
       cur_col :=  show_inside main !cur_format !cur_col </r><U>false</U></b>;
       <b><U>let</U><r> format = (get_col !cur_format !cur_col) </r><U>in</U></b>
       do_open_col main format 1 0
 </r>555 <r>;;
     
     <b><U>let</U><r> open_first_col main =
       first_col := </r><U>true</U></b> ;
       first_border := <b><U>true</U></b>;
 </r>560   <r>open_col main
     ;;
     
     <b><U>let</U><r> erase_col main =
       </r><U>let</U></b> old_format = get_col !cur_format !cur_col <b><U>in</U><m>
 565   <r>scan_this main (as_post old_format) ;
       <b><U>if</U><r> math_table !in_table  &amp;&amp; not (as_wrap old_format) </r><U>then</U></b>
         scan_this main "$"
       <b><U>else</U></b>
         scan_this main "}" ;
 </r>570   </m><U>if</U></b> !display <b><U>then</U> <U>begin</U></b>
         Dest.close_display () ;
         display := <b><U>false</U>
       <U>end</U></b> ;
       Dest.erase_cell () ;
 </r>575   <r>Dest.erase_cell_group ()
     ;;
     
     
     <b><U>let</U></b> open_row () =
 </r>580   <r>cur_col := 0 ;
       Dest.new_row ()
     
     <b><U>and</U></b> close_row () = Dest.close_row ()
     ;;
 </r>585 
     
     <b><U>let</U><r> do_hline main =
       </r><U>if</U><r> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "hline: %d %d" !cur_col (Array.length !cur_format) ;
 </r></b>590     <r>prerr_newline ()
       <b><U>end</U></b> ;
       erase_col main ;
       Dest.erase_row () ;
       Dest.make_hline (Array.length !cur_format) (is_noborder_table !in_table);
 </r>595   <r>open_row () ;
       open_first_col main
     ;;
     
     <b><U>let</U></b> do_multi n format main =
 </r>600   <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U><r>
         prerr_string
           ("multicolumn: n="^string_of_int n^" format:") ;
         pretty_formats format ;
         prerr_endline ""
 </r></b>605   <b><U>end</U><r> ;
     
       erase_col main ;
     
       </r><U>let</U><r> start_span = find_start !cur_col
 </r></b>610   <r><b><U>and</U><r> k,b,insides = find_end n !cur_format !cur_col 0 0 </r><U>in</U>
       <U>let</U></b> end_span = k - b <b><U>in</U><r>
     
       in_multi := </r><U>true</U></b>;
     
 </r>615   <b><U>let</U><r> i = show_inside main format 0 </r><U>true</U> <U>in</U><r>
     
       Dest.open_cell_group () ;
       do_open_col main (get_col format i) (end_span - start_span) insides;
       push stack_multi (!cur_format,k) ;
 </r></b>620   <r>cur_format := format ;
       cur_col := i ;
     ;;
     
     
 </r>625 <b><U>let</U><r> close_col_aux main content is_last =
       </r><U>let</U><r> old_format = get_col !cur_format !cur_col <b><U>in</U><r>
       scan_this main (as_post old_format) ;
       </r><U>if</U></b> math_table !in_table &amp;&amp; not (as_wrap old_format) <b><U>then</U></b>
         scan_this main "$"
 </r></b>630   <b><U>else</U><r>
         scan_this main "}" ;
       </r><U>if</U><r> !display <b><U>then</U> <U>begin</U></b>
         Dest.close_display () ;
         display := <b><U>false</U><m>
 635   </m><U>end</U></b> ;
       <b><U>if</U><r> is_last &amp;&amp; Dest.is_empty () </r><U>then</U></b> Dest.erase_cell ()
       <b><U>else</U> <U>begin</U>
         <U>if</U></b> !in_multi <b><U>then</U> <U>begin</U>
           <U>let</U></b> _ = show_inside main !cur_format (!cur_col+1) <b><U>true</U> <U>in</U><m>
 640       <r>in_multi := <b><U>false</U><r> ;
           </r><U>let</U></b> f,n = pop stack_multi <b><U>in</U><r>
           cur_format := f ;
           cur_col := next_no_border f n;
           cur_col := show_inside main !cur_format !cur_col </r><U>false</U></b>;
 </r>645     </m><U>end</U> <U>else</U> <U>begin</U></b>
           cur_col := !cur_col + 1;
           cur_col := show_inside main !cur_format !cur_col <b><U>true</U><r>;
         </r><U>end</U></b>;
         Dest.close_cell content;
 </r></b>650     <b><U>if</U><r> !first_col </r><U>then</U> <U>begin</U><r>
           first_col := <b><U>false</U><r>;
           first_border := </r><U>false</U></b>;
         <b><U>end</U>
       <U>end</U></b> ;
 </r></b>655   <r>Dest.close_cell_group ()
     ;;
     
     <b><U>let</U><r> close_col main content = close_col_aux main content </r><U>false</U>
     <U>and</U></b> close_last_col main content = close_col_aux main content <b><U>true</U><m>
 660 
     </m><U>and</U></b> close_last_row () =
       <b><U>if</U><r> !first_col </r><U>then</U></b>
         Dest.erase_row ()
       <b><U>else</U><m>
 665     <r>Dest.close_row ()
     ;;
     
     <w>(* Compute functions *)
     
 <m>670 <b><U>let</U><r> get_style lexfun {arg=s ; subst=env} =
       start_normal env ;
       </r><U>let</U><r> lexer = Lexing.from_string s <b><U>in</U>
       <U>let</U></b> r = Dest.to_style (<b><U>fun</U><r> () -&gt; lexfun lexer) </r><U>in</U></b>
       end_normal () ;
 </r></b>675   <r>r
     
     <w>(* Image stuff *)
     
     <b><U>let</U></b></w> iput_newpage () = Image.page ()
 </r>680 <r>;;
     
     <b><U>let</U><r> stack_entry = Stack.create "stack_entry"
     </r><U>and</U></b> stack_out = Stack.create  "stack_out"
     ;;
 </r>685 
     <b><U>let</U><r> start_other_scan env lexfun lexbuf =
       </r><U>if</U><r> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
         prerr_endline ("Start other scan ("^env^")") ;
         stack_env_pretty () ;
 </r></b>690     <r>prerr_endline ("Current env is: ``"^ !cur_env^"''") ;
         pretty (<b><U>fun</U><r> x -&gt; x) stack_entry
       </r><U>end</U></b>;
       save_lexstate () ;
       push stack_entry env ;
 </r>695   <r>rev stack_entry ;
       lexfun lexbuf
     ;;
     
     <b><U>let</U></b> start_image_scan s image lexbuf =
 </r>700   <r>start_other_scan "toimage" (<b><U>fun</U><r> b -&gt; Image.dump s image b) lexbuf
     ;;
     
     </r><U>let</U></b> complete_scan main lexbuf =
       main lexbuf ;
 </r>705   <r>close_env (pop stack_out) ;
       top_close_block "" ;
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U> <U>begin</U></b>
         prerr_endline "Complete scan" ;
         stack_env_pretty () ;
 </r>710     <r>prerr_endline ("Current env is: ``"^ !cur_env^"''")
       <b><U>end</U></b>
     ;;
     
     
 </r>715 <b><U>let</U><r> stop_other_scan comment main lexbuf =
       </r><U>if</U><r> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
         prerr_endline "Stop image: env stack is" ;
         stack_env_pretty () ;
         prerr_endline ("Current env is: ``"^ !cur_env^"''")
 </r></b>720   <b><U>end</U><r>;
       </r><U>let</U><r> _ = pop stack_entry <b><U>in</U>
       <U>if</U></b> not comment <b><U>then</U><r> close_env !cur_env ;
       </r><U>if</U></b> not (Stack.empty stack_out) <b><U>then</U> <U>begin</U></b>
         complete_scan main lexbuf ;
 </r></b>725     <b><U>while</U><r> not (Stack.empty stack_out) </r><U>do</U>
           <U>let</U><r> lexbuf = previous_lexbuf () <b><U>in</U><r>
           complete_scan main lexbuf
         </r><U>done</U>
       <U>end</U></b> ;
 </r></b>730   <r>restore_lexstate ()
     ;;
     
     <b><U>let</U><r> includes_table = Hashtbl.create 17
     </r><U>and</U></b> check_includes = ref <b><U>false</U><m>
 735 <r>;;
     
     <b><U>let</U><r> add_includes l =
       check_includes := </r><U>true</U></b> ;
       List.iter (<b><U>fun</U></b> x -&gt; Hashtbl.add includes_table x ()) l
 </r>740 <r>;;
     
     
     <b><U>let</U></b> check_include s =
       not !check_includes ||
 </r>745   </m><U>begin</U>  <U>try</U></b>
         Hashtbl.find includes_table s ; <b><U>true</U>
       <U>with</U></b> Not_found -&gt; <b><U>false</U>
       <U>end</U></b>
     ;;
 </r>750 
     
     <r><b><U>let</U><r> mk_out_file () = </r><U>match</U></b> Parse_opts.name_out,!Parse_opts.destination <b><U>with</U></b>
     | "", Parse_opts.Info -&gt;  Out.create_buff ()
     | "", _ -&gt; Out.create_chan stdout
 </r>755 <r>| x , Parse_opts.Info -&gt; Out.create_chan (open_out (x^".tmp"))
     | x , _  -&gt; Out.create_chan (open_out x)
     ;;
     
     <b><U>let</U></b> no_prelude () =
 </r>760   <r><b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b> prerr_endline "Filter mode" ;
       flushing := <b><U>true</U><r> ;
       </r><U>let</U></b> _ = Dest.forget_par () <b><U>in</U></b> () ;
       Dest.set_out (mk_out_file ())
     ;;
 </r>765 
     <b><U>let</U><r> macro_depth = ref 0
     ;;
     
     </r><U>let</U><r> debug = </r><U>function</U></b>
 770   <r>| Not -&gt; "Not"
       | Macro -&gt; "Macro"
       | Inside -&gt; "Inside"
     ;;
     
 </r>775 
     <b><U>let</U> <U>rec</U><r> expand_toks main = <b><U>function</U><r>
       | [] -&gt; ()
       | s::rem -&gt;
           expand_toks main rem ;
 <m>780       </m>scan_this main s
     
     </r><U>let</U></b> expand_command main skip_blanks name lexbuf =
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "expand_command: %s\n" name
 <m>785   <b><U>end</U><r> ;
       </r><U>let</U><r> cur_subst = get_subst () <b><U>in</U>
       <U>let</U></b> exec =
         <b><U>if</U></b> !alltt_loaded </r><U>then</U>
           <U>function</U></b>
 790         </m>| Subst body -&gt;
                 <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U></b>
                   prerr_endline ("user macro: "^body) ;
                 <b><U>let</U><r> old_alltt = !alltt </r><U>in</U></b>
                 Stack.push stack_alltt old_alltt ;
 <m>795             </m>alltt :=
                    (<b><U>match</U><r> old_alltt </r><U>with</U></b>
                    | Not -&gt; Not
                    | _   -&gt; Macro) ;
     <w>(*
 <m>800   </m>Printf.fprintf stderr
       "Enter: %s, %s -&gt; %s\n" name (debug old_alltt) (debug !alltt) ;
       *)
                 </w>scan_this_may_cont main lexbuf cur_subst (string_to_arg body) ;
                 <b><U>let</U></b> _ =  Stack.pop stack_alltt </r><U>in</U></b>
 805             <r>alltt :=
                    (<b><U>match</U><r> old_alltt, !alltt </r><U>with</U></b>
                    | Not, Inside         -&gt; Inside
                    | (Macro|Inside), Not -&gt; Not
                    | _, _                -&gt; old_alltt)
 </r>810 </m>(*
       Printf.fprintf stderr
       "After: %s, %s -&gt; %s\n" name (debug old_alltt) (debug !alltt)
       *)
             </w>| Toks l -&gt; expand_toks main l
 </r>815         <r>| CamlCode f -&gt; f lexbuf
         <b><U>else</U>
           <U>function</U></b>
             | Subst body -&gt;
                 <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U><m>
 820               <r>prerr_endline ("user macro: "^body) ;
                 scan_this_may_cont main lexbuf cur_subst (string_to_arg body)
             | Toks l -&gt; expand_toks main l
             | CamlCode f -&gt; f lexbuf <b><U>in</U><m>
     
 825   </m><U>let</U></b> pat,body = Latexmacros.find name <b><U>in</U>
       <U>let</U></b> par_before = Dest.forget_par () <b><U>in</U>
       <U>if</U></b>
         (<b><U>if</U><r> !in_math </r><U>then</U></b> Latexmacros.invisible name
         <b><U>else</U><m>
 830       <r>not (effective !alltt) &amp;&amp;
           is_subst body &amp;&amp; last_letter name)
       <b><U>then</U> <U>begin</U>
         <U>if</U></b> !verbose &gt; 2 <b><U>then</U></b>
           prerr_endline ("skipping blanks ("^name^")");
 </r>835     <r>skip_blanks lexbuf
       <b><U>end</U> <U>else</U> <U>begin</U>
         <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
           prerr_endline ("not skipping blanks ("^name^")")
         <b><U>end</U><m>
 840   </m><U>end</U></b> ;
       <b><U>let</U><r> par_after = Dest.forget_par () </r><U>in</U></b>
       Dest.par par_before ;
       <b><U>let</U><r> args = make_stack name pat lexbuf </r><U>in</U>
       <U>let</U></b> saw_par = !Save.seen_par <b><U>in</U><m>
 845   </m><U>if</U></b> (!verbose &gt; 1) <b><U>then</U> <U>begin</U></b>
         prerr_endline
           ("Expanding macro "^name^" {"^(string_of_int !macro_depth)^"}") ;
         macro_depth := !macro_depth + 1
       <b><U>end</U></b> ;
 </r>850   <r>scan_body exec body args ;
       <b><U>if</U><r> (!verbose &gt; 1) </r><U>then</U> <U>begin</U></b>
         prerr_endline ("Cont after macro "^name^": ") ;
         macro_depth := !macro_depth - 1
       <b><U>end</U></b> ;
 </r>855   <r>Dest.par par_after ;
       <b><U>if</U><r> saw_par </r><U>then</U> <U>begin</U></b>
         top_par (par_val !in_table)
       <b><U>end</U></b>
     ;;
 </r>860 
     </m><U>let</U></b> count_newlines s =
       <b><U>let</U><r> l = String.length s </r><U>in</U>
       <U>let</U> <U>rec</U></b> c_rec i =
         <b><U>if</U><r> i &gt;= l </r><U>then</U></b> 0
 </r>865     </m><U>else</U> <U>match</U></b> s.[i] <b><U>with</U><r>
         | '\n'  -&gt; 1 + c_rec (i+1)
         | _     -&gt;  c_rec (i+1) </r><U>in</U></b>
       c_rec 0
     ;;
 </r>870 
     </m><U>let</U></b> check_case s = <b><U>match</U><r> !case </r><U>with</U></b>
     | Lower -&gt;  String.lowercase s
     | Upper -&gt; String.uppercase s
     | Neutral -&gt; s
 </r>875 
     <r><b><U>and</U><r> check_case_char c = </r><U>match</U></b> !case <b><U>with</U></b>
     | Lower -&gt; Char.lowercase c
     | Upper -&gt; Char.uppercase c
     | Neutral -&gt; c
 </r>880 <b><U>let</U><r> lex_tables = {
       Lexing.lex_base =
        "\000\000\001\000\002\000\002\000\004\000\003\000\056\000\005\000\
    \032\000\255\255\008\000\006\000\007\000\011\000\001\000\012\000\
    \090\000\119\000\009\000\010\000\254\255\097\000\253\255\098\000\
    \053\000\022\000\033\000\013\000\104\000\072\000\041\000\023\000\
    \039\000\021\000\058\000\074\000\056\000\077\000\013\000\137\000\
    \138\000\117\000\081\000\083\000\055\000\056\000\057\000\041\000\
    \059\000\064\000\014\000\059\000\058\000\054\000\026\000\133\000\
    \091\000\106\000\063\000\076\000\058\000\075\000\057\000\252\255\
    \081\000\076\000\080\000\100\000\117\000\099\000\123\000\119\000\
    \123\000\092\000\091\000\090\000\086\000\074\000\092\000\104\000\
    \086\000\102\000\085\000\096\000\098\000\105\000\093\000\091\000\
    \132\000\150\000\155\000\151\000\151\000\147\000\248\255\255\255\
    \126\000\118\000\127\000\131\000\250\000\053\001\112\001\171\001\
    \230\001\033\002\092\002\151\002\210\002\013\003\071\003\129\003\
    \119\000\134\000\188\003\247\003\027\000\004\000\028\000\255\255\
    \010\000\029\000\030\000\139\000\136\000\126\000\132\000\127\000\
    \133\000\238\000\214\000\015\000\249\255\223\000\050\004\059\004\
    \250\255\140\004\221\004\046\005\127\005\083\004\163\004\169\000\
    \180\000\140\000\150\000\134\000\152\000\157\000\223\000\167\000\
    \249\000\160\004\205\000\174\000\187\000\182\000\185\000\153\003\
    \222\000\218\000\221\000\205\000\223\000\228\000\226\000\013\004\
    \251\255\244\004\186\005\011\006\092\006\173\006\254\006\245\004\
    \069\005\217\000\227\000\187\000\197\000\181\000\199\000\204\000\
    \014\001\203\000\016\001\158\004\240\000\209\000\191\000\207\000\
    \189\000\014\004\226\000\242\000\225\000\255\000\017\001\022\001\
    \020\001\112\007\113\007\114\007\244\000\034\001\045\001\023\001\
    \039\001\051\001\033\001\102\001\084\001\094\001\096\001\099\001\
    \087\001\137\001\015\004\115\007\238\255\116\007\118\007\239\255\
    \125\005\227\001\255\255\250\255\006\006\240\255\110\007\169\007\
    \252\255\253\255\247\255\246\255\241\255\245\255\250\007\073\008\
    \016\006\120\007\121\007";
       Lexing.lex_backtrk =
        "\255\255\001\000\000\000\255\255\255\255\255\255\255\255\255\255\
    \003\000\255\255\002\000\001\000\255\255\002\000\001\000\000\000\
    \008\000\004\000\001\000\255\255\255\255\001\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\002\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \007\000\255\255\255\255\255\255\255\255\002\000\002\000\002\000\
    \002\000\002\000\002\000\002\000\002\000\001\000\006\000\005\000\
    \255\255\255\255\004\000\003\000\000\000\000\000\000\000\255\255\
    \000\000\000\000\000\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\002\000\002\000\002\000\255\255\006\000\002\000\006\000\
    \255\255\005\000\005\000\005\000\004\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\001\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\001\000\
    \255\255\002\000\004\000\004\000\004\000\004\000\003\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \001\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\001\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\001\000\011\000\255\255\
    \017\000\004\000\255\255\255\255\013\000\255\255\012\000\017\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\007\000\012\000\
    \013\000\255\255\011\000";
 </r></b>885   <r>Lexing.lex_default =
        "\220\000\009\000\255\255\020\000\168\000\167\000\132\000\131\000\
    \255\255\000\000\255\255\255\255\020\000\255\255\255\255\255\255\
    \094\000\255\255\038\000\020\000\000\000\255\255\000\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\038\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\131\000\000\000\255\255\255\255\136\000\
    \000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\159\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\167\000\
    \000\000\255\255\168\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\193\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\218\000\255\255\000\000\255\255\255\255\000\000\
    \255\255\255\255\000\000\000\000\255\255\000\000\255\255\094\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\255\255\255\255\
    \255\255\255\255\255\255";
       Lexing.lex_trans =
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\221\000\117\000\002\000\009\000\117\000\009\000\
    \120\000\119\000\020\000\009\000\120\000\020\000\000\000\009\000\
    \000\000\255\255\000\000\000\000\000\000\000\000\000\000\000\000\
    \222\000\223\000\219\000\224\000\225\000\226\000\227\000\201\000\
    \121\000\169\000\009\000\118\000\116\000\028\000\050\000\021\000\
    \228\000\228\000\228\000\228\000\228\000\228\000\228\000\228\000\
    \228\000\228\000\055\000\116\000\118\000\121\000\122\000\229\000\
    \122\000\230\000\230\000\230\000\230\000\230\000\230\000\230\000\
    \230\000\230\000\230\000\230\000\230\000\230\000\230\000\230\000\
    \230\000\230\000\230\000\230\000\230\000\230\000\230\000\230\000\
    \230\000\230\000\230\000\133\000\231\000\134\000\232\000\233\000\
    \170\000\230\000\230\000\230\000\230\000\230\000\230\000\230\000\
    \230\000\230\000\230\000\230\000\230\000\230\000\230\000\230\000\
    \230\000\230\000\230\000\230\000\230\000\230\000\230\000\230\000\
    \230\000\230\000\230\000\234\000\123\000\235\000\236\000\095\000\
    \039\000\023\000\023\000\037\000\026\000\027\000\023\000\023\000\
    \028\000\034\000\031\000\032\000\033\000\009\000\035\000\036\000\
    \009\000\027\000\039\000\039\000\135\000\041\000\091\000\040\000\
    \088\000\073\000\041\000\022\000\041\000\051\000\047\000\048\000\
    \049\000\050\000\052\000\053\000\054\000\055\000\024\000\024\000\
    \070\000\039\000\040\000\067\000\064\000\060\000\061\000\041\000\
    \062\000\063\000\065\000\066\000\029\000\009\000\096\000\042\000\
    \068\000\042\000\069\000\063\000\071\000\043\000\072\000\043\000\
    \009\000\074\000\075\000\076\000\077\000\078\000\025\000\025\000\
    \079\000\080\000\081\000\082\000\042\000\083\000\056\000\084\000\
    \085\000\057\000\043\000\044\000\030\000\086\000\087\000\045\000\
    \020\000\045\000\089\000\090\000\050\000\046\000\092\000\046\000\
    \093\000\054\000\112\000\097\000\098\000\044\000\044\000\099\000\
    \110\000\100\000\113\000\114\000\045\000\124\000\058\000\125\000\
    \126\000\059\000\046\000\127\000\128\000\129\000\130\000\166\000\
    \130\000\163\000\151\000\147\000\148\000\149\000\150\000\150\000\
    \237\000\255\255\022\000\009\000\136\000\020\000\022\000\022\000\
    \063\000\255\255\022\000\152\000\020\000\255\255\129\000\255\255\
    \063\000\063\000\063\000\063\000\063\000\063\000\063\000\063\000\
    \063\000\153\000\160\000\156\000\157\000\158\000\159\000\161\000\
    \020\000\162\000\159\000\164\000\165\000\150\000\152\000\200\000\
    \197\000\185\000\181\000\182\000\183\000\184\000\184\000\186\000\
    \187\000\194\000\190\000\191\000\192\000\193\000\195\000\196\000\
    \094\000\193\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\198\000\199\000\184\000\
    \186\000\205\000\255\255\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\102\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \206\000\207\000\208\000\209\000\210\000\211\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\212\000\213\000\214\000\215\000\216\000\
    \217\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \103\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\218\000\168\000\
    \000\000\000\000\000\000\000\000\101\000\101\000\101\000\101\000\
    \104\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\000\000\000\000\000\000\000\000\000\000\000\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\105\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\101\000\101\000\101\000\101\000\106\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \107\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\108\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\101\000\101\000\101\000\101\000\109\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\000\000\009\000\000\000\000\000\000\000\000\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\255\255\
    \009\000\009\000\000\000\000\000\000\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\141\000\000\000\000\000\000\000\000\000\142\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\000\000\141\000\000\000\000\000\000\000\143\000\
    \000\000\000\000\144\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\000\000\145\000\
    \143\000\255\255\146\000\144\000\137\000\137\000\137\000\137\000\
    \138\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\136\000\000\000\
    \145\000\000\000\000\000\146\000\000\000\000\000\187\000\000\000\
    \153\000\000\000\000\000\141\000\000\000\000\000\000\000\000\000\
    \142\000\000\000\000\000\000\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\000\000\
    \143\000\154\000\188\000\144\000\000\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\136\000\
    \145\000\155\000\189\000\146\000\000\000\255\255\255\255\255\255\
    \000\000\000\000\000\000\000\000\175\000\175\000\000\000\000\000\
    \000\000\176\000\000\000\000\000\000\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \000\000\177\000\177\000\255\255\178\000\178\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\139\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \136\000\179\000\179\000\000\000\180\000\180\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\175\000\000\000\000\000\
    \000\000\000\000\176\000\000\000\000\000\000\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\000\000\177\000\000\000\000\000\178\000\000\000\137\000\
    \137\000\137\000\140\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\136\000\179\000\000\000\000\000\180\000\132\000\132\000\
    \132\000\132\000\132\000\132\000\132\000\132\000\132\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\171\000\171\000\171\000\171\000\172\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\168\000\240\000\240\000\
    \240\000\240\000\240\000\240\000\240\000\240\000\240\000\240\000\
    \240\000\240\000\240\000\240\000\240\000\240\000\240\000\240\000\
    \240\000\240\000\000\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\168\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\000\000\
    \000\000\000\000\255\255\000\000\000\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\173\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\168\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\171\000\171\000\
    \171\000\174\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \168\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\000\000\000\000\000\000\000\000\000\000\000\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\202\000\202\000\202\000\000\000\002\000\241\000\000\000\
    \241\000\000\000\241\000\241\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \202\000\202\000\202\000\219\000\241\000\203\000\242\000\203\000\
    \241\000\242\000\136\000\000\000\136\000\000\000\136\000\136\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\239\000\
    \239\000\239\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\000\000\000\000\000\000\204\000\204\000\204\000\239\000\
    \239\000\239\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\238\000\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\094\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\000\000\000\000\000\000\000\000\
    \000\000\255\255\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000";
       Lexing.lex_check =
 </r>890    <r>"\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\000\000\014\000\002\000\005\000\117\000\007\000\
    \011\000\012\000\010\000\018\000\120\000\013\000\255\255\038\000\
    \255\255\131\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\000\000\002\000\000\000\000\000\000\000\000\000\003\000\
    \010\000\004\000\008\000\013\000\015\000\027\000\050\000\019\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\054\000\116\000\118\000\121\000\122\000\000\000\
    \008\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\006\000\000\000\006\000\000\000\000\000\
    \004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\008\000\000\000\000\000\016\000\
    \017\000\021\000\023\000\024\000\025\000\026\000\021\000\023\000\
    \028\000\029\000\030\000\031\000\032\000\033\000\034\000\035\000\
    \036\000\037\000\039\000\040\000\006\000\041\000\042\000\017\000\
    \043\000\044\000\041\000\008\000\017\000\045\000\046\000\047\000\
    \048\000\049\000\051\000\052\000\053\000\055\000\021\000\023\000\
    \056\000\039\000\040\000\057\000\058\000\059\000\060\000\040\000\
    \061\000\062\000\064\000\065\000\028\000\066\000\016\000\041\000\
    \067\000\017\000\068\000\069\000\070\000\041\000\071\000\017\000\
    \072\000\073\000\074\000\075\000\076\000\077\000\021\000\023\000\
    \078\000\079\000\080\000\081\000\040\000\082\000\055\000\083\000\
    \084\000\055\000\040\000\017\000\028\000\085\000\086\000\041\000\
    \087\000\017\000\088\000\089\000\090\000\041\000\091\000\017\000\
    \092\000\093\000\097\000\096\000\096\000\039\000\040\000\096\000\
    \098\000\099\000\112\000\113\000\040\000\123\000\055\000\124\000\
    \125\000\055\000\040\000\126\000\127\000\128\000\130\000\143\000\
    \129\000\144\000\145\000\146\000\147\000\148\000\149\000\150\000\
    \000\000\001\000\003\000\005\000\004\000\007\000\011\000\012\000\
    \010\000\018\000\019\000\151\000\015\000\038\000\129\000\131\000\
    \133\000\133\000\133\000\133\000\133\000\133\000\133\000\133\000\
    \133\000\152\000\154\000\155\000\156\000\157\000\158\000\160\000\
    \008\000\161\000\162\000\163\000\164\000\165\000\166\000\177\000\
    \178\000\179\000\180\000\181\000\182\000\183\000\184\000\185\000\
    \186\000\188\000\189\000\190\000\191\000\192\000\194\000\195\000\
    \006\000\196\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\197\000\198\000\199\000\
    \200\000\204\000\016\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \205\000\206\000\207\000\208\000\209\000\210\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \101\000\101\000\101\000\101\000\101\000\101\000\101\000\101\000\
    \102\000\102\000\102\000\102\000\102\000\102\000\102\000\102\000\
    \102\000\102\000\102\000\102\000\102\000\102\000\102\000\102\000\
    \102\000\102\000\102\000\102\000\102\000\102\000\102\000\102\000\
    \102\000\102\000\102\000\211\000\212\000\213\000\214\000\215\000\
    \216\000\102\000\102\000\102\000\102\000\102\000\102\000\102\000\
    \102\000\102\000\102\000\102\000\102\000\102\000\102\000\102\000\
    \102\000\102\000\102\000\102\000\102\000\102\000\102\000\102\000\
    \102\000\102\000\102\000\103\000\103\000\103\000\103\000\103\000\
    \103\000\103\000\103\000\103\000\103\000\103\000\103\000\103\000\
    \103\000\103\000\103\000\103\000\103\000\103\000\103\000\103\000\
    \103\000\103\000\103\000\103\000\103\000\103\000\217\000\225\000\
    \255\255\255\255\255\255\255\255\103\000\103\000\103\000\103\000\
    \103\000\103\000\103\000\103\000\103\000\103\000\103\000\103\000\
    \103\000\103\000\103\000\103\000\103\000\103\000\103\000\103\000\
    \103\000\103\000\103\000\103\000\103\000\103\000\104\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\104\000\
    \104\000\255\255\255\255\255\255\255\255\255\255\255\255\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\104\000\
    \104\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\105\000\105\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\105\000\105\000\106\000\106\000\106\000\106\000\
    \106\000\106\000\106\000\106\000\106\000\106\000\106\000\106\000\
    \106\000\106\000\106\000\106\000\106\000\106\000\106\000\106\000\
    \106\000\106\000\106\000\106\000\106\000\106\000\106\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\106\000\106\000\106\000\
    \106\000\106\000\106\000\106\000\106\000\106\000\106\000\106\000\
    \106\000\106\000\106\000\106\000\106\000\106\000\106\000\106\000\
    \106\000\106\000\106\000\106\000\106\000\106\000\106\000\107\000\
    \107\000\107\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \107\000\107\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \107\000\107\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \107\000\107\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \107\000\107\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \107\000\107\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \107\000\107\000\107\000\107\000\107\000\107\000\107\000\107\000\
    \107\000\107\000\108\000\108\000\108\000\108\000\108\000\108\000\
    \108\000\108\000\108\000\108\000\108\000\108\000\108\000\108\000\
    \108\000\108\000\108\000\108\000\108\000\108\000\108\000\108\000\
    \108\000\108\000\108\000\108\000\108\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\108\000\108\000\108\000\108\000\108\000\
    \108\000\108\000\108\000\108\000\108\000\108\000\108\000\108\000\
    \108\000\108\000\108\000\108\000\108\000\108\000\108\000\108\000\
    \108\000\108\000\108\000\108\000\108\000\109\000\109\000\109\000\
    \109\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \109\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \109\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\109\000\109\000\
    \109\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \109\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \109\000\109\000\109\000\109\000\109\000\109\000\109\000\109\000\
    \110\000\110\000\110\000\110\000\110\000\110\000\110\000\110\000\
    \110\000\110\000\110\000\110\000\110\000\110\000\110\000\110\000\
    \110\000\110\000\110\000\110\000\110\000\110\000\110\000\110\000\
    \110\000\110\000\255\255\159\000\255\255\255\255\255\255\255\255\
    \110\000\110\000\110\000\110\000\110\000\110\000\110\000\110\000\
    \110\000\110\000\110\000\110\000\110\000\110\000\110\000\110\000\
    \110\000\110\000\110\000\110\000\110\000\110\000\110\000\110\000\
    \110\000\110\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\111\000\111\000\111\000\111\000\
    \111\000\111\000\111\000\111\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\114\000\114\000\114\000\114\000\167\000\
    \193\000\218\000\255\255\255\255\255\255\114\000\114\000\114\000\
    \114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\114\000\114\000\114\000\114\000\114\000\
    \114\000\114\000\114\000\114\000\114\000\114\000\114\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\134\000\255\255\255\255\255\255\255\255\134\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\115\000\115\000\115\000\115\000\115\000\115\000\
    \115\000\115\000\255\255\141\000\255\255\255\255\255\255\134\000\
    \255\255\255\255\134\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\255\255\134\000\
    \141\000\159\000\134\000\141\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\135\000\135\000\
    \135\000\135\000\135\000\135\000\135\000\135\000\137\000\255\255\
    \141\000\255\255\255\255\141\000\255\255\255\255\187\000\255\255\
    \153\000\255\255\255\255\142\000\255\255\255\255\255\255\255\255\
    \142\000\255\255\255\255\255\255\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\255\255\
    \142\000\153\000\187\000\142\000\255\255\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\137\000\
    \137\000\137\000\137\000\137\000\137\000\137\000\137\000\138\000\
    \142\000\153\000\187\000\142\000\255\255\167\000\193\000\218\000\
    \255\255\255\255\255\255\255\255\169\000\175\000\255\255\255\255\
    \255\255\169\000\255\255\255\255\255\255\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \255\255\169\000\175\000\135\000\169\000\175\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \138\000\138\000\138\000\138\000\138\000\138\000\138\000\138\000\
    \139\000\169\000\175\000\255\255\169\000\175\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\176\000\255\255\255\255\
    \255\255\255\255\176\000\255\255\255\255\255\255\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\255\255\176\000\255\255\255\255\176\000\255\255\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\139\000\139\000\139\000\139\000\139\000\139\000\139\000\
    \139\000\140\000\176\000\255\255\255\255\176\000\224\000\224\000\
    \224\000\224\000\224\000\224\000\224\000\224\000\224\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\140\000\140\000\140\000\140\000\140\000\140\000\
    \140\000\140\000\170\000\170\000\170\000\170\000\170\000\170\000\
    \170\000\170\000\170\000\170\000\170\000\170\000\170\000\170\000\
    \170\000\170\000\170\000\170\000\170\000\170\000\170\000\170\000\
    \170\000\170\000\170\000\170\000\170\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\170\000\170\000\170\000\170\000\170\000\
    \170\000\170\000\170\000\170\000\170\000\170\000\170\000\170\000\
    \170\000\170\000\170\000\170\000\170\000\170\000\170\000\170\000\
    \170\000\170\000\170\000\170\000\170\000\171\000\228\000\228\000\
    \228\000\228\000\228\000\228\000\228\000\228\000\228\000\228\000\
    \240\000\240\000\240\000\240\000\240\000\240\000\240\000\240\000\
    \240\000\240\000\255\255\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\171\000\171\000\
    \171\000\171\000\171\000\171\000\171\000\171\000\172\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\172\000\172\000\172\000\172\000\
    \172\000\172\000\172\000\172\000\172\000\172\000\172\000\172\000\
    \172\000\172\000\172\000\172\000\172\000\172\000\172\000\172\000\
    \172\000\172\000\172\000\172\000\172\000\172\000\172\000\255\255\
    \255\255\255\255\170\000\255\255\255\255\172\000\172\000\172\000\
    \172\000\172\000\172\000\172\000\172\000\172\000\172\000\172\000\
    \172\000\172\000\172\000\172\000\172\000\172\000\172\000\172\000\
    \172\000\172\000\172\000\172\000\172\000\172\000\172\000\173\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\173\000\173\000\173\000\
    \173\000\173\000\173\000\173\000\173\000\173\000\173\000\173\000\
    \173\000\173\000\173\000\173\000\173\000\173\000\173\000\173\000\
    \173\000\173\000\173\000\173\000\173\000\173\000\173\000\173\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\173\000\173\000\
    \173\000\173\000\173\000\173\000\173\000\173\000\173\000\173\000\
    \173\000\173\000\173\000\173\000\173\000\173\000\173\000\173\000\
    \173\000\173\000\173\000\173\000\173\000\173\000\173\000\173\000\
    \174\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\174\000\174\000\
    \174\000\174\000\174\000\174\000\174\000\174\000\174\000\174\000\
    \174\000\174\000\174\000\174\000\174\000\174\000\174\000\174\000\
    \174\000\174\000\174\000\174\000\174\000\174\000\174\000\174\000\
    \174\000\255\255\255\255\255\255\255\255\255\255\255\255\174\000\
    \174\000\174\000\174\000\174\000\174\000\174\000\174\000\174\000\
    \174\000\174\000\174\000\174\000\174\000\174\000\174\000\174\000\
    \174\000\174\000\174\000\174\000\174\000\174\000\174\000\174\000\
    \174\000\201\000\202\000\203\000\255\255\219\000\221\000\255\255\
    \222\000\255\255\241\000\242\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \201\000\202\000\203\000\219\000\221\000\201\000\222\000\203\000\
    \241\000\242\000\221\000\255\255\222\000\255\255\241\000\242\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\230\000\
    \230\000\230\000\230\000\230\000\230\000\230\000\230\000\230\000\
    \230\000\230\000\230\000\230\000\230\000\230\000\230\000\230\000\
    \230\000\230\000\230\000\230\000\230\000\230\000\230\000\230\000\
    \230\000\255\255\255\255\255\255\201\000\202\000\203\000\230\000\
    \230\000\230\000\230\000\230\000\230\000\230\000\230\000\230\000\
    \230\000\230\000\230\000\230\000\230\000\230\000\230\000\230\000\
    \230\000\230\000\230\000\230\000\230\000\230\000\230\000\230\000\
    \230\000\231\000\231\000\231\000\231\000\231\000\231\000\231\000\
    \231\000\231\000\231\000\231\000\231\000\231\000\231\000\231\000\
    \231\000\231\000\231\000\231\000\231\000\231\000\231\000\231\000\
    \231\000\231\000\231\000\231\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\231\000\231\000\231\000\231\000\231\000\231\000\
    \231\000\231\000\231\000\231\000\231\000\231\000\231\000\231\000\
    \231\000\231\000\231\000\231\000\231\000\231\000\231\000\231\000\
    \231\000\231\000\231\000\231\000\238\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\238\000\238\000\238\000\
    \238\000\238\000\238\000\238\000\238\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\255\255\255\255\255\255\255\255\
    \255\255\231\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\239\000\239\000\239\000\239\000\
    \239\000\239\000\239\000\239\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255"
     }
     
     <b><U>let</U> <U>rec</U></b> main lexbuf = __ocaml_lex_main_rec lexbuf 0
     <b><U>and</U></b> __ocaml_lex_main_rec lexbuf state =
 </r>895   <r><b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><r>
         0 -&gt; (
      900 "latexscan.mll"
         expand_command main skip_blanks "\\@hevea@percent" lexbuf ;
        main lexbuf)
 <m>900   </m>| 1 -&gt; (
      905 "latexscan.mll"
            expand_command main skip_blanks "\\@hevea@newline" lexbuf ;
           main lexbuf)
       | 2 -&gt; (
 <m>905  </m>909 "latexscan.mll"
            expand_command main skip_blanks "\\@hevea@underscore" lexbuf ;
           main lexbuf)
       | 3 -&gt; (
      912 "latexscan.mll"
 <m>910        </m>expand_command main skip_blanks "\\@hevea@circ" lexbuf ;
           main lexbuf)
       | 4 -&gt; (
      916 "latexscan.mll"
           <b><U>let</U></b> lxm = lexeme lexbuf </r><U>in</U><m>
 915      <w>(* ``$'' has nothing special *)
          <b><U>let</U><r> dodo = lxm &lt;&gt; "$" </r><U>in</U>
          <U>if</U><r> effective !alltt || not (is_plain '$') <b><U>then</U> <U>begin</U></b>
            Dest.put lxm ; main lexbuf
          </r></b>(* vicious case ``$x$$y$'' *)
 </w>920      <b><U>end</U> <U>else</U> <U>if</U><r> dodo &amp;&amp; not !display &amp;&amp; !in_math <b><U>then</U> <U>begin</U></b>
            scan_this main "${}$" ;
            main lexbuf
          <b><U>end</U> <U>else</U> <U>begin</U><w> (* General case *)
            </w><U>let</U></b> math_env = <b><U>if</U><r> dodo </r><U>then</U></b> "*display" <b><U>else</U></b> "*math" </r><U>in</U></b>
 925        <b><U>if</U><r> !in_math </r><U>then</U> <U>begin</U><r>
              in_math := pop stack_in_math ;
              <b><U>if</U><r> dodo </r><U>then</U> <U>begin</U></b>
         Dest.close_maths dodo
              </r><U>end</U> <U>else</U> <U>begin</U></b>
 930            <r>top_close_display () ;
         Dest.close_maths dodo
              <b><U>end</U><r> ;
              display := pop stack_display ;
              </r><U>if</U></b> !display </r></m><U>then</U> <U>begin</U><m>
 935            <r>Dest.item_display ()
              <b><U>end</U><r> ;
              close_env math_env ;
              main lexbuf
            </r><U>end</U> <U>else</U> <U>begin</U><m>
 940          <r>push stack_in_math !in_math ;
              in_math := <b><U>true</U><r> ;
              </r><U>let</U></b> lexfun lb =
                <b><U>if</U><r> !display </r><U>then</U></b>  Dest.item_display () ;
                push stack_display !display ;
 </r>945            </m><U>if</U></b> dodo <b><U>then</U> <U>begin</U></b>
                  display  := <b><U>true</U><r> ;
           Dest.open_maths dodo;
                </r><U>end</U> <U>else</U> <U>begin</U></b>
           Dest.open_maths dodo;
 </r>950              <r>top_open_display () ;
                <b><U>end</U><r>;
                skip_blanks lb ; main lb </r><U>in</U></b>
              new_env math_env ;
              lexfun lexbuf
 </r>955        <b><U>end</U> <U>end</U><r>)
       | 5 -&gt; (
      962 "latexscan.mll"
          expand_command main skip_blanks "\\@hevea@amper" lexbuf ;
         main lexbuf)
 </r></b>960   <r>| 6 -&gt; (
      966 "latexscan.mll"
            <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
           <U>begin</U> <U>if</U></b> effective !alltt || not (is_plain '#') <b><U>then</U></b>
             Dest.put lxm
 </r>965       </m><U>else</U>
             <U>let</U></b> i = Char.code lxm.[1] - Char.code '1' <b><U>in</U><r>
             scan_arg
               (</r><U>if</U></b> !alltt_loaded <b><U>then</U><r>
                 (</r><U>fun</U></b> arg -&gt;
 </r>970               <b><U>let</U><r> old_alltt = !alltt </r><U>in</U><r>
                   alltt := Stack.pop stack_alltt ;
                   scan_this_may_cont main lexbuf (get_subst ()) arg ;
                   alltt := old_alltt ;
                   Stack.push stack_alltt old_alltt)
 </r></b>975           <b><U>else</U><r>
                 (</r><U>fun</U><r> arg -&gt; scan_this_may_cont main lexbuf (get_subst ()) arg))
               i
           <b><U>end</U></b> ;
           main lexbuf)
 </r></b>980   <r>| 7 -&gt; (
      986 "latexscan.mll"
            <b><U>let</U><r> name = lexeme lexbuf </r><U>in</U></b>
           expand_command main skip_blanks name lexbuf ;
           main lexbuf)
 </r>985   <r>| 8 -&gt; (
      991 "latexscan.mll"
          expand_command main skip_blanks "\\@hevea@obrace" lexbuf ;
         main lexbuf)
       | 9 -&gt; (
 </r>990  <r>994 "latexscan.mll"
          expand_command main skip_blanks "\\@hevea@cbrace" lexbuf ;
         main lexbuf)
       | 10 -&gt; (
      996 "latexscan.mll"
 </r>995        <r>())
       | 11 -&gt; (
      998 "latexscan.mll"
         <b><U>if</U><r> effective !alltt </r><U>then</U>
          <U>let</U></b> lxm = lexeme lexbuf <b><U>in</U></b> Dest.put lxm
</r>1000    <b><U>else</U><r>
          Dest.put_char ' ';
        main lexbuf)
       | 12 -&gt; (
      1005 "latexscan.mll"
</r></b>1005     <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
        <U>let</U><r> lxm = check_case lxm <b><U>in</U>
        <U>if</U></b> !in_math <b><U>then</U> <U>begin</U></b>
           Dest.put_in_math lxm;
         <b><U>end</U> <U>else</U><m>
1010       <r>Dest.put lxm ;
         main lexbuf)
       | 13 -&gt; (
      1014 "latexscan.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U><m>
1015     <r>Dest.put lxm;
         main lexbuf)
       | 14 -&gt; (
      1019 "latexscan.mll"
        expand_command main skip_blanks "\\@hevea@tilde" lexbuf ;
</r>1020   <r>main lexbuf )
       | 15 -&gt; (
      1023 "latexscan.mll"
        expand_command main skip_blanks "\\@hevea@question" lexbuf ;
       main lexbuf)
</r>1025   <r>| 16 -&gt; (
      1026 "latexscan.mll"
        expand_command main skip_blanks "\\@hevea@excl" lexbuf ;
       main lexbuf)
       | 17 -&gt; (
</r>1030  <r>1030 "latexscan.mll"
         <b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U>
        <U>let</U></b> lxm = check_case_char lxm <b><U>in</U></b>
        Dest.put (Dest.iso lxm) ;
        main lexbuf)
</r>1035   <r>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_main_rec lexbuf n
     
     <b><U>and</U><r> gobble_one_char lexbuf = __ocaml_lex_gobble_one_char_rec lexbuf 1
     </r><U>and</U></b> __ocaml_lex_gobble_one_char_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><m>
1040     <r>0 -&gt; (
      1036 "latexscan.mll"
            ())
       | 1 -&gt; (
      1037 "latexscan.mll"
</r>1045        <r>fatal ("Gobble at end of file"))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_gobble_one_char_rec lexbuf n
     
     <b><U>and</U><r> complete_newline lexbuf = __ocaml_lex_complete_newline_rec lexbuf 2
     </r><U>and</U></b> __ocaml_lex_complete_newline_rec lexbuf state =
</r>1050   </m><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
      1040 "latexscan.mll"
                      lexeme lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_complete_newline_rec lexbuf n
</r>1055 
     </m><U>and</U></b> latex2html_latexonly lexbuf = __ocaml_lex_latex2html_latexonly_rec lexbuf 3
     <b><U>and</U><r> __ocaml_lex_latex2html_latexonly_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
</r>1060  <r>1044 "latexscan.mll"
           () )
       | 1 -&gt; (
      1046 "latexscan.mll"
          latex2html_latexonly lexbuf)
</r>1065   <r>| 2 -&gt; (
      1048 "latexscan.mll"
          fatal "End of file in latex2html_latexonly")
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_latex2html_latexonly_rec lexbuf n
     
</r>1070 </m><U>and</U></b> latexonly lexbuf = __ocaml_lex_latexonly_rec lexbuf 4
     <b><U>and</U><r> __ocaml_lex_latexonly_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
      1052 "latexscan.mll"
</r></b>1075       <r>stop_other_scan <b><U>true</U></b> main lexbuf)
       | 1 -&gt; (
      1054 "latexscan.mll"
           latexonly lexbuf)
       | 2 -&gt; (
</r>1080  <r>1056 "latexscan.mll"
           latex_comment lexbuf ; latexonly lexbuf)
       | 3 -&gt; (
      1058 "latexscan.mll"
           <b><U>let</U><r> {arg=arg} = save_arg lexbuf </r><U>in</U><m>
1085      </m><U>if</U></b> arg = "latexonly" <b><U>then</U> <U>begin</U></b>
            top_close_block "" ;
            stop_other_scan <b><U>false</U><r> main lexbuf
          </r><U>end</U> <U>else</U> <U>if</U></b> arg = top stack_entry <b><U>then</U> <U>begin</U>
            <U>let</U></b> _ = pop stack_entry <b><U>in</U><m>
1090        <r>push stack_out arg ;
            <b><U>begin</U> <U>match</U></b> Latexmacros.find (end_env arg) <b><U>with</U></b>
              _,(Subst body) -&gt;
                scan_this_may_cont latexonly lexbuf (get_subst ())
                  (string_to_arg body)
</r>1095        <r>|  _,_ -&gt;
                raise (Misc.ScanError ("Bad closing macro in latexonly: ``"^arg^"''"))
            <b><U>end</U>
          <U>end</U> <U>else</U></b>
            latexonly lexbuf)
</r>1100   <r>| 4 -&gt; (
      1074 "latexscan.mll"
                          latexonly lexbuf)
       | 5 -&gt; (
      1076 "latexscan.mll"
</r>1105      </m><U>if</U></b> empty stack_lexbuf <b><U>then</U><r> ()
         </r><U>else</U> <U>begin</U>
           <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U><r>
           latexonly lexbuf
         </r><U>end</U></b>)
</r>1110   <r>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_latexonly_rec lexbuf n
     
     <b><U>and</U><r> latex_comment lexbuf = __ocaml_lex_latex_comment_rec lexbuf 5
     </r><U>and</U></b> __ocaml_lex_latex_comment_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><m>
1115     <r>0 -&gt; (
      1084 "latexscan.mll"
                    ())
       | 1 -&gt; (
      1085 "latexscan.mll"
</r>1120                <r>latex_comment lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_latex_comment_rec lexbuf n
     
     <b><U>and</U><r> image lexbuf = __ocaml_lex_image_rec lexbuf 6
     </r><U>and</U></b> __ocaml_lex_image_rec lexbuf state =
</r>1125   </m><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      1091 "latexscan.mll"
           stop_other_scan </r><U>true</U></b> main lexbuf)
       | 1 -&gt; (
</r>1130  <r>1093 "latexscan.mll"
           image lexbuf)
       | 2 -&gt; (
      1095 "latexscan.mll"
           <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U><m>
1135      <r>Image.put lxm ;
          image_comment lexbuf ;
          image lexbuf)
       | 3 -&gt; (
      1101 "latexscan.mll"
</r>1140      </m><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U>
         <U>let</U></b> i = Char.code (lxm.[1]) - Char.code '1' <b><U>in</U></b>
         scan_arg (scan_this_arg image) i ;
         image lexbuf)
       | 4 -&gt; (
</r>1145  <r>1106 "latexscan.mll"
           <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
          Save.start_echo () ;
          <b><U>let</U><r> {arg=arg} = save_arg lexbuf </r><U>in</U>
          <U>let</U></b> true_arg = Save.get_echo () <b><U>in</U><m>
1150      </m><U>if</U></b> arg = "toimage" <b><U>then</U> <U>begin</U></b>
            top_close_block "" ;
            stop_other_scan <b><U>false</U><r> main lexbuf
          </r><U>end</U> <U>else</U> <U>if</U></b> arg = top stack_entry <b><U>then</U> <U>begin</U>
            <U>let</U></b> _ = pop stack_entry <b><U>in</U><m>
1155        <r>push stack_out arg ;
            <b><U>begin</U> <U>match</U></b> Latexmacros.find (end_env arg) <b><U>with</U></b>
              _,(Subst body) -&gt;
                scan_this_may_cont  image lexbuf (get_subst ())
                  (string_to_arg body)
</r>1160        <r>|  _,_ -&gt; raise (Misc.ScanError ("Bad closing macro in image: ``"^arg^"''"))
            <b><U>end</U>
          <U>end</U> <U>else</U> <U>begin</U></b>
            Image.put lxm ; Image.put true_arg ;
            image lexbuf
</r>1165      </m><U>end</U></b>)
       | 5 -&gt; (
      1127 "latexscan.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>begin</U> <U>match</U></b> lxm <b><U>with</U><m>
1170 <w>(* Definitions of  simple macros, bodies are not substituted *)
         <r>| "\\def" | "\\gdef" -&gt;
             Save.start_echo () ;
             skip_csname lexbuf ;
             skip_blanks lexbuf ;
</r></w>1175         </m><U>let</U></b> _ = Save.defargs lexbuf <b><U>in</U>
             <U>let</U></b> _ = save_arg lexbuf <b><U>in</U><r>
             Image.put lxm ;
             </r><U>let</U></b> saved = Save.get_echo () <b><U>in</U></b>
             Image.put saved
</r>1180     <r>| "\\renewcommand" | "\\newcommand" | "\\providecommand"
         | "\\renewcommand*" | "\\newcommand*" | "\\providecommand*" -&gt;
             Save.start_echo () ;
             <b><U>let</U><r> _ = save_arg lexbuf </r><U>in</U>
             <U>let</U></b> _ = save_opts ["0" ; ""] lexbuf <b><U>in</U><m>
1185         </m><U>let</U></b> _ = save_arg lexbuf <b><U>in</U><r>
             Image.put lxm ;
             </r><U>let</U></b> saved = Save.get_echo () <b><U>in</U></b>
             Image.put saved
         | "\\newenvironment" | "\\renewenvironment"
</r>1190     <r>| "\\newenvironment*" | "\\renewenvironment*" -&gt;
             Save.start_echo () ;
             <b><U>let</U><r> _ = save_arg lexbuf </r><U>in</U>
             <U>let</U></b> _ = save_opts ["0" ; ""] lexbuf <b><U>in</U>
             <U>let</U></b> _ = save_arg lexbuf <b><U>in</U><m>
1195         </m><U>let</U></b> _ = save_arg lexbuf <b><U>in</U><r>
             Image.put lxm ;
             Image.put (Save.get_echo ())
         | _ -&gt; Image.put lxm </r><U>end</U></b> ;
         image lexbuf)
</r>1200   <r>| 6 -&gt; (
      1160 "latexscan.mll"
           <b><U>let</U><r> s = lexeme lexbuf </r><U>in</U></b>
          Image.put s ;
          image lexbuf)
</r>1205   <r>| 7 -&gt; (
      1164 "latexscan.mll"
          <b><U>if</U><r> empty stack_lexbuf </r><U>then</U> <U>begin</U>
           <U>if</U></b> not filter &amp;&amp; top_lexstate () <b><U>then</U></b>
             raise (Misc.ScanError ("No \\end{document} found"))
</r>1210     <b><U>end</U> <U>else</U> <U>begin</U>
           <U>let</U><r> lexbuf = previous_lexbuf () <b><U>in</U><r>
           image lexbuf
         </r><U>end</U></b>)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_image_rec lexbuf n
</r></b>1215 
     <b><U>and</U><r> image_comment lexbuf = __ocaml_lex_image_comment_rec lexbuf 7
     </r><U>and</U><r> __ocaml_lex_image_comment_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
</r></b>1220  <r>1174 "latexscan.mll"
             Image.put_char '\n')
       | 1 -&gt; (
      1175 "latexscan.mll"
             ())
</r>1225   <r>| 2 -&gt; (
      1177 "latexscan.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
         Image.put lxm ;
         image_comment lexbuf)
</r>1230   <r>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_image_comment_rec lexbuf n
     
     <b><U>and</U><r> mbox_arg lexbuf = __ocaml_lex_mbox_arg_rec lexbuf 8
     </r><U>and</U></b> __ocaml_lex_mbox_arg_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><m>
1235     <r>0 -&gt; (
      1182 "latexscan.mll"
                    mbox_arg lexbuf)
       | 1 -&gt; (
      1184 "latexscan.mll"
</r>1240       </m><U>if</U></b> not (empty stack_lexbuf) <b><U>then</U> <U>begin</U>
          <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U>
          <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
            prerr_endline "Poping lexbuf in mbox_arg" ;
            pretty_lexbuf lexbuf
</r>1245      <b><U>end</U><r> ;
          mbox_arg lexbuf
        </r><U>end</U> <U>else</U><r> raise (Misc.ScanError "End of file in \\mbox argument"))
       | 2 -&gt; (
      1193 "latexscan.mll"
</r></b>1250      <r>start_mbox ())
       | 3 -&gt; (
      1195 "latexscan.mll"
          raise (Misc.ScanError "Cannot find a \\mbox argument here, use braces"))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_mbox_arg_rec lexbuf n
</r>1255 
     <b><U>and</U><r> no_skip lexbuf = __ocaml_lex_no_skip_rec lexbuf 9
     </r><U>and</U><r> __ocaml_lex_no_skip_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
</r></b>1260  <r>1198 "latexscan.mll"
           ())
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_no_skip_rec lexbuf n
     
     <b><U>and</U></b> skip_blanks_pop lexbuf = __ocaml_lex_skip_blanks_pop_rec lexbuf 10
</r>1265 <b><U>and</U><r> __ocaml_lex_skip_blanks_pop_rec lexbuf state =
       </r><U>match</U><r> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
      1201 "latexscan.mll"
             skip_blanks_pop lexbuf)
</r></b>1270   <r>| 1 -&gt; (
      1202 "latexscan.mll"
             more_skip_pop lexbuf)
       | 2 -&gt; (
      1203 "latexscan.mll"
</r>1275         <r>())
       | 3 -&gt; (
      1205 "latexscan.mll"
         <b><U>if</U><r> not (empty stack_lexbuf) </r><U>then</U> <U>begin</U>
          <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U><m>
1280      </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
            prerr_endline "Poping lexbuf in skip_blanks" ;
            pretty_lexbuf lexbuf
          <b><U>end</U></b> ;
          skip_blanks_pop lexbuf
</r>1285    <b><U>end</U> <U>else</U><r> ())
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_blanks_pop_rec lexbuf n
     
     <b><U>and</U><r> more_skip_pop lexbuf = __ocaml_lex_more_skip_pop_rec lexbuf 11
     </r><U>and</U></b> __ocaml_lex_more_skip_pop_rec lexbuf state =
</r></b>1290   <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><r>
         0 -&gt; (
      1215 "latexscan.mll"
              top_par (par_val !in_table))
       | 1 -&gt; (
</r></b>1295  <r>1216 "latexscan.mll"
              skip_blanks_pop lexbuf)
       | 2 -&gt; (
      1218 "latexscan.mll"
         <b><U>if</U><r> not (empty stack_lexbuf) </r><U>then</U> <U>begin</U><m>
1300      </m><U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U>
          <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
            prerr_endline "Poping lexbuf in skip_blanks" ;
            pretty_lexbuf lexbuf
          <b><U>end</U></b> ;
</r>1305      <r>more_skip_pop lexbuf
        <b><U>end</U> <U>else</U></b> ())
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_more_skip_pop_rec lexbuf n
     
     <b><U>and</U></b> to_newline lexbuf = __ocaml_lex_to_newline_rec lexbuf 12
</r>1310 <b><U>and</U><r> __ocaml_lex_to_newline_rec lexbuf state =
       </r><U>match</U><r> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
      1228 "latexscan.mll"
              ())
</r></b>1315   <r>| 1 -&gt; (
      1229 "latexscan.mll"
              Out.put_char more_buff (Lexing.lexeme_char lexbuf 0) ;
             to_newline lexbuf)
       | 2 -&gt; (
</r>1320  <r>1232 "latexscan.mll"
         <b><U>if</U><r> not (empty stack_lexbuf) </r><U>then</U>
          <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U></b>
          to_newline lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_to_newline_rec lexbuf n
</r>1325 
     <r><b><U>and</U><r> skip_blanks lexbuf = __ocaml_lex_skip_blanks_rec lexbuf 13
     </r><U>and</U></b> __ocaml_lex_skip_blanks_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
</r>1330  <r>1237 "latexscan.mll"
             skip_blanks lexbuf)
       | 1 -&gt; (
      1238 "latexscan.mll"
             more_skip lexbuf)
</r>1335   <r>| 2 -&gt; (
      1239 "latexscan.mll"
             ())
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_blanks_rec lexbuf n
     
</r>1340 <b><U>and</U><r> more_skip lexbuf = __ocaml_lex_more_skip_rec lexbuf 14
     </r><U>and</U><r> __ocaml_lex_more_skip_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
      1242 "latexscan.mll"
</r></b>1345          <r>top_par (par_val !in_table))
       | 1 -&gt; (
      1243 "latexscan.mll"
              skip_blanks lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_more_skip_rec lexbuf n
</r>1350 
     <b><U>and</U><r> skip_spaces lexbuf = __ocaml_lex_skip_spaces_rec lexbuf 15
     </r><U>and</U><r> __ocaml_lex_skip_spaces_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
<m>1355  </m>1246 "latexscan.mll"
              ())
       | 1 -&gt; (
      1247 "latexscan.mll"
              ())
<m>1360   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_spaces_rec lexbuf n
     
     <b><U>and</U><r> skip_false lexbuf = __ocaml_lex_skip_false_rec lexbuf 16
     </r><U>and</U></b> __ocaml_lex_skip_false_rec lexbuf state =
       <b><U>match</U></b> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
1365     <r>0 -&gt; (
      1252 "latexscan.mll"
           <b><U>if</U><r> is_plain '%' </r><U>then</U></b> skip_comment lexbuf ;
            skip_false lexbuf)
       | 1 -&gt; (
</r>1370  <r>1255 "latexscan.mll"
           skip_false lexbuf)
       | 2 -&gt; (
      1257 "latexscan.mll"
           if_level := !if_level + 1 ;
</r>1375      <r>skip_false lexbuf)
       | 3 -&gt; (
      1260 "latexscan.mll"
           skip_false lexbuf)
       | 4 -&gt; (
</r>1380  <r>1262 "latexscan.mll"
           <b><U>if</U><r> !if_level = 0 </r><U>then</U></b> skip_blanks lexbuf
          <b><U>else</U></b> skip_false lexbuf)
       | 5 -&gt; (
      1265 "latexscan.mll"
</r>1385       <r>skip_false lexbuf)
       | 6 -&gt; (
      1267 "latexscan.mll"
           <b><U>if</U><r> !if_level = 0 </r><U>then</U> <U>begin</U></b>
             skip_blanks lexbuf
</r>1390      <b><U>end</U> <U>else</U> <U>begin</U><r>
            if_level := !if_level -1 ;
            skip_false lexbuf
          <b><U>end</U><r>)
       | 7 -&gt; (
<m>1395  </m>1273 "latexscan.mll"
           skip_false lexbuf)
       | 8 -&gt; (
      1274 "latexscan.mll"
           raise (Error "End of entry while skipping TeX conditional macro"))
<m>1400   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_false_rec lexbuf n
     
     </r><U>and</U></b> comment lexbuf = __ocaml_lex_comment_rec lexbuf 17
     <b><U>and</U><r> __ocaml_lex_comment_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
1405     <r>0 -&gt; (
      1278 "latexscan.mll"
          skip_comment lexbuf ; start_image_scan "" image lexbuf)
       | 1 -&gt; (
      1281 "latexscan.mll"
</r>1410      <r>latex2html_latexonly lexbuf)
       | 2 -&gt; (
      1283 "latexscan.mll"
         ())
       | 3 -&gt; (
</r>1415  <r>1285 "latexscan.mll"
          skip_to_end_latex lexbuf)
       | 4 -&gt; (
      1287 "latexscan.mll"
          skip_comment lexbuf ; more_skip lexbuf)
</r>1420   <r>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_comment_rec lexbuf n
     
     <b><U>and</U><r> skip_comment lexbuf = __ocaml_lex_skip_comment_rec lexbuf 18
     </r><U>and</U></b> __ocaml_lex_skip_comment_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><m>
1425     <r>0 -&gt; (
      1291 "latexscan.mll"
         <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b>
          prerr_endline ("Comment:"^lexeme lexbuf) ;
        <b><U>if</U><r> !flushing </r><U>then</U></b> Dest.flush_out () )
</r>1430   <r>| 1 -&gt; (
      1294 "latexscan.mll"
           raise (Misc.ScanError "Latex comment is not terminated"))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_comment_rec lexbuf n
     
</r>1435 </m><U>and</U></b> skip_to_end_latex lexbuf = __ocaml_lex_skip_to_end_latex_rec lexbuf 19
     <b><U>and</U><r> __ocaml_lex_skip_to_end_latex_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
      1298 "latexscan.mll"
</r>1440      </m></TT></r></m><r><TT>skip_comment lexbuf ; skip_spaces lexbuf)
       | 1 -&gt; (
      1300 "latexscan.mll"
          skip_to_end_latex lexbuf)
       | 2 -&gt; (
<m>1445  <r>1301 "latexscan.mll"
            fatal ("End of file in %BEGIN LATEX ... %END LATEX"))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_to_end_latex_rec lexbuf n
     
     ;;
</r>1450 
      <r>1302 "latexscan.mll"
     
     <b><U>let</U></b> _ = ()
     ;;
</r>1455 <w>(* A few subst definitions, with 2 optional arguments *)
     
     <r>def "\\makebox" (latex_pat ["" ; ""] 3)
         (Subst "\\warning{makebox}\\mbox{#3}") ;
     def "\\framebox" (latex_pat ["" ; ""] 3)
</r></w>1460     <r>(Subst "\\warning{framebox}\\fbox{#3}")
     ;;
     
     
     <b><U>let</U></b> check_alltt_skip lexbuf =
</r>1465   <b><U>if</U></b></m> not (effective !alltt) <b><U>then</U><r> skip_blanks lexbuf
     
     </r><U>and</U></b> skip_pop lexbuf =
       save_lexstate () ;
       skip_blanks_pop lexbuf ;
<m>1470   <r>restore_lexstate ()
     ;;
     
     <b><U>let</U><r> def_code name f = def_init name f
     </r><U>let</U></b> def_name_code name f = def_init name (f name)
</r>1475 <r>;;
     
     
     def_code "\\@hevea@percent"
         (<b><U>fun</U></b> lexbuf -&gt;
</r>1480       <b><U>if</U></b></m> effective !alltt || not (is_plain '%') <b><U>then</U> <U>begin</U>
             <U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><r>
             Dest.put lxm ;
             main lexbuf
           </r><U>end</U> <U>else</U> <U>begin</U><m>
1485         <r>comment lexbuf
           <b><U>end</U></b>)
     ;;
     
     def_code "\\@hevea@newline"
</r>1490     <r>(<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> lxm = complete_newline lexbuf <b><U>in</U>
           <U>let</U></b> nlnum = count_newlines lxm <b><U>in</U>
           <U>if</U></b> !Lexstate.withinLispComment
           <b><U>then</U> <U>begin</U><m>
1495         </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline "NL caught after LispComment" ;
             raise (Misc.EndOfLispComment nlnum) </r><w>(* QNC *)
           </w><U>end</U> <U>else</U> <U>begin</U>
             <U>if</U></b> effective !alltt <b><U>then</U> <U>begin</U></b>
               Dest.put_char '\n' ;
</r>1500           <r>Dest.put lxm
             <b><U>end</U> <U>else</U> <U>if</U></b> nlnum &gt;= 1 <b><U>then</U><r>
               expand_command main skip_blanks "\\par" lexbuf
             </r><U>else</U></b>
               Dest.put_separator ()
</r>1505        </m><U>end</U></b>)
     ;;
     
     <b><U>let</U><r> sub_sup lxm lexbuf =
       </r><U>if</U></b> effective !alltt || not (is_plain lxm) <b><U>then</U><r> Dest.put_char lxm
</r><m>1510   </m><U>else</U> <U>if</U></b> not !in_math <b><U>then</U> <U>begin</U></b>
         warning ("``"^Char.escaped lxm^"''occuring outside math mode") ;
         Dest.put_char lxm
       <b><U>end</U> <U>else</U> <U>begin</U>
         <U>let</U></b> sup,sub = <b><U>match</U><r> lxm </r><U>with</U><m>
1515       <r>'^' -&gt;
             <b><U>let</U><r> sup = save_arg lexbuf </r><U>in</U>
             <U>let</U></b> sub = save_sub lexbuf <b><U>in</U></b>
             sup,unoption sub
         | '_'   -&gt;
</r>1520         </m><U>let</U></b> sub = save_arg lexbuf <b><U>in</U>
             <U>let</U></b> sup = save_sup lexbuf <b><U>in</U><r>
             unoption sup,sub
         | _ -&gt; </r><U>assert</U> <U>false</U> <U>in</U></b>
         Dest.standard_sup_sub (scan_this_arg main) (<b><U>fun</U><r> () -&gt; ()) sup sub !display
</r><m>1525   </m><U>end</U></b>
     ;;
     
     def_code "\\@hevea@underscore" (<b><U>fun</U><r> lexbuf -&gt; sub_sup '_' lexbuf) ;
     def_code "\\@hevea@circ" (</r><U>fun</U></b> lexbuf -&gt; sub_sup '^' lexbuf)
<m>1530 <r>;;
     
     def_code "\\mathop"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> symbol = save_arg lexbuf <b><U>in</U><m>
1535     </m><U>let</U></b> {limits=limits ; sup=sup ; sub=sub} = save_sup_sub lexbuf <b><U>in</U>
         <U>begin</U> <U>match</U></b> limits <b><U>with</U><r>
         | (Some Limits|None) </r><U>when</U></b> !display -&gt;
             Dest.limit_sup_sub
               (scan_this_arg main)
</r>1540           <r>(<b><U>fun</U><r> _ -&gt; scan_this_arg main symbol) sup sub !display
         | (Some IntLimits) </r><U>when</U></b> !display -&gt;
             Dest.int_sup_sub <b><U>true</U><r> 3
               (scan_this_arg main)
               (</r><U>fun</U></b> () -&gt; scan_this_arg main symbol)
</r>1545           <r>sup sub !display
         | _ -&gt;
             scan_this_arg main symbol ;
             Dest.standard_sup_sub
               (scan_this_arg main)
</r>1550           <r>(<b><U>fun</U><r> _ -&gt; ()) sup sub !display
         </r><U>end</U></b>)
     ;;
     
     
</r>1555 <r>def_code "\\@hevea@obrace"
         (<b><U>fun</U><r> _ -&gt;
           </r><U>if</U></b> !activebrace &amp;&amp; is_plain '{' <b><U>then</U><r>
             top_open_group ()
           </r><U>else</U> <U>begin</U><m>
1560         <r>Dest.put_char '{'
           <b><U>end</U><r>) ;
     
     def_code "\\bgroup"
         (</r><U>fun</U></b> lexbuf -&gt;
</r>1565       <r>top_open_group () ;
           check_alltt_skip lexbuf)
     ;;
     
     def_code "\\@hevea@cbrace"
</r>1570     <r>(<b><U>fun</U><r> _ -&gt;
           </r><U>if</U></b> !activebrace &amp;&amp; is_plain '}' <b><U>then</U> <U>begin</U></b>
             top_close_group ()
           <b><U>end</U> <U>else</U> <U>begin</U></b>
             Dest.put_char '}'
</r>1575       </m><U>end</U></b>) ;
     def_code "\\egroup"
         (<b><U>fun</U></b> lexbuf -&gt;
           top_close_group () ;
           check_alltt_skip lexbuf)
</r>1580 <r>;;
     
     
     def_code "\\@hevea@tilde"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>1585     <b><U>if</U></b></m> effective !alltt || not (is_plain '~') <b><U>then</U><r>
           Dest.put_char '~'
         </r><U>else</U></b> Dest.put_nbsp ())
     ;;
     
<m>1590 <r>def_code "\\@hevea@question"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>if</U></b> if_next_char '`' lexbuf <b><U>then</U> <U>begin</U></b>
           gobble_one_char lexbuf ;
           <b><U>if</U><r> effective !alltt </r><U>then</U></b> Dest.put "?`"
</r>1595       <b><U>else</U></b></m>
             Dest.put (Dest.iso '')
         <b><U>end</U> <U>else</U></b>
           Dest.put_char  '?')
     ;;
<m>1600 <r>def_code "\\@hevea@excl"
       (<b><U>fun</U><r> lexbuf -&gt;
          </r><U>if</U></b> if_next_char '`' lexbuf <b><U>then</U> <U>begin</U></b>
            gobble_one_char lexbuf ;
            <b><U>if</U><r> effective !alltt </r><U>then</U></b> Dest.put "!`"
</r>1605        <b><U>else</U></b></m> Dest.put (Dest.iso '')
          <b><U>end</U> <U>else</U></b>
            Dest.put_char '!')
     ;;
     
<m>1610 <b><U>let</U><r> get_this_main arg = get_this_string main arg
     
     </r><U>let</U><r> check_this_main s =
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b>
         prerr_endline ("check_this: ``"^s^"''");
<m>1615   </m>start_normal (get_subst ()) ;
       <b><U>let</U><r> save_par = Dest.forget_par () </r><U>in</U></b>
       Dest.open_block "TEMP" "";
       <b><U>let</U></b> r =
         </r><U>try</U></b>
1620       </m>scan_this main s ;
           <b><U>true</U>
         <U>with</U></b>
         |  x -&gt; <b><U>false</U> <U>in</U></b>
       Dest.erase_block "TEMP" ;
<m>1625   </m>Dest.par save_par ;
       end_normal () ;
       <b><U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
         prerr_endline ("check_this: ``"^s^"'' = "^sbool r);
       r
</r><m>1630 
     </m><U>let</U></b> get_prim_onarg arg =
       <b><U>let</U><r> plain_sub = is_plain '_'
       </r><U>and</U></b> plain_sup = is_plain '^'
       <b><U>and</U><r> plain_dollar = is_plain '$'
</r><m>1635   </m><U>and</U></b> plain_amper = is_plain '&amp;' <b><U>in</U><r>
       unset_plain '_' ; unset_plain '^' ; unset_plain '$' ; unset_plain '&amp;' ;
       </r><U>let</U></b> r = do_get_this
           start_normal end_normal
           Dest.nostyle
<m>1640       <r>main arg <b><U>in</U></b>
       plain_back plain_sub '_' ; plain_back plain_sup '^' ;
       plain_back plain_dollar '$' ; plain_back plain_amper '&amp;' ;
       r
     
</r>1645 <b><U>let</U></b></m> get_prim s = get_prim_onarg (string_to_arg s)
     
     <b><U>let</U><r> get_prim_arg lexbuf =
       </r><U>let</U></b> arg = save_arg lexbuf <b><U>in</U><r>
       get_prim_onarg arg
</r><m>1650 
     </m><U>and</U></b> get_prim_opt def lexbuf =
       <b><U>let</U><r> arg = save_opt def lexbuf </r><U>in</U></b>
       get_prim_onarg arg
     
<m>1655 
     <b><U>let</U></b></m> get_csname lexbuf =
       protect_save_string
         (<b><U>fun</U><r> lexbuf -&gt; Save.csname lexbuf get_prim Subst.subst_this)
         lexbuf
</r><m>1660 
     
     </m><U>let</U></b> def_fun name f =
       def_code name
         (<b><U>fun</U><r> lexbuf -&gt;
<m>1665       <b><U>let</U><r> arg = subst_arg lexbuf </r><U>in</U><r>
           scan_this main (f arg))
     ;;
     
     <w>(* Paragraphs *)
<m>1670 <b><U>let</U><r> do_unskip () =
      </r><U>let</U><r> _ = Dest.forget_par () <b><U>in</U></b>
      Dest.unskip ()
     ;;
     
</r></b>1675 <r>def_code "\\unskip"
         (<b><U>fun</U></b> lexbuf -&gt;
           do_unskip () ;
           check_alltt_skip lexbuf)
     ;;
</r>1680 
     <r>def_code "\\par"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>match</U></b> par_val !in_table <b><U>with</U></b>
         | None -&gt;
</r>1685         <r>Dest.put_char ' ' ;
             check_alltt_skip lexbuf
         | pval -&gt;
             top_par pval ;
             check_alltt_skip lexbuf)
</r>1690 
     <r>;;
     
     <w>(* Styles and packages *)
     <b><U>let</U></b></w> do_documentclass command lexbuf =
</r>1695   <r>Save.start_echo () ;
       <b><U>let</U><r> {arg=opt_arg} = save_opt "" lexbuf </r><U>in</U>
       <U>let</U></b> {arg=arg} =  save_arg lexbuf <b><U>in</U>
       <U>let</U></b> real_args = Save.get_echo () <b><U>in</U>
       <U>begin</U> <U>try</U> <U>if</U></b> not !styleloaded <b><U>then</U><m>
1700     <r>input_file 0 main (arg^".hva")
       <b><U>with</U><r>
         Myfiles.Except | Myfiles.Error _ -&gt;
           raise (Misc.ScanError ("No base style"))
       </r><U>end</U></b> ;
</r>1705   </m><U>if</U></b> command = "\\documentstyle" <b><U>then</U> <U>begin</U>
         <U>let</U> <U>rec</U></b> read_packages = <b><U>function</U></b>
           | [] -&gt; ()
           | pack :: rest -&gt;
               scan_this main ("\\usepackage{"^pack^"}") ;
</r>1710           <r>read_packages rest <b><U>in</U><r>
         read_packages
           (Save.cite_arg (Lexing.from_string ("{"^opt_arg^"}")))
       </r><U>end</U></b> ;
       Image.start () ;
</r>1715   <r>Image.put command ;
       Image.put real_args ;
       Image.put_char '\n' ;
       Dest.set_out (mk_out_file ()) ;
       Dest.stop ()
</r>1720 <r>;;
     
     def_name_code  "\\documentstyle" do_documentclass ;
     def_name_code  "\\documentclass" do_documentclass
     ;;
</r>1725 
     
     <b><U>let</U><r> do_input lxm lexbuf =
       Save.start_echo () ;
       </r><U>let</U><r> arg = get_prim_arg lexbuf </r><U>in</U></b>
1730   <b><U>let</U><r> echo_arg = Save.get_echo () </r><U>in</U>
       <U>if</U><r> lxm &lt;&gt; "\\include" || check_include arg <b><U>then</U> <U>begin</U>
         <U>let</U></b> filename =
           <b><U>if</U><r> lxm = "\\bibliography" </r><U>then</U></b> Parse_opts.base_in^".bbl"
           <b><U>else</U></b> arg </r><U>in</U></b>
1735 
         <b><U>begin</U> <U>try</U><r> input_file !verbose main filename
         <b><U>with</U><r> Myfiles.Except -&gt;
           Image.put lxm ;
           Image.put echo_arg ;
<m>1740       </m>Image.put "\n" ;
         | Myfiles.Error _ -&gt; ()
         </r><U>end</U>
       <U>end</U></b>
     ;;
<m>1745 
     </m>def_code "\\input" (do_input "\\input") ;
     def_code "\\include" (do_input "\\include") ;
     def_code "\\bibliography" (do_input "\\bibliography")
     ;;
<m>1750 
     <w>(* Command definitions *)
     
     <b><U>let</U><r> do_newcommand lxm lexbuf =
       Save.start_echo () ;
<m>1755   <b><U>let</U><r> name = get_csname lexbuf </r><U>in</U>
       <U>let</U><r> nargs = save_opts ["0" ; ""] lexbuf <b><U>in</U>
       <U>let</U></b> body = subst_body lexbuf <b><U>in</U>
       <U>let</U></b> echo () =
         <b><U>if</U></b> echo_toimage () &amp;&amp; lxm &lt;&gt; "\\@forcecommand" </r><U>then</U> <U>begin</U></b>
1760       </m>Image.put lxm ;
           Image.put (Save.get_echo ()) ;
           Image.put_char '\n'
         </r><U>end</U> <U>in</U>
       <U>let</U><r> nargs,(def,defval) = <b><U>match</U></b> nargs </r><U>with</U></b></w>
1765     </m>[a1 ; a2] -&gt;
           Get.get_int (from_ok a1),
           (<b><U>match</U><r> a2 </r><U>with</U></b>
           | {arg=No s ; subst=env} -&gt; <b><U>false</U><r>,mkarg s env
           | {arg=Yes s ; subst=env} -&gt; </r><U>true</U></b>,mkarg s env)
<m>1770   </m>| _ -&gt; <b><U>assert</U> <U>false</U> <U>in</U>
       <U>let</U></b> pat =
         latex_pat (<b><U>if</U><r> def </r><U>then</U></b> [do_subst_this defval] <b><U>else</U><r> []) nargs </r><U>in</U>
       <U>match</U></b> lxm <b><U>with</U><r>
       | "\\@forcecommand" -&gt; Latexmacros.def name pat (Subst body)
<m>1775   </m>| "\\newcommand"|"\\newcommand*"    -&gt;
           echo () ;
           </r><U>if</U></b> Latexmacros.exists name <b><U>then</U></b>
             warning ("Ignoring (re-)definition of ``"^name^"'' by \\newcommand")
           </r><U>else</U> <U>begin</U></b>
1780         <r>Latexmacros.def name pat (Subst body)
           <b><U>end</U><r>
       | "\\renewcommand"|"\\renewcommand*" -&gt;
           </r><U>if</U></b> not (Latexmacros.exists name) <b><U>then</U> <U>begin</U></b>
             warning ("Defining ``"^name^"'' by \\renewcommand")
</r>1785       <b><U>end</U> <U>else</U><r>
             echo () ;
           Latexmacros.def name pat (Subst body)
       | _                -&gt;
           echo () ;
<m>1790       <b><U>if</U><r> not (Latexmacros.exists name) </r><U>then</U><r>
             Latexmacros.def name pat (Subst body)
     ;;
     
     def_name_code "\\renewcommand" do_newcommand  ;
<m>1795 </m>def_name_code "\\renewcommand*" do_newcommand  ;
     def_name_code "\\newcommand" do_newcommand ;
     def_name_code "\\newcommand*" do_newcommand ;
     def_name_code "\\providecommand" do_newcommand ;
     def_name_code "\\providecommand*" do_newcommand ;
<m>1800 </m>def_name_code "\\@forcecommand" do_newcommand
     ;;
     
     def_name_code "\\newcolumntype"
       (<b><U>fun</U><r> lxm lexbuf -&gt;
<m>1805     </m>Save.start_echo () ;
         </r><U>let</U></b> old_raw = !raw_chars <b><U>in</U><r>
         raw_chars := </r><U>true</U></b> ;
         <b><U>let</U><r> name = get_prim_arg lexbuf </r><U>in</U></b>
         raw_chars := old_raw ;
<m>1810     <b><U>let</U><r> nargs = save_opt "0" lexbuf </r><U>in</U>
         <U>let</U><r> body = subst_body lexbuf <b><U>in</U>
         <U>let</U></b> rest = Save.get_echo () <b><U>in</U>
         <U>if</U></b> echo_toimage () <b><U>then</U><r>
           Image.put (lxm^rest^"\n") ;
<m>1815     <b><U>let</U><r> col_cmd = Misc.column_to_command name </r><U>in</U>
         <U>if</U><r> Latexmacros.exists col_cmd <b><U>then</U></b>
           warning
             ("Not (re)-defining column type ``"^name^"'' with \\newcolumntype")
         </r><U>else</U></b>
1820       </m>Latexmacros.def
             col_cmd
             (latex_pat [] (Get.get_int nargs))
             (Subst body))
     ;;
<m>1825 
     <b><U>let</U><r> do_newenvironment lxm lexbuf =
       Save.start_echo () ;
       </r><U>let</U><r> name = get_prim_arg lexbuf <b><U>in</U>
       <U>let</U></b> nargs,optdef = <b><U>match</U></b> save_opts ["0" ; ""] lexbuf </r><U>with</U></b>
1830   </m>|  [x ; y ] -&gt; x,y
       | _ -&gt; </r><U>assert</U> <U>false</U> <U>in</U>
       <U>let</U></b> body1 = subst_body lexbuf <b><U>in</U>
       <U>let</U></b> body2 = subst_body lexbuf <b><U>in</U>
       <U>if</U></b> echo_toimage () </r><U>then</U></b>
1835     </m>Image.put (lxm^Save.get_echo ()^"\n") ;
     
       <b><U>let</U><r> do_defs () =
         Latexmacros.def
           (start_env name)
<m>1840       </m>(latex_pat
              (</r><U>match</U></b> optdef <b><U>with</U><r>
              | {arg=No _}    -&gt; []
              | {arg=Yes s ; subst=env} -&gt; [do_subst_this (mkarg s env)])
              (</r><U>match</U></b> nargs </r><U>with</U></b>
1845          </m>| {arg=No _} -&gt; 0
              | {arg=Yes s ; subst=env} -&gt; Get.get_int (mkarg s env)))
           (Subst body1) ;
         Latexmacros.def (end_env name)  zero_pat (Subst body2) </r><U>in</U></b>
     
1850   <b><U>if</U><r> lxm = "\\newenvironment" || lxm = "\\newenvironment*" </r><U>then</U>
         <U>if</U><r>
           Latexmacros.exists (start_env name) ||
           Latexmacros.exists (start_env name)
         </r><U>then</U></b>
1855       <r>warning
             ("Not (re)-defining environment ``"^name^"'' with "^lxm)
         <b><U>else</U><r>
           do_defs ()
       </r><U>else</U> <U>begin</U><m>
1860     </m><U>if</U></b>
           not (Latexmacros.exists (start_env name) &amp;&amp;
                Latexmacros.exists (start_env name))
         <b><U>then</U></b>
           warning
</r>1865         <r>("Defining environment ``"^name^"'' with "^lxm) ;
         do_defs ()
       <b><U>end</U></b>
     ;;
     
</r>1870 <r>def_name_code "\\newenvironment" do_newenvironment ;
     def_name_code "\\newenvironment*" do_newenvironment ;
     def_name_code  "\\renewenvironment" do_newenvironment ;
     def_name_code  "\\renewenvironment*" do_newenvironment
     ;;
</r>1875 
     <b><U>let</U><r> do_newcounter name within =
       </r><U>try</U><r>
         Counter.def_counter name within ;
         Latexmacros.global_def
<m>1880       </m>("\\the"^name) zero_pat (Subst ("\\arabic{"^name^"}"))
       <b><U>with</U><r>
       | Failed -&gt; ()
     
     </r><U>let</U></b> do_newtheorem lxm lexbuf =
<m>1885   </m>Save.start_echo () ;
       <b><U>let</U><r> name = get_prim_arg lexbuf </r><U>in</U>
       <U>let</U></b> numbered_like = <b><U>match</U><r> save_opts [""] lexbuf </r><U>with</U></b>
       |  [x] -&gt; x
       | _ -&gt; </r><U>assert</U> <U>false</U> <U>in</U></b>
1890   <b><U>let</U><r> caption = subst_arg lexbuf </r><U>in</U>
       <U>let</U><r> within =  <b><U>match</U><r> save_opts [""] lexbuf </r><U>with</U></b>
       | [x] -&gt; x
       | _   -&gt; <b><U>assert</U> <U>false</U> <U>in</U>
       <U>if</U></b> echo_global_toimage () </r><U>then</U></b>
1895     <r>Image.put (lxm^Save.get_echo ()^"\n") ;
       <b><U>let</U><r> cname = </r><U>match</U></b> numbered_like,within <b><U>with</U></b>
         {arg=No _},{arg=No _} -&gt;
           do_newcounter  name "" ; name
       | _,{arg=Yes _} -&gt;
</r>1900       <b><U>let</U><r> within = get_prim_onarg (from_ok within) </r><U>in</U><r>
           do_newcounter name within ; name
       | {arg=Yes _},_ -&gt;
           get_prim_onarg (from_ok numbered_like) <b><U>in</U><r>
       Latexmacros.global_def
<m>1905     </m>(start_env name) (latex_pat [""] 1)
         (Subst
            ("\\begin{flushleft}\\refstepcounter{"^cname^"}{\\bf "^caption^"~"^
             "\\the"^cname^"}\\quad\\ifoptarg{\\purple[#1]\\quad}\\fi\\em")) ;
       Latexmacros.global_def
<m>1910     </m>(end_env name) zero_pat
         (Subst "\\end{flushleft}")
     ;;
     
     def_name_code "\\newtheorem" do_newtheorem ;
<m>1915 </m>def_name_code "\\renewtheorem" do_newtheorem
     ;;
     
     <w>(* Command definitions, TeX style *)
     
<m>1920 <b><U>let</U><r> do_def global lxm lexbuf =
       Save.start_echo () ;
       </r><U>let</U><r> name = get_csname lexbuf <b><U>in</U><r>
       Save.skip_blanks_init lexbuf ;
       </r><U>let</U></b> name,args_pat,body =
<m>1925     <b><U>if</U><r> top_level () </r><U>then</U>
           <U>let</U><r> args_pat = Save.defargs lexbuf <b><U>in</U>
           <U>let</U></b> {arg=body} = save_arg lexbuf <b><U>in</U></b>
           name,args_pat,body
         </r><U>else</U></b>
1930       <b><U>let</U><r> args_pat =
             Save.defargs
               (Lexing.from_string
                  (subst_this (Save.get_defargs lexbuf))) </r><U>in</U>
           <U>let</U><r> body = subst_body lexbuf </r><U>in</U></b>
1935       </m>name,args_pat,body <b><U>in</U>
       <U>let</U></b> real_args = Save.get_echo () <b><U>in</U>
       <U>if</U></b> echo_toimage () || (global &amp;&amp; echo_global_toimage ()) <b><U>then</U> <U>begin</U></b>
         Image.put  (lxm^real_args) ;
         Image.put_char '\n'
<m>1940   <b><U>end</U><r> ;
       (</r><U>if</U><r> global <b><U>then</U><r> global_def </r><U>else</U></b> def)
         name ([],args_pat) (Subst body)
     ;;
     
<m>1945 </m>def_name_code "\\def" (do_def <b><U>false</U><r>) ;
     def_name_code "\\gdef" (do_def </r><U>true</U></b>)
     ;;
     
     <b><U>let</U><r> do_let global lxm lexbuf =
<m>1950   </m>Save.start_echo () ;
       </r><U>let</U></b> name = get_csname lexbuf <b><U>in</U><r>
       Save.skip_equal lexbuf ;
       </r><U>let</U></b> alt = get_csname lexbuf <b><U>in</U>
       <U>let</U></b> real_args = Save.get_echo () </r><U>in</U></b>
1955   <b><U>try</U>
         <U>let</U><r> nargs,body = Latexmacros.find_fail alt <b><U>in</U><r>
         (</r><U>if</U></b> global <b><U>then</U><r> global_def </r><U>else</U></b> def)
           name nargs body ;
         <b><U>if</U></b> echo_toimage () || (global &amp;&amp; echo_global_toimage ()) </r><U>then</U> <U>begin</U></b>
1960       </m>Image.put lxm ;
           Image.put real_args ;
           Image.put "\n"
         </r><U>end</U>
       <U>with</U></b>
1965   </m></w>| Failed -&gt;
           warning ("Not binding "^name^" with "^lxm^", command "^alt^" does not exist")
     ;;
     
     def_name_code "\\let" (do_let </r><U>false</U></b>) ;
<m>1970 </m>;;
     
     <b><U>let</U><r> do_global lxm lexbuf =
       </r><U>let</U></b> next = subst_arg lexbuf <b><U>in</U>
       <U>begin</U> <U>match</U></b> next </r><U>with</U></b>
1975   <r>| "\\def" -&gt; do_def <b><U>true</U><r> (lxm^next) lexbuf
       | "\\let" -&gt; do_let </r><U>true</U></b> (lxm^next) lexbuf
       | _       -&gt; warning "Ignored \\global"
       <b><U>end</U></b>
     ;;
</r>1980 
     
     
     <r>def_name_code "\\global" do_global
     ;;
</r>1985 
     </m>(* TeXisms *)
     </w>def_code "\\noexpand"
       (<b><U>fun</U><r> lexbuf -&gt;
          </r><U>let</U></b> arg = subst_arg lexbuf </r><U>in</U></b>
1990      </m>Dest.put arg)
     ;;
     
     def_code "\\execafter"
       (</r><U>fun</U></b> lexbuf -&gt;
<m>1995      <b><U>let</U><r> arg = save_arg lexbuf </r><U>in</U>
          <U>let</U><r> next_arg = save_arg lexbuf <b><U>in</U>
          <U>let</U></b> cur_subst = get_subst () <b><U>in</U><r>
          scan_this_may_cont main lexbuf cur_subst next_arg ;
          scan_this_may_cont main lexbuf cur_subst arg)
<m>2000 </m>;;
     
     
     def_code "\\csname"
       (</r><U>fun</U></b> lexbuf -&gt;
<m>2005     </m>skip_blanks lexbuf ;
         <b><U>let</U><r> name = "\\"^get_prim (Save.incsname lexbuf) </r><U>in</U></b>
         check_alltt_skip lexbuf ;
         expand_command main skip_blanks name lexbuf)
     ;;
<m>2010 
     </m>def_code "\\string"
        (<b><U>fun</U><r> lexbuf -&gt;
          </r><U>let</U></b> arg = subst_arg lexbuf <b><U>in</U><r>
          Dest.put arg)
<m>2015 </m>;;
     
     </r><U>let</U></b> get_num_arg lexbuf =
       Save.num_arg lexbuf (<b><U>fun</U><r> s -&gt; Get.get_int (string_to_arg s))
     ;;
<m>2020 
     
     <b><U>let</U><r> top_plain c =
       </r><U>if</U><r> not (is_plain c) <b><U>then</U> <U>begin</U></b>
         set_plain c ;
<m>2025     </m>fun_register (<b><U>fun</U><r> () -&gt; unset_plain c)
       </r><U>end</U>
     
     <U>and</U></b> top_unplain c =
       <b><U>if</U></b> is_plain c </r><U>then</U> <U>begin</U></b>
2030     </m>unset_plain c ;
         fun_register (</r><U>fun</U></b> () -&gt; set_plain c)
       <b><U>end</U><r>
     ;;
     
<m>2035 </m>def_code "\\catcode"
        (</r><U>fun</U></b> lexbuf -&gt;
          <b><U>let</U><r> char = Char.chr
              (Get.get_int (save_arg_with_delim "=" lexbuf)) </r><U>in</U>
          <U>let</U></b> code = get_num_arg lexbuf </r><U>in</U></b>
2040      <b><U>begin</U> <U>match</U><r> char,code <b><U>with</U><r>
          | ('\\',0) | ('{',1) | ('}',2) | ('$',3) | ('&amp;' ,4) |
            ('#',6) | ('^',7) | ('_',8) | ('~',13) |
            ('%',14) -&gt; top_plain char
          | ('{',(11|12)) | ('}',(11|12)) | ('$',(11|12)) | ('&amp;' ,(11|12)) |
<m>2045        </m>('#',(11|12)) | ('^',(11|12)) | ('_',(11|12)) | ('~',(11|12)) |
            ('%',(11|12)) | ('\\',(11|12)) -&gt; top_unplain char
          | _ -&gt;
              warning "This \\catcode operation is not permitted"
          </r><U>end</U></b> ;
<m>2050      </m>main lexbuf)
     ;;
     
     def_code "\\chardef"
       (<b><U>fun</U><r> lexbuf -&gt;
<m>2055     <b><U>let</U><r> csname = get_csname lexbuf </r><U>in</U><r>
         Save.skip_equal lexbuf ;
         <b><U>let</U><r> i = get_num_arg lexbuf </r><U>in</U></b>
         Latexmacros.def csname zero_pat (Subst (string_of_int i)))
     ;;
<m>2060 
     <w>(* Complicated use of output blocks *)
     <r>def_code "\\left"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> dprev = !display <b><U>in</U><m>
2065     <r>Stack.push stack_display dprev ;
         display := <b><U>true</U><r> ;
         </r><U>if</U></b> not dprev <b><U>then</U><r>
           top_open_display () ;
         </r><U>let</U></b> delim = subst_arg lexbuf <b><U>in</U><m>
2070     </m><U>let</U></b> {sub=sub ; sup=sup} = save_sup_sub lexbuf <b><U>in</U><r>
         Dest.left delim
           (</r><U>fun</U></b> vsize -&gt;
             Dest.int_sup_sub <b><U>false</U><r> vsize
               (scan_this_arg main) (</r><U>fun</U></b> () -&gt; ())  sup sub <b><U>true</U></b>))
</r>2075 <r>;;
     
     <w>(* Display is true *)
     </w>def_code "\\right"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>2080     </m><U>let</U></b> delim = subst_arg lexbuf <b><U>in</U>
         <U>let</U></b> vsize = Dest.right delim <b><U>in</U>
         <U>let</U></b> {sup=sup ; sub=sub} = save_sup_sub lexbuf <b><U>in</U>
         <U>let</U></b> do_what = (<b><U>fun</U><r> () -&gt; ()) </r><U>in</U></b>
         Dest.int_sup_sub <b><U>false</U><r> vsize
<m>2085       </m>(scan_this_arg main) do_what sup sub !display ;
         </r><U>let</U></b> dprev = Stack.pop stack_display <b><U>in</U>
         <U>if</U></b> not dprev <b><U>then</U><r> top_close_display () ;
         display := dprev)
     ;;
<m>2090 
     </m>def_code "\\over"
        (</r><U>fun</U></b> lexbuf -&gt;
          Dest.over !display lexbuf;
          skip_blanks lexbuf)
<m>2095 </m>;;
     
     <b><U>let</U><r> check_not = </r><U>function</U></b>
       | "\\in" -&gt; "\\notin"
       | "="    -&gt; "\\neq"
<m>2100   </m>| "\\subset" -&gt; "\\notsubset"
       | s -&gt; "\\neg\\:"^s
     ;;
     
     def_fun "\\not" check_not
<m>2105 </m>;;
     
     def_code "\\uppercase"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = save_arg lexbuf <b><U>in</U><m>
2110     </m><U>let</U></b> old_case = !case <b><U>in</U><r>
         case := Upper ;
         scan_this_arg main arg ;
         case := old_case) ;
     def_code "\\lowercase"
<m>2115   </m>(</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> arg = save_arg lexbuf </r><U>in</U>
         <U>let</U></b> old_case = !case <b><U>in</U></b>
         case := Lower ;
         scan_this_arg main arg ;
<m>2120     </m>case := old_case)
     ;;
     
     </r>(* list items *)
     <r>def_code "\\@li" (<b><U>fun</U><r> _ -&gt; Dest.item ()) ;
<m>2125 </m>def_code "\\@linum" (</r><U>fun</U></b> _ -&gt; Dest.nitem ()) ;
     def_code "\\@dt"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = subst_arg lexbuf <b><U>in</U></b>
         Dest.ditem (scan_this main) arg ;
<m>2130     </m>check_alltt_skip lexbuf)
     ;;
     
     
     </r>(* Html primitives *)
</w>2135 </m>def_code "\\@open"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> tag = get_prim_arg lexbuf <b><U>in</U>
         <U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U><r>
         top_open_block tag arg)
<m>2140 </m>;;
     
     def_code "\\@insert"
       (</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U></b> tag = get_prim_arg lexbuf </r><U>in</U></b>
2145     <b><U>let</U><r> arg = get_prim_arg lexbuf </r><U>in</U><r>
         Dest.insert_block tag arg )
     ;;
     
     def_code "\\@close"
<m>2150   </m>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> tag = get_prim_arg  lexbuf <b><U>in</U><r>
         top_close_block tag)
     ;;
     
<m>2155 </m>def_code "\\@print"
       (</r><U>fun</U></b> lexbuf -&gt;
               <b><U>let</U><r> {arg=arg} = save_arg lexbuf </r><U>in</U></b>
               Dest.put arg) ;
     ;;
<m>2160 
     </m>def_code "\\@printnostyle"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> {arg=arg} =  save_arg lexbuf <b><U>in</U><r>
         top_open_group () ;
<m>2165     </m>Dest.nostyle () ;
         Dest.put arg ;
         top_close_group ())
     ;;
     
<m>2170 </m>def_code "\\@getprintnostyle"
       (</r><U>fun</U></b> lexbuf -&gt;
         top_open_group () ;
         Dest.nostyle () ;
         <b><U>let</U></b> arg = get_prim_arg lexbuf </r><U>in</U></b>
2175     </m>Dest.put arg ;
         top_close_group ())
     ;;
     
     def_code "\\@getprint"
<m>2180   </m>(</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> arg = get_prim_arg lexbuf </r><U>in</U>
         <U>let</U></b> buff = Lexing.from_string arg <b><U>in</U><r>
         Dest.put (Save.tagout buff)) ;
     ;;
<m>2185 
     </m>def_code "\\@subst"
       (</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> arg = subst_arg lexbuf </r><U>in</U></b>
         Dest.put arg)
<m>2190 </m>;;
     
     def_code "\\@notags"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = save_arg lexbuf </r><U>in</U></b>
2195     <b><U>let</U><r> arg = get_this_arg main arg </r><U>in</U>
         <U>let</U><r> r =
           <b><U>let</U><r> buff = Lexing.from_string arg </r><U>in</U></b>
           Save.tagout buff <b><U>in</U><r>
         Dest.put r)
<m>2200 </m>;;
     def_code "\\@anti"
       (</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> arg = save_arg lexbuf </r><U>in</U>
         <U>let</U></b> envs = get_style main arg </r><U>in</U></b>
2205     <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U><r>
           prerr_string ("Anti result: ") ;
           List.iter
             (</r><U>fun</U><r> s -&gt;
               prerr_string (Element.pretty_text s^", ")) envs ;
<m>2210       </m>prerr_endline ""
         </r><U>end</U><r> ;
         Dest.erase_mods envs)
     ;;
     def_code "\\@style"
<m>2215   </m>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U><r>
         Dest.open_mod (Style arg) )
     ;;
     def_code "\\@fontcolor"
<m>2220   </m>(</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> arg = get_prim_arg lexbuf </r><U>in</U></b>
         Dest.open_mod (Color arg))
     ;;
     def_code "\\@fontsize"
<m>2225   </m>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = save_arg lexbuf <b><U>in</U><r>
         Dest.open_mod (Font (Get.get_int arg)) )
     ;;
     def_code "\\@nostyle"
<m>2230         </m>(</r><U>fun</U></b> lexbuf -&gt; Dest.nostyle () ; check_alltt_skip lexbuf)
     ;;
     def_code "\\@clearstyle"
             (<b><U>fun</U><r> lexbuf -&gt; Dest.clearstyle ()  ; check_alltt_skip lexbuf)
     ;;
<m>2235 </m>def_code "\\@incsize"
       (</r><U>fun</U></b> lexbuf -&gt;
               <b><U>let</U><r> arg = save_arg lexbuf </r><U>in</U></b>
               inc_size (Get.get_int arg) )
     ;;
<m>2240 </m>def_code "\\htmlcolor"
       (<b><U>fun</U><r> lexbuf -&gt;
               </r><U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U><r>
               Dest.open_mod (Color ("\"#"^arg^"\"")) )
     ;;
<m>2245 
     </m>def_code "\\usecounter"
       (</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> arg = get_prim_arg lexbuf </r><U>in</U></b>
         Counter.set_counter arg 0 ;
<m>2250     </m>scan_this main ("\\let\\@currentlabel\\the"^arg) ;
         Dest.set_dcount arg )
     ;;
     def_code "\\@fromlib"
       (<b><U>fun</U><r> lexbuf -&gt;
<m>2255           <b><U>let</U><r> arg = get_prim_arg lexbuf </r><U>in</U><r>
               start_lexstate ();
               Mysys.put_from_file (Filename.concat Mylib.libdir arg) Dest.put;
               restore_lexstate ())
     ;;
<m>2260 </m>def_code "\\@imageflush"
       (<b><U>fun</U><r> lexbuf -&gt;
         iput_newpage () ;
         check_alltt_skip lexbuf)
     ;;
<m>2265 </m>def_code "\\textalltt"
       (</r><U>fun</U></b> lexbuf -&gt;
            <b><U>let</U><r> opt = get_prim_opt "CODE" lexbuf </r><U>in</U>
            <U>let</U></b> arg = save_arg lexbuf <b><U>in</U>
            <U>let</U></b> old = !alltt </r><U>in</U></b>
2270        </m>scan_this main "\\mbox{" ;
            alltt := Inside ;
            Dest.open_group opt ;
            scan_this_arg main arg ;
            Dest.close_group () ;
<m>2275        </m>scan_this main "}" ;
            alltt := old )
     ;;
     def_code "\\@itemdisplay"
       (</r><U>fun</U></b> lexbuf -&gt; Dest.force_item_display ())
<m>2280 </m>;;
     def_code "\\@br"
       (<b><U>fun</U><r> lexbuf -&gt; Dest.skip_line ())
     ;;
     
<m>2285 
     <w>(* TeX conditionals *)
     <b><U>let</U><r> testif cell lexbuf =
       </r><U>if</U><r> !cell <b><U>then</U><r> check_alltt_skip lexbuf
       </r><U>else</U></b> skip_false lexbuf
<m>2290 
     <b><U>let</U></b></m> setif cell b lexbuf =
       <b><U>let</U><r> old = !cell </r><U>in</U></b>
       fun_register (<b><U>fun</U><r> () -&gt; cell := old) ;
       cell := b ;
<m>2295   </m>check_alltt_skip lexbuf
     ;;
     
     </r><U>let</U></b> extract_if name =
       <b><U>let</U><r> l = String.length name </r><U>in</U><m>
2300   </m><U>if</U></b> l &lt;= 3 || String.sub name 0 3 &lt;&gt; "\\if" <b><U>then</U><r>
         raise (Error ("Bad newif: "^name)) ;
       String.sub name 3 (l-3)
     ;;
     
</r><m>2305 </m><U>let</U></b> def_and_register name f =
       def name zero_pat (CamlCode f)
     ;;
     
     <b><U>let</U><r> tverb name cell lexbuf =
</r><m>2310   </m><U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
       Printf.fprintf stderr
         "Testing %s -&gt; %b\n" name !cell ;
       testif cell lexbuf
     ;;
</r><m>2315 
     </m><U>let</U></b> newif_ref name cell =
       def_and_register ("\\if"^name) (tverb name cell) ;
       def_and_register ("\\"^name^"true") (setif cell <b><U>true</U><r>) ;
       def_and_register ("\\"^name^"false") (setif cell </r><U>false</U></b>) ;
<m>2320   <r>register_cell name cell ;
       fun_register (<b><U>fun</U><r> () -&gt; unregister_cell name)
     ;;
     
     </r><U>let</U></b> newif lexbuf =
</r>2325   <b><U>let</U><r> arg = get_csname lexbuf </r><U>in</U>
       <U>let</U><r> saw_par = !Save.seen_par  <b><U>in</U>
       <U>begin</U> <U>try</U>
         <U>let</U></b> name = extract_if arg <b><U>in</U>
         <U>let</U></b> cell = ref <b><U>false</U> <U>in</U><m>
2330     <r>newif_ref name cell ;
       <b><U>with</U><r> Latexmacros.Failed -&gt; ()
       </r><U>end</U></b> ;
       <b><U>if</U><r> saw_par </r><U>then</U> <U>begin</U></b>
         top_par (par_val !in_table)
</r>2335   </m><U>end</U></b>
     ;;
     
     <b><U>exception</U><r> FailedFirst
     ;;
<m>2340 
     </m>def_code "\\ifx"
       (</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> arg1 = get_csname lexbuf </r><U>in</U>
         <U>let</U></b> arg2 = get_csname lexbuf  <b><U>in</U><m>
2345     </m><U>let</U></b> r =
           </r><U>try</U>
             <U>let</U><r> m1 =
               <b><U>try</U><r> Latexmacros.find_fail arg1 </r><U>with</U></b>
               |  Failed -&gt; raise FailedFirst </r><U>in</U></b>
2350         <b><U>let</U><r> m2 = Latexmacros.find_fail arg2 </r><U>in</U><r>
             m1 = m2
           <b><U>with</U></b>
           | FailedFirst -&gt;
               </r><U>begin</U></b>
2355             <b><U>try</U> <U>let</U><r> _ = Latexmacros.find_fail arg2 <b><U>in</U> <U>false</U>
                 <U>with</U></b> Failed -&gt; <b><U>true</U>
               <U>end</U></b>
           | Failed -&gt; <b><U>false</U> <U>in</U>
         <U>if</U></b> r </r><U>then</U></b>
2360       <r>check_alltt_skip lexbuf
         <b><U>else</U><r>
           skip_false lexbuf)
     ;;
     def_code "\\ifu"
<m>2365   </m>(</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> arg1 = get_csname lexbuf </r><U>in</U>
         <U>try</U>
           <U>let</U></b> _ = Latexmacros.find_fail arg1 <b><U>in</U></b>
           skip_false lexbuf
</r>2370     <b><U>with</U><r>
         | Failed -&gt; check_alltt_skip lexbuf)
     ;;
     
     def_code "\\newif" newif
<m>2375 </m>;;
     
     def_code "\\else" (</r><U>fun</U><r> lexbuf -&gt; skip_false lexbuf)
     ;;
     
<m>2380 </m>def_code "\\fi" (<b><U>fun</U><r> lexbuf -&gt; check_alltt_skip lexbuf)
     ;;
     
     
     </r><U>let</U></b> sawdocument = ref </r><U>false</U></b>
2385 </m>;;
     
     newif_ref "symb" symbols ;
     newif_ref "iso" iso ;
     newif_ref "raw" raw_chars ;
<m>2390 </m>newif_ref "silent" silent;
     newif_ref "math" in_math ;
     newif_ref "mmode" in_math ;
     newif_ref "display" display ;
     newif_ref "french" french ;
<m>2395 </m>newif_ref "html" html;
     newif_ref "text" text;
     newif_ref "info" text;
     newif_ref "mathml" Parse_opts.mathml;
     newif_ref "entities" Parse_opts.entities;
<m>2400 </m>newif_ref "optarg" optarg;
     newif_ref "styleloaded" styleloaded;
     newif_ref "activebrace" activebrace;
     newif_ref "pedantic" pedantic ;
     newif_ref "fixpoint" fixpoint ;
<m>2405 </m>newif_ref "alltt@loaded" alltt_loaded ;
     newif_ref "filter" (ref filter) ;
     newif_ref "@sawdocument" sawdocument ;
     def_code "\\iftrue" (testif (ref <b><U>true</U><r>)) ;
     def_code "\\iffalse" (testif (ref </r><U>false</U></b>))
<m>2410 </m>;;
     
     def_code "\\if@toplevel"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>if</U></b> echo_global_toimage () <b><U>then</U><r> check_alltt_skip lexbuf
<m>2415     <b><U>else</U><r> skip_false lexbuf)
     ;;
     
     
     
<m>2420 <w>(* Bibliographies *)
     <b><U>let</U><r> bib_ref s1 s2 =
       scan_this main ("\\@bibref{"^s1^"}{"^s2^"}")
     ;;
     
<m>2425 </m>def_code "\\cite"
       (</r><U>fun</U><r> lexbuf -&gt;
         <b><U>let</U><r> opt = save_opt "" lexbuf </r><U>in</U></b>
         check_alltt_skip lexbuf ;
         <b><U>let</U></b> args = List.map subst_this (Save.cite_arg lexbuf) </r><U>in</U></b></w>
2430     </m>Dest.put_char '[' ;
         Dest.open_group "CITE" ;
         </r><U>let</U> <U>rec</U><r> do_rec = <b><U>function</U><r>
             [] -&gt; ()
           | [x] -&gt; bib_ref x (Auxx.bget </r><U>true</U></b> x)
<m>2435       </m>| x::rest -&gt;
               bib_ref x (Auxx.bget <b><U>true</U><r> x) ;
               Dest.put ", " ;
               do_rec rest </r><U>in</U></b>
         do_rec args ;
<m>2440     <b><U>if</U><r> opt.arg &lt;&gt; "" </r><U>then</U> <U>begin</U><r>
           Dest.put ", " ;
           scan_this_arg main opt ;
         <b><U>end</U><r> ;
         Dest.close_group () ;
<m>2445     </m>Dest.put_char ']' )
     ;;
     
     <w>(* Includes *)
     </w>def_code "\\includeonly"
<m>2450   </m>(</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> arg = Save.cite_arg lexbuf </r><U>in</U></b>
         add_includes arg )
     ;;
     
<m>2455 <w>(* Foot notes *)
     
     <r>def_code "\\@stepanchor"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> mark = Get.get_int (save_arg lexbuf) <b><U>in</U><m>
2460     <r>Foot.step_anchor mark) ;
     def_code "\\@anchorval"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> mark = Get.get_int (save_arg lexbuf) <b><U>in</U></b>
         Dest.put (string_of_int (Foot.get_anchor mark)))
</r>2465 <r>;;
     
     def_code "\\@footnotetext"
       (<b><U>fun</U></b> lexbuf -&gt;
         start_lexstate () ;
</r>2470     </m><U>let</U></b> mark = Get.get_int (save_arg lexbuf) <b><U>in</U>
         <U>let</U></b> text = save_arg lexbuf <b><U>in</U>
         <U>let</U></b> text =
           do_get_this
             start_normal end_normal Dest.clearstyle
<m>2475         <r>main text <b><U>in</U></b>
         Foot.register
           mark
           (get_this_string main ("\\@fnmarknote{"^string_of_int mark^"}"))
           text ;
</r>2480     <r>restore_lexstate ())
     ;;
     
     def_code "\\@footnoteflush"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>2485     <b><U>let</U></b></m> sec_here = get_prim_arg lexbuf
         <b><U>and</U><r> sec_notes = get_prim "\\@footnotelevel" </r><U>in</U></b>
         start_lexstate () ;
         Foot.flush (scan_this main) sec_notes sec_here ;
         restore_lexstate ())
<m>2490 </m>;;
     
     </r>(* Opening and closing environments *)
     
     
</w>2495 </m>def_code "\\begin"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> cur_subst = get_subst () <b><U>in</U>
         <U>let</U></b> env = get_prim_arg lexbuf <b><U>in</U><r>
         new_env env ;
<m>2500     </m>top_open_block "" "" ;
         </r><U>let</U></b> macro = start_env env <b><U>in</U>
         <U>let</U></b> old_envi = save stack_entry <b><U>in</U></b>
         push stack_entry env ;
         </r><U>begin</U> <U>try</U></b>
2505       </m>expand_command main no_skip macro lexbuf
         <b><U>with</U><r>
         | e -&gt;
             restore stack_entry old_envi ;
             raise e
<m>2510     <b><U>end</U><r> ;
         restore stack_entry old_envi)
     ;;
     
     
<m>2515 </m>def_code "\\@begin"
       (</r><U>fun</U><r> lexbuf -&gt;
          <b><U>let</U><r> env = get_prim_arg lexbuf </r><U>in</U></b>
          new_env env ;
          top_open_block "" "")
<m>2520 </m>;;
     
     def_code "\\end"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> env = get_prim_arg lexbuf </r><U>in</U></b>
2525     </m>expand_command main no_skip ("\\end"^env) lexbuf ;
         close_env env ;
         top_close_block "")
     ;;
     
<m>2530 </m>def_code "\\@raise@enddocument"
       (</r><U>fun</U></b> _ -&gt;
         <b><U>if</U><r> not !sawdocument </r><U>then</U></b>
           fatal ("\\end{document} with no \\begin{document}")
         <b><U>else</U> <U>if</U></b> not (Stack.empty stack_env) </r><U>then</U></b>
2535       </m>error_env "document" !cur_env
         </r><U>else</U></b>
           raise Misc.EndDocument)
     ;;
     
<m>2540 </m>def_code "\\@end"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> env = get_prim_arg lexbuf <b><U>in</U><r>
         top_close_block "" ;
         close_env env)
<m>2545 </m>;;
     
     </r><U>let</U></b> little_more lexbuf =
       to_newline lexbuf ;
       Out.to_string more_buff
<m>2550 </m>;;
     
     def_code "\\endinput" (<b><U>fun</U><r> lexbuf -&gt;
       </r><U>let</U></b> reste = little_more lexbuf <b><U>in</U></b>
       scan_this main reste ;
<m>2555   </m>raise Misc.EndInput)
     ;;
     
     </r></b>(* Boxes *)
     
</w>2560 </m>def_code "\\mbox" (</r><U>fun</U></b> lexbuf -&gt; mbox_arg lexbuf)
     ;;
     
     
     
<m>2565 </m>def_code "\\newsavebox"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> name = get_csname lexbuf <b><U>in</U>
         <U>try</U>
           <U>let</U></b> _ = find_fail name </r><U>in</U></b>
2570       </m>warning ("Not (re-)defining ``"^name^"'' with \\newsavebox")
         <b><U>with</U><r>
         | Failed -&gt;
             global_def name zero_pat (CamlCode (</r><U>fun</U></b> _ -&gt; ())))
     ;;
<m>2575 
     </m>def_code "\\providesavebox"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> name = get_csname lexbuf <b><U>in</U>
         <U>try</U><m>
2580       </m><U>let</U></b> _ = find_fail name <b><U>in</U><r> ()
         </r><U>with</U></b>
         | Failed -&gt;
             global_def name zero_pat (CamlCode (<b><U>fun</U><r> _ -&gt; ())))
     ;;
<m>2585 
     <b><U>let</U><r> caml_print s = CamlCode (</r><U>fun</U><r> _ -&gt; Dest.put s)
     
     <b><U>let</U><r> do_sbox global name body =
       </r><U>if</U></b> not (Latexmacros.exists name) </r><U>then</U></b>
2590     </m>warning ("\\sbox on undefined bin ``"^name^"''") ;
       start_mbox () ;
       </r><U>let</U></b> to_print =  get_this_arg main body <b><U>in</U><r>
       top_close_group () ;
       (</r><U>if</U></b> global <b><U>then</U><r> global_def </r><U>else</U></b> def) name zero_pat (caml_print to_print)
<m>2595 </m>;;
     
     def_code "\\savebox"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> name = get_csname lexbuf <b><U>in</U><m>
2600     <r>warning "savebox";
         skip_opt lexbuf ;
         skip_opt lexbuf ;
         <b><U>let</U><r> body = save_arg lexbuf </r><U>in</U></b>
         do_sbox <b><U>false</U></b> name body)
</r>2605 <r>;;
     
     def_code "\\sbox"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> name = get_csname lexbuf <b><U>in</U><m>
2610     </m><U>let</U></b> body = save_arg lexbuf <b><U>in</U><r>
         do_sbox </r><U>false</U></b> name body) ;
     
     def_code "\\gsbox"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>2615     </m><U>let</U></b> name = get_csname lexbuf <b><U>in</U>
         <U>let</U></b> body = save_arg lexbuf <b><U>in</U></b>
         do_sbox <b><U>true</U></b> name body) ;
     ;;
     
<m>2620 </m>def_code "\\usebox"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> name = get_csname lexbuf <b><U>in</U></b>
         top_open_group () ;
         Dest.nostyle () ;
<m>2625     <r>expand_command main skip_blanks name lexbuf ;
         top_close_group ())
     ;;
     
     def_code "\\lrbox"
</r>2630   <r>(<b><U>fun</U><r> lexbuf -&gt;
         close_env "lrbox" ;
         push stack_display !display ;
         display := </r><U>false</U></b> ;
         <b><U>let</U><r> name = get_csname lexbuf </r><U>in</U><m>
2635     <r>Dest.open_aftergroup
           (<b><U>fun</U></b> s -&gt;
             def name zero_pat (caml_print s) ;
             "") ;
         start_mbox ())
</r>2640 <r>;;
     
     def_code "\\endlrbox"
       (<b><U>fun</U><r> _ -&gt;
         top_close_group () ;   <w>(* close mbox *)
<m>2645     <r>Dest.close_group () ;  <w>(* close after group *)
         </w>display := pop stack_display ;
         new_env "lrbox")
     ;;
     
</r>2650 
     </m>(* chars *)
     </w>def_code "\\char"
       (</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> arg = get_num_arg lexbuf </r><U>in</U><m>
2655     </m><U>if</U></b> not !silent &amp;&amp; (arg &lt; 32 || (arg &gt; 127 &amp;&amp; arg &lt; 161)) <b><U>then</U> <U>begin</U></b>
           Location.print_pos () ;
           prerr_endline ("Warning: \\char, check output");
         <b><U>end</U></b> ;
         Dest.put (Dest.iso (Char.chr arg)) ;
</r>2660     </m><U>if</U></b> not (effective !alltt) <b><U>then</U><r> check_alltt_skip lexbuf)
     ;;
     
     def_code "\\symbol"
       (</r><U>fun</U></b> lexbuf -&gt;
</r>2665     <b><U>let</U><r> arg = get_prim_arg lexbuf </r><U>in</U><r>
         scan_this main ("\\char"^arg))
     ;;
     
     <w>(* labels *)
<m>2670 
     </m>(* Counters *)
     <b><U>let</U></b></w> alpha_of_int i = String.make 1 (Char.chr (i-1+Char.code 'a'))
     <b><U>and</U></b> upalpha_of_int i = String.make 1 (Char.chr (i-1+Char.code 'A'))
     ;;
</r></b>2675 
     <r><b><U>let</U> <U>rec</U></b> roman_of_int = <b><U>function</U></b>
       0 -&gt; ""
     | 1 -&gt; "i"
     | 2 -&gt; "ii"
</r>2680 <r>| 3 -&gt; "iii"
     | 4 -&gt; "iv"
     | 9 -&gt; "ix"
     | i -&gt;
        <b><U>if</U><r> i &lt; 9 </r><U>then</U></b> "v"^roman_of_int (i-5)
</r>2685    <b><U>else</U>
          <U>let</U><r> d = i / 10 <b><U>and</U><r> u = i </r><U>mod</U></b> 10 <b><U>in</U></b>
          String.make d 'x'^roman_of_int u
     ;;
     
</r></b>2690 <b><U>let</U><r> uproman_of_int i = String.uppercase (roman_of_int i)
     ;;
     
     </r><U>let</U><r> fnsymbol_of_int = <b><U>function</U></b>
       0 -&gt; " "
</r></b>2695 <r>| 1 -&gt; "*"
     | 2 -&gt; "#"
     | 3 -&gt; "%"
     | 4 -&gt; "\167"
     | 5 -&gt; "\182"
</r>2700 <r>| 6 -&gt; "||"
     | 7 -&gt; "**"
     | 8 -&gt; "##"
     | 9 -&gt; "%%"
     | i -&gt; alpha_of_int (i-9)
</r>2705 <r>;;
     
     <b><U>let</U><r> def_printcount name f =
       def_code name
         (</r><U>fun</U></b> lexbuf -&gt;
</r>2710       <b><U>let</U><r> cname = get_prim_arg lexbuf </r><U>in</U>
           <U>let</U><r> cval = Counter.value_counter cname <b><U>in</U></b>
           Dest.put (f cval))
     ;;
     
</r></b>2715 <r>def_printcount "\\arabic" string_of_int ;
     def_printcount "\\alph"  alpha_of_int ;
     def_printcount "\\Alph"  upalpha_of_int ;
     def_printcount "\\roman" roman_of_int;
     def_printcount "\\Roman" uproman_of_int;
</r>2720 <r>def_printcount "\\fnsymbol" fnsymbol_of_int
     ;;
     
     <b><U>let</U><r> pad p l s =
       </r><U>for</U></b> i = l-String.length s <b><U>downto</U><r> 1 </r><U>do</U><m>
2725     <r>Dest.put (Dest.iso_string p)
       <b><U>done</U></b>
     ;;
     
     def_code "\\@pad"
</r>2730   <r>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> p = get_prim_arg lexbuf <b><U>in</U>
         <U>let</U></b> l = Get.get_int (save_arg lexbuf) <b><U>in</U>
         <U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U></b>
         pad p l arg ;
</r>2735     <r>Dest.put (Dest.iso_string arg))
     ;;
     
     def_code "\\newcounter"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>2740     <r>Save.start_echo () ;
         <b><U>let</U><r> name = get_prim_arg lexbuf </r><U>in</U>
         <U>let</U></b> within = get_prim_opt "" lexbuf <b><U>in</U>
         <U>let</U></b> real_args = Save.get_echo () <b><U>in</U>
         <U>if</U></b> echo_global_toimage () <b><U>then</U> <U>begin</U><m>
2745       <r>Image.put "\\newcounter" ;
           Image.put real_args ;
           Image.put_char '\n'
         <b><U>end</U></b> ;
         do_newcounter name within)
</r>2750 <r>;;
     
     def_code "\\addtocounter"
       (<b><U>fun</U></b> lexbuf -&gt;
         Save.start_echo () ;
</r>2755     </m><U>let</U></b> name = get_prim_arg lexbuf <b><U>in</U>
         <U>let</U></b> arg = save_arg lexbuf <b><U>in</U>
         <U>let</U></b> real_args = Save.get_echo () <b><U>in</U>
         <U>if</U></b> echo_global_toimage () <b><U>then</U> <U>begin</U></b>
           Image.put "\\addtocounter" ;
</r>2760       <r>Image.put real_args ;
           Image.put_char '\n'
         <b><U>end</U></b> ;
         Counter.add_counter name (Get.get_int arg))
     ;;
</r>2765 
     <r>def_code "\\setcounter"
       (<b><U>fun</U><r> lexbuf -&gt;
         Save.start_echo () ;
         </r><U>let</U></b> name = get_prim_arg lexbuf <b><U>in</U><m>
2770     </m><U>let</U></b> arg = save_arg lexbuf <b><U>in</U>
         <U>let</U></b> real_args = Save.get_echo () <b><U>in</U>
         <U>if</U></b> echo_global_toimage () <b><U>then</U> <U>begin</U></b>
           Image.put "\\setcounter" ;
           Image.put real_args ;
</r>2775       <r>Image.put_char '\n'
         <b><U>end</U></b> ;
         Counter.set_counter name (Get.get_int arg) )
     ;;
     
</r>2780 <r>def_code "\\stepcounter"
       (<b><U>fun</U><r> lexbuf -&gt;
         Save.start_echo () ;
         </r><U>let</U></b> name = get_prim_arg lexbuf <b><U>in</U>
         <U>let</U></b> real_args = Save.get_echo () <b><U>in</U><m>
2785     </m><U>if</U></b> echo_global_toimage () <b><U>then</U> <U>begin</U></b>
           Image.put "\\stepcounter" ;
           Image.put real_args ;
           Image.put_char '\n'
         <b><U>end</U></b> ;
</r>2790     <r>Counter.step_counter name)
     ;;
     
     <w>(* terminal output *)
     </w>def_code "\\typeout"
</r>2795   <r>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> what = get_prim_arg lexbuf <b><U>in</U></b>
         prerr_endline what )
     ;;
     
</r>2800 <r>def_code "\\warning"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> what = subst_arg lexbuf <b><U>in</U></b>
         warning what )
     ;;
</r>2805 
     <w>(* spacing *)
     
     </w></m><U>let</U></b> stack_closed = Stack.create "stack_closed"
     ;;
</r>2810 
     <r>def_code "\\@saveclosed"
       (<b><U>fun</U></b> lexbuf -&gt;
         push stack_closed (Dest.get_last_closed ()) ;
         check_alltt_skip lexbuf)
</r>2815 <r>;;
     
     def_code "\\@restoreclosed"
       (<b><U>fun</U></b> lexbuf -&gt;
         Dest.set_last_closed (pop stack_closed) ;
</r>2820     <r>check_alltt_skip lexbuf)
     ;;
     
     <b><U>exception</U></b> Cannot
     ;;
</r>2825 
     <r>def_code "\\@getlength"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U>
         <U>let</U></b> pxls =
</r>2830       <b><U>match</U><r> Get.get_length arg </r><U>with</U><r>
           | Length.Pixel n -&gt; n
           | Length.Char n -&gt; Length.char_to_pixel n
           | _             -&gt; 0 <b><U>in</U></b>
         Dest.put (string_of_int (pxls/2)))
</r></b>2835 <r>;;
     
     <b><U>let</U><r> do_space vert lexbuf  =
       </r><U>let</U></b> arg = subst_arg lexbuf <b><U>in</U>
       <U>begin</U> <U>try</U><m>
2840     </m><U>let</U></b> n = <b><U>match</U><r> Length.main (Lexing.from_string arg) </r><U>with</U></b>
         | Length.Char n -&gt; n
         | Length.Pixel n -&gt; Length.pixel_to_char n
         | _                 -&gt; raise Cannot <b><U>in</U>
         <U>if</U></b> vert <b><U>then</U><m>
2845       </m><U>for</U></b> i=1 <b><U>to</U><r> n </r><U>do</U></b>
             Dest.skip_line ()
           <b><U>done</U>
         <U>else</U>
           <U>for</U></b> i=1 <b><U>to</U><r> n </r><U>do</U><m>
2850         <r>Dest.put_nbsp (); <w>(* "&amp;nbsp;"*)
           <b><U>done</U>
       <U>with</U></b></w> Cannot -&gt;
         warning ((<b><U>if</U><r> vert </r><U>then</U></b> "\\vspace" <b><U>else</U></b> "\\hspace")^
                  " with arg ``"^arg^"''")
</r>2855   </m><U>end</U></b>
     ;;
     
     def_code "\\hspace"  (<b><U>fun</U><r> lexbuf -&gt; do_space </r><U>false</U></b> lexbuf) ;
     def_code "\\vspace"  (<b><U>fun</U><r> lexbuf -&gt; do_space </r><U>true</U></b> lexbuf)
</r>2860 <r>;;
     
     <w>(* Explicit groups *)
     </w>def_code "\\begingroup"
       (<b><U>fun</U></b> lexbuf  -&gt;
</r>2865     <r>new_env "command-group" ; top_open_block "" "" ;
         check_alltt_skip lexbuf)
     ;;
     
     def_code "\\endgroup"
</r>2870   <r>(<b><U>fun</U></b> lexbuf  -&gt;
         top_close_block ""  ; close_env !cur_env ;
         check_alltt_skip lexbuf)
     ;;
     
</r>2875 <w>(* alltt *)
     
     <r>register_init "alltt"
         (<b><U>fun</U></b> () -&gt;
           def_code "\\alltt"
<m>2880         <r>(<b><U>fun</U><r> _ -&gt;
               </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U><r> prerr_endline "begin alltt" ;
               alltt := Inside ;
               fun_register (</r><U>fun</U></b> () -&gt; alltt := Not) ;
               Dest.close_block "" ; Dest.open_block "PRE" "") ;
</r>2885 
           <r>def_code "\\endalltt"
             (<b><U>fun</U><r> _ -&gt;
               </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U></b> prerr_endline "end alltt" ;
               Dest.close_block "PRE" ; Dest.open_block "" ""))
</r>2890 <r>;;
     
     <w>(* Multicolumn *)
     
     </w>def_code "\\multicolumn"
</r>2895     <r>(<b><U>fun</U><r> lexbuf -&gt;
           </r><U>if</U></b> not (is_table !in_table) <b><U>then</U><r>
             raise (ScanError "\\multicolumn should occur in some array") ;
           </r><U>let</U></b> n = Get.get_int (save_arg lexbuf) <b><U>in</U>
           <U>let</U></b> format =  Tabular.main (save_arg lexbuf) <b><U>in</U><m>
2900       <r>do_multi n  format main)
     ;;
     
     def_code "\\hline"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>2905     </m><U>if</U></b> not (is_table !in_table) <b><U>then</U><r>
           raise (ScanError "\\hline should occur in some array") ;
         do_hline main ;
         skip_blanks_pop lexbuf ;
         </r><U>let</U></b> _ = Dest.forget_par () <b><U>in</U><m>
2910     <r>())
     ;;
     
     <w>(* inside tabbing *)
     <b><U>let</U></b></w> do_tabul lexbuf =
</r>2915   </m><U>if</U></b> is_tabbing !in_table <b><U>then</U> <U>begin</U></b>
         do_unskip () ;
         Dest.close_cell ""; Dest.open_cell default_format 1 0
       <b><U>end</U></b> ;
       skip_blanks_pop lexbuf
</r>2920 <r>;;
     
     def_code "\\&gt;" do_tabul ;
     def_code "\\=" do_tabul
     ;;
</r>2925 
     <r>def_code "\\kill"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>if</U></b> is_tabbing !in_table <b><U>then</U> <U>begin</U></b>
           do_unskip () ;
</r>2930       <r>Dest.close_cell "";
           Dest.erase_row () ;
           Dest.new_row () ;
           Dest.open_cell default_format 1 0
         <b><U>end</U></b> ;
</r>2935     <r>skip_blanks_pop lexbuf)
     ;;
     
     
     <w>(* Tabular and arrays *)
<m>2940 
     
     <b><U>let</U><r> check_width = </r><U>function</U><r>
       | Length.Char x -&gt;
           " WIDTH="^string_of_int (Length.char_to_pixel x)
<m>2945   </m>| Length.Pixel x -&gt;
           " WIDTH="^string_of_int x
       | Length.Percent x -&gt;
           " WIDTH=\""^string_of_int x^"%\""
       | _ -&gt; ""
<m>2950 </m>;;
     
     <b><U>let</U><r> get_table_attributes border len =
       </r><U>let</U></b> attrs = get_prim
           (<b><U>if</U></b> border </r><U>then</U></b>
2955         <r>"\\@table@attributes@border"
           <b><U>else</U><r>
             "\\@table@attributes") </r><U>in</U></b>
       attrs^check_width len
     
</r>2960 
     <b><U>let</U><r> open_tabbing lexbuf =
       </r><U>let</U><r> lexbuf = Lexstate.previous_lexbuf <b><U>in</U>
       <U>let</U></b> lexfun lb =
         Dest.open_table <b><U>false</U><r> "border=0 cellspacing=0 cellpadding=0" ;
<m>2965     </m>Dest.new_row ();
         Dest.open_cell default_format 1 0 </r><U>in</U></b>
       push stack_table !in_table ;
       in_table := Tabbing ;
       new_env "tabbing" ;
<m>2970   </m>def "\\a" zero_pat
         (CamlCode
            (<b><U>fun</U><r> lexbuf -&gt;
              </r><U>let</U></b> acc = subst_arg lexbuf <b><U>in</U>
              <U>let</U></b> arg = subst_arg lexbuf </r><U>in</U></b>
2975          <r>scan_this main ("\\"^acc^arg))) ;
       lexfun lexbuf
     ;;
     
     def_code "\\tabbing" open_tabbing
</r>2980 <r>;;
     
     <b><U>let</U></b> close_tabbing _ =
       Dest.do_close_cell ();
       Dest.close_row ();
</r>2985   <r>Dest.close_table ();
       in_table := pop stack_table ;
       close_env "tabbing" ;
     ;;
     
</r>2990 <r>def_code "\\endtabbing" close_tabbing
     ;;
     
     <b><U>let</U></b> open_array env lexbuf =
       save_array_state ();
</r>2995   <r>Tabular.border := <b><U>false</U><r> ;
       </r><U>let</U></b> len =  <b><U>match</U><r> env </r><U>with</U></b>
         | "tabular*"|"Tabular*" -&gt;
             <b><U>let</U><r> arg = save_arg lexbuf </r><U>in</U>
             <U>begin</U> <U>match</U></b> Get.get_length (get_prim_onarg arg) <b><U>with</U><m>
3000         <r>| Length.No s -&gt;
                 warning ("``tabular*'' with length argument: "^
                          do_subst_this arg) ;
                 Length.Default
             | width -&gt; width
</r>3005         </m><U>end</U></b>
         | _ -&gt; Length.Default <b><U>in</U>
       <U>let</U></b> attributes = <b><U>match</U><r> env </r><U>with</U></b>
       | "Tabular*" | "Array" | "Tabular" -&gt; get_prim_opt "" lexbuf
       | _ -&gt; skip_opt lexbuf ; "" <b><U>in</U><m>
3010   <r>skip_opt lexbuf ;
       <b><U>let</U><r> format = save_arg lexbuf </r><U>in</U>
       <U>let</U></b> format = Tabular.main format <b><U>in</U></b>
       cur_format := format ;
       push stack_in_math !in_math ;
</r>3015   <r>in_table := Table
            {math = (env = "array")  ;
              border = !Tabular.border} ;
       <b><U>if</U><r> !display </r><U>then</U></b> Dest.item_display () ;
       in_math := <b><U>false</U></b> ;
</r>3020   <r>push stack_display !display ;
       display := <b><U>false</U><r> ;
       </r><U>begin</U> <U>match</U></b> attributes <b><U>with</U><r>
       | "" -&gt;
           </r><U>if</U></b> !Tabular.border <b><U>then</U><m>
3025         <r>Dest.open_table <b><U>true</U><r> (get_table_attributes </r><U>true</U></b> len)
           <b><U>else</U><r>
             Dest.open_table </r><U>false</U></b> (get_table_attributes <b><U>false</U></b> len);
       | _  -&gt;
            Dest.open_table !Tabular.border (attributes^check_width len)
</r>3030   </m><U>end</U></b> ;
       open_row() ;
       open_first_col main ;
       skip_blanks_pop lexbuf ;
     ;;
</r>3035 
     <r>def_code "\\@array" (open_array "array") ;
     def_code "\\@tabular" (open_array "tabular") ;
     def_code "\\@tabular*" (open_array "tabular*")
     ;;
</r>3040 <r>def_code "\\@Array" (open_array "Array") ;
     def_code "\\@Tabular" (open_array "Tabular") ;
     def_code "\\@Tabular*" (open_array "Tabular*")
     ;;
     
</r>3045 
     </m><U>let</U></b> close_array _ =
       do_unskip () ;
       close_last_col main "" ;
       close_last_row () ;
</r>3050   <r>Dest.close_table () ;
       restore_array_state () ;
       in_math := pop stack_in_math ;
       display := pop stack_display;
       <b><U>if</U><r> !display </r><U>then</U></b> Dest.item_display () ;
</r>3055 <r>;;
     
     def_code "\\end@array" close_array  ;
     def_code "\\end@tabular" close_array ;
     def_code "\\end@tabular*" close_array ;
</r>3060 <r>def_code "\\end@Array" close_array  ;
     def_code "\\end@Tabular" close_array ;
     def_code "\\end@Tabular*" close_array ;
     ;;
     
</r>3065 
     <b><U>let</U><r> do_amper lexbuf =
       </r><U>if</U><r> effective !alltt || not (is_plain '&amp;') <b><U>then</U> <U>begin</U>
         <U>let</U></b> lxm = lexeme lexbuf <b><U>in</U>
         <U>for</U></b> i = 0 <b><U>to</U></b> String.length lxm -1 </r><U>do</U></b>
3070       <r>Dest.put (Dest.iso lxm.[i])
         <b><U>done</U>
       <U>end</U> <U>else</U> <U>if</U></b> is_table !in_table  <b><U>then</U> <U>begin</U></b>
         close_col main "&amp;nbsp;";
         open_col main
</r>3075   <b><U>end</U><r> ;
       </r><U>if</U><r> not (effective !alltt) &amp;&amp; is_plain '&amp;' <b><U>then</U><r> skip_blanks_pop lexbuf
     
     </r><U>and</U></b> do_bsbs lexbuf =
       do_unskip () ;
<m>3080   </m>skip_opt lexbuf ;
       <b><U>if</U><r> is_table !in_table  </r><U>then</U> <U>begin</U></b>
         close_col main "&amp;nbsp;" ; close_row () ;
         open_row () ; open_first_col main
       <b><U>end</U> <U>else</U> <U>if</U></b> is_tabbing !in_table </r><U>then</U> <U>begin</U></b>
3085     <r>Dest.close_cell "";
         Dest.close_row () ;
         Dest.new_row () ;
         Dest.open_cell default_format 1 0
       <b><U>end</U> <U>else</U> <U>begin</U><m>
3090     </m><U>if</U></b> !display <b><U>then</U><r>
           warning "\\\\ in display mode, ignored"
         </r><U>else</U></b>
           Dest.skip_line ()
       <b><U>end</U></b> ;
</r>3095   <r>skip_blanks_pop lexbuf ;
       <b><U>let</U><r> _ = Dest.forget_par () </r><U>in</U></b> ()
     ;;
     
     def_code "\\@hevea@amper" do_amper ;
</r>3100 <r>def_code "\\\\"           do_bsbs  ;
     def_code "\\@HEVEA@amper" do_amper ;
     def_code "\\@HEVEA@bsbs"  do_bsbs  ; ()
     ;;
     
</r>3105 
     </m>(* Other scanners *)
     
     </w>def_code "\\latexonly"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>3110     <r>start_other_scan "latexonly" latexonly lexbuf)
     ;;
     
     def_code "\\toimage"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>3115     <r>start_image_scan "" image lexbuf)
     ;;
     
     def_code "\\@stopimage"
         (<b><U>fun</U></b> lexbuf  -&gt;
</r>3120       <r>Image.stop () ;
           check_alltt_skip lexbuf)
     ;;
     
     def_code "\\@restartimage"
</r>3125     <r>(<b><U>fun</U></b> lexbuf  -&gt;
           Image.restart () ;
           check_alltt_skip lexbuf)
     ;;
     
</r>3130 
     
     <r>def_code "\\@stopoutput"
         (<b><U>fun</U></b> lexbuf  -&gt;
           Dest.stop () ;
</r>3135       <r>check_alltt_skip lexbuf)
     ;;
     
     def_code "\\@restartoutput"
         (<b><U>fun</U></b> lexbuf  -&gt;
</r>3140       <r>Dest.restart () ;
           check_alltt_skip lexbuf)
     ;;
     
     
</r>3145 </m></r>(* Info  format specific *)
     
     <r>def_code "\\@infomenu"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U><m>
3150     <r>Dest.infomenu arg)
     ;;
     
     def_code  "\\@infonode"
       (<b><U>fun</U></b> lexbuf -&gt;
</r>3155     </m><U>let</U></b> opt = get_prim_opt "" lexbuf <b><U>in</U>
         <U>let</U></b> num = get_prim_arg lexbuf <b><U>in</U>
         <U>let</U></b> nom = get_prim_arg lexbuf <b><U>in</U></b>
         Dest.infonode opt num nom)
     ;;
<m>3160 
     <r>def_code "\\@infoextranode"
       (<b><U>fun</U><r> lexbuf -&gt;
        </r><U>let</U></b> num = get_prim_arg lexbuf <b><U>in</U>
        <U>let</U></b> nom = get_prim_arg lexbuf <b><U>in</U><m>
3165    </m><U>let</U></b> text = get_prim_arg lexbuf <b><U>in</U></b>
        Dest.infoextranode num nom text)
     ;;
     
     def_code "\\@infoname"
</r>3170   <r>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U></b>
         Dest.loc_name arg)
     ;;
     
</r>3175 <b><U>let</U><r> safe_len = </r><U>function</U><r>
       | Length.No _ -&gt; Length.Default
       | l    -&gt; l
     ;;
     
</r></b>3180 <r>def_code "\\@printHR"
         (<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U>
           <U>let</U></b> taille = safe_len (Get.get_length (get_prim_arg lexbuf)) <b><U>in</U></b>
           Dest.horizontal_line arg taille (Length.Pixel 2))
</r>3185 <r>;;
     
     def_code"\\@hr"
        (<b><U>fun</U><r> lexbuf -&gt;
          </r><U>let</U></b> attr = subst_opt "" lexbuf <b><U>in</U><m>
3190      </m><U>let</U></b> width = safe_len (Get.get_length (get_prim_arg lexbuf)) <b><U>in</U>
          <U>let</U></b> height = safe_len (Get.get_length (get_prim_arg lexbuf)) <b><U>in</U></b>
          Dest.horizontal_line attr width height)
     ;;
     
</r>3195 </m></r>(* Accents *)
     <b><U>let</U></b></w><r> aigu = <b><U>function</U></b>
       "a" -&gt; "" | "e" -&gt; "e" | "i" | "\\i" | "\\i " -&gt; ""
     | "o" -&gt; "" | "u" -&gt; ""
     | "A" -&gt; "" | "E" -&gt; "E" | "I" | "\\I" | "\\I " -&gt; ""
</r>3200 <r>| "O" -&gt; "" | "U" -&gt; ""
     | "y" -&gt; "" | "Y" -&gt; ""
     | "" | " " -&gt; "'"
     | s   -&gt; s
     
</r>3205 <r><b><U>and</U><r> grave = </r><U>function</U></b>
       "a" -&gt; "a" | "e" -&gt; "e"  | "i" -&gt; ""
     | "o" -&gt; "" | "u" -&gt; ""  | "\\i" | "\\i " -&gt; ""
     | "A" -&gt; "A" | "E" -&gt; "E"  | "I" -&gt; ""
     | "O" -&gt; "" | "U" -&gt; ""  | "\\I" | "\\I " -&gt; ""
</r>3210 <r>| "" | " " -&gt; "`"
     | s -&gt; s
     <b><U>and</U><r> circonflexe = </r><U>function</U></b>
       "a" -&gt; "a" | "e" -&gt; "e"  | "i" -&gt; "i"
     | "o" -&gt; "o" | "u" -&gt; "u"  | "\\i" | "\\i " -&gt; "i"
</r>3215 <r>| "A" -&gt; "A" | "E" -&gt; "E"  | "I" -&gt; "I"
     | "O" -&gt; "O" | "U" -&gt; "U"  | "\\I" | "\\I " -&gt; "I"
     | "" | " " -&gt; "\\@print{^}"
     | s -&gt; s
     
</r>3220 <b><U>and</U><r> trema = </r><U>function</U><r>
       "a" -&gt; "" | "e" -&gt; "e"  | "i" -&gt; "i"
     | "o" -&gt; "" | "u" -&gt; "u"  | "\\i" | "\\i " -&gt; "i"
     | "A" -&gt; "" | "E" -&gt; "E"  | "I" -&gt; "I"
     | "O" -&gt; "" | "U" -&gt; "U"  | "\\I" | "\\I " -&gt; "I"
</r></b>3225 <r>| "" | " " -&gt; ""
     | s -&gt; s
     
     <b><U>and</U><r> cedille = </r><U>function</U></b>
       "c" -&gt; "c"
</r>3230 <r>| "C" -&gt; "C"
     | s   -&gt; s
     
     <b><U>and</U><r> tilde = </r><U>function</U></b>
       "a" -&gt; "" | "A" -&gt; ""
</r>3235 <r>| "o" -&gt; "" | "O" -&gt; ""
     | "n" -&gt; "" | "N" -&gt; ""
     | "" | " " -&gt; "\\@print{~}"
     | s   -&gt; s
     ;;
</r>3240 
     
     
     <r>def_fun "\\'"  aigu ;
     def_fun "\\`"  grave ;
</r>3245 <r>def_fun "\\^"  circonflexe ;
     def_fun "\\\"" trema ;
     def_fun "\\c"  cedille ;
     def_fun "\\~"  tilde
     ;;
</r>3250 
     <r>Get.init
       get_prim_onarg
       get_fun_result
       new_env close_env
</r>3255   <r>get_csname
       main
     ;;
     
     def_code "\\@primitives"
</r>3260   <r>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> pkg = get_prim_arg lexbuf <b><U>in</U></b>
         exec_init pkg)
     ;;
     
</r>3265 <w>(* try e1 with _ -&gt; e2 *)
     
     <r>def_code "\\@try"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> saved_location = Location.check ()
<m>3270     <b><U>and</U></b></m> env_saved = env_check ()
         <b><U>and</U><r> saved = Hot.checkpoint ()
         </r><U>and</U></b> saved_lexstate = Lexstate.check_lexstate ()
         <b><U>and</U><r> saved_out = Dest.check ()
         </r><U>and</U></b> saved_get = Get.check ()
<m>3275     <b><U>and</U></b></m> saved_aux = Auxx.check () <b><U>in</U>
         <U>let</U></b> e1 = save_arg lexbuf <b><U>in</U>
         <U>let</U></b> e2 = save_arg lexbuf <b><U>in</U>
         <U>try</U></b>
           top_open_block "TEMP" "" ;
<m>3280       </m>scan_this_arg main e1 ;
           top_close_block "TEMP"
         <b><U>with</U><r> e -&gt; </r><U>begin</U></b>
           Location.hot saved_location ;
           env_hot env_saved ;
<m>3285       </m>Misc.print_verb 0
             ("\\@try caught exception : "^Printexc.to_string e) ;
           Lexstate.hot_lexstate saved_lexstate ;
           Dest.hot saved_out ;
           Get.hot saved_get ;
<m>3290       </m>Auxx.hot saved_aux ;
           Hot.start saved ;
           scan_this_arg main e2
         <b><U>end</U><r>)
     ;;
<m>3295 
     </m>def_code "\\@heveafail"
       (</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> s = get_prim_arg lexbuf </r><U>in</U></b>
         raise (Misc.Purposly s))
<m>3300 </m>;;
     
     </r>(*
     (* A la TeX ouput (more or less...) *)
     
<m>3305 <w>def_code "\\newwrite"
       (fun lexbuf -&gt;
         let cmd = save_arg lexbuf in
         let file = ref stderr in
         def_code cmd
</w>3310       <w>(fun lexbuf -&gt;
             let op = save_arg lexbuf in
             try
               match op with
               |  "\\write" -&gt;
</w>3315               <w>let what = subst_arg subst lexbuf in
                   output_string !file what ;
                   output_char !file '\n'
               | "\\closeout" -&gt;
                   close_out !file
</w>3320           <w>| "\\openout" -&gt;
                   let name = get_this_nostyle main (save_filename lexbuf) in
                   file := open_out name
               | _ -&gt;
                   warning ("Unkown file operation: "^op)
</w>3325         <w>with Sys_error s -&gt;
               warning ("TeX file error : "^s)))
     ;;
     
     let def_fileop me =
</w>3330   <w>def_code me
        (fun lexbuf -&gt;
          let cmd = subst_arg lexbuf in
          scan_this_may_cont main lexbuf (cmd^me))
     ;;
</w>3335 
     <w>def_fileop "\\write" ;
     def_fileop "\\openout" ;
     def_fileop "\\closeout"
     ;;
</w>3340 <w>*)<r><PL><B>
<6>97 length.ml</6>
</B><TT><y> 
     # <b><U>end</U></b></y>13 "length.mll"
     
     <b><U>open</U><r> Lexing
     </r><U>let</U></b> header = "$Id: length.mll,v 1.13 2001/06/06 16:52:52 maranget Exp $"
   <m>5 
     <b><U>exception</U></b></m> Cannot
     ;;
     
     <b><U>let</U><r> font = 10
  <m>10 </m>;;
     
     </r><U>let</U></b> font_float = float font
     ;;
     <b><U>type</U><r> t =
  <m>15   </m>Char </r><U>of</U></b> int | Pixel <b><U>of</U><r> int | Percent </r><U>of</U></b> int | No <b><U>of</U><r> string | Default
     
     </r><U>let</U></b> pretty = <b><U>function</U><r>
       | Char x -&gt; string_of_int x^" chars"
       | Pixel x -&gt; string_of_int x^" pxls"
  <m>20   </m>| Percent x  -&gt; string_of_int x^"%"
       | Default    -&gt; "default"
       | No s       -&gt; "*"^s^"*"
     
     </r><U>let</U></b> pixel_to_char x =  (100 * x + 50)/(100 * font)
  <m>25 <b><U>and</U></b></m> char_to_pixel x = font * x
     
     <b><U>let</U><r> mk_char x = Char (truncate (0.5 +. x))
     </r><U>let</U></b> mk_pixel x = Pixel (truncate (0.5 +. x))
     <b><U>and</U><r> mk_percent x = Percent (truncate x)
  <m>30 </m>;;
     
     </r><U>let</U></b> convert unit x = <b><U>match</U><r> unit </r><U>with</U></b>
         |   "ex"|"em" -&gt; mk_char x
         |  "pt"     -&gt; mk_pixel x
  <m>35     </m>|  "in"     -&gt; mk_char ((x *. 72.27) /. font_float)
         |  "cm"     -&gt; mk_char ((x *. 28.47) /. font_float)
         |  "mm"     -&gt; mk_char ((x *. 2.847) /. font_float)
         |  "pc"     -&gt; mk_char ((x *. 12.0)  /. font_float)
         |  "@percent" -&gt; mk_percent (100.0 *. x)
  <m>40     </m>|  _ -&gt; No unit
     ;;
     
     <b><U>let</U><r> lex_tables = {
       Lexing.lex_base =
  <m>45    </m>"\000\000\000\000\000\000\002\000\007\000\017\000\029\000\000\000\
    \000\000\000\000\000\000\001\000\000\000\000\000\254\255\039\000\
    \255\255";
       Lexing.lex_backtrk =
        "\001\000\002\000\001\000\001\000\000\000\255\255\000\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\000\000\
    \255\255";
       Lexing.lex_default =
        "\255\255\255\255\003\000\003\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\000\000\255\255\
    \000\000";
  <m>50   </m>Lexing.lex_trans =
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\004\000\004\000\255\255\255\255\004\000\000\000\255\255\
    \004\000\004\000\000\000\000\000\004\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \004\000\000\000\255\255\000\000\000\000\000\000\000\000\004\000\
    \000\000\000\000\000\000\000\000\000\000\016\000\005\000\000\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \007\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\005\000\000\000\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\000\000\000\000\011\000\000\000\009\000\012\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\013\000\000\000\
    \008\000\000\000\010\000\000\000\014\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \255\255\000\000\255\255\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    ";
       Lexing.lex_check =
        "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\002\000\002\000\003\000\003\000\002\000\255\255\003\000\
    \004\000\004\000\255\255\255\255\004\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \002\000\255\255\003\000\255\255\255\255\255\255\255\255\004\000\
    \255\255\255\255\255\255\255\255\255\255\000\000\001\000\255\255\
    \001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
    \001\000\001\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \001\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\005\000\006\000\255\255\006\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\255\255\255\255\010\000\255\255\008\000\011\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\012\000\255\255\
    \007\000\255\255\009\000\255\255\013\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \002\000\255\255\003\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    "
     }
  <m>55 
     <b><U>let</U> <U>rec</U><r> main_rule lexbuf = __ocaml_lex_main_rule_rec lexbuf 0
     <b><U>and</U><r> __ocaml_lex_main_rule_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
  <m>60  </m>57 "length.mll"
            </r><U>let</U></b> x,unit = positif lexbuf <b><U>in</U><r> convert unit (0.0 -. x))
       | 1 -&gt; (
      58 "length.mll"
            </r><U>let</U></b> x,unit = positif lexbuf <b><U>in</U><r> convert unit x)
  <m>65   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_main_rule_rec lexbuf n
     
     </r><U>and</U></b> positif lexbuf = __ocaml_lex_positif_rec lexbuf 1
     <b><U>and</U><r> __ocaml_lex_positif_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
  70     </m>0 -&gt; (
      62 "length.mll"
         </r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><r>
        float_of_string lxm,unit lexbuf)
       | 1 -&gt; (
  <m>75  </m>64 "length.mll"
                    1.0, "@percent")
       | 2 -&gt; (
      65 "length.mll"
            raise Cannot)
  <m>80   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_positif_rec lexbuf n
     
     </r><U>and</U></b> unit lexbuf = __ocaml_lex_unit_rec lexbuf 2
     <b><U>and</U><r> __ocaml_lex_unit_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><m>
  85     <r>0 -&gt; (
      67 "length.mll"
                           unit lexbuf)
       | 1 -&gt; (
      68 "length.mll"
  </r>90                        <r>lexeme lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_unit_rec lexbuf n
     
     ;;
     
  </r>95  <r>70 "length.mll"
     
     <b><U>open</U><r> Lexing
     
     </r><U>let</U></b> main lexbuf =
 </r>100   </m><U>try</U></b> main_rule lexbuf <b><U>with</U><r>
       | Cannot -&gt;
           </r><U>let</U></b> sbuf = lexbuf.lex_buffer <b><U>in</U></b>
           No (String.sub sbuf 0 lexbuf.lex_buffer_len)</TT>
<6><B>98 lexstate.ml</B></6>
</PL></r> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   </w>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>let</U></b></w><r> header = "$Id: lexstate.ml,v 1.57 2001/02/12 10:05:37 maranget Exp $"
     
     <b><U>open</U></b> Misc
  </r>15 <r><b><U>open</U><r> Lexing
     </r><U>open</U></b> Stack
     
     
     
  </r>20 <w>(* Commands nature *)
     <b><U>type</U><r> action =
       | Subst </r><U>of</U><r> string
       | Toks <b><U>of</U><r> string list
       | CamlCode </r><U>of</U></b> (Lexing.lexbuf -&gt; unit)
  </r></b></w>25 
     
     <b><U>let</U><r> pretty_action acs =
        </r><U>match</U><r> acs <b><U>with</U></b>
        | Subst s    -&gt; Printf.fprintf stderr "{%s}" s
  </r></b>30    <r>| Toks l -&gt;
            List.iter
              (<b><U>fun</U></b> s -&gt; Printf.fprintf stderr "{%s}, " s)
              l
        | CamlCode _ -&gt; prerr_string "*code*"
  </r>35 
     <r><b><U>type</U><r> pat = string list * string list
     
     
     </r><U>let</U></b> pretty_pat (_,args) =
  </r>40   <r>List.iter (<b><U>fun</U><r> s -&gt; prerr_string s ; prerr_char ',') args
     
     </r><U>let</U></b> is_subst body = <b><U>match</U><r> body </r><U>with</U></b>
     | CamlCode _ -&gt; <b><U>false</U><r>
     | _ -&gt; </r><U>true</U><m>
  45 
     </m><U>let</U></b> latex_pat opts n =
       <b><U>let</U><r> n_opts = List.length opts </r><U>in</U>
       <U>let</U> <U>rec</U></b> do_rec r i =
         <b><U>if</U><r> i &lt;=  n_opts  </r><U>then</U></b> r
  </r>50     <b><U>else</U><r> do_rec (("#"^string_of_int i)::r) (i-1) </r><U>in</U><r>
       opts,do_rec [] n
     
     <b><U>let</U><r> zero_pat = latex_pat [] 0
     </r><U>and</U></b> one_pat  = latex_pat [] 1
  </r></b>55 
     <w>(* Environments *)
     <r><b><U>type</U><r> subst = Top | Env </r><U>of</U></b> string arg array
     <b><U>and</U></b> 'a arg = {arg : 'a ; subst : subst }
     
  </r></w>60 <b><U>let</U><r> mkarg arg subst = {arg=arg ; subst=subst }
     
     
     
     </r><U>type</U><r> alltt = Not | Inside | Macro
  </r></b>65 
     <b><U>let</U><r> effective = </r><U>function</U><r>
       | Inside -&gt; <b><U>true</U><r>
       | _      -&gt; </r><U>false</U><m>
     
  70 </m><U>let</U></b> subst = ref Top
     <b><U>and</U><r> alltt = ref Not
     
     </r><U>let</U></b> stack_subst = Stack.create "stack_subst"
     <b><U>and</U></b> stack_alltt = Stack.create_init "stack_alltt" Not
  </r></b>75 
     <b><U>let</U><r> get_subst () = !subst
     </r><U>let</U><r> set_subst s = subst := s
     <b><U>let</U></b> top_subst = Top
     
  </r></b>80 
     
     <b><U>let</U><r> pretty_subst = </r><U>function</U><r>
       | Top -&gt; prerr_endline "Top level"
       | Env args -&gt;
  </r></b>85       <b><U>if</U><r> Array.length args &lt;&gt; 0 </r><U>then</U> <U>begin</U><r>
             prerr_endline "Env: " ;
             <b><U>for</U><r> i = 0 </r><U>to</U></b> Array.length args - 1 <b><U>do</U></b>
               prerr_string "\t``" ;
               prerr_string args.(i).arg  ;
  </r></b>90           <r>prerr_endline "''"
             <b><U>done</U>
           <U>end</U>
     
     <U>let</U> <U>rec</U></b> pretty_subst_rec indent = <b><U>function</U><m>
  95   <r>| Top -&gt; prerr_string indent ; prerr_endline "Top level"
       | Env args -&gt;
           <b><U>if</U><r> Array.length args &lt;&gt; 0 </r><U>then</U> <U>begin</U></b>
             prerr_string indent ;
             prerr_endline "Env: " ;
 </r>100         </m><U>for</U></b> i = 0 <b><U>to</U><r> Array.length args - 1 </r><U>do</U></b>
               prerr_string indent ;
               prerr_string ("  #"^string_of_int (i+1)^" ``");
               prerr_string  args.(i).arg ;
               prerr_endline "''" ;
 </r>105           <r>pretty_subst_rec ("  "^indent) args.(i).subst
             <b><U>done</U>
           <U>end</U>
     
     <U>let</U></b> full_pretty_subst s = pretty_subst_rec "  " s
 </r>110 
     <b><U>exception</U><r> Error </r><U>of</U><r> string
     
     <w>(* Status flags *)
     <b><U>let</U></b></w> display = ref <b><U>false</U><m>
 115 </m><U>and</U></b> raw_chars = ref <b><U>false</U>
     <U>and</U></b> in_math = ref <b><U>false</U>
     <U>and</U></b> french =
       ref
         (<b><U>match</U><r> !Parse_opts.language </r><U>with</U><m>
 120     <r>| Parse_opts.Francais -&gt; <b><U>true</U><r> | _ -&gt; </r><U>false</U></b>)
     <b><U>and</U><r> optarg = ref </r><U>false</U>
     <U>and</U></b> styleloaded = ref <b><U>false</U>
     <U>and</U></b> activebrace = ref <b><U>true</U>
     <U>and</U></b> html =
 </r>125   <r>ref
         (<b><U>match</U><r> !Parse_opts.destination </r><U>with</U></b>
         | Parse_opts.Html -&gt; <b><U>true</U><r>
         | Parse_opts.Info | Parse_opts.Text -&gt; </r><U>false</U></b>)
     <b><U>and</U></b> text =
 </r>130   <r>ref
         (<b><U>match</U><r> !Parse_opts.destination </r><U>with</U></b>
         | Parse_opts.Html -&gt; <b><U>false</U><r>
         | Parse_opts.Info | Parse_opts.Text -&gt; </r><U>true</U></b>)
     <b><U>and</U><r> alltt_loaded = ref </r><U>false</U><m>
 135 <w>(* Additional variables for videoc *)
     </w></m><U>and</U></b> withinLispComment = ref <b><U>false</U>
     <U>and</U></b> afterLispCommentNewlines = ref 0
     <w>(* Additional flags for transformations *)
     </w>;;
 </r>140 </m><U>type</U></b> case = Upper | Lower | Neutral
     <b><U>let</U></b> case = ref Neutral
     ;;
     
     
 </r></b>145 <b><U>let</U><r> string_to_arg arg = {arg=arg ; subst= !subst }
     
     </r><w>(* Stacks for flags *)
     </w><U>let</U><r> stack_in_math = Stack.create "stack_in_math"
     <b><U>and</U></b> stack_display = Stack.create "stack_display"
 </r></b>150 
     <w>(* Stacks for entry stream  *)
     <b><U>let</U><r> stack_lexbuf = Stack.create "stack_lexbuf"
     ;;
     
 </r></b></w>155 <b><U>let</U><r> pretty_lexbuf lb =
       </r><U>let</U><r>  pos = lb.lex_curr_pos <b><U>and</U><r> len = String.length lb.lex_buffer </r><U>in</U></b>
       prerr_endline "Buff contents:" ;
       <b><U>let</U><r> size = </r><U>if</U></b> !verbose &gt; 3 <b><U>then</U><r> len-pos </r><U>else</U></b> min (len-pos) 80 <b><U>in</U>
       <U>if</U></b> size &lt;&gt; len-pos <b><U>then</U> <U>begin</U><m>
 160     <r>prerr_string "&lt;&lt;" ;
         prerr_string (String.sub lb.lex_buffer pos (size/2)) ;
         prerr_string "... (omitted) ..." ;
         prerr_string (String.sub lb.lex_buffer (len-size/2-1) (size/2)) ;
         prerr_endline "&gt;&gt;"
 </r>165   </m><U>end</U> <U>else</U></b>
         prerr_endline ("&lt;&lt;"^String.sub lb.lex_buffer pos size^"&gt;&gt;");
       prerr_endline ("curr_pos="^string_of_int lb.lex_curr_pos);
       prerr_endline "End of buff"
     ;;
 </r></b>170 
     
     <w>(* arguments inside macros*)
     <b><U>type</U><r> env = string array ref
     </r><U>type</U><r> closenv = string array t
 </r></b></w>175 
     
     
     
     <w>(* catcodes *)
 <m>180 
     <r><b><U>let</U><r> plain_of_char = </r><U>function</U></b>
       | '{' -&gt; 0
       | '}' -&gt; 1
       | '$' -&gt; 2
 </r>185   <r>| '&amp;' -&gt; 3
       | '#' -&gt; 4
       | '^' -&gt; 5
       | '_' -&gt; 6
       | '~' -&gt; 7
 </r>190   <r>| '\\' -&gt; 8
       | '%'  -&gt; 9
       | c   -&gt;
           raise
             (Fatal ("Internal catcode table error: '"^String.make 1 c^"'"))
 </r>195 
     <b><U>and</U><r> plain = Array.create 10 </r><U>true</U>
     
     <U>let</U><r> is_plain c = plain.(plain_of_char c)
     <b><U>and</U></b> set_plain c = plain.(plain_of_char c) &lt;- </r><U>true</U></b>
 200 <b><U>and</U><r> unset_plain c = plain.(plain_of_char c) &lt;- </r><U>false</U>
     <U>and</U><r> plain_back b c = plain.(plain_of_char c) &lt;- b
     
     
     <b><U>let</U><r> top_level () = </r><U>match</U></b> !subst <b><U>with</U><r> Top -&gt; </r><U>true</U></b> | _ -&gt; </r><U>false</U></b>
 205 <b><U>and</U><r> is_top = </r><U>function</U><r>
       | Top -&gt; <b><U>true</U></b>
       | _   -&gt; </r><U>false</U></b>
     
     
 210 <b><U>let</U><r> prerr_args () = pretty_subst !subst
     
     
     </r><U>let</U><r> scan_arg lexfun i =
       <b><U>let</U><r> args = </r><U>match</U></b> !subst </r><U>with</U></b>
 215   <r>| Top -&gt; [||]
       | Env args -&gt; args <b><U>in</U>
       <U>if</U></b> i &gt;= Array.length args <b><U>then</U> <U>begin</U>
         <U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
           prerr_string ("Subst arg #"^string_of_int (i+1)^" -&gt; not found") ;
 </r>220       <r>pretty_subst !subst
         <b><U>end</U><r> ;
         raise (Error "Macro argument not found")
       </r><U>end</U></b>;
       <b><U>let</U><r> arg = args.(i) </r><U>in</U><m>
 225 
       </m><U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
         prerr_string ("Subst arg #"^string_of_int (i+1)^" -&gt; ``"^arg.arg^"''")
       <b><U>end</U><r> ;
       </r><U>let</U></b> r = lexfun arg <b><U>in</U><m>
 230   <r>r
     
     <b><U>and</U><r> scan_body exec body args = </r><U>match</U></b> body <b><U>with</U></b>
     | CamlCode _|Toks _ -&gt; exec body
     | Subst _ -&gt;
 </r>235     </m><U>let</U></b> old_subst = !subst <b><U>in</U><r>
         subst := args ;
         </r><U>let</U></b> r = exec body <b><U>in</U></b>
         subst := old_subst ;
         r
 </r>240 
     </m>(* Recoding and restoring lexbufs *)
     
     <b><U>let</U><r> record_lexbuf lexbuf subst =
       Stack.push stack_subst subst ;
 </r></b></w>245   <r>Stack.push stack_lexbuf lexbuf ;
     
     <b><U>and</U><r> previous_lexbuf () =
       </r><U>let</U></b> lexbuf = Stack.pop stack_lexbuf <b><U>in</U></b>
       subst := Stack.pop stack_subst ;
 </r>250   <r>lexbuf
     ;;
     
     <w>(* Saving and restoring lexing status *)
     
 <m>255 <b><U>let</U><r> stack_lexstate = Stack.create "stack_lexstate"
     
     </r><U>let</U><r> top_lexstate () = Stack.empty stack_lexstate
     
     <b><U>let</U></b> save_lexstate () =
 </r></b>260   <r><b><U>let</U><r> old_stack = Stack.save stack_subst </r><U>in</U></b>
       Stack.push stack_subst !subst ;
       push stack_lexstate
         (Stack.save stack_lexbuf,
          Stack.save stack_subst) ;
 </r>265   <r>Stack.restore stack_subst old_stack
     
     <b><U>and</U><r> restore_lexstate () =
       </r><U>let</U></b> lexbufs,substs = pop stack_lexstate <b><U>in</U></b>
       Stack.restore stack_lexbuf lexbufs ;
 </r>270   <r>Stack.restore stack_subst substs ;
       subst := Stack.pop stack_subst
     
     <w>(* Flags save and restore *)
     <b><U>let</U></b></w> save_flags () =
 </r>275   <r>push stack_display !display ;
       push stack_in_math !in_math
     
     <b><U>and</U></b> restore_flags () =
       in_math := pop stack_in_math ;
 </r>280   <r>display := pop stack_display
     
     <w>(* Total ckeckpoint of lexstate *)
     <b><U>type</U></b></w> saved_lexstate =
     (Lexing.lexbuf Stack.saved * subst Stack.saved) Stack.saved *
 </r>285 <r>bool Stack.saved * bool Stack.saved
     
     <b><U>let</U></b> check_lexstate () =
       save_lexstate () ;
       save_flags () ;
 </r>290   <b><U>let</U><r> r =
         Stack.save stack_lexstate,
         Stack.save stack_display,
         Stack.save stack_in_math </r><U>in</U><r>
       restore_lexstate () ;
 </r></b>295   <r>restore_flags () ;
       r
     
     <b><U>and</U></b> hot_lexstate (l,d,m) =
       Stack.restore stack_lexstate l ;
 </r>300   <r>Stack.restore stack_display d ;
       Stack.restore stack_in_math m ;
       restore_lexstate ()  ;
       restore_flags ()
     ;;
 </r>305 
     </m>(* Blank lexing status *)
     <b><U>let</U></b></w> start_lexstate () =
       save_lexstate () ;
       Stack.restore stack_lexbuf (Stack.empty_saved) ;
 </r>310   <r>Stack.restore stack_subst (Stack.empty_saved)
     
     <b><U>let</U></b> start_lexstate_subst this_subst =
       start_lexstate () ;
       subst := this_subst
 </r>315 <r>;;
     
     <b><U>let</U><r> flushing = ref </r><U>false</U></b>
     ;;
     
 </r>320 
     <b><U>let</U><r> start_normal this_subst =
       start_lexstate () ;
       save_flags () ;
       display := </r><U>false</U><r> ;
 </r></b>325   <r>in_math := <b><U>false</U><r> ;
       subst := this_subst
     
     </r><U>and</U></b> end_normal () =
       restore_flags () ;
 </r>330   <r>restore_lexstate ()
     ;;
     
     <b><U>let</U><r> full_save_arg eoferror mkarg parg lexfun lexbuf =
       </r><U>let</U> <U>rec</U></b> save_rec lexbuf =
 </r>335     <b><U>try</U>
           <U>let</U><r> arg = lexfun lexbuf <b><U>in</U><r>
           mkarg arg !subst
         </r><U>with</U></b> Save.Eof -&gt; <b><U>begin</U>
             <U>if</U></b> Stack.empty stack_lexbuf <b><U>then</U><m>
 340            <r>eoferror ()
             <b><U>else</U> <U>begin</U>
               <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U>
               <U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
                 prerr_endline "popping stack_lexbuf in full_save_arg";
 </r>345             <r>pretty_lexbuf lexbuf ;
                 prerr_args ()
               <b><U>end</U><r>;
               save_rec lexbuf
             </r><U>end</U><m>
 350     </m><U>end</U> <U>in</U>
     
       <U>let</U></b> start_pos = Location.get_pos () <b><U>in</U>
       <U>try</U></b>
         Save.seen_par := <b><U>false</U></b> ;
 </r>355     <r>save_lexstate () ;
         <b><U>let</U><r> r = save_rec lexbuf </r><U>in</U></b>
         restore_lexstate () ;
         <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U></b>
           prerr_endline ("Arg parsed: ``"^parg r^"''") ;
 </r>360     <r>r
       <b><U>with</U><r>
       | (Save.Error _ | Error _) </r><U>as</U></b> e -&gt;
           restore_lexstate () ;
           Save.seen_par := <b><U>false</U></b> ;
 </r>365       <r>Location.print_this_pos start_pos ;
           prerr_endline "Parsing of argument failed" ;
           raise e
       | e -&gt;
           restore_lexstate () ;
 </r>370       <r>raise e
     ;;
     
     <b><U>type</U><r> ok = No </r><U>of</U></b> string | Yes <b><U>of</U></b> string
     ;;
 </r>375 
     </m><U>let</U></b> parg {arg=arg} = arg
     <b><U>and</U><r> pok = </r><U>function</U></b>
       | {arg=Yes s} -&gt; s
       | {arg=No s} -&gt; "* default arg: ["^s^"] *"
 </r></b>380 
     
     <b><U>let</U><r> eof_arg () =
       Save.empty_buffs () ;
       raise (Error "Eof while looking for argument")
 </r></b>385 
     <b><U>let</U><r> save_arg lexbuf =
       </r><U>let</U><r> r = full_save_arg eof_arg mkarg parg Save.arg lexbuf <b><U>in</U></b>
       r
     
 </r></b>390 <b><U>and</U><r> save_arg_with_delim delim lexbuf =
       full_save_arg eof_arg mkarg parg (Save.with_delim delim) lexbuf
     </r><U>and</U><r> save_filename lexbuf =
       full_save_arg eof_arg mkarg parg Save.filename lexbuf
     <b><U>and</U></b> save_verbatim lexbuf =
 </r></b>395   <r>full_save_arg eof_arg mkarg parg Save.arg_verbatim lexbuf
     
     <b><U>type</U></b> sup_sub = {
       limits : Misc.limits option ;
       sup : string arg ;
 </r>400   <r>sub : string arg ;
     }
     
     <b><U>let</U></b> mklimits x _ = x
     
 </r>405 <r><b><U>let</U><r> plimits = </r><U>function</U></b>
       | Some Limits -&gt;    "\\limits"
       | Some NoLimits -&gt;  "\\nolimits"
       | Some IntLimits -&gt; "\\intlimits"
       | None          -&gt; "*no limit info*"
 </r>410 
     <b><U>exception</U><r> Over
     </r><U>let</U><r> eof_over () = raise Over
     
     <b><U>let</U></b> save_limits lexbuf =
 </r></b>415   <b><U>let</U> <U>rec</U><r> do_rec res =
         <b><U>try</U>
           <U>let</U></b> r =
             full_save_arg eof_over mklimits plimits Save.get_limits lexbuf <b><U>in</U>
           <U>match</U></b> r <b><U>with</U><m>
 420       <r>| None -&gt; res
           | Some _ -&gt; do_rec r
         <b><U>with</U><r>
         | Over -&gt; res </r><U>in</U></b>
       do_rec None
 </r>425 
     </m><U>let</U></b> mkoptionarg opt subst = <b><U>match</U><r> opt </r><U>with</U></b>
     | None -&gt; None
     | Some s -&gt; Some (mkarg s subst)
     
 </r></b>430 <b><U>and</U><r> poptionarg = </r><U>function</U><r>
     | None -&gt; "*None*"
     | Some a -&gt; a.arg
     
     <b><U>let</U></b> save_sup lexbuf =
 </r></b>435   <b><U>try</U><r>
        full_save_arg eof_over mkoptionarg poptionarg Save.get_sup lexbuf
       </r><U>with</U><r>
       | Over -&gt; None
     
 </r></b>440 </m><b><U>and</U><r> save_sub lexbuf =
       </r><U>try</U></b>
         full_save_arg eof_over mkoptionarg poptionarg Save.get_sub lexbuf
       <b><U>with</U><r>
       | Over -&gt; None
 </r><m>445 
     </m><U>let</U></b> unoption = <b><U>function</U><r>
       | None   -&gt; {arg="" ; subst=top_subst }
       | Some a -&gt; a
     
 </r><m>450 </m><U>let</U></b> save_sup_sub lexbuf =
       <b><U>let</U><r> limits = save_limits lexbuf </r><U>in</U>
       <U>match</U></b> save_sup lexbuf <b><U>with</U><r>
       | None -&gt;
           </r><U>let</U></b> sub = save_sub lexbuf <b><U>in</U><m>
 455       </m><U>let</U></b> sup = save_sup lexbuf <b><U>in</U><r>
           {limits=limits  ; sup = unoption sup ; sub = unoption sub}
       | Some sup -&gt;
           </r><U>let</U></b> sub = save_sub lexbuf <b><U>in</U><r>
           {limits=limits  ; sup = sup ; sub = unoption sub}
 </r><m>460 
     </m><U>let</U></b> protect_save_string lexfun lexbuf =
       full_save_arg eof_arg
         (<b><U>fun</U><r> s _ -&gt; s)
         (</r><U>fun</U></b> s -&gt; s)
 <m>465     <r>lexfun lexbuf
     
     <b><U>let</U><r> eof_opt def () = {arg=No def ; subst=Top }
     
     </r><U>let</U></b> save_arg_opt def lexbuf =
 </r>470   <b><U>let</U><r> r =
         full_save_arg
           (eof_opt def)
           mkarg
           pok
 <m>475       </m>(</r><U>fun</U><r> lexbuf -&gt;
             <b><U>try</U><r> Yes (Save.opt lexbuf) </r><U>with</U></b>
             | Save.NoOpt -&gt; No def)
           lexbuf <b><U>in</U>
       <U>match</U></b> r.arg <b><U>with</U><m>
 480   <r>| Yes _ -&gt; r
       | No  _ -&gt; mkarg (No def) !subst
     
     
     ;;
 </r>485 
     
     </m><U>let</U></b> from_ok okarg = <b><U>match</U><r> okarg.arg </r><U>with</U></b>
       | Yes s -&gt;
           optarg := <b><U>true</U><r> ;
 <m>490       </m>mkarg s okarg.subst
       | No s  -&gt;
           optarg := </r><U>false</U></b> ;
           mkarg s okarg.subst
     
 <m>495 <b><U>let</U></b></m> pretty_ok = <b><U>function</U><r>
       Yes s -&gt; "+"^s^"+"
     | No s  -&gt; "-"^s^"-"
     ;;
     
 </r><m>500 
     </m><U>let</U></b> norm_arg s =
       String.length s = 2 &amp;&amp; s.[0] = '#' &amp;&amp;
       ('0' &lt;= s.[1] &amp;&amp; s.[1] &lt;= '9')
     
 <m>505 <b><U>let</U> <U>rec</U><r> parse_args_norm pat lexbuf = <b><U>match</U><r> pat </r><U>with</U></b>
     |   [] -&gt; []
     | s :: (ss :: _ <b><U>as</U><r> pat) </r><U>when</U></b> norm_arg s &amp;&amp; norm_arg ss -&gt;
         <b><U>let</U><r> arg = save_arg lexbuf </r><U>in</U>
         <U>let</U></b> r = parse_args_norm pat lexbuf </r><U>in</U></b>
 510      </m>arg :: r
     | s :: ss :: pat <b><U>when</U><r> norm_arg s &amp;&amp; not (norm_arg ss) -&gt;
         </r><U>let</U></b> arg = save_arg_with_delim ss lexbuf <b><U>in</U><r>
         arg :: parse_args_norm pat lexbuf
     | s :: pat </r><U>when</U></b> not (norm_arg s) -&gt;
 <m>515     </m>Save.skip_delim s lexbuf ;
         parse_args_norm pat lexbuf
     | s :: pat -&gt;
         <b><U>let</U><r> arg = save_arg lexbuf </r><U>in</U>
         <U>let</U></b> r = parse_args_norm pat lexbuf <b><U>in</U><m>
 520     <r>arg :: r
     ;;
     
     
     <b><U>let</U></b> skip_csname lexbuf =
 </r>525   </m><U>let</U></b> _ = Save.csname lexbuf (<b><U>fun</U><r> x -&gt; x) </r><U>in</U></b> ()
     
     
     </r><U>let</U></b></m> skip_opt lexbuf =
       <b><U>let</U><r> _ =  save_arg_opt "" lexbuf  </r><U>in</U><m>
 530   <r>()
     
     <b><U>and</U></b> save_opt def lexbuf = from_ok (save_arg_opt def  lexbuf)
     ;;
     
 </r>535 </m><U>let</U> <U>rec</U></b> save_opts pat lexbuf = <b><U>match</U><r> pat </r><U>with</U></b>
       [] -&gt; []
     | def::rest -&gt;
        <b><U>let</U><r> arg = save_arg_opt def lexbuf </r><U>in</U>
        <U>let</U></b> r = save_opts rest lexbuf <b><U>in</U><m>
 540    <r>arg :: r
     ;;
     
     
     <b><U>let</U></b> parse_args (popt,pat) lexbuf =
 </r>545   <r>Save.seen_par := <b><U>false</U><r> ;
       </r><U>let</U></b> opts =  save_opts popt lexbuf <b><U>in</U>
       <U>begin</U> <U>match</U></b> pat <b><U>with</U><r>
       | s :: ss :: _ </r><U>when</U></b> norm_arg s &amp;&amp; not (norm_arg ss) -&gt;
           Save.skip_blanks_init lexbuf
 </r>550   <r>| _ -&gt; ()
       <b><U>end</U><r> ;
       </r><U>let</U></b> args =  parse_args_norm pat lexbuf <b><U>in</U></b>
       (opts,args)
     ;;
 </r>555 
     </m><U>let</U></b> make_stack name pat lexbuf =
       <b><U>try</U>
         <U>let</U></b> (opts,args) = parse_args pat lexbuf <b><U>in</U>
         <U>let</U></b> args = Array.of_list (List.map from_ok opts@args) <b><U>in</U><m>
 560     </m><U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
           Printf.fprintf stderr "make_stack for macro: %s "  name ;
           pretty_pat pat ;
           prerr_endline "";
           <b><U>for</U><r> i = 0 </r><U>to</U></b> Array.length args-1 <b><U>do</U><m>
 565         <r>Printf.fprintf stderr "\t#%d = %s\n" (i+1) (args.(i).arg) ;
             pretty_subst (args.(i).subst)
           <b><U>done</U>
         <U>end</U></b> ;
         Env args
 </r>570   </m><U>with</U></b> Save.Delim delim -&gt;
         raise
           (Error
              ("Use of "^name^
               " does not match its definition (delimiter: "^delim^")"))
 <m>575 
     <r>;;
     
     <b><U>let</U></b> scan_this lexfun s =
       start_lexstate ();
 </r>580   <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U> <U>begin</U><r>
         Printf.fprintf stderr "scan_this : [%s]" s ;
         prerr_endline ""
       <b><U>end</U><r> ;
       </r><U>let</U></b> lexer = Lexing.from_string s <b><U>in</U><m>
 585   </m><U>let</U></b> r = lexfun lexer <b><U>in</U>
       <U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "scan_this : over" ;
         prerr_endline ""
       <b><U>end</U></b> ;
 </r></b>590   <r>restore_lexstate ();
       r
     
     <b><U>and</U></b> scan_this_arg lexfun {arg=s ; subst=this_subst } =
       start_lexstate () ;
 </r>595   <r>subst := this_subst ;
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "scan_this_arg : [%s]" s ;
         prerr_endline ""
       <b><U>end</U></b> ;
 </r>600   <b><U>let</U><r> lexer = Lexing.from_string s </r><U>in</U>
       <U>let</U><r> r = lexfun lexer <b><U>in</U>
       <U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "scan_this_arg : over" ;
         prerr_endline ""
 </r></b>605   <b><U>end</U><r> ;
       restore_lexstate ();
       r
     ;;
     
 </r></b>610 <b><U>let</U><r> scan_this_may_cont lexfun lexbuf cur_subst
         {arg=s ; subst=env } =
       </r><U>if</U><r> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "scan_this_may_cont : [%s]" s ;
         prerr_endline "" ;
 </r></b>615     <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U> <U>begin</U><r>
           prerr_endline "Pushing lexbuf and env" ;
           pretty_lexbuf lexbuf ;
           pretty_subst !subst
         <b><U>end</U><m>
 620   </m><U>end</U></b> ;
       save_lexstate ();
       record_lexbuf lexbuf cur_subst ;
       subst := env ;
       <b><U>let</U><r> lexer = Lexing.from_string s </r><U>in</U><m>
 625   </m><U>let</U></b> r = lexfun lexer <b><U>in</U><r>
     
       restore_lexstate ();
       </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "scan_this_may_cont : over" ;
 </r></b>630     <r>prerr_endline ""
       <b><U>end</U><r> ;
       r
     
     </r><U>let</U></b> real_input_file loc_verb main filename input =
 </r>635   <b><U>if</U><r> !verbose &gt; 0 </r><U>then</U><r>
         prerr_endline ("Input file: "^filename) ;
       <b><U>let</U><r> buf = Lexing.from_channel input </r><U>in</U></b>
       Location.set filename buf ;
       <b><U>let</U><r> old_verb = !verbose </r><U>in</U><m>
 640   <r>verbose := loc_verb ;
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b> prerr_endline ("scanning: "^filename) ;
       start_lexstate () ;
       <b><U>let</U><r> old_lexstate = Stack.save stack_lexstate </r><U>in</U></b>
       subst := Top ;
 </r>645   </m><U>begin</U> <U>try</U></b>  main buf <b><U>with</U></b>
       | Misc.EndInput -&gt;
           Stack.restore  stack_lexstate old_lexstate
       | e -&gt;
           Stack.restore  stack_lexstate old_lexstate ;
 </r></b>650       <r>restore_lexstate ();
           close_in input ;
           verbose := old_verb ;
     <w>(*   NO  Location.restore () ;  for proper error messages *)
           </w>raise e
 </r>655   <b><U>end</U><r> ;
       restore_lexstate ();
       </r><U>if</U><r> !verbose &gt; 1 <b><U>then</U><r> prerr_endline ("scanning over: "^filename) ;
       close_in input ;
       verbose := old_verb ;
 <m>660   </m>Location.restore ()
     
     </r><U>let</U></b> input_file loc_verb main filename =
       <b><U>try</U>
         <U>let</U></b> filename,input = Myfiles.open_tex filename </r><U>in</U></b>
 665     <r>real_input_file loc_verb main filename input
       <b><U>with</U><r> Myfiles.Except -&gt; </r><U>begin</U>
         <U>if</U></b> !verbose &gt; 0 <b><U>then</U></b>
           prerr_endline ("Not opening file: "^filename) ;
         raise  Myfiles.Except
 </r>670   <b><U>end</U><r>
      | Myfiles.Error m </r><U>as</U><r> x -&gt; <b><U>begin</U></b>
          Misc.warning m ;
          raise x
      </r><U>end</U></b>
 675 
     
     <w>(* Hot start *)
     </w></m><b><U>type</U><r> saved = (string * bool ref) list * bool list
     
 </r><m>680 </m><U>let</U></b> cell_list = ref []
     
     <b><U>let</U><r> checkpoint () =
       !cell_list, List.map (</r><U>fun</U></b> (_,cell) -&gt; !cell) !cell_list ;
     
 <m>685 <b><U>and</U></b></m> hot_start (cells, values)  =
       <b><U>let</U> <U>rec</U></b> start_rec cells values = <b><U>match</U><r> cells, values </r><U>with</U></b>
       | [],[] -&gt; ()
       | (name,cell)::rcells, value :: rvalues -&gt;
           <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U> <U>begin</U><m>
 690       <r>prerr_endline
             ("Restoring "^name^" as "^<b><U>if</U><r> value </r><U>then</U></b> "true" <b><U>else</U><r> "false")
           </r><U>end</U></b> ;
           cell := value ;
           start_rec rcells rvalues
 </r>695   <r>| _,_ -&gt;
           Misc.fatal ("Trouble in Lexstate.hot_start") <b><U>in</U></b>
       start_rec cells values ;
       cell_list := cells
     
 </r>700 
     </m><U>let</U></b> register_cell name cell =
       cell_list :=  (name,cell) :: !cell_list
     
     <b><U>and</U><r> unregister_cell name =
 </r><m>705   </m><U>let</U> <U>rec</U></b> un_rec = <b><U>function</U><r>
         | [] -&gt;
             Misc.warning ("Cannot unregister cell: "^name) ;
             []
         | (xname,cell) :: rest -&gt;
 </r><m>710         </m><U>if</U></b> xname = name <b><U>then</U><r> rest
             </r><U>else</U></b>
               (xname,cell) :: un_rec rest <b><U>in</U></b>
       cell_list := un_rec !cell_list</TT>
<B><6>99 location.ml</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     <b><U>open</U></b></w> Stack
     
     <b><U>let</U><r> header = "$Id: location.ml,v 1.19 2001/05/28 17:28:56 maranget Exp $"
     
  </r><m>15 </m><U>type</U></b> fileOption = No | Yes <b><U>of</U><r> in_channel
     ;;
     
     </r><U>let</U></b> stack = Stack.create "location"
     ;;
  <m>20 
     
     
     <b><U>let</U></b></m> curlexbuf = ref (Lexing.from_string "")
     <b><U>and</U><r> curlexname = ref ""
  </r><m>25 </m><U>and</U></b> curline = ref (0,1)
     <b><U>and</U><r> curfile = ref No
     ;;
     
     </r><U>let</U></b> save_state () =
  <m>30   <r>push stack (!curlexname,!curlexbuf,!curline,!curfile)
     
     <b><U>and</U><r> restore_state () =
       </r><U>let</U></b> name,lexbuf,line,file = pop stack <b><U>in</U></b>
       curlexname := name ;
  </r>35   <r>curlexbuf := lexbuf;
       curline := line;
       curfile := file
     
     <b><U>type</U></b> saved = (string * Lexing.lexbuf * (int * int)  * fileOption) Stack.saved
  </r>40 
     <b><U>let</U></b></m> close_file = <b><U>function</U><r>
       | Yes f -&gt; close_in f
       | _ -&gt; ()
     
  </r><m>45 </m><U>let</U></b> close_curfile () = close_file !curfile
     
     <b><U>let</U><r> check () =
       save_state () ;
       </r><U>let</U></b> r = Stack.save stack <b><U>in</U><m>
  50   <r>restore_state () ;
       r
     
     <b><U>and</U><r> hot saved =
       </r><U>let</U></b> to_finalize = stack <b><U>in</U><m>
  55   <r>Stack.restore stack saved ;
       <b><U>let</U><r> _,_,_,file_now = Stack.top stack </r><U>in</U></b>
       Stack.finalize to_finalize
         (<b><U>fun</U><r> (_,_,_,file) -&gt; file == file_now)
         (</r><U>fun</U></b> (_,_,_,file) -&gt; close_file file) ;
  </r>60   <r>restore_state ()
     
     <b><U>let</U></b> get () = !curlexname
     ;;
     
  </r>65 </m><U>let</U></b> set name lexbuf =
       save_state () ;
       curlexname := name ;
       curlexbuf := lexbuf;
       curfile :=
  </r>70      </m><U>begin</U> <U>match</U></b> name <b><U>with</U><r> "" -&gt; No
          | _ -&gt;
              </r><U>try</U></b> Yes (open_in name) <b><U>with</U><r> Sys_error _ -&gt; No
          </r><U>end</U></b> ;
       curline := (0,1)
  <m>75 <r>;;
     
     <b><U>let</U></b> restore () =
       close_curfile () ;
       restore_state ()
  </r>80 <r>;;
     
     
     <b><U>let</U> <U>rec</U></b> do_find_line file lp r c = <b><U>function</U></b>
       0 -&gt; lp,r,c
  </r>85 <r>| n -&gt;
        <b><U>let</U><r> cur = input_char file </r><U>in</U></b>
        do_find_line file
         (<b><U>match</U><r> cur </r><U>with</U></b> '\n' -&gt; lp+c+1 | _ -&gt; lp)
         (<b><U>match</U><r> cur </r><U>with</U></b> '\n' -&gt; r+1 | _ -&gt; r)
  </r>90     <r>(<b><U>match</U><r> cur </r><U>with</U></b> '\n' -&gt; 0 | _ -&gt; c+1)
         (n-1)
     ;;
     
     <b><U>let</U></b> find_line file lp nline nchars = do_find_line file lp nline 0 nchars
  </r>95 
     <b><U>type</U></b></m> t = string * int * int
     
     <b><U>let</U><r> do_get_pos () =  </r><U>match</U></b> !curfile <b><U>with</U><r>
       No -&gt; -1,-1
 <m>100 </m>| Yes file -&gt;
         </r><U>try</U>
           <U>let</U></b>  char_pos = Lexing.lexeme_start !curlexbuf
           <b><U>and</U><r> last_pos,last_line = !curline </r><U>in</U>
           <U>let</U></b> last_pos,last_line =
 <m>105         <b><U>if</U></b></m> char_pos &lt; last_pos <b><U>then</U><r> 0,1 </r><U>else</U></b> last_pos,last_line <b><U>in</U><r>
           seek_in file last_pos ;
     </r><w>(*      prerr_endline ("char_pos="^string_of_int char_pos) ; *)
           </w><U>let</U></b> line_pos,nline,nchar =
             find_line file last_pos last_line (char_pos-last_pos) <b><U>in</U><m>
 110       <r>curline := (line_pos,nline);
           nline,nchar
         <b><U>with</U></b> Sys_error _ -&gt; -1,-1
     ;;
     
 </r>115 </m><U>let</U></b> get_pos () =
       <b><U>let</U><r> nline,nchars = do_get_pos () </r><U>in</U></b>
       !curlexname,nline,nchars
     ;;
     
 <m>120 <b><U>let</U></b></m> do_print_pos full (s,nline,nchars) =
       <b><U>if</U><r> nline &gt;= 0 </r><U>then</U></b>
         prerr_string
           (s^":"^string_of_int nline^
            (<b><U>if</U><r> full </r><U>then</U></b> ":"^string_of_int (nchars+1)^": " <b><U>else</U><r> ": "))
 </r><m>125   </m><U>else</U>
         <U>match</U></b> s <b><U>with</U><r>
         | "" -&gt; ()
         | _  -&gt;  prerr_string (s^": ")
     
 </r><m>130 </m><U>let</U></b> print_pos () =
       <b><U>let</U><r> nlines,nchars = do_get_pos () </r><U>in</U></b>
       do_print_pos <b><U>false</U><r> (!curlexname,nlines,nchars)
     
     </r><U>and</U></b> print_fullpos () =
 <m>135   <b><U>let</U></b></m> nlines,nchars = do_get_pos () <b><U>in</U><r>
       do_print_pos </r><U>true</U></b> (!curlexname,nlines,nchars)
     
     <b><U>and</U><r> print_this_pos p = do_print_pos </r><U>false</U></b> p
     <b><U>and</U><r> print_this_fullpos p = do_print_pos </r><U>true</U></b> p</TT><B>
<6>100 mathML.ml</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>let</U></b></w> header = "$Id: mathML.ml,v 1.15 2000/10/13 19:17:41 maranget Exp $"
     
     
  <m>15 <b><U>open</U></b></m> Misc
     <b><U>open</U><r> Parse_opts
     </r><U>open</U></b> Element
     <b><U>open</U><r> HtmlCommon
     </r><U>open</U></b> Latexmacros
  <m>20 <b><U>open</U></b></m> Stack
     
     <w>(*----------*)
     (* DISPLAYS *)
     (*----------*)
  <m>25 
     <b><U>let</U><r> begin_item_display f is_freeze =
       </r><U>if</U><r> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "begin_item_display: ncols=%d empty=%s" flags.ncols (sbool flags.empty) ;
         prerr_newline ()
  </r></b>30   <b><U>end</U><r> ;
       open_block (OTHER "mrow") "";
       open_block GROUP "" ;
       </r><U>if</U><r> is_freeze <b><U>then</U><w>(* push out_stack (Freeze f) ;*)<r>freeze f;
     
  <m>35 
     <b><U>and</U><r> end_item_display () =
       </r><U>let</U><r> f,is_freeze = pop_freeze () <b><U>in</U>
       <U>let</U></b> _ = close_flow_loc GROUP <b><U>in</U>
       <U>if</U></b> close_flow_loc (OTHER "mrow") </r><U>then</U></b>
  40     </m>flags.ncols &lt;- flags.ncols + 1;
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "end_item_display: ncols=%d stck: " flags.ncols;
         pretty_stack out_stack
       <b><U>end</U></b>;
  <m>45   <r>flags.vsize,f,is_freeze
     
     
     <b><U>and</U><r> open_display () =
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U><m>
  50     <r>Printf.fprintf stderr "open_display: "
       <b><U>end</U></b> ;
       try_open_display () ;
       open_block (OTHER "mrow") "";
       do_put_char '\n';
  </r>55   <r>open_block GROUP "" ;
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
         pretty_cur  !cur_out ;
         prerr_endline ""
       <b><U>end</U><m>
  60 
     
     </m><U>and</U></b> close_display () =
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
         prerr_flags "=&gt; close_display"
  </r>65   </m><U>end</U></b> ;
       <b><U>if</U><r> not (flush_freeze ()) </r><U>then</U> <U>begin</U></b>
         close_flow GROUP ;
         <b><U>let</U><r> n = flags.ncols </r><U>in</U>
         <U>if</U></b> (n = 0 &amp;&amp; not flags.blank) <b><U>then</U> <U>begin</U><m>
  70       </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
             prerr_string "No Display n=0" ;
             (Out.debug stderr !cur_out.out);
             prerr_endline ""
           <b><U>end</U></b>;
  </r>75       <b><U>let</U><r> active = !cur_out.active </r><U>and</U><r> pending = !cur_out.pending <b><U>in</U><r>
           do_close_mods () ;
           </r><U>let</U></b> ps,_,ppout = pop_out out_stack <b><U>in</U>
           <U>if</U></b> ps &lt;&gt; (OTHER "mrow") <b><U>then</U><r>
      failclose "close_display"  ps (OTHER "mrow") ;
  <m>80       </m>try_close_block (OTHER "mrow");
           </r><U>let</U></b> old_out = !cur_out <b><U>in</U><r>
           cur_out := ppout ;
           do_close_mods () ;
           Out.copy old_out.out !cur_out.out ;
  <m>85       </m>flags.empty &lt;- </r><U>false</U></b> ; flags.blank &lt;- <b><U>false</U><r> ;
           free old_out ;
           !cur_out.pending &lt;- to_pending pending active
         </r><U>end</U> <U>else</U> <U>if</U></b> (n=1 <w>(*&amp;&amp; flags.blank*)</w>) <b><U>then</U> <U>begin</U>
           <U>if</U></b> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
  90         <r>prerr_string "No display n=1";
             (Out.debug stderr !cur_out.out);
             prerr_endline "" ;
           <b><U>end</U><r>;
           </r><U>let</U></b> active = !cur_out.active <b><U>and</U><r> pending = !cur_out.pending </r><U>in</U><m>
  95       </m><U>let</U></b> ps,_,pout = pop_out out_stack <b><U>in</U>
           <U>if</U></b> ps&lt;&gt; (OTHER "mrow") <b><U>then</U><r>
      failclose "close_display" ps (OTHER "mrow");
           try_close_block (OTHER "mrow") ;
           </r><U>let</U></b> old_out = !cur_out <b><U>in</U><m>
 100       <r>cur_out := pout ;
           do_close_mods () ;
           <b><U>if</U><r> flags.blank </r><U>then</U></b> Out.copy_no_tag old_out.out !cur_out.out
           <b><U>else</U><r> Out.copy old_out.out !cur_out.out;
           flags.empty &lt;- </r><U>false</U></b> ; flags.blank &lt;- <b><U>false</U></b> ;
 </r>105       <r>free old_out ;
           !cur_out.pending &lt;- to_pending pending active
         <b><U>end</U> <U>else</U> <U>begin</U>
           <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
             prerr_string ("One Display n="^string_of_int n) ;
 </r>110         <r>(Out.debug stderr !cur_out.out);
             prerr_endline ""
           <b><U>end</U></b>;
           flags.empty &lt;- flags.blank ;
           close_flow (OTHER "mrow") ;
 </r>115       <r>do_put_char '\n';
         <b><U>end</U><r> ;
         try_close_display ()
       </r><U>end</U></b> ;
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U><m>
 120     <r>prerr_flags ("&lt;= close_display")
     ;;
     
     
     <b><U>let</U></b> do_item_display force =
 </r>125   </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         prerr_endline ("Item Display ncols="^string_of_int flags.ncols^" table_inside="^sbool flags.table_inside)
       <b><U>end</U><r> ;
       </r><U>let</U></b> f,is_freeze = pop_freeze () <b><U>in</U>
       <U>if</U></b> (<w>(*force &amp;&amp; *)</w>not flags.empty) || flags.table_inside <b><U>then</U><m>
 130     <r>flags.ncols &lt;- flags.ncols + 1 ;
       <b><U>let</U><r> active  = !cur_out.active
       </r><U>and</U></b> pending = !cur_out.pending <b><U>in</U></b>
       close_flow GROUP ;
       open_block GROUP "";
 </r>135   <r>!cur_out.pending &lt;- to_pending pending active;
       !cur_out.active &lt;- [] ;
       <b><U>if</U><r> is_freeze </r><U>then</U></b> freeze f;
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
         prerr_string ("out item_display -&gt; ncols="^string_of_int flags.ncols) ;
 </r>140     <r>pretty_stack out_stack
       <b><U>end</U><r> ;
     ;;
     
     </r><U>let</U></b> item_display () = do_item_display <b><U>false</U><m>
 145 </m><U>and</U></b> force_item_display () = do_item_display <b><U>true</U></b>
     ;;
     
     
     
 </r>150 </m><U>let</U></b> erase_display () =
       erase_block GROUP ;
       erase_block (OTHER "mrow");
       try_close_display ()
     ;;
 </r>155 
     </m><U>let</U></b> open_maths display =
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b> prerr_endline "=&gt; open_maths";
       push stacks.s_in_math flags.in_math;
       <b><U>if</U><r> display </r><U>then</U></b> do_put "&lt;BR&gt;\n";
 </r>160   <b><U>if</U><r> not flags.in_math </r><U>then</U><r> open_block (OTHER "math") "align=\"center\""
       <b><U>else</U><r> erase_mods [Style "mtext"];
       do_put_char '\n';
       flags.in_math &lt;- </r><U>true</U></b>;
       open_display ();
 <m>165   </m>open_display ();
     ;;
     
     <b><U>let</U><r> close_maths display =
       </r><U>if</U></b> !verbose &gt;1 <b><U>then</U><r> prerr_endline "=&gt; close_maths";
 <m>170   </m>close_display ();
       close_display ();
       flags.in_math &lt;- pop stacks.s_in_math ;
       do_put_char '\n';
       </r><U>if</U></b> not flags.in_math </r><U>then</U> <U>begin</U></b>
 175     <r>close_block (OTHER "math") <b><U>end</U>
       <U>else</U></b> open_mod (Style "mtext");
     ;;
     
     
 </r>180 
     
     <b><U>let</U><r> insert_vdisplay open_fun =
       </r><U>if</U><r> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         prerr_flags "=&gt; insert_vdisplay" ;
 <m>185   <b><U>end</U><r> ;
       </r><U>try</U>
         <U>let</U><r> mods = to_pending !cur_out.pending !cur_out.active <b><U>in</U>
         <U>let</U></b> bs,bargs,bout = pop_out out_stack <b><U>in</U>
         <U>if</U></b> bs &lt;&gt; GROUP </r><U>then</U></b>
 190       </m>failclose "insert_vdisplay" bs GROUP ;
         <b><U>let</U><r> ps,pargs,pout = pop_out out_stack </r><U>in</U>
         <U>if</U></b> ps &lt;&gt; (OTHER "mrow") <b><U>then</U><r>
           failclose "insert_vdisplay" ps (OTHER "mrow");
         </r><U>let</U></b> new_out = create_status_from_scratch <b><U>false</U></b> [] </r><U>in</U></b>
 195     <r>push_out out_stack (ps,pargs,new_out) ;
         push_out out_stack (bs,bargs,bout) ;
         close_display () ;
         cur_out := pout ;
         open_fun () ;
 </r>200     <r>do_put (Out.to_string new_out.out) ;
         flags.empty &lt;- <b><U>false</U><r> ; flags.blank &lt;- </r><U>false</U></b> ;
         free new_out ;
         <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
           prerr_string "insert_vdisplay -&gt; " ;
 </r>205       <r>pretty_mods stderr mods ;
           prerr_newline ()
         <b><U>end</U><r> ;
         </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U></b>
           prerr_flags "&lt;= insert_vdisplay" ;
 </r>210     <r>mods
       <b><U>with</U></b> PopFreeze -&gt;
         raise (UserError "wrong parenthesization");
     ;;
     
 </r>215 
     </m></r>(* delaying output .... *)
     (*
     let delay f =
       if !verbose &gt; 2 then
 <m>220     </m>prerr_flags "=&gt; delay" ;
       push vsize_stack flags.vsize ;
       flags.vsize &lt;- 0;
       push delay_stack f ;
       open_block "DELAY" "" ;
 <m>225   </m>if !verbose &gt; 2 then
         prerr_flags "&lt;= delay"
     ;;
     
     let flush x =
 <m>230   </m>if !verbose &gt; 2 then
         prerr_flags ("=&gt; flush arg is ``"^string_of_int x^"''");
       try_close_block "DELAY" ;
       let ps,_,pout = pop_out out_stack in
       if ps &lt;&gt; "DELAY" then
 <m>235     </m>raise (Misc.Fatal ("html: Flush attempt on: "^ps)) ;
       let mods = !cur_out.active @ !cur_out.pending in
       do_close_mods () ;
       let old_out = !cur_out in
       cur_out := pout ;
 <m>240   </m>let f = pop "delay" delay_stack in
       f x ;
       Out.copy old_out.out !cur_out.out ;
       flags.empty &lt;- false ; flags.blank &lt;- false ;
       free old_out ;
 <m>245   </m>!cur_out.pending &lt;- mods ;
       flags.vsize &lt;- max (pop "vsive" vsize_stack) flags.vsize ;
       if !verbose &gt; 2 then
         prerr_flags "&lt;= flush"
     ;;
 <m>250 </m>*)
     
     (* put functions *)
     
     </w><U>let</U></b> is_digit = </r><U>function</U></b>
 255     <r>'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'0'|'.'|',' -&gt; <b><U>true</U><r>
       | _ -&gt; </r><U>false</U></b>
     ;;
     
     <b><U>let</U></b> is_number s =
 </r>260   <b><U>let</U><r> r = ref </r><U>true</U> <U>in</U>
       <U>for</U><r> i = 0 <b><U>to</U><r> String.length s -1 </r><U>do</U></b>
         r := !r &amp;&amp; is_digit s.[i]
       <b><U>done</U><r>;
       !r
 <m>265 </m>;;
     
     
     </r><U>let</U></b> is_op = <b><U>function</U></b>
       "+" | "-"|"/"|"*"|"%"|"&lt;"|"&gt;"|"="|"("|")"|"{"|"}"|"["|"]"|","|";"|":"|"|"|"&amp;"|"#"|"!"|"~"|"$" -&gt; </r><U>true</U></b>
 270 <r>| _ -&gt; <b><U>false</U><r>
     ;;
     
     </r><U>let</U></b> is_open_delim = <b><U>function</U><r>
       | "(" | "[" | "{" | "&lt;" -&gt; </r><U>true</U><m>
 275   <r>| _ -&gt; <b><U>false</U>
     <U>and</U></b> is_close_delim = <b><U>function</U><r>
       | ")" | "]" | "}" | "&gt;" -&gt; </r><U>true</U></b>
       | _ -&gt; <b><U>false</U></b>
     ;;
 </r>280 
     </m><U>let</U></b> open_delim () =
       open_display ();
       freeze
         ( <b><U>fun</U></b> () -&gt;
 </r>285       <r>close_display ();
           close_display (););
     <b><U>and</U><r> is_close () =
       </r><U>let</U></b> f, is_freeze = pop_freeze () <b><U>in</U>
       <U>if</U></b> is_freeze <b><U>then</U> <U>begin</U><m>
 290     <r>freeze f;
         <b><U>false</U>
       <U>end</U> <U>else</U>
         <U>true</U></b>;
     <b><U>and</U></b> close_delim () =
 </r>295   </m><U>let</U></b> f, is_freeze = pop_freeze () <b><U>in</U>
       <U>if</U></b> is_freeze <b><U>then</U> <U>begin</U></b>
         close_display ();
       <b><U>end</U> <U>else</U> <U>begin</U><r>
         close_display ();
 <m>300     <r>open_display ();
         warning "Math expression improperly parenthesized";
       <b><U>end</U></b>
     ;;
     
 </r>305 
     
     <b><U>let</U></b></m> put s =
       <b><U>let</U><r> s_blank =
         </r><U>let</U></b> r = ref <b><U>true</U> <U>in</U><m>
 310     </m><U>for</U></b> i = 0 <b><U>to</U><r> String.length s - 1 </r><U>do</U></b>
           r := !r &amp;&amp; is_blank (String.get s i)
         <b><U>done</U><r> ;
         !r </r><U>in</U>
       <U>let</U></b> s_blanc =
 <m>315     <b><U>let</U></b></m> r = ref <b><U>true</U> <U>in</U>
         <U>for</U></b> i = 0 <b><U>to</U><r> String.length s - 1 </r><U>do</U></b>
           r := !r &amp;&amp;  ((String.get s i)=' ')
         <b><U>done</U><r> ;
         !r </r><U>in</U><m>
 320   </m><U>if</U></b> not s_blanc <b><U>then</U> <U>begin</U>
         <U>let</U></b> s_op = is_op s
         <b><U>and</U><r> s_number = is_number s </r><U>in</U>
         <U>let</U></b> save_last_closed = flags.last_closed </r><U>in</U>
         <U>if</U><r> is_open_delim s </r><U>then</U><r> open_delim ();
 <m>325     <b><U>let</U></b></m> s_text = <b><U>if</U><r> is_close_delim s </r><U>then</U></b> is_close () <b><U>else</U> <U>false</U> <U>in</U>
         <U>if</U></b> s_op || s_number <b><U>then</U><r> force_item_display ();
         do_pending () ;
         flags.empty &lt;- </r><U>false</U></b>;
         flags.blank &lt;- s_blank &amp;&amp; flags.blank ;
 <m>330     <b><U>if</U></b></m> s_number <b><U>then</U> <U>begin</U></b>
           do_put ("&lt;mn&gt; "^s^" &lt;/mn&gt;\n")
         <b><U>end</U> <U>else</U> <U>if</U></b> s_text <b><U>then</U> <U>begin</U></b>
           do_put ("&lt;mtext&gt;"^s^"&lt;/mtext&gt;")
         <b><U>end</U> <U>else</U> <U>if</U></b> s_op <b><U>then</U> <U>begin</U><m>
 335       <r>do_put ("&lt;mo&gt; "^s^" &lt;/mo&gt;\n");
         <b><U>end</U> <U>else</U> <U>begin</U></b>
           do_put s
         <b><U>end</U><r>;
         </r><U>if</U></b> s_blank <b><U>then</U></b> flags.last_closed &lt;- save_last_closed;
 </r>340     </m><U>if</U></b> is_close_delim s <b><U>then</U><r> close_delim ();
       </r><U>end</U></b>
     ;;
     
     <b><U>let</U><r> put_char c =
 </r><m>345   </m><U>let</U></b> save_last_closed = flags.last_closed <b><U>in</U>
       <U>let</U></b> c_blank = is_blank c <b><U>in</U>
       <U>if</U></b> c &lt;&gt; ' ' <b><U>then</U> <U>begin</U>
         <U>let</U></b> s = String.make 1 c </r><U>in</U>
         <U>let</U></b> c_op = is_op s <b><U>in</U><m>
 350     </m><U>let</U></b> c_digit = is_digit c <b><U>in</U>
         <U>if</U></b> is_open_delim s <b><U>then</U><r> open_delim ();
         </r><U>let</U></b> c_text = <b><U>if</U><r> is_close_delim s </r><U>then</U></b> is_close () <b><U>else</U> <U>false</U> <U>in</U>
         <U>if</U></b> c_op || c_digit <b><U>then</U></b> force_item_display ();
         do_pending () ;
 </r>355     <r>flags.empty &lt;- <b><U>false</U><r>;
         flags.blank &lt;- c_blank &amp;&amp; flags.blank ;
         </r><U>if</U></b> c_digit <b><U>then</U> <U>begin</U></b>
           do_put ("&lt;mn&gt; "^s^" &lt;/mn&gt;\n")
         <b><U>end</U> <U>else</U> <U>if</U></b> c_text <b><U>then</U> <U>begin</U><m>
 360       <r>do_put ("&lt;mtext&gt;"^s^"&lt;/mtext&gt;")
         <b><U>end</U> <U>else</U> <U>if</U></b> c_op <b><U>then</U> <U>begin</U></b>
           do_put ("&lt;mo&gt; "^s^" &lt;/mo&gt;\n");
         <b><U>end</U> <U>else</U> <U>begin</U></b>
           do_put_char c;
 </r>365     </m><U>end</U></b>;
         <b><U>if</U><r> c_blank </r><U>then</U></b> flags.last_closed &lt;- save_last_closed;
         <b><U>if</U><r> is_close_delim s </r><U>then</U></b> close_delim ();
       <b><U>end</U></b>
     ;;
 </r>370 
     <b><U>let</U><r> put_in_math s =
       </r><U>if</U><r> flags.in_pre &amp;&amp; !pedantic <b><U>then</U></b>
         put s
       </r><U>else</U> <U>begin</U></b>
 375     <r>force_item_display ();
         do_pending () ;
         do_put "&lt;mi&gt; ";
         do_put s;
         do_put " &lt;/mi&gt;\n";
 </r>380     <r>flags.empty &lt;- <b><U>false</U><r>; flags.blank &lt;- </r><U>false</U></b>;
       <b><U>end</U></b>
     ;;
     
     
 </r>385 
     </m>(* Sup/Sub stuff *)
     
     
     <b><U>let</U></b></w> put_sub_sup  s =
 <m>390   <r>open_display ();
       put s;
       item_display ();
       close_display ();
     ;;
 </r>395 
     <b><U>let</U></b></m> insert_sub_sup tag s t =
       <b><U>let</U><r> f, is_freeze = pop_freeze () </r><U>in</U>
       <U>let</U></b> ps,pargs,pout = pop_out out_stack <b><U>in</U>
       <U>if</U></b> ps &lt;&gt; GROUP <b><U>then</U><r> failclose "sup_sub" ps GROUP ;
 </r><m>400   </m><U>let</U></b> new_out = create_status_from_scratch <b><U>false</U><r> [] </r><U>in</U></b>
       push_out out_stack (ps,pargs,new_out);
       close_block GROUP;
       cur_out := pout;
       open_block tag "";
 <m>405   <r>open_display ();
       <b><U>let</U><r> texte = Out.to_string new_out.out </r><U>in</U></b>
       do_put (<b><U>if</U><r> texte = "" </r><U>then</U></b> "&lt;mo&gt; &amp;InvisibleTimes; &lt;/mo&gt;" <b><U>else</U><r> texte);
       flags.empty &lt;- </r><U>false</U></b>; flags.blank &lt;- <b><U>false</U></b>;
       free new_out;
 </r>410   <r>close_display ();
       put_sub_sup s;
       <b><U>if</U><r> t&lt;&gt;"" </r><U>then</U></b> put_sub_sup t;
       close_block tag;
       open_block GROUP "";
 </r>415   <b><U>if</U></b></m> is_freeze <b><U>then</U><r> freeze f
     ;;
     
     </r><U>let</U></b> get_sup_sub
         (scanner : string Lexstate.arg -&gt; unit)
 <m>420     <r>(s : string Lexstate.arg) =
       to_string (<b><U>fun</U><r> () -&gt; scanner s)
     
     </r><U>let</U></b> standard_sup_sub scanner what sup sub display =
       <b><U>let</U></b> sup = get_sup_sub scanner sup
 </r>425   <b><U>and</U></b></m> sub = get_sup_sub  scanner sub <b><U>in</U>
       <U>match</U></b> sub,sup <b><U>with</U><r>
       | "","" -&gt; what ()
       | a,"" -&gt;
           open_block (OTHER "msub") "";
 <m>430       </m>open_display ();
           what ();
           </r><U>if</U></b> flags.empty <b><U>then</U> <U>begin</U></b>
      erase_display ();
      erase_block (OTHER "msub") ;
 <m>435  <r>insert_sub_sup (OTHER "msub") a "";
           <b><U>end</U> <U>else</U> <U>begin</U></b>
      close_display ();
      put_sub_sup a;
      close_block (OTHER "msub") ;
 </r>440       <b><U>end</U></b></m>;
       | "",b -&gt;
           open_block (OTHER "msup") "";
           open_display ();
           what ();
 <m>445       <b><U>if</U></b></m> flags.empty <b><U>then</U> <U>begin</U></b>
      erase_display ();
      erase_block (OTHER "msup") ;
      insert_sub_sup (OTHER "msup") b "";
           <b><U>end</U> <U>else</U> <U>begin</U><m>
 450  <r>close_display ();
      put_sub_sup b;
      close_block (OTHER "msup");
           <b><U>end</U></b>;
       | a,b -&gt;
 </r>455       <r>open_block (OTHER "msubsup") "";
           open_display ();
           what ();
           <b><U>if</U><r> flags.empty </r><U>then</U> <U>begin</U></b>
      erase_display ();
 </r>460  <r>erase_block (OTHER "msubsup") ;
      insert_sub_sup (OTHER "msubsup") a b;
           <b><U>end</U> <U>else</U> <U>begin</U></b>
      close_display ();
      put_sub_sup a;
 </r>465  <r>put_sub_sup b;
      close_block (OTHER "msubsup") ;
           <b><U>end</U></b>;
     ;;
     
 </r>470 
     
     </m><U>let</U></b> limit_sup_sub scanner what sup sub display =
       <b><U>let</U><r> sup = get_sup_sub scanner sup
       </r><U>and</U></b> sub = get_sup_sub  scanner sub <b><U>in</U><m>
 475   </m><U>match</U></b> sub,sup <b><U>with</U><r>
       | "","" -&gt; what ()
       | a,"" -&gt;
           open_block (OTHER "munder") "";
           open_display ();
 <m>480       </m>what ();
           </r><U>if</U></b> flags.empty <b><U>then</U> <U>begin</U></b>
      erase_display ();
      erase_block (OTHER "munder");
      insert_sub_sup (OTHER "munder") a "";
 <m>485       <b><U>end</U> <U>else</U> <U>begin</U></b></m>
      close_display ();
      put_sub_sup a;
      close_block (OTHER "munder");
           <b><U>end</U><r>;
 <m>490   </m>| "",b -&gt;
           open_block (OTHER "mover") "";
           open_display ();
           what ();
           </r><U>if</U></b> flags.empty <b><U>then</U> <U>begin</U><m>
 495  <r>erase_display ();
      erase_block (OTHER "mover");
      insert_sub_sup (OTHER "mover") b "";
           <b><U>end</U> <U>else</U> <U>begin</U></b>
      close_display ();
 </r>500  <r>put_sub_sup b;
      close_block (OTHER "mover");
           <b><U>end</U></b>;
       | a,b -&gt;
           open_block (OTHER "munderover") "";
 </r>505       <r>open_display ();
           what ();
           <b><U>if</U><r> flags.empty </r><U>then</U> <U>begin</U></b>
      erase_display ();
      erase_block (OTHER "munderover");
 </r>510  <r>insert_sub_sup (OTHER "munderover") a b;
           <b><U>end</U> <U>else</U> <U>begin</U></b>
      close_display ();
      put_sub_sup a;
      put_sub_sup b;
 </r>515  <r>close_block (OTHER "munderover");
           <b><U>end</U><r>;
     ;;
     
     </r><U>let</U></b> int_sup_sub something vsize scanner what sup sub display =
 </r>520   <r>standard_sup_sub scanner what sup sub display
     ;;
     
     
     <b><U>let</U></b> over display lexbuf =
 </r>525  </m><U>if</U></b> display <b><U>then</U> <U>begin</U></b>
         force_item_display ();
         <b><U>let</U><r> mods = insert_vdisplay
             (</r><U>fun</U></b> () -&gt;
               open_block (OTHER "mfrac") "";
 <m>530    <r>open_display ()) <b><U>in</U></b>
         force_item_display ();
         flags.ncols &lt;- flags.ncols +1;
         close_display () ;
         open_display () ;
 </r>535     <r>freeze
           (<b><U>fun</U></b> () -&gt;
      force_item_display ();
      flags.ncols &lt;- flags.ncols +1;
             close_display () ;
 </r>540         <r>close_block (OTHER "mfrac"))
       <b><U>end</U> <U>else</U> <U>begin</U></b>
         put "/"
       <b><U>end</U></b>
     ;;
 </r>545 
     
     <b><U>let</U></b></m> tr = <b><U>function</U><r>
       "&lt;" -&gt; "&lt;"
     | "&gt;" -&gt; "&gt;"
 </r><m>550 <r>| "\\{" -&gt; "{"
     | "\\}" -&gt; "}"
     | s   -&gt; s
     ;;
     
 </r>555 </m><U>let</U></b> left delim k =
       force_item_display ();
       open_display ();
       <b><U>if</U><r> delim &lt;&gt;"." </r><U>then</U></b> put ("&lt;mo&gt; "^ tr delim^" &lt;/mo&gt;");
       k 0 ;
 <m>560   <r>force_item_display ();
       freeze
         ( <b><U>fun</U></b> () -&gt;
           force_item_display ();
           close_display ();
 </r>565       <r>warning "Left delimitor not matched with a right one.";
           force_item_display ();
           close_display ();)
     ;;
     
 </r>570 <b><U>let</U></b></m> right delim =
       force_item_display ();
       <b><U>if</U><r> delim &lt;&gt; "." </r><U>then</U></b> put ("&lt;mo&gt; "^tr delim^" &lt;/mo&gt;");
       force_item_display ();
       <b><U>let</U><r> f,is_freeze = pop_freeze () </r><U>in</U><m>
 575   </m><U>if</U></b> not is_freeze <b><U>then</U> <U>begin</U></b>
         warning "Right delimitor alone";
         close_display ();
         open_display ();
       <b><U>end</U> <U>else</U> <U>begin</U><m>
 580     </m><U>try</U>
           <U>let</U></b> ps,parg,pout = pop_out out_stack <b><U>in</U>
           <U>let</U></b> pps,pparg,ppout = pop_out out_stack <b><U>in</U>
           <U>if</U></b> pblock() = (OTHER "mfrac") <b><U>then</U> <U>begin</U></b>
      warning "Right delimitor not matched with a left one.";
 <m>585  <r>push_out out_stack (pps,pparg,ppout);
      push_out out_stack (ps,parg,pout);
      freeze f;
      close_display ();
      open_display ();
 </r>590       <b><U>end</U> <U>else</U> <U>begin</U></b></m>
      push_out out_stack (pps,pparg,ppout);
      push_out out_stack (ps,parg,pout);
      close_display ();
           <b><U>end</U><r>;
 </r><m>595     </m><U>with</U></b> PopFreeze -&gt; raise (UserError ("Bad placement of right delimitor"));
       <b><U>end</U></b>;
       3
     ;;</TT><B>
<6>101 misc.ml</6>
</B><TT><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1999 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     <b><U>let</U></b></w> header = "$Id: misc.ml,v 1.19 2001/02/20 14:10:09 maranget Exp $"
     
     <b><U>exception</U><r> Fatal </r><U>of</U></b> string
  <m>15 <b><U>exception</U><r> NoSupport </r><U>of</U><r> string
     <b><U>exception</U><r> Purposly </r><U>of</U></b> string
     <b><U>exception</U><r> ScanError </r><U>of</U></b> string
     <b><U>exception</U><r> UserError </r><U>of</U></b> string
     <b><U>exception</U></b> EndInput
  </r></b>20 <b><U>exception</U><r> EndDocument
     </r><U>exception</U><r> Close <b><U>of</U><r> string
     </r><U>exception</U></b> EndOfLispComment <b><U>of</U><r> int </r><w>(* QNC *)
     
     </w><U>let</U></b> verbose = ref 0
  </r></b>25 <b><U>and</U><r> readverb = ref 0
     
     </r><U>let</U><r> silent = ref <b><U>false</U>
     
     <U>let</U></b> column_to_command s = "\\@"^s^"@"
  </r></b>30 
     
     <r><b><U>let</U><r> hot_start () = ()
     
     </r><U>let</U></b> warning s =
  </r>35   <b><U>if</U><r> not !silent || !verbose &gt; 0 </r><U>then</U> <U>begin</U><r>
         Location.print_pos () ;
         prerr_string "Warning: " ;
         prerr_endline s
       <b><U>end</U><m>
  40 
     </m><U>let</U></b> print_verb level s =
       <b><U>if</U><r>  !verbose &gt; level </r><U>then</U> <U>begin</U></b>
         Location.print_pos () ;
         prerr_endline s
  </r></b>45   <b><U>end</U>
     
     <U>let</U><r> message s =
       <b><U>if</U><r> not !silent || !verbose &gt; 0 </r><U>then</U></b> prerr_endline s
     
  </r></b>50 </m><b><U>let</U><r> fatal s = raise (Fatal s)
     </r><U>let</U></b> not_supported s = raise (NoSupport s)
     
     
     <b><U>let</U> <U>rec</U></b> rev_iter f = <b><U>function</U><m>
  55   <r>| [] -&gt; ()
       | x::rem -&gt; rev_iter f rem ; f x
     
     <b><U>let</U></b> copy_hashtbl from_table to_table =
       Hashtbl.clear to_table ;
  </r>60   </m><U>let</U> <U>module</U></b> OString =
         <b><U>struct</U>
           <U>type</U></b> t = string
           <b><U>let</U><r> compare = Pervasives.compare
         </r><U>end</U> <U>in</U><m>
  65   </m><U>let</U> <U>module</U></b> Strings = Set.Make (OString) <b><U>in</U>
       <U>let</U></b> keys = ref Strings.empty <b><U>in</U><r>
       Hashtbl.iter
         (</r><U>fun</U></b> key _ -&gt; keys := Strings.add key !keys)
         from_table ;
  <m>70   <r>Strings.iter
         (<b><U>fun</U><r> key -&gt;
           </r><U>let</U></b> vals = Hashtbl.find_all from_table key <b><U>in</U></b>
           rev_iter (Hashtbl.add to_table key) vals)
         !keys
  </r>75 
     <b><U>let</U></b></m> clone_hashtbl from_table =
       <b><U>let</U><r> to_table = Hashtbl.create 17 </r><U>in</U></b>
       copy_hashtbl from_table to_table ;
       to_table
  <m>80 
     <b><U>let</U></b></m> copy_int_hashtbl from_table to_table =
       Hashtbl.clear to_table ;
       <b><U>let</U> <U>module</U></b> OInt =
         <b><U>struct</U><m>
  85       </m><U>type</U></b> t = int
           <b><U>let</U><r> compare x y = x-y
         </r><U>end</U> <U>in</U>
       <U>let</U> <U>module</U></b> Ints = Set.Make (OInt) <b><U>in</U>
       <U>let</U></b> keys = ref Ints.empty <b><U>in</U><m>
  90   <r>Hashtbl.iter
         (<b><U>fun</U><r> key _ -&gt; keys := Ints.add key !keys)
         from_table ;
       Ints.iter
         (</r><U>fun</U></b> key -&gt;
  </r>95       </m><U>let</U></b> vals = Hashtbl.find_all from_table key <b><U>in</U><r>
           rev_iter (Hashtbl.add to_table key) vals)
         !keys
     
     </r><U>let</U></b> clone_int_hashtbl from_table =
 <m>100   <b><U>let</U></b></m> to_table = Hashtbl.create 17 <b><U>in</U><r>
       copy_int_hashtbl from_table to_table ;
       to_table
     
     </r><U>let</U></b> start_env env = "\\"^ env
 <m>105 <b><U>and</U></b></m> end_env env = "\\end"^env
     
     <b><U>type</U><r> limits = Limits | NoLimits | IntLimits<PL><B>
<6>102 myfiles.ml</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>let</U></b> header = "$Id: myfiles.ml,v 1.22 2001/05/25 09:07:25 maranget Exp $"
     <b><U>open</U><r> Misc
     
  </r><m>15 </m><U>exception</U></b> Error <b><U>of</U><r> string
     ;;
     </r><U>exception</U></b> Except
     ;;
     
  <m>20 <b><U>let</U></b></m> etable = Hashtbl.create 17
     ;;
     
     
     List.iter (<b><U>fun</U><r> name -&gt; Hashtbl.add etable name ()) !Parse_opts.except
  <m>25 </m>;;
     
     </r><U>let</U></b> is_except name =
       <b><U>try</U><r> Hashtbl.find etable name ; </r><U>true</U> <U>with</U></b> Not_found -&gt; <b><U>false</U><r>
     ;;
  </r><m>30 
     </m><U>let</U></b> tex_path = "." :: !Parse_opts.path @
       [Mylib.libdir ;
       Filename.concat
         Mylib.libdir
  <m>35      <r>(<b><U>match</U><r> !Parse_opts.destination </r><U>with</U></b>
          | Parse_opts.Html -&gt; "html"
          | Parse_opts.Text -&gt; "text"
          | Parse_opts.Info -&gt; "info")]
     ;;
  </r>40 
     <b><U>exception</U></b></m> Found <b><U>of</U><r> (string * in_channel)
     ;;
     
     </r><U>let</U></b> do_open_tex filename =
  <m>45   <b><U>try</U></b></m>
         List.iter (<b><U>fun</U><r> dir -&gt;
           </r><U>try</U>
             <U>let</U></b> full_name = Filename.concat dir filename <b><U>in</U>
             <U>if</U></b> !verbose &gt; 1 <b><U>then</U><r> prerr_endline ("Trying: "^full_name) ;
  </r><m>50         </m><U>let</U></b> r = open_in full_name <b><U>in</U>
             <U>if</U></b> !verbose &gt; 1 <b><U>then</U><r> prerr_endline ("Opening: "^full_name) ;
             raise (Found (full_name,r))
           </r><U>with</U></b> Sys_error s -&gt;
             <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b> prerr_endline ("Failed: "^s))
  <m>55     <r>tex_path ;
         raise (Error ("Cannot open file: "^filename))
       <b><U>with</U></b> Found r -&gt; r
     ;;
     
  </r>60 
     
     <b><U>let</U></b></m> open_tex filename =
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b>
         prerr_endline ("Searching file: "^filename) ;
  <m>65   <b><U>if</U></b></m> is_except filename <b><U>then</U><r> raise Except ;
       </r><U>if</U></b> Filename.is_implicit filename <b><U>then</U>
         <U>if</U></b>
           Filename.check_suffix filename ".tex" ||
           Filename.check_suffix filename ".hva"
  <m>70     <b><U>then</U></b></m> do_open_tex filename
           <b><U>else</U>
             <U>try</U>
                 <U>let</U></b> name = filename^".tex" <b><U>in</U>
                 <U>if</U></b> is_except name <b><U>then</U><r> raise Except ;
  <m>75             </m>do_open_tex name
             </r><U>with</U></b> Error _ -&gt; do_open_tex filename
        <b><U>else</U>
         <U>try</U>
           <U>if</U></b> Filename.check_suffix filename ".tex" <b><U>then</U><r> filename,open_in filename
  </r><m>80       </m><U>else</U>
             <U>try</U></b> (filename^".tex"),open_in (filename^".tex") <b><U>with</U><r>
             Sys_error _ -&gt; filename,open_in filename
         </r><U>with</U></b> Sys_error _ -&gt; raise (Error ("Cannot open: "^filename))
     
  <m>85 
     <b><U>exception</U></b></m> FoundBis <b><U>of</U><r> string
     
     </r><U>let</U></b> do_find name =
       <b><U>try</U><m>
  90     <r>List.iter (<b><U>fun</U><r> dir -&gt;
           </r><U>let</U></b> full_name = Filename.concat dir name <b><U>in</U>
           <U>if</U></b> Sys.file_exists full_name <b><U>then</U></b>
             raise (FoundBis full_name))
           tex_path ;
  </r>95     <r>raise Not_found
       <b><U>with</U><r> FoundBis r -&gt; r
     ;;
     
     </r><U>let</U></b> find_one name =
 </r>100   </m><U>if</U></b> Sys.file_exists name <b><U>then</U><r>
         name
       </r><U>else</U></b>
         raise Not_found
     
 <m>105 <b><U>let</U></b></m> find name =
       <b><U>if</U><r> Filename.is_implicit name </r><U>then</U>
         <U>if</U></b>
           Filename.check_suffix name ".tex" ||
           Filename.check_suffix name ".hva"
 <m>110     <b><U>then</U></b></m> do_find name
           <b><U>else</U>
             <U>try</U>
                 <U>let</U></b> name = name^".tex" <b><U>in</U><r>
                 do_find name
 </r><m>115         </m><U>with</U></b> Not_found -&gt; do_find name
        <b><U>else</U>
         <U>if</U></b> Filename.check_suffix name ".tex" <b><U>then</U><r>
           find_one name
         </r><U>else</U><m>
 120       </m><U>try</U></b> find_one (name^".tex")
           <b><U>with</U><r>
           | Not_found -&gt; find_one name
     
     
 </r><m>125 </m><U>exception</U></b> Return <b><U>of</U><r> bool
     
     </r><U>let</U></b> diff_chan chan1 chan2 =
       <b><U>try</U>
         <U>while</U> <U>true</U> <U>do</U><m>
 130       </m><U>let</U></b> c1 =
             <b><U>try</U><r> input_char chan1 </r><U>with</U></b> End_of_file -&gt; <b><U>begin</U>
               <U>try</U>
                 <U>let</U></b> _ = input_char chan2 <b><U>in</U><r>
                 raise (Return </r><U>true</U></b>)
 <m>135           <b><U>with</U></b></m> End_of_file -&gt; raise (Return <b><U>false</U><r>)
             </r><U>end</U> <U>in</U>
           <U>let</U></b> c2 =
             <b><U>try</U><r> input_char chan2 </r><U>with</U></b> End_of_file -&gt; raise (Return <b><U>true</U><r>) </r><U>in</U>
           <U>if</U></b> c1 &lt;&gt; c2 <b><U>then</U><m>
 140         <r>raise (Return <b><U>true</U><r>)
         </r><U>done</U></b> ;
         <b><U>assert</U> <U>false</U>
       <U>with</U></b> Return r -&gt; r
     
 </r>145 </m><U>let</U></b> changed tmp_name name =
       <b><U>try</U>
         <U>let</U></b> true_chan = open_in name <b><U>in</U>
         <U>let</U></b> tmp_chan =
           <b><U>try</U><r> open_in tmp_name
 </r><m>150       </m><U>with</U></b> Sys_error _ -&gt; <b><U>begin</U><r>
             close_in true_chan ;
             raise
               (Misc.Fatal
                  ("Cannot reopen temporary image file: "^tmp_name))
 </r><m>155       </m><U>end</U> <U>in</U>
         <U>let</U></b> r = diff_chan true_chan tmp_chan <b><U>in</U><r>
         close_in true_chan ;
         close_in tmp_chan ;
         r
 </r><m>160   </m><U>with</U></b> Sys_error _ -&gt; <b><U>true</U><w><r><PL><B>
<6>103 mylib.ml</6>
</B></PL></r> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>let</U></b> header = "$Id: mylib.ml,v 1.7 2001/05/25 09:07:26 maranget Exp $"
     <b><U>exception</U><r> Error </r><U>of</U></b> string
     ;;
  <m>15 
     <b><U>let</U></b></m> static_libdir  = LIBDIR
     ;;
     
     <b><U>let</U><r> libdir =
  </r><m>20   </m><U>try</U></b> Sys.getenv "HEVEADIR" <b><U>with</U><r> Not_found -&gt; LIBDIR
     ;;<PL><B>
<6>104 mysys.ml</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>let</U></b> header = "$Id: mysys.ml,v 1.1 2001/05/25 09:07:26 maranget Exp $"
     
     <b><U>exception</U><r> Error </r><U>of</U></b> string
  <m>15 
     <b><U>let</U></b></m> put_from_file name put =
       <b><U>try</U>
         <U>let</U></b> size = 1024 <b><U>in</U>
         <U>let</U></b> buff = String.create size <b><U>in</U><m>
  20     </m><U>let</U></b> chan_in = open_in_bin name <b><U>in</U>
         <U>let</U> <U>rec</U></b> do_rec () =
           <b><U>let</U><r> i = input chan_in buff 0 size </r><U>in</U>
           <U>if</U></b> i &gt; 0 <b><U>then</U> <U>begin</U></b>
             put (String.sub buff 0 i) ;
  <m>25         </m>do_rec ()
           <b><U>end</U> <U>in</U></b>
         do_rec () ;
         close_in chan_in
       <b><U>with</U></b> Sys_error _ -&gt;
  <m>30     <r>raise (Error ("Cannot read file "^name))
     ;;
     
     <b><U>let</U><r> copy_from_lib dir name =
       </r><U>let</U></b> chan_out =
  </r>35     <b><U>try</U><r> open_out_bin name
         </r><U>with</U><r> Sys_error _ -&gt; raise (Error ("Cannot open file: "^name)) <b><U>in</U>
       <U>try</U></b>
         put_from_file
           (Filename.concat dir name)
  </r></b>40       <r>(<b><U>fun</U><r> s -&gt; output_string chan_out s) ;
         close_out chan_out
       </r><U>with</U></b>
       | e -&gt; close_out chan_out ; raise e
     ;;
  </r>45 
     
     <w>(* handle windows/Unix dialectic =&gt; no error when s2 exists *)
     </w></m><b><U>let</U><r> rename s1 s2 =
       </r><U>if</U></b> Sys.file_exists s2 <b><U>then</U><m>
  50     <r>Sys.remove s2 ;
       Sys.rename s1 s2
     
     <b><U>let</U><r> remove s =
       </r><U>if</U></b> Sys.file_exists s <b><U>then</U><m>
  55     <r>Sys.remove s<PL><B>
<6>105 noimage.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><b><U>let</U><r> header = "$Id: noimage.ml,v 1.7 1999/12/01 19:04:50 maranget Exp $"
     </r><U>let</U></b> start () = ()
     <b><U>and</U></b> stop () = ()
  </r>15 </m><U>and</U></b> restart () = ()
     ;;
     
     <b><U>let</U><r> put _ = ()
     </r><U>and</U></b> put_char _ = ()
  </r>20 <r>;;
     
     <b><U>let</U><r> dump _ image lexbuf  = image lexbuf
     </r><U>let</U></b> page () = ()
     ;;
  </r>25 </m><U>let</U></b> finalize _ = <b><U>false</U><r>
     ;;<PL><B>
<6>106 out.ml</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>open</U></b> Lexing
     
     <b><U>let</U><r> header = "$Id: out.ml,v 1.20 2000/10/27 11:26:58 maranget Exp $"
  </r><m>15 </m><U>let</U></b> verbose = ref 0
     ;;
     
     <b><U>type</U><r> buff = {
       </r><U>mutable</U></b> buff : string;
  <m>20   <b><U>mutable</U></b></m> bp : int;
       <b><U>mutable</U><r> len : int
     }
     ;;
     
  </r><m>25 </m><U>type</U></b> t = Buff <b><U>of</U><r> buff | Chan </r><U>of</U></b> out_channel | Null
     ;;
     
     <b><U>let</U><r> debug chan out = </r><U>match</U></b> out <b><U>with</U><r>
       Buff out -&gt;
  <m>30    </m>output_char chan '*' ;
        output chan out.buff 0 out.bp ;
        output_char chan '*'
     | Chan _   -&gt;
        output_string chan "*CHAN*"
  <m>35 </m>| Null -&gt;
        output_string chan "*NULL*"
     ;;
     
     </r><U>let</U></b> free_list  = ref []
  <m>40 
     <b><U>let</U></b></m> free = <b><U>function</U><r>
       | Buff b -&gt; b.bp &lt;- 0 ; free_list := b :: !free_list
       | _ -&gt; ()
     
  <m>45 <b><U>let</U><r> create_buff () =
       Buff
         (</r><U>match</U><r> !free_list <b><U>with</U><r>
         | [] -&gt; {buff = String.create 128 ; bp = 0 ; len = 128}
         | b::rem -&gt;
  <m>50         </m>free_list := rem ;
             b)
     
     </r><U>and</U></b> create_chan chan = Chan chan
     <b><U>and</U><r> create_null () = Null
  <m>55 <b><U>and</U><r> is_null  = </r><U>function</U><r>
       | Null -&gt; <b><U>true</U><r>
       | _ -&gt; </r><U>false</U>
     
     <U>and</U></b> is_empty = </r><U>function</U></b>
  60   </m>| Buff {bp=0} -&gt; </r><U>true</U></b>
       | _ -&gt; <b><U>false</U><r>
     ;;
     
     </r><U>let</U></b> reset = </r><U>function</U></b>
  65   </m>Buff b -&gt; b.bp &lt;- 0
     | _      -&gt; raise (Misc.Fatal "Out.reset")
     
     </r><U>let</U></b> get_pos = <b><U>function</U><r>
       | Buff b -&gt; b.bp
  <m>70   </m>| _      -&gt; 0
     
     </r><U>let</U></b> erase_start n = <b><U>function</U></b>
       | Buff b -&gt;
           String.blit b.buff n b.buff 0 (b.bp-n) ;
  <m>75       </m>b.bp &lt;- b.bp-n
       | _      -&gt;  raise (Misc.Fatal "Out.erase_start")
     
     
     <b><U>let</U><r> realloc out =
  </r><m>80   </m><U>let</U></b> new_len = 2 * out.len <b><U>in</U>
       <U>let</U></b> new_b = String.create new_len <b><U>in</U><r>
       String.unsafe_blit out.buff 0 new_b 0 out.bp ;
       out.buff &lt;- new_b ;
       out.len  &lt;-  new_len
  <m>85 </m>;;
     
     </r><U>let</U> <U>rec</U></b> put out s = <b><U>match</U><r> out </r><U>with</U></b>
       (Buff out) <b><U>as</U><r> b -&gt;
         </r><U>let</U></b> l = String.length s <b><U>in</U><m>
  90     </m><U>if</U></b> out.bp + l &lt; out.len <b><U>then</U> <U>begin</U></b>
           String.unsafe_blit s 0 out.buff out.bp l ;
           out.bp &lt;- out.bp + l
         <b><U>end</U> <U>else</U> <U>begin</U></b>
           realloc out ;
  <m>95       <r>put b s
         <b><U>end</U></b>
     | Chan chan -&gt; output_string chan s
     | Null -&gt; ()
     ;;
 </r>100 
     <b><U>let</U> <U>rec</U></b></m> blit out lexbuf = <b><U>match</U><r> out </r><U>with</U></b>
       (Buff out) <b><U>as</U><r> b -&gt;
         </r><U>let</U></b> l = lexbuf.lex_curr_pos - lexbuf.lex_start_pos <b><U>in</U>
         <U>if</U></b> out.bp + l &lt; out.len <b><U>then</U> <U>begin</U><m>
 105       <r>String.blit lexbuf.lex_buffer lexbuf.lex_start_pos
             out.buff out.bp l ;
           out.bp &lt;- out.bp + l
         <b><U>end</U> <U>else</U> <U>begin</U></b>
           realloc out ;
 </r>110       <r>blit b lexbuf
         <b><U>end</U></b>
     | Chan chan -&gt; output_string chan (lexeme lexbuf)
     | Null -&gt; ()
     ;;
 </r>115 
     </m><U>let</U> <U>rec</U></b> put_char out c = <b><U>match</U><r> out </r><U>with</U></b>
       Buff out <b><U>as</U><r> b -&gt;
         </r><U>if</U></b> out.bp + 1 &lt; out.len <b><U>then</U> <U>begin</U></b>
           String.unsafe_set out.buff out.bp c ;
 <m>120       </m>out.bp &lt;- out.bp + 1
         <b><U>end</U> <U>else</U> <U>begin</U></b>
           realloc out ;
           put_char b c
         <b><U>end</U><m>
 125 <r>| Chan chan -&gt; Pervasives.output_char chan c
     | Null -&gt; ()
     ;;
     
     <b><U>let</U><r> flush = </r><U>function</U><m>
 130   <r>Chan chan -&gt; flush chan
     | _         -&gt; ()
     ;;
     
     <b><U>let</U><r> iter f = </r><U>function</U><m>
 135   <r>| Buff {buff=buff ; bp=bp} -&gt;
           <b><U>for</U><r> i = 0 </r><U>to</U></b> bp-1 <b><U>do</U><r>
             f (buff.[i])
           </r><U>done</U></b>
       | Null -&gt; ()
 </r>140   <r>| _ -&gt; Misc.fatal "Out.iter"
     
     <b><U>let</U><r> to_string out = </r><U>match</U></b> out <b><U>with</U><r>
       Buff out -&gt;
         </r><U>let</U></b> r = String.sub out.buff 0 out.bp <b><U>in</U><m>
 145     <r>out.bp &lt;- 0 ; r
     | _ -&gt; raise (Misc.Fatal "Out.to_string")
     ;;
     
     <b><U>let</U><r> to_chan chan out = </r><U>match</U></b> out <b><U>with</U><m>
 150   <r>Buff out -&gt;
         output chan out.buff 0 out.bp ;
         out.bp &lt;- 0
     | _  -&gt; raise (Misc.Fatal "to_chan")
     ;;
 </r>155 
     
     </m><U>let</U></b> hidden_copy from to_buf i l = <b><U>match</U><r> to_buf </r><U>with</U></b>
       Chan chan -&gt; output chan from.buff i l
     | Buff out   -&gt;
 </r>160     </m><U>while</U></b> out.bp + l &gt;= out.len <b><U>do</U><r>
           realloc out
         </r><U>done</U></b> ;
         String.unsafe_blit from.buff i out.buff out.bp l ;
         out.bp &lt;- out.bp + l
 </r>165 <r>| Null -&gt; ()
     ;;
     
     <b><U>let</U><r> copy from_buff to_buff = </r><U>match</U></b> from_buff <b><U>with</U></b>
       Buff from -&gt; hidden_copy from to_buff 0 from.bp
 </r>170 <r>| _         -&gt; raise (Misc.Fatal "Out.copy")
     
     <b><U>let</U><r> copy_fun f  from_buff to_buff = </r><U>match</U></b> from_buff <b><U>with</U></b>
       Buff from -&gt;
         put to_buff (f (String.sub from.buff 0 from.bp))
 </r>175 <r>| _         -&gt; raise (Misc.Fatal "Out.copy_fun")
     
     <b><U>let</U><r> copy_no_tag from_buff to_buff =
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         prerr_string "copy no tag from_buff";
 </r>180     <r>debug stderr from_buff ;
         prerr_endline ""
       <b><U>end</U><r> ;
       </r><U>match</U></b> from_buff <b><U>with</U><r>
         Buff from -&gt; </r><U>begin</U><m>
 185       </m><U>try</U>
             <U>let</U></b> i = String.index from.buff '&gt;' <b><U>in</U>
             <U>let</U></b> j =
        <b><U>if</U><r> from.bp=0 </r><U>then</U></b> i+1
        <b><U>else</U><r> String.rindex_from from.buff (from.bp-1) '&lt;' </r><U>in</U><m>
 190         <r>hidden_copy from to_buff (i+1) (j-i-1) ;
             <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U> <U>begin</U></b>
               prerr_string "copy no tag to_buff";
               debug stderr to_buff ;
               prerr_endline ""
 </r>195         </m><U>end</U>
           <U>with</U></b> Not_found -&gt;  raise (Misc.Fatal "Out.copy_no_tag, no tag found")
         <b><U>end</U></b>
       | _         -&gt; raise (Misc.Fatal "Out.copy_no_tag")
     ;;
 </r>200 
     </m><U>let</U></b> close = <b><U>function</U></b>
     | Chan c -&gt; close_out c
     | _ -&gt; ()
     ;;
 </r>205 
     </m><U>let</U></b> is_space = <b><U>function</U><r>
       | ' ' | '\n' -&gt; </r><U>true</U></b>
       | _ -&gt; <b><U>false</U><m>
     
 210 </m><U>let</U></b> unskip = <b><U>function</U><r>
     | Buff b -&gt;
         </r><U>while</U></b> b.bp &gt; 0 &amp;&amp; is_space b.buff.[b.bp-1] <b><U>do</U><r>
           b.bp &lt;- b.bp - 1
         </r><U>done</U><m>
 215 <r>| _      -&gt; ()<PL><B>
<6>107 package.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
   <m>5 </m>(*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  en Automatique.  Distributed only by permission.                   *)
     (*                                                                     *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     (*  $Id: package.ml,v 1.30 2001/02/12 10:05:39 maranget Exp $    *)
     
     </w><b><U>module</U> <U>type</U></b> S = <b><U>sig</U>  <U>end</U><m>
  15 
     </m><U>module</U></b> Make
       (Dest : OutManager.S)  (Image : ImageManager.S)
       (Scan : Latexscan.S)  : S =
     <b><U>struct</U><m>
  20 </m><U>open</U></b> Misc
     <b><U>open</U><r> Lexing
     </r><U>open</U></b> Lexstate
     <b><U>open</U><r> Latexmacros
     </r><U>open</U></b> Subst
  </r>25 </m><U>open</U></b> Stack
     <b><U>open</U><r> Scan
     ;;
     
     <w>(* Various outworld information *)
  <m>30 <b><U>let</U><r> def_print name s =
       def_code name  (</r><U>fun</U><r> _ -&gt; Dest.put (Dest.iso_string s))
     ;;
     
     def_code "\\@lexbuf"
  </r></b>35   <r>(<b><U>fun</U></b> lexbuf -&gt;
         prerr_endline ("LEXBUF: "^string_of_int (Stack.length stack_lexbuf)))
     ;;
     
     def_code "\\@macros"
  </r>40   <r>(<b><U>fun</U></b> _ -&gt; Latexmacros.pretty_table ())
     ;;
     
     def_print "\\@basein" Parse_opts.base_in ;
     def_print "\\jobname" Parse_opts.base_out ;
  </r>45 <r>def_print "\\@heveacomline"
       (Array.fold_right
          (<b><U>fun</U></b> arg r -&gt; arg^" "^r)
          Sys.argv "") ;
     def_print "\@heveaversion" Version.version ;
  </r>50 <r>def_print "\@hevealibdir" Mylib.libdir
     ;;
     
     <w>(* ``Token'' registers *)
     </w>def_code "\\newtokens"
  </r>55   <r>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> toks = Scan.get_csname lexbuf <b><U>in</U>
         <U>if</U></b> Latexmacros.exists toks <b><U>then</U></b>
           Misc.warning ("\\newtokens redefines command ``"^toks^"''") ;
         Latexmacros.def toks zero_pat (Toks []))
  </r>60 <r>;;
     
     def_code "\\resettokens"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> toks = Scan.get_csname lexbuf <b><U>in</U><m>
  65     </m><U>begin</U> <U>try</U> <U>match</U></b> Latexmacros.find_fail toks <b><U>with</U><r>
         | _,Toks _ -&gt;
             Latexmacros.def toks zero_pat (Toks [])
         | _ -&gt; raise Failed
         </r><U>with</U></b> Failed -&gt;
  </r>70       <r>Misc.warning ("\\resettokens for "^toks^" failed")
         <b><U>end</U></b>)
     ;;
     
     def_code "\\addtokens"
  </r>75   <r>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> toks = Scan.get_csname lexbuf <b><U>in</U>
         <U>let</U></b> arg = Subst.subst_arg lexbuf <b><U>in</U>
         <U>begin</U> <U>try</U> <U>match</U></b> Latexmacros.find_fail toks <b><U>with</U></b>
         | _,Toks l -&gt;
  </r>80         <r>Latexmacros.def toks zero_pat (Toks (arg::l))
         | _ -&gt; raise Failed
         <b><U>with</U><r> Failed -&gt;
           Misc.warning ("\\addtokens for "^toks^" failed")
         </r><U>end</U></b>)
  </r>85 <r>;;
     
     <b><U>let</U><r> call_subst lexbuf =
       </r><U>let</U></b> csname = get_csname lexbuf <b><U>in</U>
       <U>let</U></b> arg = subst_arg lexbuf <b><U>in</U><m>
  90   </m><U>let</U></b> exec = csname^" "^arg <b><U>in</U>
       <U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
         prerr_string "\\@callsubst: " ;
         prerr_endline exec ;
       <b><U>end</U></b> ;
  </r>95   <r>scan_this  main exec
     
     
     <b><U>and</U><r> call_prim lexbuf =
       </r><U>let</U></b> csname = get_csname lexbuf <b><U>in</U><m>
 100   </m><U>let</U></b> arg = get_prim_arg lexbuf <b><U>in</U>
       <U>let</U></b> exec = csname^" "^arg <b><U>in</U>
       <U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
         prerr_string "\\@callprim: " ;
         prerr_endline exec ;
 </r>105   <b><U>end</U><r> ;
       scan_this  main exec
     ;;
     
     
 <m>110 
     <r>def_code "\\@funcall" call_subst ;
     def_code "\\@callsubst" call_subst ;
     def_code "\\@callprim" call_prim ;
     ;;
 </r>115 
     <w>(* Aux files parsing *)
     </w></m>def_code "\\@hauxinit"
       (</r><U>fun</U><r> lexbuf -&gt;
         Auxx.init Parse_opts.base_out ;
 <m>120     </m>check_alltt_skip lexbuf)
     ;;
     
     <b><U>let</U><r> get_raw lexbuf =
       </r><U>let</U></b> saved = !raw_chars </r><U>in</U></b>
 125   <r>raw_chars := <b><U>true</U><r> ;
       </r><U>let</U></b> r = get_prim_arg lexbuf <b><U>in</U></b>
       raw_chars := saved ;
       r
     ;;
 </r>130 
     <r>def_code "\\@newlabel"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> name = get_raw lexbuf <b><U>in</U>
         <U>let</U></b> arg = get_raw lexbuf <b><U>in</U><m>
 135     <r>Auxx.rset name arg)
     ;;
     
     
     def_code "\\@auxwrite"
 </r>140   <r>(<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> lab = get_raw lexbuf <b><U>in</U>
         <U>let</U></b> theref = get_prim_arg lexbuf <b><U>in</U></b>
         Auxx.rwrite lab theref)
     ;;
 </r>145 
     <r>def_code "\\@auxread"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> lab = get_raw lexbuf <b><U>in</U></b>
         scan_this main (Auxx.rget lab))
 </r>150 <r>;;
     
     def_code "\\@bibread"
       (<b><U>fun</U><r> lexbuf -&gt;
         </r><U>let</U></b> key = get_raw lexbuf <b><U>in</U><m>
 155     <r>scan_this main (Auxx.bget <b><U>false</U><r> key))
     ;;
     
     def_code "\\@bibwrite"
       (</r><U>fun</U></b> lexbuf -&gt;
 </r>160     </m><U>let</U></b> pretty = <b><U>match</U><r> Subst.subst_arg lexbuf </r><U>with</U></b>
         | "\\theheveabib" <b><U>as</U><r> s  -&gt; get_prim s
         | s -&gt; s </r><U>in</U>
         <U>let</U></b> key = get_raw lexbuf <b><U>in</U></b>
         Auxx.bwrite key pretty)
 </r>165 <r>;;
     
     
     def_code "\\bibcite"
       (<b><U>fun</U></b> lexbuf -&gt;
 </r>170     </m><U>let</U></b> name = get_raw lexbuf <b><U>in</U>
         <U>let</U></b> arg = Subst.subst_arg lexbuf <b><U>in</U></b>
         Auxx.bset name arg)
     ;;
     
 </r>175 </m>(* Index primitives *)
     
     </w>register_init "index"
       (</r><U>fun</U></b> () -&gt;
        def_code "\\@indexwrite"
 </r>180       <r>(<b><U>fun</U><r> lexbuf -&gt;
             </r><U>let</U></b> tag = get_prim_opt "default" lexbuf <b><U>in</U>
             <U>let</U></b> arg = Subst.subst_arg lexbuf <b><U>in</U>
             <U>let</U></b> theref = get_prim_arg lexbuf <b><U>in</U>
             <U>let</U></b> lbl = Index.treat  tag arg theref <b><U>in</U><m>
 185         <r>Dest.put lbl) ;
     
         def_code "\\@printindex"
           (<b><U>fun</U><r> lexbuf -&gt;
             </r><U>let</U></b> tag =  get_prim_opt "default" lexbuf <b><U>in</U><m>
 190         <r>Index.print (scan_this main) tag) ;
     
         def_code "\\@indexname"
           (<b><U>fun</U><r> lexbuf -&gt;
             </r><U>let</U></b> tag = get_prim_opt "default" lexbuf <b><U>in</U><m>
 195         </m><U>let</U></b> name = get_prim_arg lexbuf <b><U>in</U><r>
             Index.changename tag name) ;
         </r><U>let</U></b> new_index lexbuf =
           <b><U>let</U><r> tag = get_prim_arg lexbuf </r><U>in</U>
           <U>let</U></b> sufin = get_prim_arg lexbuf <b><U>in</U><m>
 200       </m><U>let</U></b> sufout = get_prim_arg lexbuf <b><U>in</U>
           <U>let</U></b> name = get_prim_arg lexbuf <b><U>in</U><r>
           Index.newindex tag sufin sufout name </r><U>in</U></b>
         def_code "\\newindex" new_index ;
         def_code "\\renewindex" new_index)
 </r>205 <r>;;
     
     <w>(* ifthen package *)
     </w>register_init "ifthen"
       (<b><U>fun</U></b> () -&gt;
 </r>210     <r>def_code "\\ifthenelse"
           (<b><U>fun</U><r> lexbuf -&gt;
             </r><U>let</U></b> cond = save_arg lexbuf <b><U>in</U>
             <U>let</U></b> arg_true = save_arg lexbuf <b><U>in</U>
             <U>let</U></b> arg_false = save_arg lexbuf <b><U>in</U><m>
 215         <r>scan_this_arg main
               (<b><U>if</U><r> Get.get_bool cond </r><U>then</U></b> arg_true <b><U>else</U><r> arg_false)) ;
     
         def_code "\\whiledo"
           (</r><U>fun</U></b> lexbuf -&gt;
 </r>220         </m><U>let</U></b> test = save_arg lexbuf <b><U>in</U>
             <U>let</U></b> body = save_arg lexbuf <b><U>in</U>
             <U>let</U></b> btest = ref (Get.get_bool test) <b><U>in</U>
             <U>while</U></b> !btest <b><U>do</U></b>
               scan_this_arg main body ;
 </r>225           <r>btest := Get.get_bool test
             <b><U>done</U><r>) ;
     
         def_fun "\\newboolean" (</r><U>fun</U></b> s -&gt; "\\newif\\if"^s) ;
     
 </r>230     <r>def_code "\\setboolean"
           (<b><U>fun</U><r> lexbuf -&gt;
             </r><U>let</U></b> name = get_prim_arg lexbuf <b><U>in</U>
             <U>let</U></b> arg = save_arg lexbuf <b><U>in</U>
             <U>let</U></b> b = Get.get_bool arg <b><U>in</U><m>
 235         <r>scan_this main ("\\"^name^(<b><U>if</U><r> b </r><U>then</U></b> "true" <b><U>else</U></b> "false"))) ;
         ())
     ;;
     
     
 </r>240 <w>(* color package *)
     <r>register_init "color"
       (<b><U>fun</U><r> () -&gt;
         def_code "\\definecolor"
           (</r><U>fun</U></b> lexbuf -&gt;
 </r></w>245         <r>Save.start_echo () ;
             <b><U>let</U><r> clr = get_prim_arg lexbuf </r><U>in</U>
             <U>let</U></b> mdl = get_prim_arg lexbuf <b><U>in</U>
             <U>let</U></b> value = get_prim_arg lexbuf <b><U>in</U></b>
             Image.put "\\definecolor" ;
 </r>250         <r>Image.put (Save.get_echo ()) ;
             fun_register (<b><U>fun</U></b> () -&gt; Color.remove clr) ;
             Color.define clr mdl value ) ;
     
         def_code "\\DefineNamedColor"
 </r>255       <r>(<b><U>fun</U><r> lexbuf -&gt;
             </r><U>let</U></b> _ = get_prim_arg lexbuf <b><U>in</U>
             <U>let</U></b> clr = get_prim_arg lexbuf <b><U>in</U>
             <U>let</U></b> mdl = get_prim_arg lexbuf <b><U>in</U>
             <U>let</U></b> value = get_prim_arg lexbuf <b><U>in</U><m>
 260         <r>fun_register (<b><U>fun</U></b> () -&gt; Color.remove clr) ;
             Color.define clr mdl value ;
             Color.define_named clr mdl value) ;
     
         def_code "\\@getcolor"
 </r>265       <r>(<b><U>fun</U><r> lexbuf -&gt;
             </r><U>let</U></b> mdl = get_prim_opt "!*!" lexbuf <b><U>in</U>
             <U>let</U></b> clr = get_prim_arg lexbuf <b><U>in</U>
             <U>let</U></b> htmlval = <b><U>match</U><r> mdl </r><U>with</U></b>
             | "!*!"|"" -&gt; Color.retrieve clr
 </r>270         <r>| _     -&gt; Color.compute mdl clr <b><U>in</U></b>
             Dest.put_char '"' ;
             Dest.put_char '#' ;
             Dest.put htmlval ;
             Dest.put_char '"'))
 </r>275 <r>;;
     
     register_init "colortbl"
         (<b><U>fun</U></b> () -&gt;
           def_code "\\columncolor"
 </r>280         <r>(<b><U>fun</U><r> lexbuf -&gt;
               </r><U>let</U></b> mdl = get_prim_opt "!*!" lexbuf <b><U>in</U>
               <U>let</U></b> clr = get_prim_arg lexbuf <b><U>in</U>
               <U>let</U></b> htmlval = <b><U>match</U><r> mdl </r><U>with</U></b>
               | "!*!" -&gt; Color.retrieve clr
 </r>285           <r>| _     -&gt; Color.compute mdl clr <b><U>in</U></b>
               skip_opt lexbuf ;
               skip_opt lexbuf ;
               Dest.insert_attr "TD" ("bgcolor=\"#"^htmlval^"\"")) ;
           def_code "\\rowcolor"
 </r>290         <r>(<b><U>fun</U><r> lexbuf -&gt;
               </r><U>let</U></b> mdl = get_prim_opt "!*!" lexbuf <b><U>in</U>
               <U>let</U></b> clr = get_prim_arg lexbuf <b><U>in</U>
               <U>let</U></b> htmlval = <b><U>match</U><r> mdl </r><U>with</U></b>
               | "!*!" -&gt; Color.retrieve clr
 </r>295           <r>| _     -&gt; Color.compute mdl clr <b><U>in</U></b>
               skip_opt lexbuf ;
               skip_opt lexbuf ;
               Dest.insert_attr "TR" ("bgcolor=\"#"^htmlval^"\"")))
     ;;
 </r>300 
     
     </m><w>(* sword package *)
     <r>register_init "sword"
     (<b><U>fun</U></b> () -&gt;
 <m>305       </m>def_code "\\FRAME"
             (<b><U>fun</U><r> lexbuf -&gt;
               </r><U>let</U><r> lxm = lexeme lexbuf <b><U>in</U><w>
               (* discard the first 7 arguments *)
               </w><U>let</U></b> _ = save_arg lexbuf </r><U>in</U><m>
 310           <b><U>let</U><r> _ = save_arg lexbuf </r><U>in</U>
               <U>let</U><r> _ = save_arg lexbuf <b><U>in</U>
               <U>let</U></b> _ = save_arg lexbuf <b><U>in</U>
               <U>let</U></b> _ = save_arg lexbuf <b><U>in</U>
               <U>let</U></b> _ = save_arg lexbuf </r><U>in</U></b>
 315           <b><U>let</U><r> _ = save_arg lexbuf </r><U>in</U><w>
               (* keep argument 8 *)
               </w><U>let</U><r> t = Subst.subst_arg lexbuf <b><U>in</U><w>
               (* try to find rightmost material in single quotes *)
               </w><U>let</U></b> i = <b><U>try</U><r> String.rindex t '\'' </r><U>with</U></b> Not_found-&gt; (-1) </r><U>in</U></b>
 320           <b><U>if</U><r> i&gt;=0 </r><U>then</U> <U>begin</U><w>
                 (* we found something, so extract the filename *)
                 </w><U>let</U><r> j = String.rindex_from t (i - 1) '\'' <b><U>in</U>
                 <U>let</U></b> s = String.sub t (j + 1) (i - j - 1) <b><U>in</U>
                 <U>let</U></b> t = Filename.basename (s) </r><U>in</U></b>
 325             <b><U>let</U><r> s = Filename.chop_extension (t) </r><U>in</U><w>
                 (* now form the macro swFRAME whose arg is just the base file
     name *)
                 </w><U>let</U><r> cmd = "\\swFRAME{"^s^"}" <b><U>in</U><w>
                 (* put it back into the input stream *)
 <m>330             <r>scan_this main cmd
                 <b><U>end</U><r> ;
               </r><U>if</U></b> i&lt;0 <b><U>then</U> <U>begin</U><w>
                (* no filename found: we use a default name and give a warning *)
                <r>warning ("\\FRAME: no filename (missing snapshot?) - using
 <m>335 </m>fallback name");
                <b><U>let</U><r> s = "FRAME-graphic-not-found" </r><U>in</U>
                <U>let</U></b> cmd = "\\swFRAME{"^s^"}" <b><U>in</U><r>
                scan_this main cmd
               </r><U>end</U></b>) ;
 <m>340   </m>def_code "\\UNICODE"
         (<b><U>fun</U></b> lexbuf -&gt;
           </r>(* input: \UNICODE{arg} where arg is a hex number, eg 0x23ab *)
           (* output: call to \swUNICODE{arg1}{arg2} where: *)
           (*    arg1 = hex number w/o leading 0, eg x23ab *)
 <m>345       </m>(*    arg2 = decimal equivalent, eg 9131 *)
           (* it is up to \swUNICODE (in sword.hva) to do final formatting *)
           </w><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U>
           <U>let</U></b> t = Subst.subst_arg lexbuf <b><U>in</U>
           <U>let</U></b> s = string_of_int (int_of_string (t)) <b><U>in</U><m>
 350       </m><U>let</U></b> tt = String.sub t (String.index t 'x') (-1+String.length t) <b><U>in</U>
           <U>let</U></b> cmd = "\\swUNICODE{" ^tt^"}{"^s^"}" <b><U>in</U></b>
           scan_this main cmd)
         )
     ;;
 </r>355 
     </m>(* url package *)
     </w><U>let</U></b> verb_arg lexbuf =
       <b><U>let</U><r> {arg=url} = save_verbatim lexbuf </r><U>in</U>
       <U>for</U></b> i = 0 <b><U>to</U></b> String.length url - 1 </r><U>do</U></b>
 360     <r>Dest.put (Dest.iso url.[i])
       <b><U>done</U></b>
     ;;
     
     def_code "\\@verbarg" verb_arg ;
 </r>365 <r>;;
     
     register_init "url"
       (<b><U>fun</U></b> () -&gt;
         def_code "\\@Url" verb_arg ;
 </r>370 
         <r>def_code "\\Url"
           (<b><U>fun</U><r> lexbuf -&gt;
             Save.start_echo () ;
             </r><U>let</U></b> _ = save_verbatim lexbuf <b><U>in</U><m>
 375         </m><U>let</U></b> arg = Save.get_echo () <b><U>in</U><r>
             scan_this main
               ("\\UrlFont\\UrlLeft\\@Url"^arg^"\\UrlRight\\endgroup")) ;
     
         </r><U>let</U></b> do_urldef lexbuf =
 </r>380         <r>Save.start_echo () ;
             <b><U>let</U><r> name = Scan.get_csname lexbuf </r><U>in</U>
             <U>let</U></b> url_macro = Scan.get_csname lexbuf <b><U>in</U>
             <U>let</U></b> true_args = Save.get_echo () <b><U>in</U></b>
             Save.start_echo () ;
 </r>385         <b><U>let</U><r> _ = save_verbatim lexbuf </r><U>in</U>
             <U>let</U><r> arg = Save.get_echo () <b><U>in</U>
             <U>let</U></b> what = get_this_main (url_macro^arg) <b><U>in</U>
             <U>if</U></b> Scan.echo_toimage () <b><U>then</U> <U>begin</U></b>
               Image.put "\\urldef" ;
 <m>390           </m>Image.put true_args ;
               Image.put arg
             <b><U>end</U><r> ;
             Latexmacros.def name zero_pat
               (CamlCode (</r><U>fun</U></b> _ -&gt; Dest.put what)) </r><U>in</U></b>
 395 
         <r>def_code "\\urldef" do_urldef ;
         ())
     ;;
     
 </r>400 <w>(* hyperref (not implemented in fact) *)
     <r>register_init "hyperref"
       (<b><U>fun</U><r> () -&gt;
         def_code "\\href"
           (</r><U>fun</U></b> lexbuf -&gt;
 <m>405         </m>Save.start_echo () ;
             <b><U>let</U><r> _ = save_arg lexbuf </r><U>in</U>
             <U>let</U></b> url = Save.get_echo () <b><U>in</U>
             <U>let</U></b> {arg=arg ; subst=subst} = save_arg lexbuf <b><U>in</U><r>
             scan_this_arg main
 <m>410           </m>(mkarg ("\\ahref{\\textalltt[]"^url^"}{"^arg^"}") subst)) ;
         def_code "\\hyperimage"
           (</r><U>fun</U></b> lexbuf -&gt;
             Save.start_echo () ;
             <b><U>let</U><r> _ = save_arg lexbuf </r><U>in</U><m>
 415         </m><U>let</U></b> url = Save.get_echo () <b><U>in</U>
             <U>let</U></b> _ = save_arg lexbuf <b><U>in</U><r>
             scan_this main
               ("\\imgsrc{\\textalltt[]"^url^"}")) ;
         def_code "\\hyperref"
 <m>420       </m>(</r><U>fun</U></b> lexbuf -&gt;
             Save.start_echo () ;
             <b><U>let</U><r> url = save_arg lexbuf </r><U>in</U>
             <U>let</U></b> url = Save.get_echo () <b><U>in</U>
             <U>let</U></b> category = get_prim_arg lexbuf <b><U>in</U><m>
 425         </m><U>let</U></b> name = get_prim_arg lexbuf <b><U>in</U>
             <U>let</U></b> {arg=text ; subst=subst} = save_arg lexbuf <b><U>in</U></b>
             scan_this_arg main
               (mkarg
                  ("\\ahref{\\textalltt[]"^url^
 <m>430               </m>"\\#"^category^"."^name^"}{"^text^"}")
                  subst)))
     ;;
     
     </r>(* (extended) keyval package *)
 </w>435 
     <b><U>let</U><r> keyval_name f k = "\\KV@"^f^"@"^k
     </r><U>let</U><r> keyval_extra f k = keyval_name f k^"@extra"
     
     
 <m>440 <b><U>let</U><r> do_definekey lexbuf =
       </r><U>let</U><r> argdef = save_opts ["1" ; ""] lexbuf <b><U>in</U>
       <U>let</U></b> family = get_prim_arg lexbuf <b><U>in</U>
       <U>let</U></b> key = get_prim_arg lexbuf <b><U>in</U>
       <U>let</U></b> opt = save_opts [""] lexbuf </r><U>in</U></b>
 445   <b><U>let</U><r> body = subst_body lexbuf </r><U>in</U>
       <U>begin</U> <U>match</U><r> argdef <b><U>with</U><r>
       | {arg=No _}:: _ -&gt;
           </r><U>begin</U> <U>match</U></b> opt <b><U>with</U></b>
           | [{arg=No _}] -&gt;
 <m>450           </m>Latexmacros.def (keyval_name family key) one_pat (Subst body)
           | [{arg=Yes opt ; subst=subst}] -&gt;
               Latexmacros.def (keyval_name family key) one_pat (Subst body) ;
               Latexmacros.def
                 (keyval_name family key^"@default") zero_pat
 <m>455             </m>(Subst
                    ((keyval_name family key^
                     "{"^do_subst_this (mkarg opt subst))^"}"))
           | _ -&gt; </r><U>assert</U> <U>false</U>
           <U>end</U></b>
 460   </m>| [{arg=Yes nargs ; subst=subst} ; opt] -&gt;
           <b><U>let</U><r> nargs = Get.get_int (mkarg nargs subst) </r><U>in</U>
           <U>let</U></b> extra = keyval_extra key family <b><U>in</U><r>
           Latexmacros.def (keyval_name family key) one_pat
             (Subst
 <m>465            </m>("\\@funcall{"^extra^"}{#1}")) ;
           </r><U>begin</U> <U>match</U></b> opt <b><U>with</U></b>
           | {arg=No _} -&gt;
               Latexmacros.def extra (latex_pat [] nargs) (Subst body)
           | {arg=Yes opt ; subst=o_subst} -&gt;
 <m>470           </m>Latexmacros.def
                 extra
                 (latex_pat [do_subst_this (mkarg opt o_subst)] nargs)
                 (Subst body)
           </r><U>end</U></b>
 475   <r>| _ -&gt; <b><U>assert</U> <U>false</U>
       <U>end</U></b>
     ;;
     
     <b><U>let</U></b> do_definekeyopt lexbuf =
 </r>480   <b><U>let</U><r> familly = get_prim_arg lexbuf </r><U>in</U>
       <U>let</U><r> key =  get_prim_arg lexbuf <b><U>in</U>
       <U>let</U></b> opt = subst_arg lexbuf <b><U>in</U>
       <U>let</U></b> body = subst_body lexbuf <b><U>in</U>
       <U>let</U></b> name = keyval_name familly key </r><U>in</U></b>
 485   <b><U>let</U><r> extra = keyval_extra key familly </r><U>in</U><r>
       Latexmacros.def name one_pat
         (Subst
            ("\\@funcall{"^extra^"}{"^opt^"}")) ;
       Latexmacros.def extra one_pat (Subst body)
 <m>490 
     
     <b><U>let</U><r> do_setkey lexbuf =
       </r><U>let</U><r> family = get_prim_arg lexbuf <b><U>in</U>
       <U>let</U></b> arg = subst_arg lexbuf^",," </r><U>in</U></b>
 495   <b><U>let</U><r> abuff = Lexing.from_string arg </r><U>in</U>
       <U>let</U> <U>rec</U><r> do_rec () =
         <b><U>let</U><r> {arg=x} = save_arg_with_delim "," abuff </r><U>in</U>
         <U>if</U></b> x &lt;&gt;  "" <b><U>then</U> <U>begin</U>
           <U>let</U></b> xbuff = Lexing.from_string (x^"==") </r><U>in</U></b>
 500       </m>check_alltt_skip xbuff ;
           <b><U>let</U><r> {arg=key} = save_arg_with_delim "=" xbuff </r><U>in</U>
           <U>let</U></b> {arg=value} = save_arg_with_delim "=" xbuff <b><U>in</U>
           <U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
             Printf.fprintf stderr "SETKEY, key=%s, value=%s\n" key value ;
 <m>505       <b><U>let</U><r> csname = keyval_name family key </r><U>in</U>
           <U>if</U><r> Latexmacros.exists csname <b><U>then</U> <U>begin</U>
             <U>if</U></b> value &lt;&gt; "" <b><U>then</U></b>
               scan_this main (csname^"{"^value^"}")
             </r><U>else</U></b>
 510           </m>scan_this main (csname^"@default")
           </r><U>end</U> <U>else</U></b>
             warning ("keyval, uknown key: ``"^key^"''") ;
           do_rec ()
         </r><U>end</U> <U>in</U></b>
 515   <r>do_rec ()
     ;;
     
     register_init "keyval"
       (<b><U>fun</U></b> () -&gt;
 </r>520     <r>def_code "\\define@key" do_definekey ;
         def_code "\\@setkeys" do_setkey
       )
     ;;
     
 </r>525 <r>register_init "amsmath"
       (<b><U>fun</U><r> () -&gt;
         def_code "\\numberwithin"
           (</r><U>fun</U></b> lexbuf -&gt;
             <b><U>let</U><r> name = get_prim_arg lexbuf </r><U>in</U><m>
 530         </m><U>let</U></b> within = get_prim_arg  lexbuf <b><U>in</U></b>
             Counter.number_within name within)
       )
     ;;
     
 </r>535 
     </m><U>end</U></b><PL><B>
<6>108 parse_opts.ml</6>
</B></PL></r> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>open</U></b> Misc
     
     <b><U>let</U></b> header = "$Id: parse_opts.ml,v 1.25 2001/05/25 12:37:27 maranget Exp $"
  </r>15 
     </m><U>type</U></b> input = File <b><U>of</U><r> string | Prog </r><U>of</U></b> string
     
     <b><U>let</U></b> files = ref []
     ;;
  </r>20 
     </m><U>let</U></b> add_input s =
       files := File s :: !files
     <b><U>and</U></b> add_program s =
       files := Prog s :: !files
  </r>25 <r>;;
     
     <b><U>type</U></b> language = Francais | English
     ;;
     
  </r>30 </m><U>type</U></b> destination = Html | Text | Info
     ;;
     <b><U>let</U><r> mathml = ref </r><U>false</U>
     <U>and</U></b> entities = ref <b><U>false</U></b>
     ;;
  </r>35 
     </m><U>let</U></b> language = ref English
     <b><U>and</U><r> symbols = ref </r><U>true</U>
     <U>and</U></b> iso = ref <b><U>true</U>
     <U>and</U></b> pedantic = ref <b><U>false</U><m>
  40 </m><U>and</U></b> destination = ref Html
     <b><U>and</U><r> fixpoint = ref </r><U>false</U>
     <U>and</U></b> optimize = ref <b><U>false</U></b>
     ;;
     
  </TT><m><TT>45 <b><U>let</U></b><r> width = ref 72
     ;;
     
     
     <b><U>let</U></b> except = ref []
  </r>50 <r>;;
     
     <b><U>let</U></b> path = ref []
     ;;
     
  </r>55 <b><U>let</U><r> outname = ref ""
     ;;
     
     </r><U>let</U><r> _ = Arg.parse
         [
  <m>60       </m>("-version", Arg.Unit
              (<b><U>fun</U><r> () -&gt;
                print_endline ("hevea "^Version.version) ;
                print_endline ("library directory: "^Mylib.static_libdir) ;
                exit 0),
  <m>65        </m>"show hevea version and library directory") ;
           ("-v", Arg.Unit (</r><U>fun</U></b> () -&gt; readverb := !readverb + 1),
            "verbose flag, can be repeated to increase verbosity") ;
           ("-s", Arg.Unit (<b><U>fun</U><r> () -&gt; silent := </r><U>true</U></b>),
            "suppress warnings") ;
  <m>70       </m>("-e", Arg.String (<b><U>fun</U><r> s -&gt; except := s :: !except),
            "filename, prevent file ``filename'' from being read") ;
           ("-fix", Arg.Unit (</r><U>fun</U></b> () -&gt; fixpoint := <b><U>true</U><r>),
            "iterate Hevea until fixpoint") ;
           ("-O", Arg.Unit (</r><U>fun</U></b> () -&gt; optimize := <b><U>true</U><r>),
  <m>75        </m>"call esponja to optimize HTML output") ;
          ("-exec", Arg.String add_program,
            "prog , execute external program ``prog'', then read its result") ;
          ("-francais",Arg.Unit (</r><U>fun</U></b> () -&gt; language := Francais),
            "french mode") ;
  <m>80      </m>("-nosymb",Arg.Unit (</r><U>fun</U><r> () -&gt; symbols := <b><U>false</U><r>),
            "do not output symbol fonts") ;
          ("-noiso",Arg.Unit (</r><U>fun</U></b> () -&gt; iso := <b><U>false</U><r>),
            "use HTML entities in place of isolatin1 non-ascii characters") ;
          ("-pedantic",Arg.Unit (</r><U>fun</U></b> () -&gt; pedantic := <b><U>true</U><r>),
  <m>85        </m>"be pedantic in interpreting HTML 4.0 transitional definition") ;
          ("-I", Arg.String (</r><U>fun</U></b> s -&gt; path := s :: !path),
            "dir, add directory ``dir'' to search path") ;
          ("-mathml",Arg.Unit (<b><U>fun</U><r>() -&gt; mathml := </r><U>true</U></b>),
            "produces MathML output for equations, very experimental");
  <m>90      <r>("-entities",Arg.Unit (<b><U>fun</U><r>() -&gt; entities := </r><U>true</U></b>),
            "produces HTML 4.0 entities and unicode characters references for symbols, very experimental");
          ("-text",Arg.Unit (<b><U>fun</U><r> () -&gt; symbols := </r><U>false</U></b>; destination := Text),
            "output plain text");
          ("-info",Arg.Unit (<b><U>fun</U><r> () -&gt; symbols := </r><U>false</U></b>; destination := Info),
  </r>95        <r>"output info file(s)");
          ("-w", Arg.String (<b><U>fun</U><r> s -&gt; width := int_of_string s),
           "width, set the output width for text or info output");
          ("-o", Arg.String (</r><U>fun</U></b> s -&gt; outname := s),
            "filename, make hevea output go into file ``filename''")
 </r>100     <r>]
         (add_input)
        ("hevea "^Version.version)
     ;;
     
 </r>105 <b><U>let</U></b></m> warning s =
       <b><U>if</U><r> not !silent || !verbose &gt; 0 </r><U>then</U> <U>begin</U></b>
         Location.print_pos () ;
         prerr_string "Warning: " ;
         prerr_endline s
 <m>110   <b><U>end</U></b></m>
     ;;
     
     <w>(* For correcting strange user (-exec prog en dernier) *)
     <b><U>let</U> <U>rec</U></b></w> ffirst = <b><U>function</U><m>
 115   <r>| [] -&gt; None,[]
       | Prog _ <b><U>as</U><r> arg::rem -&gt;
           </r><U>let</U></b> file, rest = ffirst rem <b><U>in</U><r>
           file, arg::rest
       | File _ </r><U>as</U></b> arg::rem -&gt;
 </r>120       <r>Some arg,rem
     ;;
     
     files :=
        <b><U>match</U><r> ffirst !files </r><U>with</U><m>
 125    <r>| None,rem -&gt; rem
        | Some arg,rem -&gt; arg::rem
     
     
     
 </r>130 </m><U>let</U></b> base_in,name_in,styles = <b><U>match</U><r> !files </r><U>with</U></b>
     | File x :: rest -&gt;
         <b><U>if</U><r> Filename.check_suffix x ".hva" </r><U>then</U></b>
           "","", !files
         <b><U>else</U><m>
 135       </m><U>let</U></b> base_file = Filename.basename x <b><U>in</U>
           <U>begin</U> <U>try</U>
             <U>let</U></b> base =
               <b><U>if</U><r> Filename.check_suffix base_file ".tex" </r><U>then</U></b>
                 Filename.chop_extension base_file
 </r>140           </m><U>else</U></b>
                 base_file <b><U>in</U><r>
             base,x,rest
           </r><U>with</U></b> Invalid_argument _ -&gt; base_file, x,rest
           <b><U>end</U><m>
 145 <r>| _ -&gt; "","",!files
     
     <b><U>let</U><r> filter = </r><U>match</U></b> base_in <b><U>with</U><r> "" -&gt; </r><U>true</U></b> | _ -&gt;  <b><U>false</U></b>
     ;;
     
 </r>150 </m><U>if</U></b> filter <b><U>then</U> <U>begin</U>
       <U>if</U></b> !fixpoint <b><U>then</U><r>
         Misc.warning ("No fixpoint in filter mode");
       fixpoint := </r><U>false</U>
     <U>end</U><m>
 155 <r>;;
     
     <b><U>let</U><r> base_out = </r><U>match</U></b> !outname <b><U>with</U><r>
     | "" -&gt; </r><U>begin</U> <U>match</U></b> base_in <b><U>with</U></b>
       | "" -&gt; ""
 </r>160   <r>| _  -&gt; Filename.basename base_in
     <b><U>end</U><r>
     | name -&gt;
         </r><U>let</U></b> suff = <b><U>match</U><r> !destination </r><U>with</U></b>
         | Html -&gt; ".html"
 </r>165     <r>| Text -&gt; ".txt"
         | Info -&gt; ".info"
         <b><U>in</U>
         <U>if</U></b> Filename.check_suffix name suff <b><U>then</U></b>
           Filename.chop_suffix name suff
 </r>170     </m><U>else</U>
           <U>try</U></b>
             Filename.chop_extension name
           <b><U>with</U><r> Invalid_argument _ -&gt; name
     
 </r><m>175 </m><U>let</U></b> name_out = <b><U>match</U><r> !outname </r><U>with</U></b>
     | "" -&gt; <b><U>begin</U> <U>match</U></b> base_in <b><U>with</U><r>
       | "" -&gt; ""
       | x  -&gt; </r><U>begin</U>
           <U>match</U></b> !destination <b><U>with</U><m>
 180       <r>| Html -&gt;x^".html"
           | Text -&gt;x^".txt"
           | Info -&gt;x^".info"
       <b><U>end</U>
     <U>end</U><m>
 185 <r>| x  -&gt; x<PL><B>
<6>109 pp.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: pp.ml,v 1.4 2001/05/28 17:28:56 maranget Exp $                *)
     (***********************************************************************)
     </w><b><U>open</U><r> Printf
     </r><U>open</U></b> Lexeme
     <b><U>open</U></b> Tree
  </r>15 
     </m><U>let</U></b>  potag chan ({txt=txt} <b><U>as</U><r> s)= output_string chan txt ; s
     
     </r><U>let</U> <U>rec</U></b> pctag chan  {ctxt=txt} = output_string chan txt
     
  </r>20 
     </m><U>let</U> <U>rec</U></b> tree po pc chan = <b><U>function</U><r>
       | Text txt -&gt; output_string chan txt
       | Blanks txt -&gt;
           output_string chan txt
  <m>25   </m>| Node (styles, ts) -&gt;
           </r><U>let</U></b> styles = po chan styles <b><U>in</U><r>
           trees po pc chan ts ;
           pc chan styles
       | ONode (so,sc,ts) -&gt;
  <m>30       </m>output_string chan so ;
           trees po pc chan ts ;
           output_string chan sc
     
     </r><U>and</U></b> trees po pc chan = <b><U>function</U><m>
  35   <r>| [] -&gt; ()
       | t::rem -&gt; tree po pc chan t ; trees po pc chan rem
     
     <b><U>let</U><r> ptree chan t = tree potag pctag chan t
     </r><U>and</U></b> ptrees chan ts = trees potag pctag chan ts
  </r>40 
     </m><U>open</U></b> Htmltext
     
     <b><U>let</U> <U>rec</U></b> sep_font = </r><U>function</U><r>
       | [] -&gt; [],[]
  <m>45   </m>| {nat=(Size (Int _)|Face _|Color _)} </r><U>as</U><r> s::rem -&gt;
           <b><U>let</U><r> fs,os = sep_font rem </r><U>in</U></b>
           s::fs,os
       | s::rem -&gt;
           <b><U>let</U><r> fs,os = sep_font rem </r><U>in</U><m>
  50       <r>fs,s::os
     
     
     <b><U>let</U> <U>rec</U></b> do_potags chan = <b><U>function</U></b>
       | [] -&gt; ()
  </r>55   <r>| {txt=txt}::rem -&gt;
           output_string chan txt ;
           do_potags chan rem
     
     <b><U>let</U> <U>rec</U></b> do_pctags chan = <b><U>function</U><m>
  60   <r>| [] -&gt; ()
       | {ctxt=txt}::rem -&gt;
           do_pctags chan rem ;
           output_string chan txt
     
  </r>65 </m><U>let</U></b> potags chan x =
       <b><U>let</U><r> fs,os = sep_font x </r><U>in</U>
       <U>let</U></b> styles = <b><U>match</U><r> fs </r><U>with</U></b>
       | [] -&gt; os
       | {ctxt=ctxt}::_ -&gt;
  </r>70       </m><U>let</U></b> txt =
             "&lt;" ^ String.sub ctxt 2 4 ^
             List.fold_right
               (<b><U>fun</U><r> {txt=atxt} r -&gt; atxt ^ r)
               fs "&gt;" </r><U>in</U><m>
  75       <r>{nat=Other ; txt=txt ; ctxt=ctxt}::os <b><U>in</U><w>
     (*  output_char chan '[' ; *)
       <r>do_potags chan styles ;
     </r>(*  output_char chan ']' ; *)
       <r>styles
  <m>80 
     <b><U>and</U></b></m> pctags chan x = do_pctags chan x
     
     <b><U>let</U><r> tree chan t = tree potags pctags chan t
     </r><U>and</U></b> trees chan ts = trees potags pctags chan ts<PL><B>
<6>110 save.ml</6>
</B></PL> 
      12 "save.mll"
     
     <b><U>open</U><r> Lexing
     </r><U>open</U></b> Misc
   <m>5 
     <b><U>let</U></b></m> header = "$Id: save.mll,v 1.60 2001/02/12 10:05:39 maranget Exp $"
     
     <b><U>let</U> <U>rec</U></b> if_next_char  c lb =
       <b><U>if</U><r> lb.lex_eof_reached </r><U>then</U><m>
  10     </m><U>false</U>
       <U>else</U>
         <U>let</U></b> pos = lb.lex_curr_pos
         <b><U>and</U><r> len = lb.lex_buffer_len </r><U>in</U>
         <U>if</U></b> pos &gt;= len <b><U>then</U> <U>begin</U><m>
  15       <r>warning "Refilling buffer" ;
           lb.refill_buff lb ;
           if_next_char c lb
         <b><U>end</U> <U>else</U></b>
           lb.lex_buffer.[pos] = c
  </r>20 
     </m><U>let</U> <U>rec</U></b> if_next_string s lb =
       <b><U>if</U><r> s = "" </r><U>then</U>
         <U>true</U>
       <U>else</U><m>
  25     </m><U>let</U></b> pos = lb.lex_curr_pos
         <b><U>and</U><r> len = lb.lex_buffer_len
         </r><U>and</U></b> slen = String.length s <b><U>in</U>
         <U>if</U></b> pos + slen - 1 &gt;= len <b><U>then</U> <U>begin</U>
           <U>if</U></b> lb.lex_eof_reached <b><U>then</U> <U>begin</U><m>
  30           </m><U>false</U>
           <U>end</U> <U>else</U> <U>begin</U></b>
               lb.refill_buff lb ;
             if_next_string s lb
           <b><U>end</U><m>
  35     </m><U>end</U> <U>else</U></b>
           String.sub lb.lex_buffer pos slen = s
     
     <b><U>let</U><r> verbose = ref 0 </r><U>and</U></b> silent = ref <b><U>false</U><r>
     ;;
  </r><m>40 
     </m><U>let</U></b> set_verbose s v =
       silent := s ; verbose := v
     ;;
     
  <m>45 <b><U>exception</U></b></m> Error <b><U>of</U><r> string
     ;;
     </r><U>exception</U></b> Delim <b><U>of</U><r> string
     ;;
     
  </r><m>50 </m><U>let</U></b> seen_par = ref <b><U>false</U><r>
     ;;
     
     
     </r><U>let</U></b> brace_nesting = ref 0
  <m>55 <b><U>and</U></b></m> arg_buff = Out.create_buff ()
     <b><U>and</U><r> echo_buff = Out.create_buff ()
     </r><U>and</U></b> tag_buff = Out.create_buff ()
     ;;
     
  <m>60 
     <b><U>let</U></b></m> echo = ref <b><U>false</U><r>
     ;;
     
     </r><U>let</U></b> get_echo () = echo := <b><U>false</U><r> ; Out.to_string echo_buff
  </r><m>65 </m><U>and</U></b> start_echo () = echo := <b><U>true</U><r> ; Out.reset echo_buff
     </r><U>and</U></b> stop_echo () = echo := <b><U>false</U><r> ; Out.reset echo_buff
     ;;
     
     </r><U>let</U></b> empty_buffs () =
  <m>70   <r>brace_nesting := 0 ; Out.reset arg_buff ;
       echo := <b><U>false</U></b> ; Out.reset echo_buff ;
       Out.reset tag_buff
     ;;
     
  </r>75 <b><U>let</U></b></m> error s =
       empty_buffs () ;
       raise (Error s)
     ;;
     
  <m>80 <b><U>let</U></b></m> my_int_of_string s =
       <b><U>try</U><r> int_of_string s
       </r><U>with</U></b> Failure "int_of_string" -&gt;
         error ("Integer argument expected: ``"^s^"''")
     
  <m>85 <b><U>exception</U></b></m> Eof
     ;;
     <b><U>exception</U><r> NoOpt
     ;;
     
  </r><m>90 </m><U>let</U></b> put_echo s =
       <b><U>if</U><r> !echo </r><U>then</U></b> Out.put echo_buff s
     <b><U>and</U><r> put_echo_char c =
       </r><U>if</U></b> !echo <b><U>then</U><r> Out.put_char echo_buff c
     </r><U>and</U></b> blit_echo lb =
  <m>95   <b><U>if</U></b></m> !echo <b><U>then</U><r> Out.blit echo_buff lb
     ;;
     
     </r><U>let</U></b> put_both s =
       put_echo s ; Out.put arg_buff s
 <m>100 <r>;;
     <b><U>let</U><r> blit_both lexbuf =
       blit_echo lexbuf ; Out.blit arg_buff lexbuf
     
     </r><U>let</U></b> put_both_char c =
 </r>105   <r>put_echo_char c ; Out.put_char arg_buff c
         ;;
     
     <b><U>type</U><r> kmp_t = Continue </r><U>of</U></b> int | Stop <b><U>of</U></b> string
     
 </r>110 <b><U>let</U> <U>rec</U></b></m> kmp_char delim next i c =
       <b><U>if</U><r> i &lt; 0 </r><U>then</U> <U>begin</U></b>
         Out.put_char arg_buff c ;
         Continue 0
       <b><U>end</U> <U>else</U> <U>if</U></b> c = delim.[i] <b><U>then</U> <U>begin</U><m>
 115     </m><U>if</U></b> i &gt;= String.length delim - 1 <b><U>then</U><r>
           Stop (Out.to_string arg_buff)
         </r><U>else</U></b>
           Continue (i+1)
       <b><U>end</U> <U>else</U> <U>begin</U><m>
 120     </m><U>if</U></b> next.(i) &gt;= 0 <b><U>then</U><r>
           Out.put arg_buff (String.sub delim 0 (i-next.(i))) ;
         kmp_char delim next next.(i) c
       </r><U>end</U>
     <U>let</U></b> lex_tables = {
 <m>125   </m>Lexing.lex_base =
        "\000\000\001\000\002\000\000\000\006\000\003\000\004\000\008\000\
    \013\000\015\000\005\000\020\000\007\000\018\000\026\000\105\000\
    \010\000\035\000\040\000\047\000\024\000\027\000\009\000\008\000\
    \020\000\017\000\000\000\012\000\013\000\056\000\011\000\000\000\
    \255\255\254\255\253\255\000\000\254\255\252\255\000\000\001\000\
    \000\000\005\000\002\000\008\000\015\000\005\000\007\000\016\000\
    \033\000\024\000\030\000\255\255\000\000\250\255\060\000\005\000\
    \249\255\001\000\002\000\030\000\032\000\002\000\034\000\040\000\
    \014\000\015\000\251\255\016\000\042\000\122\000\041\000\071\000\
    \176\000\072\000\076\000\057\000\064\000\069\000\074\000\078\000\
    \078\000\083\000\074\000\076\000\083\000\088\000\078\000\080\000\
    \080\000\089\000\093\000\090\000\095\000\086\000\088\000\194\000\
    \195\000\197\000\000\001\163\000\182\000\185\000\191\000\015\000\
    \023\001\038\001\241\000\109\001\240\000\045\000\010\001\000\000\
    \099\000\002\000\120\000\106\000\112\000\126\000\115\000\124\000\
    \103\000\028\001\153\000\001\000\139\000\145\000\177\000\172\000\
    \183\000\030\001\244\000\245\000\255\255\254\255\248\000\050\001\
    \111\001\116\001\118\001\136\001\001\000\105\001\253\255\185\001\
    \254\255\248\255\013\002\094\002\175\002\000\003\058\003\139\003\
    \004\000\138\001\154\001\156\001\253\255\255\255\254\255\186\001\
    \188\001";
       Lexing.lex_backtrk =
        "\002\000\255\255\255\255\001\000\008\000\255\255\255\255\001\000\
    \001\000\000\000\255\255\002\000\255\255\001\000\000\000\007\000\
    \002\000\005\000\002\000\002\000\002\000\002\000\000\000\255\255\
    \255\255\255\255\002\000\002\000\255\255\001\000\255\255\001\000\
    \255\255\255\255\255\255\002\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\002\000\255\255\005\000\001\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\001\000\001\000\001\000\255\255\
    \255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\001\000\
    \000\000\000\000\255\255\255\255\001\000\255\255\006\000\006\000\
    \002\000\003\000\000\000\000\000\003\000\255\255\255\255\001\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\001\000\004\000\005\000\255\255\255\255\004\000\000\000\
    \255\255\000\000\000\000\000\000\000\000\006\000\255\255\006\000\
    \255\255\255\255\004\000\004\000\004\000\004\000\255\255\003\000\
    \000\000\000\000\001\000\001\000\255\255\255\255\255\255\255\255\
    \255\255";
       Lexing.lex_default =
 <m>130    <r>"\255\255\037\000\034\000\255\255\056\000\032\000\006\000\255\255\
    \255\255\255\255\130\000\255\255\033\000\255\255\106\000\255\255\
    \095\000\255\255\255\255\255\255\033\000\033\000\022\000\053\000\
    \034\000\034\000\255\255\255\255\034\000\255\255\032\000\255\255\
    \000\000\000\000\000\000\255\255\000\000\000\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\000\000\255\255\000\000\255\255\255\255\
    \000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\000\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\095\000\
    \255\255\255\255\255\255\255\255\255\255\056\000\255\255\066\000\
    \255\255\255\255\106\000\106\000\255\255\109\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\134\000\255\255\000\000\000\000\134\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\000\000\066\000\
    \000\000\000\000\255\255\255\255\255\255\255\255\037\000\255\255\
    \255\255\255\255\255\255\255\255\000\000\000\000\000\000\255\255\
    \255\255";
       Lexing.lex_trans =
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\159\000\160\000\152\000\154\000\159\000\152\000\139\000\
    \140\000\007\000\032\000\139\000\096\000\007\000\136\000\137\000\
    \009\000\000\000\136\000\110\000\009\000\121\000\121\000\110\000\
    \159\000\121\000\033\000\107\000\108\000\032\000\139\000\107\000\
    \007\000\141\000\096\000\142\000\073\000\136\000\054\000\009\000\
    \073\000\072\000\110\000\051\000\121\000\072\000\036\000\033\000\
    \071\000\000\000\107\000\069\000\071\000\032\000\255\255\109\000\
    \032\000\032\000\032\000\073\000\055\000\032\000\034\000\057\000\
    \072\000\034\000\066\000\037\000\135\000\032\000\000\000\071\000\
    \071\000\073\000\051\000\058\000\071\000\073\000\000\000\000\000\
    \032\000\000\000\000\000\032\000\038\000\122\000\156\000\000\000\
    \000\000\131\000\143\000\111\000\062\000\112\000\114\000\071\000\
    \073\000\035\000\047\000\043\000\039\000\052\000\040\000\041\000\
    \122\000\042\000\097\000\097\000\070\000\044\000\097\000\068\000\
    \045\000\046\000\033\000\032\000\157\000\048\000\158\000\074\000\
    \132\000\144\000\133\000\255\255\255\255\255\255\032\000\033\000\
    \036\000\097\000\049\000\098\000\050\000\032\000\032\000\123\000\
    \099\000\032\000\067\000\255\255\065\000\063\000\255\255\066\000\
    \064\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \100\000\100\000\100\000\059\000\033\000\032\000\032\000\088\000\
    \060\000\084\000\061\000\032\000\032\000\032\000\032\000\032\000\
    \032\000\032\000\032\000\032\000\078\000\075\000\079\000\080\000\
    \076\000\072\000\077\000\081\000\082\000\072\000\083\000\034\000\
    \085\000\086\000\087\000\033\000\089\000\090\000\091\000\092\000\
    \093\000\101\000\094\000\037\000\255\255\096\000\097\000\097\000\
    \072\000\113\000\097\000\104\000\104\000\104\000\104\000\104\000\
    \104\000\104\000\104\000\115\000\102\000\116\000\117\000\118\000\
    \119\000\120\000\255\255\096\000\032\000\097\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \053\000\053\000\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\108\000\108\000\255\255\124\000\108\000\125\000\126\000\
    \033\000\255\255\032\000\033\000\032\000\037\000\145\000\034\000\
    \056\000\255\255\255\255\033\000\032\000\037\000\032\000\255\255\
    \108\000\037\000\127\000\110\000\037\000\103\000\255\255\110\000\
    \255\255\128\000\255\255\255\255\129\000\255\255\000\000\000\000\
    \000\000\000\000\000\000\066\000\000\000\121\000\121\000\129\000\
    \033\000\121\000\110\000\129\000\000\000\255\255\000\000\033\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\000\000\135\000\121\000\255\255\129\000\135\000\
    \000\000\105\000\105\000\105\000\105\000\105\000\105\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\000\000\
    \255\255\034\000\135\000\000\000\255\255\000\000\105\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \000\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\000\000\255\255\255\255\
    \034\000\255\255\034\000\255\255\000\000\255\255\107\000\108\000\
    \136\000\137\000\107\000\000\000\136\000\137\000\138\000\138\000\
    \138\000\137\000\000\000\138\000\000\000\032\000\000\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\107\000\000\000\136\000\
    \000\000\153\000\255\255\153\000\137\000\153\000\138\000\153\000\
    \000\000\255\255\053\000\053\000\053\000\053\000\053\000\053\000\
    \053\000\053\000\053\000\155\000\000\000\155\000\000\000\155\000\
    \153\000\155\000\153\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\255\255\155\000\000\000\155\000\000\000\000\000\000\000\
    \000\000\000\000\255\255\159\000\160\000\160\000\000\000\159\000\
    \000\000\160\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\159\000\000\000\160\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\255\255\000\000\000\000\000\000\000\000\000\000\
    \000\000\255\255\000\000\000\000\255\255\000\000\000\000\000\000\
    \255\255\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\000\000\032\000\000\000\032\000\
    \000\000\000\000\146\000\147\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\000\000\000\000\000\000\066\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \000\000\000\000\000\000\000\000\000\000\255\255\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \066\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\255\255\000\000\000\000\000\000\000\000\000\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\148\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\066\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\149\000\
    \146\000\146\000\066\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\000\000\150\000\000\000\000\000\000\000\
    \000\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\151\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\151\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\037\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\255\255\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000";
       Lexing.lex_check =
        "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\140\000\002\000\000\000\152\000\004\000\
    \004\000\007\000\007\000\004\000\016\000\007\000\008\000\008\000\
    \009\000\255\255\008\000\013\000\009\000\011\000\011\000\013\000\
    \000\000\011\000\052\000\014\000\014\000\003\000\004\000\014\000\
    \007\000\004\000\016\000\004\000\017\000\008\000\023\000\009\000\
    \017\000\018\000\013\000\025\000\011\000\018\000\024\000\109\000\
    \019\000\255\255\014\000\020\000\019\000\031\000\021\000\014\000\
    \058\000\029\000\029\000\017\000\023\000\029\000\014\000\055\000\
    \018\000\064\000\065\000\067\000\009\000\068\000\255\255\019\000\
    \071\000\073\000\024\000\057\000\071\000\073\000\255\255\255\255\
    \029\000\255\255\255\255\000\000\026\000\123\000\001\000\255\255\
    \255\255\010\000\004\000\012\000\061\000\111\000\113\000\071\000\
    \073\000\028\000\039\000\042\000\038\000\025\000\038\000\040\000\
    \011\000\041\000\015\000\015\000\020\000\043\000\015\000\021\000\
    \044\000\045\000\046\000\035\000\001\000\047\000\001\000\017\000\
    \010\000\004\000\010\000\004\000\022\000\016\000\018\000\027\000\
    \028\000\015\000\048\000\015\000\049\000\013\000\019\000\011\000\
    \015\000\050\000\059\000\020\000\060\000\062\000\021\000\014\000\
    \063\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\054\000\070\000\068\000\071\000\075\000\
    \054\000\076\000\054\000\069\000\069\000\069\000\069\000\069\000\
    \069\000\069\000\069\000\069\000\077\000\074\000\078\000\079\000\
    \074\000\072\000\074\000\080\000\081\000\072\000\082\000\083\000\
    \084\000\085\000\086\000\087\000\088\000\089\000\090\000\091\000\
    \092\000\015\000\093\000\094\000\095\000\096\000\097\000\097\000\
    \072\000\112\000\097\000\099\000\099\000\099\000\099\000\099\000\
    \099\000\099\000\099\000\114\000\101\000\115\000\116\000\117\000\
    \118\000\119\000\095\000\096\000\120\000\097\000\100\000\100\000\
    \100\000\100\000\100\000\100\000\100\000\100\000\100\000\100\000\
    \102\000\102\000\102\000\102\000\102\000\102\000\102\000\102\000\
    \102\000\108\000\108\000\106\000\122\000\108\000\124\000\125\000\
    \000\000\001\000\002\000\005\000\006\000\010\000\004\000\012\000\
    \023\000\022\000\016\000\030\000\027\000\028\000\072\000\103\000\
    \108\000\025\000\126\000\110\000\024\000\101\000\106\000\110\000\
    \020\000\127\000\014\000\021\000\128\000\106\000\255\255\255\255\
    \255\255\255\255\255\255\017\000\255\255\121\000\121\000\129\000\
    \018\000\121\000\110\000\129\000\255\255\109\000\255\255\019\000\
    \098\000\098\000\098\000\098\000\098\000\098\000\098\000\098\000\
    \098\000\098\000\255\255\135\000\121\000\095\000\129\000\135\000\
    \255\255\098\000\098\000\098\000\098\000\098\000\098\000\104\000\
    \104\000\104\000\104\000\104\000\104\000\104\000\104\000\255\255\
    \130\000\131\000\135\000\255\255\134\000\255\255\105\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\105\000\105\000\105\000\
    \255\255\098\000\098\000\098\000\098\000\098\000\098\000\105\000\
    \105\000\105\000\105\000\105\000\105\000\255\255\106\000\130\000\
    \131\000\130\000\131\000\134\000\255\255\134\000\107\000\107\000\
    \136\000\136\000\107\000\255\255\136\000\137\000\137\000\138\000\
    \138\000\137\000\255\255\138\000\255\255\110\000\255\255\105\000\
    \105\000\105\000\105\000\105\000\105\000\107\000\255\255\136\000\
    \255\255\139\000\107\000\153\000\137\000\139\000\138\000\153\000\
    \255\255\107\000\141\000\141\000\141\000\141\000\141\000\141\000\
    \141\000\141\000\141\000\154\000\255\255\155\000\255\255\154\000\
    \139\000\155\000\153\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\101\000\154\000\255\255\155\000\255\255\255\255\255\255\
    \255\255\255\255\095\000\159\000\159\000\160\000\255\255\159\000\
    \255\255\160\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\159\000\255\255\160\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\107\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\106\000\255\255\255\255\130\000\255\255\255\255\255\255\
    \134\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\255\255\159\000\255\255\160\000\
    \255\255\255\255\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\143\000\143\000\143\000\143\000\
    \143\000\143\000\143\000\143\000\255\255\255\255\255\255\146\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \255\255\255\255\255\255\255\255\255\255\107\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \146\000\146\000\146\000\146\000\146\000\146\000\146\000\146\000\
    \147\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\147\000\147\000\
    \147\000\147\000\147\000\147\000\147\000\147\000\147\000\147\000\
    \147\000\147\000\147\000\147\000\147\000\147\000\147\000\147\000\
    \147\000\147\000\147\000\147\000\147\000\147\000\147\000\147\000\
    \147\000\143\000\255\255\255\255\255\255\255\255\255\255\147\000\
    \147\000\147\000\147\000\147\000\147\000\147\000\147\000\147\000\
    \147\000\147\000\147\000\147\000\147\000\147\000\147\000\147\000\
    \147\000\147\000\147\000\147\000\147\000\147\000\147\000\147\000\
    \147\000\148\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\148\000\
    \148\000\148\000\148\000\148\000\148\000\148\000\148\000\148\000\
    \148\000\148\000\148\000\148\000\148\000\148\000\148\000\148\000\
    \148\000\148\000\148\000\148\000\148\000\148\000\148\000\148\000\
    \148\000\148\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \148\000\148\000\148\000\148\000\148\000\148\000\148\000\148\000\
    \148\000\148\000\148\000\148\000\148\000\148\000\148\000\148\000\
    \148\000\148\000\148\000\148\000\148\000\148\000\148\000\148\000\
    \148\000\148\000\149\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \149\000\149\000\149\000\149\000\149\000\149\000\149\000\149\000\
    \149\000\149\000\149\000\149\000\149\000\149\000\149\000\149\000\
    \149\000\149\000\149\000\149\000\149\000\149\000\149\000\149\000\
    \149\000\149\000\149\000\255\255\149\000\255\255\255\255\255\255\
    \255\255\149\000\149\000\149\000\149\000\149\000\149\000\149\000\
    \149\000\149\000\149\000\149\000\149\000\149\000\149\000\149\000\
    \149\000\149\000\149\000\149\000\149\000\149\000\149\000\149\000\
    \149\000\149\000\149\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\150\000\150\000\150\000\
    \150\000\150\000\150\000\150\000\150\000\151\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\151\000\151\000\
    \151\000\151\000\151\000\151\000\151\000\151\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\150\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255"
 </r>135 <r>}
     
     <b><U>let</U> <U>rec</U></b> opt lexbuf = __ocaml_lex_opt_rec lexbuf 0
     <b><U>and</U><r> __ocaml_lex_opt_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><m>
 140     <r>0 -&gt; (
      140 "save.mll"
          put_echo (lexeme lexbuf) ;
         opt2 lexbuf)
       | 1 -&gt; (
 </r>145  <r>142 "save.mll"
              raise Eof)
       | 2 -&gt; (
      143 "save.mll"
              raise NoOpt)
 </r>150   <r>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_opt_rec lexbuf n
     
     <b><U>and</U><r> opt2 lexbuf = __ocaml_lex_opt2_rec lexbuf 1
     </r><U>and</U></b> __ocaml_lex_opt2_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><m>
 155     <r>0 -&gt; (
      147 "save.mll"
                    incr brace_nesting;
                      put_both_char '{' ; opt2 lexbuf)
       | 1 -&gt; (
 </r>160  <r>149 "save.mll"
                    decr brace_nesting;
                    <b><U>if</U><r> !brace_nesting &gt;= 0 </r><U>then</U> <U>begin</U></b>
                      put_both_char '}' ; opt2 lexbuf
                    <b><U>end</U> <U>else</U> <U>begin</U><m>
 165                  <r>error "Bad brace nesting in optional argument"
                    <b><U>end</U><r>)
       | 2 -&gt; (
      156 "save.mll"
          </r><U>if</U></b> !brace_nesting &gt; 0 <b><U>then</U> <U>begin</U><m>
 170       <r>put_both_char ']' ; opt2 lexbuf
         <b><U>end</U> <U>else</U> <U>begin</U></b>
           put_echo_char ']' ;
           Out.to_string arg_buff
         <b><U>end</U></b>)
 </r>175   <r>| 3 -&gt; (
      163 "save.mll"
            <b><U>let</U><r> s = lexeme_char lexbuf 0 </r><U>in</U></b>
           put_both_char s ; opt2 lexbuf )
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_opt2_rec lexbuf n
 </r>180 
     </m><U>and</U></b> skip_comment lexbuf = __ocaml_lex_skip_comment_rec lexbuf 2
     <b><U>and</U><r> __ocaml_lex_skip_comment_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
 </r>185  <r>167 "save.mll"
                    ())
       | 1 -&gt; (
      168 "save.mll"
                      ())
 </r>190   <r>| 2 -&gt; (
      169 "save.mll"
                    skip_comment lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_comment_rec lexbuf n
     
 </r>195 </m><U>and</U></b> check_comment lexbuf = __ocaml_lex_check_comment_rec lexbuf 3
     <b><U>and</U><r> __ocaml_lex_check_comment_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
      172 "save.mll"
 </r>200          <r>skip_comment lexbuf)
       | 1 -&gt; (
      173 "save.mll"
              ())
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_check_comment_rec lexbuf n
 </r>205 
     </m><U>and</U></b> arg lexbuf = __ocaml_lex_arg_rec lexbuf 4
     <b><U>and</U><r> __ocaml_lex_arg_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
 </r>210  <r>176 "save.mll"
                          put_echo (lexeme lexbuf) ; arg lexbuf)
       | 1 -&gt; (
      178 "save.mll"
            incr brace_nesting;
 </r>215       <r>put_echo_char '{' ;
           arg2 lexbuf)
       | 2 -&gt; (
      182 "save.mll"
           skip_comment lexbuf  ; arg lexbuf)
 </r>220   <r>| 3 -&gt; (
      184 "save.mll"
           <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
          put_echo lxm ;
          lxm)
 </r>225   <r>| 4 -&gt; (
      188 "save.mll"
           blit_both lexbuf ;
          skip_blanks lexbuf)
       | 5 -&gt; (
 </r>230  <r>191 "save.mll"
           <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
          put_echo lxm ; lxm)
       | 6 -&gt; (
      194 "save.mll"
 </r>235        </m><U>let</U></b> c = lexeme_char lexbuf 0 <b><U>in</U></b>
           put_both_char c ;
           Out.to_string arg_buff)
       | 7 -&gt; (
      197 "save.mll"
 </r>240             <r>raise Eof)
       | 8 -&gt; (
      198 "save.mll"
                 error "Argument expected")
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_arg_rec lexbuf n
 </r>245 
     <b><U>and</U><r> first_char lexbuf = __ocaml_lex_first_char_rec lexbuf 5
     </r><U>and</U><r> __ocaml_lex_first_char_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
 <m>250  <r>203 "save.mll"
            <b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U></b>
           put_echo_char lxm ;
           lxm)
       | 1 -&gt; (
 </r>255  <r>206 "save.mll"
              raise Eof)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_first_char_rec lexbuf n
     
     <b><U>and</U></b> rest lexbuf = __ocaml_lex_rest_rec lexbuf 6
 </r>260 <b><U>and</U></b></m> __ocaml_lex_rest_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
      210 "save.mll"
            <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U><m>
 265       <r>put_echo lxm ;
           lxm)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_rest_rec lexbuf n
     
     <b><U>and</U></b> skip_blanks lexbuf = __ocaml_lex_skip_blanks_rec lexbuf 7
 </r>270 </m><U>and</U></b> __ocaml_lex_skip_blanks_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
      216 "save.mll"
          seen_par := <b><U>false</U><r> ;
 <m>275     </m>put_echo (lexeme lexbuf) ;
         more_skip lexbuf)
       | 1 -&gt; (
      220 "save.mll"
          put_echo (lexeme lexbuf) ; Out.to_string arg_buff)
 <m>280   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_blanks_rec lexbuf n
     
     </r><U>and</U></b> more_skip lexbuf = __ocaml_lex_more_skip_rec lexbuf 8
     <b><U>and</U><r> __ocaml_lex_more_skip_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><m>
 285     <r>0 -&gt; (
      224 "save.mll"
         seen_par := <b><U>true</U></b> ;
        put_echo (lexeme lexbuf) ;
        more_skip lexbuf)
 </r>290   <r>| 1 -&gt; (
      228 "save.mll"
        Out.to_string arg_buff)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_more_skip_rec lexbuf n
     
 </r>295 </m><U>and</U></b> skip_equal lexbuf = __ocaml_lex_skip_equal_rec lexbuf 9
     <b><U>and</U><r> __ocaml_lex_skip_equal_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      231 "save.mll"
 <m>300                         </m>())
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_equal_rec lexbuf n
     
     </r><U>and</U></b> arg2 lexbuf = __ocaml_lex_arg2_rec lexbuf 10
     <b><U>and</U><r> __ocaml_lex_arg2_rec lexbuf state =
 </r><m>305   </m><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      235 "save.mll"
           incr brace_nesting;
          put_both_char '{' ;
 <m>310      </m>arg2 lexbuf)
       | 1 -&gt; (
      239 "save.mll"
           decr brace_nesting;
          </r><U>if</U></b> !brace_nesting &gt; 0 <b><U>then</U> <U>begin</U><m>
 315        <r>put_both_char '}' ; arg2 lexbuf
          <b><U>end</U> <U>else</U> <U>begin</U></b>
            put_echo_char '}' ;
            Out.to_string arg_buff
          <b><U>end</U></b>)
 </r>320   <r>| 2 -&gt; (
      247 "save.mll"
            blit_both lexbuf ; arg2 lexbuf )
       | 3 -&gt; (
      249 "save.mll"
 </r>325      <r>error "End of file in argument")
       | 4 -&gt; (
      252 "save.mll"
            blit_both lexbuf ; arg2 lexbuf )
       | 5 -&gt; (
 </r>330  <r>255 "save.mll"
          <b><U>let</U><r> c = lexeme_char lexbuf 0 </r><U>in</U></b>
         put_both_char c ; arg2 lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_arg2_rec lexbuf n
     
 </r>335 </m><U>and</U></b> csname lexbuf = __ocaml_lex_csname_rec lexbuf 11
     <b><U>and</U><r> __ocaml_lex_csname_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      260 "save.mll"
 <m>340      </m>(</r><U>fun</U></b> get_prim subst -&gt;
           blit_echo lexbuf ; csname lexbuf get_prim subst))
       | 1 -&gt; (
      263 "save.mll"
            (<b><U>fun</U><r> get_prim subst_fun -&gt;
 <m>345         </m>blit_echo lexbuf ;
             </r><U>let</U></b> r = incsname lexbuf <b><U>in</U><r>
             "\\"^get_prim r))
       | 2 -&gt; (
      267 "save.mll"
 </r><m>350        </m><U>fun</U></b> get_prim subst -&gt; </r><U>let</U></b></m> r = arg lexbuf <b><U>in</U><r> subst r)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_csname_rec lexbuf n
     
     </r><U>and</U></b> incsname lexbuf = __ocaml_lex_incsname_rec lexbuf 12
     <b><U>and</U><r> __ocaml_lex_incsname_rec lexbuf state =
 </r><m>355   </m><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      271 "save.mll"
          </r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><r>
         put_echo lxm ; Out.to_string arg_buff)
 <m>360   </m>| 1 -&gt; (
      274 "save.mll"
          put_both_char (lexeme_char lexbuf 0) ;
         incsname lexbuf)
       | 2 -&gt; (
 <m>365  </m>276 "save.mll"
                      error "End of file in command name")
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_incsname_rec lexbuf n
     
     </r><U>and</U></b> cite_arg lexbuf = __ocaml_lex_cite_arg_rec lexbuf 13
 <m>370 <b><U>and</U></b></m> __ocaml_lex_cite_arg_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
      279 "save.mll"
                     cite_args_bis lexbuf)
 <m>375   <r>| 1 -&gt; (
      280 "save.mll"
                   error "No opening ``{'' in citation argument")
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_cite_arg_rec lexbuf n
     
 </r>380 <b><U>and</U></b></m> cite_args_bis lexbuf = __ocaml_lex_cite_args_bis_rec lexbuf 14
     <b><U>and</U><r> __ocaml_lex_cite_args_bis_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      283 "save.mll"
 </r><m>385                              </m><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><r> lxm::cite_args_bis lexbuf)
       | 1 -&gt; (
      284 "save.mll"
                           cite_args_bis lexbuf)
       | 2 -&gt; (
 <m>390  </m>285 "save.mll"
                    cite_args_bis lexbuf)
       | 3 -&gt; (
      286 "save.mll"
                      cite_args_bis lexbuf)
 <m>395   </m>| 4 -&gt; (
      287 "save.mll"
                    [])
       | 5 -&gt; (
      288 "save.mll"
 <m>400                </m>error "Bad syntax for \\cite argument")
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_cite_args_bis_rec lexbuf n
     
     </r><U>and</U></b> num_arg lexbuf = __ocaml_lex_num_arg_rec lexbuf 15
     <b><U>and</U><r> __ocaml_lex_num_arg_rec lexbuf state =
 </r><m>405   </m><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      291 "save.mll"
                      (</r><U>fun</U></b> get_int -&gt; num_arg lexbuf get_int))
       | 1 -&gt; (
 <m>410  <r>293 "save.mll"
          <b><U>fun</U><r> get_int -&gt;
           </r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U></b>
           my_int_of_string lxm)
       | 2 -&gt; (
 </r>415  <r>297 "save.mll"
          <b><U>fun</U><r> get_int -&gt;</r><U>let</U></b> lxm = lexeme  lexbuf <b><U>in</U></b>
         my_int_of_string ("0o"^String.sub lxm 1 (String.length lxm-1)))
       | 3 -&gt; (
      300 "save.mll"
 </r>420      <b><U>fun</U></b></m> get_int -&gt;<b><U>let</U><r> lxm = lexeme  lexbuf </r><U>in</U></b>
         my_int_of_string ("0x"^String.sub lxm 1 (String.length lxm-1)))
       | 4 -&gt; (
      303 "save.mll"
          <b><U>fun</U><r> get_int -&gt;</r><U>let</U></b> c = lexeme_char lexbuf 2 <b><U>in</U><m>
 425     <r>Char.code c)
       | 5 -&gt; (
      306 "save.mll"
          <b><U>fun</U><r> get_int -&gt;
           </r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><m>
 430       <r>get_int (String.sub lxm 1 2))
       | 6 -&gt; (
      310 "save.mll"
          <b><U>fun</U><r> get_int -&gt;</r><U>let</U></b> c = lexeme_char lexbuf 1 <b><U>in</U></b>
         Char.code c)
 </r>435   <r>| 7 -&gt; (
      313 "save.mll"
          <b><U>fun</U><r> get_int -&gt;
           </r><U>let</U></b> s = arg lexbuf <b><U>in</U></b>
           get_int s)
 </r>440   <r>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_num_arg_rec lexbuf n
     
     <b><U>and</U><r> filename lexbuf = __ocaml_lex_filename_rec lexbuf 16
     </r><U>and</U></b> __ocaml_lex_filename_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><m>
 445     <r>0 -&gt; (
      319 "save.mll"
                       put_echo (lexeme lexbuf) ; filename lexbuf)
       | 1 -&gt; (
      320 "save.mll"
 </r>450                   </m><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U></b> put_echo lxm ; lxm)
       | 2 -&gt; (
      321 "save.mll"
                       arg lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_filename_rec lexbuf n
 </r>455 
     </m><U>and</U></b> get_limits lexbuf = __ocaml_lex_get_limits_rec lexbuf 17
     <b><U>and</U><r> __ocaml_lex_get_limits_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
 </r>460  <r>324 "save.mll"
                        get_limits lexbuf)
       | 1 -&gt; (
      325 "save.mll"
                      Some Limits)
 </r>465   <r>| 2 -&gt; (
      326 "save.mll"
                      Some NoLimits)
       | 3 -&gt; (
      327 "save.mll"
 </r>470                  <r>Some IntLimits)
       | 4 -&gt; (
      328 "save.mll"
                      raise Eof)
       | 5 -&gt; (
 </r>475  <r>329 "save.mll"
                      None)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_get_limits_rec lexbuf n
     
     <b><U>and</U></b> get_sup lexbuf = __ocaml_lex_get_sup_rec lexbuf 18
 </r>480 </m><U>and</U></b> __ocaml_lex_get_sup_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
      332 "save.mll"
                    <b><U>try</U><r> Some (arg lexbuf) </r><U>with</U></b> Eof -&gt; error "End of file after ^")
 <m>485   <r>| 1 -&gt; (
      333 "save.mll"
                  raise Eof)
       | 2 -&gt; (
      334 "save.mll"
 </r>490              <r>None)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_get_sup_rec lexbuf n
     
     <b><U>and</U><r> get_sub lexbuf = __ocaml_lex_get_sub_rec lexbuf 19
     </r><U>and</U></b> __ocaml_lex_get_sub_rec lexbuf state =
 </r>495   <b><U>match</U></b></m> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      338 "save.mll"
                    </r><U>try</U></b> Some (arg lexbuf) <b><U>with</U><r> Eof -&gt; error "End of file after _")
       | 1 -&gt; (
 <m>500  </m>339 "save.mll"
                  raise Eof)
       | 2 -&gt; (
      340 "save.mll"
                  None)
 <m>505   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_get_sub_rec lexbuf n
     
     </r><U>and</U></b> defargs lexbuf = __ocaml_lex_defargs_rec lexbuf 20
     <b><U>and</U><r> __ocaml_lex_defargs_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><m>
 510     <r>0 -&gt; (
      344 "save.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U></b>
         put_echo lxm ;
         lxm::defargs lexbuf)
 </r>515   <r>| 1 -&gt; (
      348 "save.mll"
          blit_both lexbuf ;
         <b><U>let</U><r> r = in_defargs lexbuf </r><U>in</U></b>
         r :: defargs lexbuf)
 </r>520   <r>| 2 -&gt; (
      351 "save.mll"
           [])
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_defargs_rec lexbuf n
     
 </r>525 </m><U>and</U></b> in_defargs lexbuf = __ocaml_lex_in_defargs_rec lexbuf 21
     <b><U>and</U><r> __ocaml_lex_in_defargs_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      354 "save.mll"
 <m>530                  </m>blit_both lexbuf ; in_defargs lexbuf)
       | 1 -&gt; (
      355 "save.mll"
                      put_both_char (lexeme_char lexbuf 0) ; in_defargs lexbuf)
       | 2 -&gt; (
 <m>535  </m>356 "save.mll"
                      Out.to_string arg_buff)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_in_defargs_rec lexbuf n
     
     </r><U>and</U></b> get_defargs lexbuf = __ocaml_lex_get_defargs_rec lexbuf 22
 <m>540 <b><U>and</U></b></m> __ocaml_lex_get_defargs_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
      359 "save.mll"
                <b><U>let</U><r> r = lexeme lexbuf </r><U>in</U></b> r)
 <m>545   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_get_defargs_rec lexbuf n
     
     <b><U>and</U><r> tagout lexbuf = __ocaml_lex_tagout_rec lexbuf 23
     </r><U>and</U></b> __ocaml_lex_tagout_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><m>
 550     <r>0 -&gt; (
      362 "save.mll"
               Out.put_char tag_buff ' ' ; tagout lexbuf)
       | 1 -&gt; (
      363 "save.mll"
 </r>555          <r>intag lexbuf)
       | 2 -&gt; (
      364 "save.mll"
                 Out.put tag_buff " " ; tagout lexbuf)
       | 3 -&gt; (
 </r>560  <r>365 "save.mll"
               Out.put tag_buff "&gt;" ; tagout lexbuf)
       | 4 -&gt; (
      366 "save.mll"
               Out.put tag_buff "&lt;" ; tagout lexbuf)
 </r>565   <r>| 5 -&gt; (
      367 "save.mll"
             Out.blit tag_buff lexbuf ; tagout lexbuf)
       | 6 -&gt; (
      368 "save.mll"
 </r>570         <r>Out.to_string tag_buff)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_tagout_rec lexbuf n
     
     <b><U>and</U><r> intag lexbuf = __ocaml_lex_intag_rec lexbuf 24
     </r><U>and</U></b> __ocaml_lex_intag_rec lexbuf state =
 </r>575   </m><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
      371 "save.mll"
             tagout lexbuf)
       | 1 -&gt; (
 <m>580  <r>372 "save.mll"
             instring lexbuf)
       | 2 -&gt; (
      373 "save.mll"
             intag lexbuf)
 </r>585   <r>| 3 -&gt; (
      374 "save.mll"
             Out.to_string tag_buff)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_intag_rec lexbuf n
     
 </r>590 <b><U>and</U></b></m> instring lexbuf = __ocaml_lex_instring_rec lexbuf 25
     <b><U>and</U><r> __ocaml_lex_instring_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      377 "save.mll"
 <m>595         </m>intag lexbuf)
       | 1 -&gt; (
      378 "save.mll"
                 instring lexbuf)
       | 2 -&gt; (
 <m>600  </m>379 "save.mll"
             instring lexbuf)
       | 3 -&gt; (
      380 "save.mll"
             Out.to_string tag_buff)
 <m>605   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_instring_rec lexbuf n
     
     </r><U>and</U></b> checklimits lexbuf = __ocaml_lex_checklimits_rec lexbuf 26
     <b><U>and</U><r> __ocaml_lex_checklimits_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><m>
 610     <r>0 -&gt; (
      384 "save.mll"
                     <b><U>true</U></b>)
       | 1 -&gt; (
      385 "save.mll"
 </r>615                 </m><U>false</U></b>)
       | 2 -&gt; (
      386 "save.mll"
                     <b><U>false</U><r>)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_checklimits_rec lexbuf n
 </r><m>620 
     </m><U>and</U></b> eat_delim_init lexbuf = __ocaml_lex_eat_delim_init_rec lexbuf 27
     <b><U>and</U><r> __ocaml_lex_eat_delim_init_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
 <m>625  </m>389 "save.mll"
            raise Eof)
       | 1 -&gt; (
      391 "save.mll"
          </r><U>fun</U></b> delim next _ -&gt;
 <m>630       <r>put_echo_char '{' ;
           incr brace_nesting ;
           <b><U>let</U><r> r = arg2 lexbuf </r><U>in</U></b>
           check_comment lexbuf ;
           <b><U>if</U><r> if_next_string delim lexbuf </r><U>then</U> <U>begin</U><m>
 635         <r>skip_delim_rec lexbuf delim 0 ;
             r
           <b><U>end</U> <U>else</U> <U>begin</U></b>
             Out.put_char arg_buff '{' ;
             Out.put arg_buff r ;
 </r>640         <r>Out.put_char arg_buff '}' ;
             eat_delim_rec lexbuf delim next 0
           <b><U>end</U></b>)
       | 2 -&gt; (
      405 "save.mll"
 </r>645        <r>eat_delim_rec lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_eat_delim_init_rec lexbuf n
     
     <b><U>and</U><r> eat_delim_rec lexbuf = __ocaml_lex_eat_delim_rec_rec lexbuf 28
     </r><U>and</U></b> __ocaml_lex_eat_delim_rec_rec lexbuf state =
 </r>650   </m><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      409 "save.mll"
        </r><U>fun</U></b> delim next i -&gt;
         put_echo "\\{" ;
 </r>655     <b><U>match</U></b></m> kmp_char delim next i '\\' <b><U>with</U><r>
         | Stop _ -&gt;
             error "Delimitors cannot end with ``\\''"
         | Continue i -&gt; </r><U>match</U></b>  kmp_char delim next i '{' <b><U>with</U><r>
           | Stop s -&gt; s
 <m>660       </m>| Continue i -&gt;  eat_delim_rec lexbuf delim next i)
       | 1 -&gt; (
      419 "save.mll"
        </r><U>fun</U></b> delim next i -&gt;
         put_echo_char '{' ;
 <m>665     <r>Out.put arg_buff (<b><U>if</U><r> i &gt; 0 </r><U>then</U></b> String.sub delim 0 i <b><U>else</U><r> "") ;
         Out.put_char arg_buff '{' ;
         incr brace_nesting ;
         </r><U>let</U></b> r = arg2 lexbuf <b><U>in</U></b>
         Out.put arg_buff r ;
 </r>670     <r>Out.put_char arg_buff '}' ;
         eat_delim_rec lexbuf delim next 0)
       | 2 -&gt; (
      429 "save.mll"
        <b><U>fun</U></b> delim next i -&gt;
 </r>675     <b><U>let</U></b></m> c = lexeme_char lexbuf 0 <b><U>in</U><r>
         put_echo_char c ;
         </r><U>match</U></b> kmp_char delim next i c <b><U>with</U><r>
         | Stop s -&gt; s
         | Continue i -&gt; eat_delim_rec lexbuf delim next i)
 <m>680   </m>| 3 -&gt; (
      436 "save.mll"
          error ("End of file in delimited argument, read:
      "^
                 Out.to_string echo_buff))
 <m>685   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_eat_delim_rec_rec lexbuf n
     
     </r><U>and</U></b> skip_delim_init lexbuf = __ocaml_lex_skip_delim_init_rec lexbuf 29
     <b><U>and</U><r> __ocaml_lex_skip_delim_init_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><m>
 690     <r>0 -&gt; (
      441 "save.mll"
                   skip_delim_init lexbuf)
       | 1 -&gt; (
      442 "save.mll"
 </r>695             <r>skip_delim_rec lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_delim_init_rec lexbuf n
     
     <b><U>and</U><r> skip_delim_rec lexbuf = __ocaml_lex_skip_delim_rec_rec lexbuf 30
     </r><U>and</U></b> __ocaml_lex_skip_delim_rec_rec lexbuf state =
 </r>700   </m><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      446 "save.mll"
        </r><U>fun</U></b> delim i -&gt;
         <b><U>let</U><r> c = lexeme_char lexbuf 0 </r><U>in</U><m>
 705     <r>put_echo_char c ;
         <b><U>if</U><r> c &lt;&gt; delim.[i] </r><U>then</U></b>
           raise (Delim delim) ;
         <b><U>if</U><r> i+1 &lt; String.length delim </r><U>then</U></b>
           skip_delim_rec lexbuf delim (i+1))
 </r>710   <r>| 1 -&gt; (
      454 "save.mll"
          <b><U>fun</U></b> delim i -&gt;
           error ("End of file checking delimiter ``"^delim^"''"))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_delim_rec_rec lexbuf n
 </r>715 
     </m><U>and</U></b> check_equal lexbuf = __ocaml_lex_check_equal_rec lexbuf 31
     <b><U>and</U><r> __ocaml_lex_check_equal_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
 <m>720  </m>457 "save.mll"
            </r><U>true</U></b>)
       | 1 -&gt; (
      458 "save.mll"
            <b><U>false</U><r>)
 </r><m>725   <r>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_check_equal_rec lexbuf n
     
     ;;
     
      460 "save.mll"
 </r>730 
     
     </m><U>let</U></b> init_kmp s =
       <b><U>let</U><r> l = String.length s </r><U>in</U>
       <U>let</U></b> r = Array.create l (-1) <b><U>in</U><m>
 735   </m><U>let</U> <U>rec</U></b> init_rec i j =
     
         <b><U>if</U><r> i+1 &lt; l </r><U>then</U> <U>begin</U>
           <U>if</U></b> j = -1 || s.[i]=s.[j] <b><U>then</U> <U>begin</U></b>
             r.(i+1) &lt;- j+1 ;
 <m>740         <r>init_rec (i+1) (j+1)
           <b><U>end</U> <U>else</U></b>
             init_rec i r.(j)
         <b><U>end</U> <U>in</U></b>
       init_rec 0 (-1) ;
 </r>745   <r>r
     
     <b><U>let</U><r> with_delim delim lexbuf =
       </r><U>let</U></b> next = init_kmp delim  <b><U>in</U></b>
       check_comment lexbuf ;
 </r>750   <b><U>let</U></b></m> r = eat_delim_init lexbuf delim next 0 <b><U>in</U><r>
       r
     
     </r><U>and</U></b> skip_delim delim lexbuf =
       check_comment lexbuf ;
 <m>755   <r>skip_delim_init lexbuf delim 0
     
     <b><U>let</U><r> skip_blanks_init lexbuf =
       </r><U>let</U></b> _ = skip_blanks lexbuf <b><U>in</U></b>
       ()
 </r>760 
     <b><U>let</U></b></m> arg_verbatim lexbuf = <b><U>match</U><r> first_char lexbuf </r><U>with</U></b>
       | '{' -&gt;
            incr brace_nesting ;
            arg2 lexbuf
 <m>765   </m>| c -&gt;
           <b><U>let</U><r> delim = String.make 1 c </r><U>in</U></b>
           with_delim delim lexbuf<PL><B>
<6>111 section.ml</6>
</B></PL></r> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>let</U></b> header = "$Id: section.ml,v 1.3 1999/10/05 17:02:31 maranget Exp $"
     <b><U>let</U><r> value s = </r><U>match</U></b> String.uppercase s <b><U>with</U></b>
       "DOCUMENT"|"" -&gt; 0
  </r>15 <r>| "PART" -&gt; 1
     | "CHAPTER" -&gt; 2
     | "SECTION" -&gt; 3
     | "SUBSECTION" -&gt; 4
     | "SUBSUBSECTION" -&gt; 5
  </r>20 <r>| "PARAGRAPH" -&gt; 6
     | "SUBPARAGRAPH" -&gt; 7
     | _         -&gt; 8
     ;;<PL><B>
<6>112 stack.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: stack.ml,v 1.8 2001/05/28 17:28:56 maranget Exp $             *)
     (***********************************************************************)
     </w><b><U>exception</U><r> Fatal </r><U>of</U></b> string
     
     <b><U>type</U><r> 'a t = {</r><U>mutable</U></b> l : 'a list ; name : string ; bottom : 'a option}
  </r>15 
     
     </m><U>let</U></b> create name = {l = [] ; name=name ; bottom = None}
     <b><U>let</U><r> create_init name x = {l = [] ; name=name ; bottom = Some x}
     
  </r><m>20 </m><U>let</U></b> reset s = s.l &lt;- []
     
     <b><U>let</U><r> bottom msg s = </r><U>match</U></b> s.bottom <b><U>with</U><r>
     | None -&gt; raise (Fatal (msg^": "^s.name))
     | Some x -&gt; x
  </r><m>25 
     </m><U>let</U></b> name {name=name} = name
     
     <b><U>and</U><r> push s x = s.l &lt;- x :: s.l
     
  </r><m>30 </m><U>and</U></b> pop s = <b><U>match</U><r> s.l </r><U>with</U></b>
     | [] -&gt; bottom "pop" s
     | x :: r -&gt;
         s.l &lt;- r ;
         x
  <m>35 
     <b><U>and</U></b></m> top s = <b><U>match</U><r> s.l </r><U>with</U></b>
     | [] -&gt; bottom "top" s
     | x :: _ -&gt; x
     
  <m>40 <b><U>and</U></b></m> length s = List.length s.l
     
     <b><U>and</U><r> empty s = </r><U>match</U></b> s.l <b><U>with</U><r>
     | [] -&gt; </r><U>true</U></b>
     | _  -&gt; <b><U>false</U><m>
  45 
     </m><U>let</U></b> pretty f stack =
       prerr_string stack.name ;
       prerr_string ": &lt;&lt;" ;
       <b><U>let</U> <U>rec</U></b> do_rec = <b><U>function</U><m>
  50     <r>| [] -&gt; prerr_endline "&gt;&gt;"
         | [x] -&gt;
             prerr_string ("``"^f x^"''") ;
             prerr_endline "&gt;&gt;"
         | x :: r -&gt;
  </r>55         <r>prerr_string "``" ;
             prerr_string (f x) ;
             prerr_string "'' " ;
             do_rec r <b><U>in</U></b>
       do_rec stack.l
  </r>60 
     </m><U>let</U></b> rev s = s.l &lt;- List.rev s.l
     <b><U>let</U><r> map s f =  s.l &lt;- List.map f s.l
     
     </r><U>type</U></b> 'a saved = 'a list
  <m>65 
     <b><U>let</U></b></m> empty_saved = []
     <b><U>and</U><r> save {l=l} = l
     </r><U>and</U></b> restore s x = s.l &lt;- x
     
  <m>70 <b><U>let</U></b></m> finalize {l=now ;  name=name} p f =
       <b><U>let</U> <U>rec</U></b> f_rec = <b><U>function</U><r>
         | [] -&gt; ()
         | nx::n -&gt;
           </r><U>if</U></b> p nx  <b><U>then</U><r> ()
  </r><m>75       </m><U>else</U> <U>begin</U></b>
             f nx ;
             f_rec n
           <b><U>end</U>  <U>in</U></b>
       f_rec now<PL><B>
<6>113 subst.ml</6>
</B></PL> 
      12 "subst.mll"
     
     <b><U>open</U><r> Misc
     </r><U>open</U></b> Lexstate
   <m>5 <b><U>open</U></b></m> Lexing
     
     
     <b><U>let</U><r> subst_buff = Out.create_buff ()
     ;;
  <m>10 <b><U>let</U><r> lex_tables = {
       Lexing.lex_base =
        "\000\000\001\000\002\000\030\000\250\255\251\255\253\255\111\000\
    \194\000\019\001\100\001\181\001\006\002\087\002\254\255\255\255\
    ";
       Lexing.lex_backtrk =
        "\006\000\002\000\255\255\002\000\255\255\255\255\255\255\004\000\
    \004\000\004\000\004\000\004\000\004\000\003\000\255\255\255\255\
    ";
  <m>15   </m>Lexing.lex_default =
        "\001\000\001\000\255\255\005\000\000\000\000\000\000\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\000\000\000\000\
    ";
       Lexing.lex_trans =
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\002\000\255\255\014\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\015\000\000\000\000\000\000\000\000\000\
    \000\000\006\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\003\000\255\255\007\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\000\000\000\000\000\000\000\000\000\000\000\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\005\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\009\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\000\000\000\000\005\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \004\000\255\255\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\000\000\255\255\000\000\
    \000\000\000\000\000\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\005\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\010\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\005\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\011\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\005\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\012\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \005\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\000\000\000\000\000\000\000\000\000\000\000\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\013\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\005\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    ";
       Lexing.lex_check =
  <m>20    </m>"\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\000\000\001\000\002\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\002\000\002\000\002\000\002\000\002\000\
    \002\000\002\000\002\000\002\000\255\255\255\255\255\255\255\255\
    \255\255\003\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\000\000\001\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\255\255\255\255\255\255\255\255\255\255\255\255\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
    \003\000\007\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
    \007\000\007\000\255\255\255\255\008\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\001\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\255\255\003\000\255\255\
    \255\255\255\255\255\255\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\009\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\010\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
    \010\000\010\000\010\000\010\000\010\000\010\000\010\000\011\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
    \012\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\255\255\255\255\255\255\255\255\255\255\255\255\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
    \012\000\013\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
    \013\000\013\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    "
     }
     
     </r><U>let</U> <U>rec</U><r> subst lexbuf = __ocaml_lex_subst_rec lexbuf 0
     <b><U>and</U><r> __ocaml_lex_subst_rec lexbuf state =
  <m>25   <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><r>
         0 -&gt; (
      25 "subst.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>if</U></b> is_plain '#' </r><U>then</U> <U>begin</U></b>
  30       <b><U>let</U><r> i = Char.code (lxm.[1]) - Char.code '1' </r><U>in</U><r>
           scan_arg
             (<b><U>fun</U><r> arg -&gt; scan_this_arg subst arg) i
         </r><U>end</U> <U>else</U></b>
           Out.put subst_buff lxm ;
  <m>35     </m>subst lexbuf)
       | 1 -&gt; (
      34 "subst.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
         <U>if</U></b> is_plain '#' </r><U>then</U></b>
  40       </m>Out.put_char subst_buff '#'
         </r><U>else</U></b>
           Out.put subst_buff lxm ;
         subst lexbuf)
       | 2 -&gt; (
  <m>45  </m>41 "subst.mll"
          Out.blit subst_buff lexbuf ; subst lexbuf)
       | 3 -&gt; (
      43 "subst.mll"
          <b><U>let</U></b> lxm = lexeme lexbuf </r><U>in</U></b>
  50     </m>Save.start_echo () ;
         </r><U>let</U></b> _ = Save.arg lexbuf <b><U>in</U>
         <U>let</U></b> real_arg = Save.get_echo () <b><U>in</U></b>
         Out.put subst_buff lxm ;
         Out.put subst_buff real_arg ;
  </r><m>55     <r>subst lexbuf)
       | 4 -&gt; (
      51 "subst.mll"
          Out.blit subst_buff lexbuf ;
         subst lexbuf)
  </r>60   <r>| 5 -&gt; (
      53 "subst.mll"
             ())
       | 6 -&gt; (
      54 "subst.mll"
  </r>65       <r>raise (Error "Empty lexeme in subst"))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_subst_rec lexbuf n
     
     ;;
     
  </r>70  <r>56 "subst.mll"
     
     
     <b><U>let</U><r> do_subst_this ({arg=arg ; subst=env} </r><U>as</U></b> x) =
       <b><U>if</U><r> not (is_top env) </r><U>then</U> <U>begin</U><m>
  75     </m><U>try</U>
           <U>let</U></b> _ = String.index arg '#' <b><U>in</U>
           <U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
             Printf.fprintf stderr "subst_this : [%s]\n" arg ;
             prerr_args ()
  </r>80       </m><U>end</U><r> ;
           </r><U>let</U><r> _ = scan_this_arg subst x </r><U>in</U>
           <U>let</U><r> r = Out.to_string subst_buff <b><U>in</U>
           <U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
             prerr_endline ("subst_this ["^arg^"] = "^r);
  <m>85       </m>r
         </r><U>with</U></b> Not_found -&gt; arg
       <b><U>end</U> <U>else</U></b>
         arg
     ;;
  <m>90 
     <b><U>let</U></b></m> subst_this s = do_subst_this (mkarg s (get_subst ()))
     
     <b><U>let</U><r> subst_arg lexbuf = do_subst_this (save_arg lexbuf)
     </r><U>and</U></b> subst_opt def lexbuf = do_subst_this (save_opt def lexbuf)
  <m>95 
     
     <b><U>let</U></b></m> subst_body = subst_arg<PL><B>
<6>114 symb.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><b><U>let</U><r> header = "$Id: symb.ml,v 1.17 1999/05/21 12:54:17 maranget Exp $"
     </r><U>open</U></b> Parse_opts
     
  <m>15 <b><U>let</U><r> tr = </r><U>function</U><r>
       "&lt;" -&gt; "&lt;"
     | "&gt;" -&gt; "&gt;"
     | "\\{" -&gt; "{"
     | "\\}" -&gt; "}"
  <m>20 </m>| s   -&gt; s
     ;;
     <b><U>let</U><r> put_delim skip put d n =
     
       </r><U>let</U></b>  put_skip s = put s ; skip () ; </r><U>in</U></b>
  25 
       <b><U>let</U> <U>rec</U><r> do_rec s i =
         <b><U>if</U><r> i &gt;= 1 </r><U>then</U> <U>begin</U></b>
           put_skip s;
           do_rec s (i-1)
  <m>30     <b><U>end</U>
     
       <U>and</U><r> do_bis s i =
         <b><U>if</U><r> i&gt;= 2 </r><U>then</U> <U>begin</U></b>
           put_skip s ;
  <m>35       </m>do_bis s (i-1)
         <b><U>end</U> <U>else</U></b>
           put s <b><U>in</U>
     
       <U>if</U></b> not !symbols || n=1 </r><U>then</U></b>
  40     <b><U>let</U><r> d = tr d </r><U>in</U><r>
         do_bis d n
       <b><U>else</U> <U>begin</U></b>
         put "&lt;FONT FACE=symbol&gt;\n" ;
         <b><U>if</U></b> d = "(" </r><U>then</U> <U>begin</U></b>
  45       </m>put_skip "" ;
           do_rec "c" (n-2) ;
           put "e"
         <b><U>end</U> <U>else</U> <U>if</U></b> d=")" <b><U>then</U> <U>begin</U></b>
           put_skip "" ;
  <m>50       </m>do_rec "" (n-2) ;
           put ""
         <b><U>end</U> <U>else</U> <U>if</U></b> d = "[" <b><U>then</U> <U>begin</U></b>
           put_skip "e" ;
           do_rec "e" (n-2) ;
  <m>55       </m>put "e"
         <b><U>end</U> <U>else</U> <U>if</U></b> d="]" <b><U>then</U> <U>begin</U></b>
           put_skip "" ;
           do_rec "" (n-2) ;
           put "u"
  <m>60    <b><U>end</U> <U>else</U> <U>if</U><r> d = "\\lfloor" <b><U>then</U> <U>begin</U></b>
           do_rec "e" (n-1) ;
           put "e"
         <b><U>end</U> <U>else</U> <U>if</U></b> d="\\rfloor" <b><U>then</U> <U>begin</U></b>
           do_rec "" (n-1) ;
  <m>65       </m>put "u"
         <b><U>end</U> <U>else</U> <U>if</U></b> d = "\\lceil" <b><U>then</U> <U>begin</U></b>
           put_skip "e" ;
           do_bis "e" (n-1)
         <b><U>end</U> <U>else</U> <U>if</U></b> d="\\rceil" </r><U>then</U> <U>begin</U></b>
  70       </m>put_skip "" ;
           do_bis "" (n-1)
         <b><U>end</U> <U>else</U> <U>if</U></b> d="|" <b><U>then</U> <U>begin</U></b>
           do_bis "" n
         <b><U>end</U> <U>else</U> <U>if</U></b> d="\\|" </r><U>then</U> <U>begin</U></b>
  75       </m>do_bis "" n
         <b><U>end</U> <U>else</U> <U>if</U></b> d = "\\{" <b><U>then</U> <U>begin</U></b>
           put_skip "" ;
           do_rec "i" ((n-3)/2) ;
           put_skip "" ;
  <m>80       </m>do_rec "i" ((n-3)/2) ;
           put "i"
         <b><U>end</U> <U>else</U> <U>if</U></b> d = "\\}" </r><U>then</U> <U>begin</U></b><r>
           put_skip "u" ;
           do_rec "i" ((n-3)/2) ;
  </r>85       <r>put_skip "" ;
           do_rec "i" ((n-3)/2) ;
           put ""
         <b><U>end</U></b> ;
         put "&lt;/FONT&gt;"
  </r>90   <b><U>end</U><r>
     ;;<PL><B>
<6>115 table.ml</6>
</B></PL></r><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1999 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>exception</U><r> Empty
     
     <b><U>type</U><r> 'a t = {</r><U>mutable</U></b> next : int ; <b><U>mutable</U></b> data : 'a array}
  </r></b>15 
     <b><U>let</U><r> default_size = 32
     ;;
     
     </r><U>let</U><r> create x = {next = 0 ; data = Array.create default_size x}
  </r></b>20 <b><U>and</U><r> reset t = t.next &lt;- 0
     ;;
     
     </r><U>let</U><r> incr_table table new_size =
       <b><U>let</U><r> t = Array.create new_size table.data.(0) </r><U>in</U><m>
  25   <r>Array.blit table.data 0 t 0 (Array.length table.data) ;
       table.data &lt;- t
     
     <b><U>let</U><r> emit table i =
      </r><U>let</U></b> size = Array.length table.data <b><U>in</U><m>
  30  </m><U>if</U></b> table.next &gt;= size <b><U>then</U></b>
         incr_table table (2*size);
      table.data.(table.next) &lt;- i ;
      table.next &lt;- table.next + 1
     
  </r>35 
     </m><U>let</U></b> apply table f =
       <b><U>if</U><r> table.next = 0 </r><U>then</U></b>
         raise Empty ;
       f table.data.(table.next - 1)
  </r></b>40 
     <b><U>let</U><r> trim t =
       </r><U>let</U><r> r = Array.sub t.data 0 t.next <b><U>in</U></b>
       reset t ;
       r
  </r></b>45 
     <b><U>let</U><r> remove_last table =
       table.next &lt;- table.next -1;
       </r><U>if</U><r> table.next &lt; 0 <b><U>then</U></b> table.next &lt;- 0 ;
     ;;
  </r></b>50 
     <r><b><U>let</U><r> get_size table = table.next
     ;;<PL><B>
<6>116 tabular.ml</6>
</B></PL> 
      13 "tabular.mll"
     
     </r><U>open</U></b> Misc
     <b><U>open</U></b> Lexing
   </r>5 <b><U>open</U><r> Table
     </r><U>open</U><r> Lexstate
     <b><U>open</U><r> Subst
     
     </r><U>exception</U></b> Error <b><U>of</U></b> string
  </r></b>10 <r>;;
     
     <b><U>type</U><r> align =
         {hor : string ; </r><U>mutable</U></b> vert : string ; wrap : bool ;
           <b><U>mutable</U><r> pre : string ; </r><U>mutable</U></b> post : string ; width : Length.t}
  </r>15 
     <b><U>let</U><r> make_hor = </r><U>function</U><r>
         'c' -&gt; "center"
       | 'l' -&gt; "left"
       | 'r' -&gt; "right"
  </r></b>20   <r>| 'p'|'m'|'b' -&gt; "left"
       | _ -&gt; raise (Misc.Fatal "make_hor")
     
     <b><U>and</U><r> make_vert = </r><U>function</U></b>
       | 'c'|'l'|'r' -&gt; ""
  </r>25   <r>| 'p' -&gt; "top"
       | 'm' -&gt; "middle"
       | 'b' -&gt; "bottom"
       | _ -&gt; raise (Misc.Fatal "make_vert")
     
  </r>30 <b><U>type</U><r> format =
       Align </r><U>of</U><r> align
     | Inside <b><U>of</U><r> string
     | Border </r><U>of</U></b> string
     ;;
  </r></b>35 
     <w>(* Patch vertical alignment (for HTML) *)
     <b><U>let</U><r> check_vert f =
       </r><U>try</U>
         <U>for</U><r> i = 0 <b><U>to</U><r> Array.length f-1 </r><U>do</U><m>
  40       </m><U>match</U></b> f.(i) <b><U>with</U><r>
           | Align {vert=s} </r><U>when</U></b> s &lt;&gt; "" -&gt; raise Exit
           | _ -&gt; ()
         <b><U>done</U><r> ;
         f
  </r><m>45   </m><U>with</U></b> Exit -&gt; <b><U>begin</U>
         <U>for</U></b> i = 0 <b><U>to</U><r> Array.length f-1 </r><U>do</U>
           <U>match</U></b> f.(i) <b><U>with</U><r>
           | Align ({vert=""} </r><U>as</U></b> f) -&gt;
               f.vert &lt;- "top"
  <m>50       <r>| _ -&gt; ()
         <b><U>done</U><r> ;
         f
       </r><U>end</U><m>
     
  55 <w>(* Compute missing length (for text) *)
     <b><U>and</U><r> check_length f =
       </r><U>for</U><r> i = 0 <b><U>to</U><r> Array.length f - 1 </r><U>do</U>
         <U>match</U></b> f.(i) <b><U>with</U><r>
         | Align ({wrap=</r><U>true</U></b> ; width=Length.No _} <b><U>as</U><r> r) -&gt;
  <m>60         </m>f.(i) &lt;-
                Align
                  {r </r><U>with</U></b>
                   width =
                   Length.Percent
  <m>65                 <r>(truncate (100.0 /. float (Array.length f)))}
         | _ -&gt; ()
       <b><U>done</U>
     
     <U>let</U></b> border = ref <b><U>false</U><m>
  70 
     
     
     </m><U>let</U></b> push s e = s := e:: !s
     <b><U>and</U><r> pop s = </r><U>match</U></b> !s <b><U>with</U><m>
  75   <r>[] -&gt; raise (Misc.Fatal "Empty stack in Latexscan")
     | e::rs -&gt; s := rs ; e
     
     <b><U>let</U></b> out_table = Table.create (Inside "")
     
  </r>80 </m><U>let</U></b> pretty_format = <b><U>function</U></b>
       |   Align {vert = v ; hor = h ; pre = pre ; post = post ; wrap = b ; width = w}
           -&gt;
             "[&gt;{"^pre^"}"^
             ", h="^h^", v="^v^
  </r>85         <r>", &lt;{"^post^"}"^(<b><U>if</U><r> b </r><U>then</U></b> ", wrap" <b><U>else</U></b> "")^
             ", w="^Length.pretty w^"]"
       | Inside s -&gt; "@{"^s^"}"
       | Border s -&gt; s
     
  </r>90 <b><U>let</U></b></m> pretty_formats f =
       Array.iter (<b><U>fun</U><r> f -&gt; prerr_string (pretty_format f) ; prerr_string "; ") f
     
     
     </r><U>let</U></b> lex_tables = {
  <m>95   <r>Lexing.lex_base =
        "\000\000\001\000\000\000\002\000\253\255\000\000\255\255\254\255\
    \251\255\252\255\255\255\018\000\253\255\254\255\250\255";
       Lexing.lex_backtrk =
        "\001\000\006\000\001\000\005\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255";
       Lexing.lex_default =
 </r>100    <r>"\255\255\008\000\255\255\255\255\000\000\255\255\000\000\000\000\
    \000\000\000\000\000\000\255\255\000\000\000\000\000\000";
       Lexing.lex_trans =
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\010\000\010\000\000\000\000\000\010\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\010\000\255\255\004\000\011\000\005\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\006\000\000\000\000\000\000\000\
    \000\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\000\000\000\000\006\000\255\255\006\000\255\255\
    \000\000\255\255\004\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\012\000\013\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\013\000\012\000\000\000\
    \000\000\012\000\000\000\013\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\255\255\007\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\014\000\008\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000";
       Lexing.lex_check =
        "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\001\000\001\000\255\255\255\255\001\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\001\000\001\000\003\000\001\000\003\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\003\000\255\255\255\255\255\255\
    \255\255\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
    \005\000\005\000\255\255\255\255\002\000\001\000\000\000\001\000\
    \255\255\001\000\003\000\011\000\011\000\011\000\011\000\011\000\
    \011\000\011\000\011\000\011\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\001\000\001\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\001\000\001\000\255\255\
    \255\255\001\000\255\255\001\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\001\000\003\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\001\000\003\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255"
 </r>105 <r>}
     
     <b><U>let</U> <U>rec</U></b> tfone lexbuf = __ocaml_lex_tfone_rec lexbuf 0
     <b><U>and</U><r> __ocaml_lex_tfone_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><m>
 110     <r>0 -&gt; (
      109 "tabular.mll"
          <b><U>let</U><r> pre = subst_arg lexbuf </r><U>in</U></b>
         tfmiddle lexbuf ;
         <b><U>try</U><m>
 115       <r>apply out_table (<b><U>function</U><r>
             |  Align a </r><U>as</U></b> r -&gt; a.pre &lt;- pre
             | _ -&gt; raise (Error "Bad syntax in array argument (&gt;)"))
         <b><U>with</U></b> Table.Empty -&gt;
           raise (Error "Bad syntax in array argument (&gt;)"))
 </r>120   <r>| 1 -&gt; (
      117 "tabular.mll"
           tfmiddle lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_tfone_rec lexbuf n
     
 </r>125 </m><U>and</U></b> tfmiddle lexbuf = __ocaml_lex_tfmiddle_rec lexbuf 1
     <b><U>and</U><r> __ocaml_lex_tfmiddle_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
      120 "tabular.mll"
 </r>130                      <r>tfmiddle lexbuf)
       | 1 -&gt; (
      122 "tabular.mll"
        <b><U>let</U><r> f = Lexing.lexeme_char lexbuf 0 </r><U>in</U>
       <U>let</U></b> post = tfpostlude lexbuf <b><U>in</U><m>
 135   <r>emit out_table
         (Align {hor = make_hor f ; vert = make_vert f ; wrap = <b><U>false</U></b> ;
             pre = "" ;   post = post ; width = Length.Default}))
       | 2 -&gt; (
      128 "tabular.mll"
 </r>140    </m><U>let</U></b> f = Lexing.lexeme_char lexbuf 0 <b><U>in</U>
       <U>let</U></b> width = subst_arg lexbuf <b><U>in</U>
       <U>let</U></b> my_width = Length.main (Lexing.from_string width) <b><U>in</U>
       <U>let</U></b> post = tfpostlude lexbuf <b><U>in</U></b>
       emit out_table
 </r>145     <r>(Align {hor = make_hor f ; vert = make_vert f ; wrap = <b><U>true</U><r> ;
               pre = "" ;   post = post ; width = my_width}))
       | 3 -&gt; (
      136 "tabular.mll"
          </r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><m>
 150     </m><U>let</U></b> i = Char.code (lxm.[1]) - Char.code '1' <b><U>in</U><r>
         Lexstate.scan_arg (scan_this_arg tfmiddle) i)
       | 4 -&gt; (
      140 "tabular.mll"
          </r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U><m>
 155     </m><U>let</U></b> name = column_to_command lxm <b><U>in</U>
         <U>let</U></b> pat,body = Latexmacros.find name <b><U>in</U>
         <U>let</U></b> args = Lexstate.make_stack name pat lexbuf <b><U>in</U><r>
         Lexstate.scan_body
           (</r><U>function</U><m>
 160         <r>| Lexstate.Subst body -&gt; scan_this lexformat body ;
             | _ -&gt; <b><U>assert</U> <U>false</U></b>)
           body args ;
         <b><U>let</U><r> post = tfpostlude lexbuf </r><U>in</U>
         <U>if</U></b> post &lt;&gt; "" <b><U>then</U><m>
 165       </m><U>try</U></b>
             Table.apply out_table
               (<b><U>function</U></b>
                 | Align f -&gt; f.post &lt;- post
                 | _ -&gt; Misc.warning ("``&lt;'' after ``@'' in tabular arg scanning"))
 </r>170       </m><U>with</U></b>
           | Table.Empty -&gt;
               raise (Error ("``&lt;'' cannot start tabular arg")))
       | 5 -&gt; (
      159 "tabular.mll"
 </r>175        <r>())
       | 6 -&gt; (
      161 "tabular.mll"
        <b><U>let</U></b> rest =
         String.sub lexbuf.lex_buffer lexbuf.lex_curr_pos
 </r>180       <r>(lexbuf.lex_buffer_len - lexbuf.lex_curr_pos) <b><U>in</U><r>
       raise (Error ("Syntax of array format near: "^rest)))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_tfmiddle_rec lexbuf n
     
     </r><U>and</U></b> tfpostlude lexbuf = __ocaml_lex_tfpostlude_rec lexbuf 2
 </r>185 </m><U>and</U></b> __ocaml_lex_tfpostlude_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
      167 "tabular.mll"
            subst_arg lexbuf)
 </r>190   <r>| 1 -&gt; (
      168 "tabular.mll"
            "")
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_tfpostlude_rec lexbuf n
     
 </r>195 <b><U>and</U></b></m> lexformat lexbuf = __ocaml_lex_lexformat_rec lexbuf 3
     <b><U>and</U><r> __ocaml_lex_lexformat_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      173 "tabular.mll"
 </r><m>200     </m><U>let</U></b> ntimes = save_arg lexbuf <b><U>in</U>
        <U>let</U></b> what = save_arg lexbuf <b><U>in</U>
        <U>let</U> <U>rec</U></b> do_rec = <b><U>function</U><r>
          0 -&gt; lexformat lexbuf
        | i -&gt;
 <m>205       </m>scan_this_arg lexformat what ; do_rec (i-1) </r><U>in</U></b>
        do_rec (Get.get_int ntimes))
       | 1 -&gt; (
      180 "tabular.mll"
            border := <b><U>true</U><r> ; emit out_table (Border "|") ; lexformat lexbuf)
 <m>210   </m>| 2 -&gt; (
      182 "tabular.mll"
          </r><U>let</U></b> lxm = Lexing.lexeme_char lexbuf 0 <b><U>in</U>
         <U>let</U></b> inside = subst_arg lexbuf <b><U>in</U>
         <U>if</U></b> lxm = '!' || inside &lt;&gt; "" <b><U>then</U><r> emit out_table (Inside inside) ;
 <m>215     </m>lexformat lexbuf)
       | 3 -&gt; (
      187 "tabular.mll"
          </r><U>let</U></b> lxm = lexeme lexbuf <b><U>in</U>
         <U>let</U></b> i = Char.code (lxm.[1]) - Char.code '1' <b><U>in</U><m>
 220     <r>Lexstate.scan_arg (scan_this_arg lexformat) i ;
         lexformat lexbuf)
       | 4 -&gt; (
      191 "tabular.mll"
            ())
 </r>225   <r>| 5 -&gt; (
      192 "tabular.mll"
           tfone lexbuf ; lexformat lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_lexformat_rec lexbuf n
     
 </r>230 <r>;;
     
      196 "tabular.mll"
     
     <b><U>open</U></b> Parse_opts
 </r>235 
     </m><U>let</U></b> main {arg=s ; subst=env} =
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b> prerr_endline ("Table format: "^s);
       start_normal env ;
       lexformat (Lexing.from_string s) ;
 <m>240   <r>end_normal () ;
       <b><U>let</U><r> r = check_vert (trim out_table) </r><U>in</U>
       <U>begin</U> <U>match</U></b> !destination <b><U>with</U></b>
       | (Text | Info) -&gt; check_length r
       | Html -&gt; ()
 </r>245   <b><U>end</U></b></m> ;
       <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U> <U>begin</U></b>
         prerr_string "Format parsed: " ;
         pretty_formats r ;
         prerr_endline ""
 <m>250   <b><U>end</U></b></m> ;
       r<PL><B>
<6>117 text.ml</6>
</B></PL></r></b> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   </w>5 <w>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  </w>10 <w>(***********************************************************************)
     
     <b><U>let</U><r> header = "$Id: text.ml,v 1.53 2001/01/15 10:55:30 maranget Exp $"
     
     
  </r><m>15 </m><U>open</U><r> Misc
     <b><U>open</U><r> Parse_opts
     </r><U>open</U></b> Element
     <b><U>open</U><r> Lexstate
     </r><U>open</U></b> Latexmacros
  <m>20 <b><U>open</U></b></m> Stack
     <b><U>open</U><r> Length
     
     </r><U>exception</U></b> Error <b><U>of</U><r> string;;
     </r><U>type</U></b> block = string
  <m>25 
     
     <b><U>let</U></b></m> r_quote = String.create 1
     ;;
     
  <m>30 <b><U>let</U></b></m> quote c =
       (r_quote.[0] &lt;- c ; r_quote)
     ;;
     
     <b><U>let</U><r> r_translate = String.create 1
  <m>35 </m>;;
     
     </r><U>let</U></b> iso_translate = <b><U>function</U><r>
     | '' -&gt; "!"
     | '' -&gt; "cent"
  </r><m>40 <r>| '' -&gt; "pound"
     | '' -&gt; "curren"
     | '' -&gt; "yen"
     | '' -&gt; "I"
     | '' -&gt; "paragraphe"
  </r>45 <r>| '' -&gt; "trema"
     | '' -&gt; "copyright"
     | '' -&gt; "a"
     | '' -&gt; "&lt;&lt;"
     | '' -&gt; "not"
  </r>50 <r>| '' -&gt; "-"
     | '' -&gt; "registered"
     | '' -&gt; "-"
     | '' -&gt; "degre"
     | '' -&gt; "plus ou moins"
  </r>55 <r>| '' -&gt; "carre"
     | '' -&gt; "cube"
     | '' -&gt; "'"
     | '' -&gt; "mu"
     | '' -&gt; ""
  </r>60 <r>| '' -&gt; "."
     | '' -&gt; ""
     | '' -&gt; "1"
     | '' -&gt; "eme"
     | '' -&gt; "&gt;&gt;"
  </r>65 <r>| '' -&gt; "1/4"
     | '' -&gt; "1/2"
     | '' -&gt; "3/4"
     | '' -&gt; "?"
     | 'A' -&gt; "A"
  </r>70 <r>| '' -&gt; "A"
     | 'A' -&gt; "A"
     | '' -&gt; "A"
     | '' -&gt; "A"
     | '' -&gt; "A"
  </r>75 <r>| '' -&gt; "AE"
     | 'C' -&gt; "C"
     | 'E' -&gt; "E"
     | 'E' | 'E' | 'E' -&gt; "E"
     | '' | '' | 'I' | 'I' -&gt; "I"
  </r>80 <r>| '' -&gt; "D"
     | '' -&gt; "N"
     | '' | '' | 'O' | '' | '' -&gt; "O"
     | '' -&gt; "x"
     | '' -&gt; "0"
  </r>85 <r>| '' | '' | 'U' | 'U' -&gt; "U"
     | '' -&gt; "Y"
     | '' -&gt; "P"
     | '' -&gt; "ss"
     | 'a' | '' | 'a' | '' | '' | '' -&gt; "a"
  </r>90 <r>| '' -&gt; "ae"
     | 'c' -&gt; "c"
     | 'e' | 'e' | 'e' | 'e' -&gt; "e"
     | '' | '' | 'i' | 'i' -&gt; "i"
     | '' -&gt; "o"
  </r>95 <r>| '' -&gt; "n"
     | '' | '' | 'o' | '' | '' -&gt; "o"
     | '' -&gt; "/"
     | '' -&gt; "o"
     | '' | '' | 'u' | 'u' -&gt; "u"
 </r>100 <r>| '' -&gt; "y"
     | '' -&gt; "y"
     | '' -&gt; "y"
     | c   -&gt; (r_translate.[0] &lt;- c ; r_translate)
     ;;
 </r>105 
     </m><U>let</U></b> iso c =
       <b><U>if</U><r> !Parse_opts.iso || !Lexstate.raw_chars </r><U>then</U></b>
         (r_translate.[0]&lt;-c; r_translate)
       <b><U>else</U><m>
 110     <r>iso_translate c
     ;;
     
     <b><U>let</U></b> iso_buff = Out.create_buff ()
     
 </r>115 </m><U>let</U></b> iso_string s =
       <b><U>if</U><r> !Parse_opts.iso </r><U>then</U> <U>begin</U>
         <U>for</U></b> i = 0 <b><U>to</U><r> String.length s - 1 </r><U>do</U></b>
           Out.put iso_buff (iso_translate s.[i])
         <b><U>done</U><r> ;
 <m>120     </m>Out.to_string iso_buff
       </r><U>end</U> <U>else</U></b>
         s
     
     
 <m>125 <b><U>let</U></b></m> failclose s = raise (Misc.Close s)
     ;;
     
     
     </r></b>(* output globals *)
 </w>130 </m><U>type</U></b> status = {
         <b><U>mutable</U><r> nostyle : bool ;
         </r><U>mutable</U></b> active : text list ;
         <b><U>mutable</U><r> out : Out.t;
         </r><U>mutable</U></b> temp : bool
 </r>135   <r>};;
     
     
     <b><U>type</U><r> stack_item =
       Normal </r><U>of</U></b> string * string * status
 </r>140 <r>| Freeze <b><U>of</U><r> (unit -&gt; unit)
     ;;
     
     </r><U>exception</U></b> PopFreeze
     ;;
 </r>145 
     <b><U>let</U></b></m> push_out s (a,b,c) = push s (Normal (a,b,c))
     ;;
     
     <b><U>let</U><r> pretty_stack s =
 <m>150   </m>Stack.pretty
        (</r><U>function</U></b>
          | Normal (s,args,_) -&gt; "["^s^"]-{"^args^"} "
          | Freeze _   -&gt; "Freeze ") s
     ;;
 <m>155 
     <b><U>let</U> <U>rec</U></b></m> pop_out s = <b><U>match</U><r> pop s </r><U>with</U></b>
       Normal (a,b,c) -&gt; a,b,c
     | Freeze f       -&gt; raise PopFreeze
     ;;
 <m>160 
     <b><U>let</U></b></m> free_list = ref [];;
     
     <b><U>let</U><r> out_stack = Stack.create "out_stack";;
     
 </r><m>165 </m><U>let</U></b> pblock () =
       <b><U>if</U><r> empty out_stack </r><U>then</U></b> "" <b><U>else</U>
       <U>match</U></b> top out_stack <b><U>with</U><r>
       | Normal (s,_,_) -&gt; s
       | _ -&gt; ""
 </r><m>170 </m><U>and</U></b> parg () =
       <b><U>if</U><r> empty out_stack </r><U>then</U></b> "" <b><U>else</U>
       <U>match</U></b> top out_stack <b><U>with</U><r>
       | Normal (_,a,_) -&gt; a
       | _ -&gt; ""
 <m>175 </m>;;
     
     </r><U>let</U></b> free out =
       out.nostyle&lt;-<b><U>false</U><r>;
       out.active&lt;-[];
 </r><m>180   <r>Out.reset out.out;
       free_list := out :: !free_list
     ;;
     
     
 </r>185 
     
     </m><U>let</U></b> cur_out = ref { nostyle = <b><U>false</U><r>;
                         active=[];
                         out=Out.create_null();
 <m>190       </m>temp=</r><U>false</U></b>
     };;
     
     <b><U>let</U><r> set_out out =
       !cur_out.out &lt;- out
 <m>195 </m>;;
     
     </r><U>let</U></b> newstatus nostyle p a t = <b><U>match</U><r> !free_list </r><U>with</U></b>
       [] -&gt;
         { nostyle = nostyle;
 <m>200       <r>active = a;
           out = Out.create_buff ();
           temp = t;
         }
     | e::reste -&gt;
 </r>205     <r>free_list:=reste;
         e.nostyle &lt;- nostyle;
         e.active &lt;- a;
         e.temp &lt;- t;
         <b><U>assert</U></b> (Out.is_empty e.out);
 </r>210     <r>e
     ;;
     
     <b><U>type</U></b> saved_out = status * stack_item Stack.saved
     
 </r>215 <b><U>let</U></b></m> save_out () = !cur_out, Stack.save out_stack
     
     <b><U>and</U><r> restore_out (a,b) =
       </r><U>if</U></b> !cur_out != a <b><U>then</U> <U>begin</U></b>
         free !cur_out ;
 <m>220     <r>Stack.finalize out_stack
           (<b><U>function</U><r>
             | Normal (_,_,out) -&gt; out == a
             | _ -&gt; </r><U>false</U></b>)
           (<b><U>function</U><m>
 225         <r>| Normal (_,_,out) -&gt; <b><U>if</U><r> out.temp </r><U>then</U></b> free out
             | _ -&gt; ())
       <b><U>end</U></b> ;
       cur_out := a ;
       Stack.restore out_stack b
 </r>230 
     
     </m><U>type</U></b> align_t = Left | Center | Right
     
     <b><U>type</U></b> flags_t = {
 </r>235     <b><U>mutable</U></b></m> pending_par : int option;
         <b><U>mutable</U></b> empty : bool;
         </r></b>(* Listes *)
         <b><U>mutable</U><r> nitems : int;
         </r><U>mutable</U><r> dt : string;
 <m>240     <b><U>mutable</U></b></m> dcount : string;
     
         <b><U>mutable</U></b> last_closed : string;
         </r></b>(* Alignement et formattage *)
         <b><U>mutable</U><r> align : align_t;
 </r><m>245     </m><U>mutable</U><r> in_align : bool;
         <b><U>mutable</U><r> hsize : int;
         </r><U>mutable</U></b> x : int;
         <b><U>mutable</U><r> x_start : int;
         </r><U>mutable</U></b> x_end : int;
 <m>250     <b><U>mutable</U></b></m> last_space : int;
         <b><U>mutable</U><r> first_line : int;
         </r><U>mutable</U></b> underline : string;
         <b><U>mutable</U><r> nocount : bool ;
         </r><U>mutable</U></b> in_table : bool;
 <m>255 
         <w>(* Maths *)
         <b><U>mutable</U><r> vsize : int;
       }
     ;;
 </r><m>260 
     </m><U>let</U><r> flags = {
       pending_par = None;
       empty = <b><U>true</U><r>;
       nitems = 0;
 <m>265   </m>dt = "";
       dcount = "";
       last_closed = "rien";
       align = Left;
       in_align = </r><U>false</U></b>;
 <m>270   <r>hsize = !Parse_opts.width;
       x = 0;
       x_start = 0;
       x_end = !Parse_opts.width - 1;
       last_space = 0;
 </r>275   <r>first_line = 2;
       underline = "";
       nocount = <b><U>false</U><r> ;
       in_table = </r><U>false</U></b>;
       vsize = 0;
 </r>280 <r>} ;;
     
     <b><U>let</U><r> copy_flags f = {f </r><U>with</U></b> vsize = flags.vsize}
     
     <b><U>and</U></b> set_flags f {
 </r>285   <r>pending_par = pending_par ;
       empty = empty ;
       nitems = nitems ;
       dt = dt ;
       dcount = dcount ;
 </r>290   <r>last_closed = last_closed ;
       align = align ;
       in_align = in_align ;
       hsize = hsize ;
       x = x ;
 </r>295   <r>x_start = x_start ;
       x_end = x_end ;
       last_space = last_space ;
       first_line = first_line ;
       underline = underline ;
 </r>300   <r>nocount = nocount ;
       in_table = in_table ;
       vsize = vsize
     }  =
       f.pending_par &lt;- pending_par ;
 </r>305   <r>f.empty &lt;- empty ;
       f.nitems &lt;- nitems ;
       f.dt &lt;- dt ;
       f.dcount &lt;- dcount ;
       f.last_closed &lt;- last_closed ;
 </r>310   <r>f.align &lt;- align ;
       f.in_align &lt;- in_align ;
       f.hsize &lt;- hsize ;
       f.x &lt;- x ;
       f.x_start &lt;- x_start ;
 </r>315   <r>f.x_end &lt;- x_end ;
       f.last_space &lt;- last_space ;
       f.first_line &lt;- first_line ;
       f.underline &lt;- underline ;
       f.nocount &lt;- nocount ;
 </r>320   <r>f.in_table &lt;- in_table ;
       f.vsize &lt;- vsize
     
     
     <b><U>type</U></b> stack_t = {
 </r>325   <r>s_nitems : int Stack.t ;
       s_dt : string Stack.t ;
       s_dcount : string Stack.t ;
       s_x : (int * int * int * int * int * int) Stack.t ;
       s_align : align_t Stack.t ;
 </r>330   <r>s_in_align : bool Stack.t ;
       s_underline : string Stack.t ;
       s_nocount : bool Stack.t ;
       s_in_table : bool Stack.t ;
       s_vsize : int Stack.t ;
 </r>335   <r>s_active : Out.t Stack.t ;
       s_pending_par : int option Stack.t ;
       s_after : (string -&gt; string) Stack.t
     }
     
 </r>340 <b><U>let</U></b></m> stacks = {
       s_nitems = Stack.create "nitems" ;
       s_dt = Stack.create "dt" ;
       s_dcount = Stack.create "dcount" ;
       s_x = Stack.create "x" ;
 <m>345   <r>s_align = Stack.create "align" ;
       s_in_align = Stack.create "in_align" ;
       s_underline = Stack.create "underline" ;
       s_nocount = Stack.create "nocount" ;
       s_in_table = Stack.create "in_table" ;
 </r>350   <r>s_vsize = Stack.create "vsize" ;
       s_active = Stack.create "active" ;
       s_pending_par = Stack.create "pending_par" ;
       s_after = Stack.create "after"
     }
 </r>355 
     <b><U>type</U></b></m> saved_stacks = {
       ss_nitems : int Stack.saved ;
       ss_dt : string Stack.saved ;
       ss_dcount : string Stack.saved ;
 <m>360   </m>ss_x : (int * int * int * int * int * int) Stack.saved ;
       ss_align : align_t Stack.saved ;
       ss_in_align : bool Stack.saved ;
       ss_underline : string Stack.saved ;
       ss_nocount : bool Stack.saved ;
 <m>365   </m>ss_in_table : bool Stack.saved ;
       ss_vsize : int Stack.saved ;
       ss_active : Out.t Stack.saved ;
       ss_pending_par : int option Stack.saved ;
       ss_after : (string -&gt; string) Stack.saved
 <m>370 </m>}
     
     <b><U>let</U></b> save_stacks () =
     {
       ss_nitems = Stack.save stacks.s_nitems ;
 </r><m>375   <r>ss_dt = Stack.save stacks.s_dt ;
       ss_dcount = Stack.save stacks.s_dcount ;
       ss_x = Stack.save stacks.s_x ;
       ss_align = Stack.save stacks.s_align ;
       ss_in_align = Stack.save stacks.s_in_align ;
 </r>380   <r>ss_underline = Stack.save stacks.s_underline ;
       ss_nocount = Stack.save stacks.s_nocount ;
       ss_in_table = Stack.save stacks.s_in_table ;
       ss_vsize = Stack.save stacks.s_vsize ;
       ss_active = Stack.save stacks.s_active ;
 </r>385   <r>ss_pending_par = Stack.save stacks.s_pending_par ;
       ss_after = Stack.save stacks.s_after
     }
     
     <b><U>and</U></b> restore_stacks
 </r>390 <r>{
       ss_nitems = saved_nitems ;
       ss_dt = saved_dt ;
       ss_dcount = saved_dcount ;
       ss_x = saved_x ;
 </r>395   <r>ss_align = saved_align ;
       ss_in_align = saved_in_align ;
       ss_underline = saved_underline ;
       ss_nocount = saved_nocount ;
       ss_in_table = saved_in_table ;
 </r>400   <r>ss_vsize = saved_vsize ;
       ss_active = saved_active ;
       ss_pending_par = saved_pending_par ;
       ss_after = saved_after
     } =
 </r>405   <r>Stack.restore stacks.s_nitems saved_nitems ;
       Stack.restore stacks.s_dt saved_dt ;
       Stack.restore stacks.s_dcount saved_dcount ;
       Stack.restore stacks.s_x saved_x ;
       Stack.restore stacks.s_align saved_align ;
 </r>410   <r>Stack.restore stacks.s_in_align saved_in_align ;
       Stack.restore stacks.s_underline saved_underline ;
       Stack.restore stacks.s_nocount saved_nocount ;
       Stack.restore stacks.s_in_table saved_in_table ;
       Stack.restore stacks.s_vsize saved_vsize ;
 </r>415   <r>Stack.restore stacks.s_active saved_active ;
       Stack.restore stacks.s_pending_par saved_pending_par ;
       Stack.restore stacks.s_after saved_after
     
     <b><U>let</U></b> check_stack what =
 </r>420   </m><U>if</U><r> not (Stack.empty what)  &amp;&amp; not !silent </r><U>then</U> <U>begin</U><r>
         prerr_endline
           ("Warning: stack "^Stack.name what^" is non-empty in Html.finalize") ;
       <b><U>end</U><r>
     ;;
 </r><m>425 
     </m><U>let</U></b> check_stacks () = <b><U>match</U><r> stacks </r><U>with</U></b>
     {
       s_nitems = nitems ;
       s_dt = dt ;
 <m>430   <r>s_dcount = dcount ;
       s_x = x ;
       s_align = align ;
       s_in_align = in_align ;
       s_underline = underline ;
 </r>435   <r>s_nocount = nocount ;
       s_in_table = in_table ;
       s_vsize = vsize ;
       s_active = active ;
       s_pending_par = pending_par ;
 </r>440   <r>s_after = after
     } -&gt;
       check_stack nitems ;
       check_stack dt ;
       check_stack dcount ;
 </r>445   <r>check_stack x ;
       check_stack align ;
       check_stack in_align ;
       check_stack underline ;
       check_stack nocount ;
 </r>450   <r>check_stack in_table ;
       check_stack vsize ;
       check_stack active ;
       check_stack pending_par ;
       check_stack after
 </r>455 
     <b><U>let</U><r> line = String.create (!Parse_opts.width +2);;
     
     </r><U>type</U><r> saved = string * flags_t * saved_stacks * saved_out
     
 </r></b>460 <b><U>let</U><r> check () =
       </r><U>let</U><r> saved_flags = copy_flags flags
       <b><U>and</U><r> saved_stacks = save_stacks ()
       </r><U>and</U></b> saved_out = save_out () <b><U>in</U></b>
       String.copy line, saved_flags, saved_stacks, saved_out
 </r></b>465 
     
     <b><U>and</U><r> hot (l,f,s,o) =
       String.blit  l 0 line 0 (String.length l) ;
       set_flags flags f ;
 </r></b>470   <r>restore_stacks s ;
       restore_out o
     
     <b><U>let</U></b> stop () =
       Stack.push stacks.s_active !cur_out.out ;
 </r>475   <r>Stack.push stacks.s_pending_par flags.pending_par ;
       !cur_out.out &lt;- Out.create_null ()
     
     <b><U>and</U></b> restart () =
       !cur_out.out &lt;- Stack.pop stacks.s_active ;
 </r>480   <r>flags.pending_par &lt;- Stack.pop stacks.s_pending_par
     
     <b><U>let</U></b> do_do_put_char c =
       Out.put_char !cur_out.out c;;
     
 </r>485 <b><U>let</U><r> do_do_put  s =
       Out.put !cur_out.out s;;
     
     
     </r><U>let</U><r> do_put_line s =
 </r></b>490   <w>(* Ligne a formatter selon flags.align, avec les parametres courants.*)
       (* soulignage eventuel *)
       <b><U>let</U><r> taille = String.length s </r><U>in</U>
       <U>let</U><r> length = <b><U>if</U><r> s.[taille-1]='\n' </r><U>then</U></b> taille-1 <b><U>else</U><r> taille </r><U>in</U>
       <U>let</U></b> soul = ref <b><U>false</U> <U>in</U><m>
 495   </m><U>for</U></b> i = 0 <b><U>to</U><r> length - 1 </r><U>do</U></b>
         soul := !soul || s.[i] &lt;&gt; ' ';
       <b><U>done</U><r>;
       soul := !soul &amp;&amp; s&lt;&gt;"\n" &amp;&amp; flags.underline &lt;&gt; "";
     
 </r><m>500   </m><U>let</U></b> ligne = <b><U>match</U><r> flags.align </r><U>with</U></b>
       | Left -&gt; s
       | Center -&gt;
           <b><U>let</U><r> sp = (flags.hsize - (length -flags.x_start))/2 </r><U>in</U></b>
           String.concat "" [String.make sp ' '; s]
 <m>505   <r>| Right -&gt;
           <b><U>let</U><r> sp = flags.hsize - length + flags.x_start </r><U>in</U></b>
           String.concat "" [ String.make sp ' '; s]
       <b><U>in</U>
       <U>if</U></b> !verbose &gt; 3 <b><U>then</U></b> prerr_endline ("line :"^ligne);
 </r>510   <r>do_do_put ligne;
     
     
       <b><U>if</U><r> !soul </r><U>then</U> <U>begin</U>
         <U>let</U></b> souligne =
 </r>515       <b><U>let</U></b></m> l = String.make taille ' ' <b><U>in</U>
           <U>let</U></b> len = String.length flags.underline <b><U>in</U>
           <U>if</U></b> len = 0 <b><U>then</U><r> raise (Misc.Fatal ("cannot underline with nothing:#"
           ^String.escaped flags.underline^"#"^
           (</r><U>if</U></b>  (flags.underline &lt;&gt; "") <b><U>then</U><r> "true" </r><U>else</U></b> "false"
 <m>520         <r>)));
           <b><U>for</U><r> i = flags.x_start </r><U>to</U></b> length -1 <b><U>do</U><r>
      l.[i]&lt;-flags.underline.[(i-flags.x_start) </r><U>mod</U></b> len]
           <b><U>done</U><r>;
           </r><U>if</U></b> taille &lt;&gt; length <b><U>then</U></b> l.[length]&lt;-'\n';
 </r>525       <b><U>match</U></b></m> flags.align <b><U>with</U><r>
           | Left -&gt; l
           | Center -&gt;
        </r><U>let</U></b> sp = (flags.hsize - length)/2 +flags.x_start/2 <b><U>in</U><r>
        String.concat "" [String.make sp ' '; l]
 <m>530       </m>| Right -&gt;
        </r><U>let</U></b> sp = (flags.hsize - length) + flags.x_start <b><U>in</U><r>
        String.concat "" [ String.make sp ' '; l]
         </r><U>in</U>
         <U>if</U></b> !verbose &gt;3 <b><U>then</U><r> prerr_endline ("line underlined:"^souligne);
 <m>535 
         </m>do_do_put souligne;
       </r><U>end</U></b>
     ;;
     
 <m>540 <b><U>let</U></b></m> do_flush () =
       <b><U>if</U><r> !verbose&gt;3 &amp;&amp; flags.x &gt;0 </r><U>then</U></b>
         prerr_endline ("flush :#"^(String.sub line 0 (flags.x))^"#");
       <b><U>if</U><r> flags.x &gt;0 </r><U>then</U></b> do_put_line (String.sub line 0 (flags.x)) ;
       flags.x &lt;- -1;
 <m>545 <r>;;
     
     <b><U>let</U><r> do_put_char_format c =
       </r><U>if</U></b> !verbose &gt; 3 <b><U>then</U></b>
         prerr_endline ("caracters read : '"^Char.escaped c^"', x="^string_of_int flags.x^", length ="^string_of_int (flags.hsize));
 </r>550 
       <b><U>if</U></b></m> c=' ' <b><U>then</U><r>  flags.last_space &lt;- flags.x;
       </r><U>if</U></b> flags.x =(-1) </r><U>then</U> <U>begin</U></b>
         (* La derniere ligne finissait un paragraphe : on indente *)
         </w></m>flags.x&lt;-flags.x_start + flags.first_line;
 <m>555     <b><U>for</U></b></m> i = 0 <b><U>to</U><r> flags.x-1 </r><U>do</U></b>
           line.[i]&lt;-' ';
         <b><U>done</U><r>;
         flags.last_space&lt;-flags.x-1;
       </r><U>end</U></b>;
 <m>560   </m>line.[flags.x]&lt;-c;
       <b><U>if</U></b> c='\n' </r><U>then</U> <U>begin</U></b>
      (* Ligne prete *)
         <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U><r>
           prerr_endline("line not cut :["^line^"]");
 <m>565     </m>do_put_line (String.sub line 0 (flags.x +1));
         flags.x &lt;- -1;
       <b><U>end</U> <U>else</U></b>
         flags.x&lt;-flags.x + 1;
       <b><U>if</U></b> flags.x&gt;(flags.x_end +1) </r><U>then</U> <U>begin</U></b> (* depassement de ligne *)
 </w>570     <b><U>if</U></b></m> (flags.x - flags.last_space) &gt;= flags.hsize <b><U>then</U> <U>begin</U><w>
        (* On coupe brutalement le mot trop long *)
           </w><U>if</U></b> !verbose &gt; 2 <b><U>then</U></b>
      prerr_endline ("line cut :"^line);
           warning ("line too long");
 <m>575       </m>line.[flags.x-1]&lt;-'\n';
        </r></b>(* La ligne est prete et complete*)
           <r>do_put_line (String.sub line 0 (flags.x));
           <b><U>for</U><r> i = 0 </r><U>to</U></b> flags.x_start-1 <b><U>do</U><r> line.[i]&lt;-' ' </r><U>done</U></b>;
           line.[flags.x_start]&lt;-c;
 <m>580       </m>flags.x&lt;-flags.x_start + 1;
           flags.last_space&lt;-flags.x_start-1;
         <b><U>end</U> <U>else</U> <U>begin</U>
           <U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
      prerr_endline ("Line and the beginning of the next word :"^line);
 <m>585  </m>prerr_endline ("x ="^string_of_int flags.x);
      prerr_endline ("x_start ="^string_of_int flags.x_start);
      prerr_endline ("x_end ="^string_of_int flags.x_end);
      prerr_endline ("hsize ="^string_of_int flags.hsize);
      prerr_endline ("last_space ="^string_of_int flags.last_space);
 <m>590  </m>prerr_endline ("line size ="^string_of_int (String.length line));
           <b><U>end</U></b>;
        </r>(* On repart du dernier espace *)
           <b><U>let</U><r> reste =
      </r><U>let</U><r> len = flags.x - flags.last_space -1 <b><U>in</U><m>
 595  </m><U>if</U></b> len = 0 <b><U>then</U><r> ""
      </r><U>else</U></b>
        String.sub line (flags.last_space +1) len
           </r><U>in</U></b>
        (* La ligne est prete et incomplete*)
 </w>600       <r>line.[flags.last_space]&lt;-'\n';
           do_put_line (String.sub line 0 (flags.last_space+1));
     
           <b><U>for</U><r> i = 0 </r><U>to</U></b> flags.x_start-1 <b><U>do</U><r> line.[i]&lt;-' ' </r><U>done</U></b>;
           <b><U>for</U><r> i = flags.x_start </r><U>to</U></b> (flags.x_start+ String.length reste -1) <b><U>do</U><m>
 605  <r>line.[i]&lt;- reste.[i-flags.x_start];
           <b><U>done</U><r>;
           flags.x&lt;- flags.x_start + (String.length reste);
           flags.last_space &lt;- flags.x_start-1;
         </r><U>end</U></b>;
 </r>610   </m><U>end</U></b>;
     ;;
     
     <b><U>let</U><r> do_put_char c =
       </r><U>if</U></b> !verbose&gt;3 <b><U>then</U><m>
 615     <r>prerr_endline ("put_char:|"^String.escaped (String.make 1 c)^"|");
       <b><U>if</U><r> !cur_out.temp || (Out.is_null !cur_out.out)
       </r><U>then</U></b> do_do_put_char c
       <b><U>else</U></b> do_put_char_format c
     ;;
 </r>620 
     </m><U>let</U></b> finit_ligne () =
       <b><U>if</U><r> !verbose&gt;3 </r><U>then</U></b> prerr_endline "ending the line.";
       <b><U>if</U><r> flags.x &gt;0 </r><U>then</U></b> do_put_char '\n'
     ;;
 </r>625 
     <b><U>let</U><r> do_unskip () =
       </r><U>if</U><r> !cur_out.temp || (Out.is_null !cur_out.out) <b><U>then</U><r>
         Out.unskip !cur_out.out
       </r><U>else</U> <U>begin</U><m>
 630     </m><U>while</U></b> flags.x &gt; flags.x_start &amp;&amp; line.[flags.x-1] = ' ' <b><U>do</U><r>
           flags.x &lt;- flags.x - 1
         </r><U>done</U></b> ;
         flags.last_space &lt;-  flags.x ;
         <b><U>while</U><m>
 635       <r>flags.last_space &gt;=  flags.x_start &amp;&amp;
           line.[flags.last_space] &lt;&gt; ' '
         <b><U>do</U><r>
           flags.last_space &lt;- flags.last_space - 1
         </r><U>done</U></b>;
 </r>640     </m><U>if</U></b> flags.x = flags.x_start &amp;&amp; !cur_out.temp <b><U>then</U><r>
           Out.unskip !cur_out.out
       </r><U>end</U><m>
     
     
 645 </m><U>let</U></b> do_put s =
       <b><U>if</U><r> !verbose&gt;3 </r><U>then</U></b>
         prerr_endline ("put:|"^String.escaped s^"|");
         <b><U>for</U><r> i = 0 </r><U>to</U></b> String.length s - 1 <b><U>do</U></b>
           do_put_char s.[i]
 </r></b>650     <b><U>done</U><r>
     ;;
     
     
     </r><U>let</U><r> get_last_closed () = flags.last_closed;;
 </r></b>655 <b><U>let</U><r> set_last_closed s = flags.last_closed&lt;-s;;
     
     </r><w>(* Gestion des styles : pas de style en mode texte *)
     
     </w><U>let</U><r> is_list = <b><U>function</U><m>
 660   <r>| "UL" | "DL" | "OL" -&gt; <b><U>true</U><r>
       | _ -&gt; </r><U>false</U></b>
     ;;
     
     <b><U>let</U></b> get_fontsize () = 3;;
 </r>665 
     </m><U>let</U></b> nostyle () =
       !cur_out.nostyle&lt;-<b><U>true</U></b>
     ;;
     
 </r></b>670 <b><U>let</U><r> clearstyle () =
       !cur_out.active&lt;-[]
     ;;
     
     </r><U>let</U><r> open_mod m =
 </r></b>675   <b><U>if</U><r> m=(Style "CODE") </r><U>then</U> <U>begin</U><r>
         do_put "`";
         !cur_out.active &lt;- m::!cur_out.active
       <b><U>end</U></b>;
     ;;
 </r></b>680 
     <r><b><U>let</U><r> do_close_mod = </r><U>function</U></b>
       |  Style "CODE" -&gt;
           do_put "'";
       | _ -&gt; ()
 </r>685 <r>;;
     
     <b><U>let</U><r> close_mod () = </r><U>match</U></b> !cur_out.active <b><U>with</U><r>
       [] -&gt; ()
     | (Style "CODE" </r><U>as</U></b> s)::reste -&gt;
 </r>690     <r>do_close_mod s;
         !cur_out.active &lt;- reste
     | _ -&gt; ()
     ;;
     
 </r>695 <b><U>let</U><r> erase_mods ml = ()
     ;;
     
     </r><U>let</U> <U>rec</U><r> open_mods = <b><U>function</U></b>
       | [] -&gt; ()
 </r></b>700   <r>| s::reste -&gt; open_mod s; open_mods reste
     ;;
     
     <b><U>let</U></b> close_mods () =
       List.iter do_close_mod !cur_out.active;
 </r>705   <r>!cur_out.active &lt;- []
     ;;
     
     <b><U>let</U><r> par = </r><U>function</U><w> (*Nombre de lignes a sauter avant le prochain put*)
       <r>| Some n <b><U>as</U><r> p-&gt;
 </r><m>710       </m><U>begin</U></b>
      flags.pending_par &lt;-
        (<b><U>match</U><r> pblock() </r><U>with</U></b>
        | "QUOTE" | "QUOTATION" -&gt; Some (n-1)
        | _ -&gt; Some n);
 <m>715  <b><U>if</U><r> !verbose&gt; 2 </r><U>then</U><r>
        prerr_endline
          ("par: last_close="^flags.last_closed^
           " r="^string_of_int n);
           </r><U>end</U></b>
 720   </m>| _ -&gt; ()
     
     
     <b><U>let</U><r> forget_par () =
       </r><U>let</U></b> r = flags.pending_par <b><U>in</U><m>
 725   <r>flags.pending_par &lt;- None;
       r
     ;;
     
     <b><U>let</U></b> flush_par n =
 </r>730   <r>flags.pending_par &lt;- None;
       <b><U>let</U><r> p = n </r><U>in</U></b>
       do_put_char '\n' ;
       <b><U>for</U><r> i=1 </r><U>to</U></b> p-1 <b><U>do</U></b>
         do_put_char '\n'
 </r>735   </m><U>done</U></b>;
       <b><U>if</U><r> !verbose &gt;2 </r><U>then</U></b>
         prerr_endline
           ("flush_par : last_closed="^flags.last_closed^
            "p="^string_of_int p);
 <m>740   </m>flags.last_closed&lt;-"rien"
     ;;
     
     <b><U>let</U><r> try_flush_par () =
       </r><U>match</U></b> flags.pending_par <b><U>with</U><m>
 745   <r>| Some n -&gt; flush_par n
       | _ -&gt; ()
     ;;
     
     <b><U>let</U></b> do_pending () =
 </r>750   </m><U>begin</U> <U>match</U></b> flags.pending_par <b><U>with</U><r>
       | Some n -&gt; flush_par n
       | _ -&gt; ()
       </r><U>end</U></b>;
       flags.last_closed &lt;- "rien";
 <m>755 </m>;;
     
     </r>(* Blocs *)
     
     </w><U>let</U></b> try_open_block s args =
 </r>760   <w>(* Prepare l'environnement specifique au bloc en cours *)
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U><r>
         prerr_endline ("=&gt; try_open ``"^s^"''");
     
       push stacks.s_x
 <m>765     <r>(flags.hsize,flags.x,flags.x_start,flags.x_end,
         flags.first_line,flags.last_space);
     
       <b><U>if</U><r> is_list s </r><U>then</U> <U>begin</U></b>
         do_put_char '\n';
 </r>770     <r>push stacks.s_nitems flags.nitems;
         flags.nitems &lt;- 0;
         flags.x_start &lt;- flags.x_start + 3;
         flags.first_line &lt;- -2;
         flags.hsize &lt;- flags.x_end - flags.x_start+1;
 </r>775 
         <b><U>if</U></b></m> not flags.in_align <b><U>then</U> <U>begin</U></b>
           push stacks.s_align flags.align;
           flags.align &lt;- Left
         <b><U>end</U><r>;
 </r><m>780     </m><U>if</U></b> s="DL" <b><U>then</U> <U>begin</U></b>
           push stacks.s_dt flags.dt;
           push stacks.s_dcount flags.dcount;
           flags.dt &lt;- "";
           flags.dcount &lt;- "";
 <m>785     <b><U>end</U></b></m>;
       <b><U>end</U> <U>else</U> <U>match</U></b> s <b><U>with</U><r>
       | "ALIGN" -&gt;
           </r><U>begin</U></b>
      finit_ligne ();
 <m>790  </m>push stacks.s_align flags.align;
      push stacks.s_in_align flags.in_align;
      flags.in_align&lt;-<b><U>true</U><r>;
      flags.first_line &lt;-2;
      </r><U>match</U></b> args <b><U>with</U><m>
 795    <r>"LEFT" -&gt; flags.align &lt;- Left
      | "CENTER" -&gt; flags.align &lt;- Center
      | "RIGHT" -&gt; flags.align &lt;- Right
      | _ -&gt; raise (Misc.ScanError "Invalid argument in ALIGN");
           <b><U>end</U><m>
 800   <r>|  "HEAD" -&gt;
           <b><U>begin</U></b>
      finit_ligne ();
      flags.first_line &lt;-0 ;
      push stacks.s_underline flags.underline;
 </r>805  <r>flags.underline &lt;- args;
           <b><U>end</U><r>
       | "QUOTE" -&gt;
           </r><U>begin</U></b>
      finit_ligne ();
 </r>810  <r>push stacks.s_align flags.align;
      push stacks.s_in_align flags.in_align;
      flags.in_align&lt;-<b><U>true</U></b>;
      flags.align &lt;- Left;
      flags.first_line&lt;-0;
 </r>815  <r>flags.x_start&lt;- flags.x_start + 20 * flags.hsize / 100;
      flags.hsize &lt;- flags.x_end - flags.x_start+1;
           <b><U>end</U><r>
       | "QUOTATION" -&gt;
           </r><U>begin</U><m>
 820  <r>finit_ligne ();
      push stacks.s_align flags.align;
      push stacks.s_in_align flags.in_align;
      flags.in_align&lt;-<b><U>true</U></b>;
      flags.align &lt;- Left;
 </r>825  <r>flags.first_line&lt;-2;
      flags.x_start&lt;- flags.x_start + 20 * flags.hsize / 100;
      flags.hsize &lt;- flags.x_end - flags.x_start+1;
           <b><U>end</U></b>
       | "PRE" -&gt;
 </r>830       <r>flags.first_line &lt;-0;
           finit_ligne ();
           do_put "&lt;&lt;";
           flags.first_line &lt;-2;
       | "INFO" -&gt;
 </r>835       <r>push stacks.s_nocount flags.nocount ;
           flags.nocount &lt;- <b><U>true</U></b> ;
           flags.first_line &lt;-0
       | "INFOLINE" -&gt;
           push stacks.s_nocount flags.nocount ;
 </r>840       <r>flags.nocount &lt;- <b><U>true</U></b> ;
           flags.first_line &lt;-0 ;
           finit_ligne ()
       | _ -&gt; ();
     
 </r>845   </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r>
         prerr_endline ("&lt;= try_open ``"^s^"''")
     ;;
     
     </r><U>let</U></b> try_close_block s =
 </r>850   </m><U>let</U></b> (h,x,xs,xe,fl,lp) = pop stacks.s_x <b><U>in</U></b>
       flags.hsize&lt;-h;
       flags.x_start&lt;-xs;
       flags.x_end&lt;-xe;
       flags.first_line &lt;-fl;
 </r>855 
     
       </m><U>if</U></b> (is_list s) <b><U>then</U> <U>begin</U></b>
         finit_ligne();
         <b><U>if</U><r> not flags.in_align </r><U>then</U> <U>begin</U><m>
 860       </m><U>let</U></b> a = pop stacks.s_align <b><U>in</U><r>
           flags.align &lt;- a
         </r><U>end</U></b>;
         flags.nitems &lt;- pop  stacks.s_nitems;
         <b><U>if</U><r> s="DL" </r><U>then</U> <U>begin</U><m>
 865       <r>flags.dt &lt;- pop stacks.s_dt;
           flags.dcount &lt;- pop stacks.s_dcount;
         <b><U>end</U><r>;
       </r><U>end</U> <U>else</U> <U>match</U></b> s <b><U>with</U></b>
       | "ALIGN" | "QUOTE" | "QUOTATION" -&gt;
 </r>870       </m><U>begin</U></b>
      finit_ligne ();
      <b><U>let</U><r> a = pop stacks.s_align </r><U>in</U></b>
      flags.align &lt;- a;
      <b><U>let</U><r> ia = pop  stacks.s_in_align </r><U>in</U><m>
 875  <r>flags.in_align &lt;- ia;
           <b><U>end</U><r>
       | "HEAD" -&gt;
           </r><U>begin</U></b>
      finit_ligne();
 </r>880  </m><U>let</U></b> u = pop stacks.s_underline <b><U>in</U><r>
      flags.underline &lt;- u
           </r><U>end</U></b>
       | "PRE" -&gt;
           flags.first_line &lt;-0;
 <m>885       </m>do_put "&gt;&gt;\n";
           flags.first_line &lt;-fl;
       | "INFO"|"INFOLINE"-&gt;
           flags.nocount &lt;- pop stacks.s_nocount
       | _ -&gt; ()
 <m>890 </m>;;
     
     <b><U>let</U></b> open_block s args =
       </r></b>(* Cree et se place dans le bloc de nom s et d'arguments args *)
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U><m>
 895     <r>prerr_endline ("=&gt; open_block ``"^s^"''");
       <b><U>let</U><r> bloc,arg =
         </r><U>if</U></b> s="DIV" &amp;&amp; args="ALIGN=center" <b><U>then</U><r>
           "ALIGN","CENTER"
         </r><U>else</U></b> s,args
 </r>900   </m><U>in</U><r>
       push_out out_stack (bloc,arg,!cur_out);
       try_flush_par ();
       </r></b>(* Sauvegarde de l'etat courant *)
     
 </w>905   <r><b><U>if</U><r> !cur_out.temp || s="TEMP" || s="AFTER" </r><U>then</U> <U>begin</U></b>
         cur_out :=
           newstatus
      !cur_out.nostyle
      !cur_out.active
 </r>910  <r>[] <b><U>true</U><r>;
       </r><U>end</U></b>;
       try_open_block bloc arg;
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U></b>
         prerr_endline ("&lt;= open_block ``"^bloc^"''")
 </r>915 <r>;;
     
     <b><U>let</U><r> force_block s content =
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U></b>
         prerr_endline ("   force_block ``"^s^"''");
 </r>920   <b><U>let</U><r> old_out = !cur_out </r><U>in</U><r>
       try_close_block s;
       <b><U>let</U><r> ps,pa,pout = pop_out out_stack </r><U>in</U>
       <U>if</U></b> ps &lt;&gt;"DELAY" <b><U>then</U> <U>begin</U></b>
         cur_out:=pout;
 </r></b>925     <b><U>if</U><r> ps = "AFTER" </r><U>then</U> <U>begin</U>
             <U>let</U><r> f = pop stacks.s_after <b><U>in</U><r>
             Out.copy_fun f old_out.out !cur_out.out
         </r><U>end</U> <U>else</U> <U>if</U></b> !cur_out.temp <b><U>then</U></b>
           Out.copy old_out.out !cur_out.out;
 </r></b>930     <r>flags.last_closed&lt;- s;
         <b><U>if</U><r> !cur_out.temp </r><U>then</U></b>
           free old_out;
       <b><U>end</U> <U>else</U></b> raise ( Misc.Fatal "text: unflushed DELAY")
     ;;
 </r>935 
     <r><b><U>let</U><r> close_block s =
       </r><w>(* Fermeture du bloc : recuperation de la pile *)
       </w><U>if</U></b> !verbose &gt; 2 <b><U>then</U></b>
         prerr_endline ("=&gt; close_block ``"^s^"''");
 </r>940   <b><U>let</U><r> bloc =  </r><U>if</U><r> s = "DIV" <b><U>then</U><r> "ALIGN" </r><U>else</U></b> s <b><U>in</U><r>
       force_block bloc "";
       </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U></b>
         prerr_endline ("&lt;= close_block ``"^bloc^"''");
     ;;
 </r></b>945 
     
     
     <b><U>let</U><r> insert_block tag arg =
       </r><U>if</U><r> tag = "ALIGN" <b><U>then</U> <U>begin</U><m>
 950     </m><U>match</U></b> arg <b><U>with</U></b>
           "LEFT" -&gt; flags.align &lt;- Left
         | "CENTER" -&gt; flags.align &lt;- Center
         | "RIGHT" -&gt; flags.align &lt;- Right
         | _ -&gt; raise (Misc.ScanError "Invalid argument in ALIGN");
 </r></b>955   <b><U>end</U><r>;
     
     </r><U>and</U><r> insert_attr _ _ = ()
     ;;
     
 </r></b>960 
     </TT><w><TT>(* Autres *)
     
     (* Listes *)
     <b><U>let</U></b><r> set_dt s = flags.dt &lt;- s
 <m>965 
     <b><U>and</U></b></m> set_dcount s = flags.dcount &lt;- s
     ;;
     
     <b><U>let</U><r> do_item isnum =
 </r><m>970   </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         prerr_string "do_item: stack=";
         pretty_stack out_stack
       <b><U>end</U><r>;
       </r><U>let</U></b> mods = !cur_out.active <b><U>in</U><m>
 975   </m><U>if</U></b> flags.nitems = 0 <b><U>then</U> <U>begin</U> <U>let</U></b> _ = forget_par () <b><U>in</U><r> () </r><U>end</U></b> ;
       try_flush_par () ;
       flags.nitems&lt;-flags.nitems+1;
       <b><U>if</U><r> isnum </r><U>then</U></b>
         do_put ("\n"^(string_of_int flags.nitems)^". ")
 <m>980   <b><U>else</U></b></m>
         do_put "\n- "
     ;;
     
     <b><U>let</U><r> item () = do_item </r><U>false</U><m>
 985 </m><U>and</U></b> nitem () = do_item <b><U>true</U><r>
     ;;
     
     
     </r><U>let</U></b> ditem scan arg =
 <m>990   <b><U>if</U></b></m> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         prerr_string "ditem: stack=";
         pretty_stack out_stack
       <b><U>end</U><r>;
     
 </r><m>995   </m><U>let</U></b> mods = !cur_out.active <b><U>in</U>
       <U>let</U></b> true_scan =
         <b><U>if</U><r> flags.nitems = 0 </r><U>then</U> <U>begin</U>
           <U>let</U></b> _ = forget_par() <b><U>in</U><r> ();
           ( </r><U>fun</U></b> arg -&gt; scan arg)
<m>1000     <b><U>end</U> <U>else</U></b></m> scan <b><U>in</U><r>
     
       try_flush_par();
       flags.nitems&lt;-flags.nitems+1;
       do_put_char '\n';
</r><m>1005   </m><U>if</U></b> flags.dcount &lt;&gt; "" <b><U>then</U><r> scan("\\refstepcounter{"^flags.dcount^"}");
       true_scan ("\\makelabel{"^arg^"}") ;
       do_put_char ' '
     ;;
     
</r><m>1010 
     
     </m><U>let</U></b> erase_block s =
       <b><U>if</U><r> not !cur_out.temp </r><U>then</U></b> close_block s
       <b><U>else</U> <U>begin</U><m>
1015     </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
           Printf.fprintf stderr "erase_block: %s" s;
           prerr_newline ()
         <b><U>end</U><r> ;
         try_close_block s ;
</r><m>1020     </m><U>let</U></b> ts,_,tout = pop_out out_stack <b><U>in</U>
         <U>if</U></b> ts &lt;&gt; s <b><U>then</U><r>
           failclose ("erase_block: "^s^" closes "^ts);
         free !cur_out ;
         cur_out := tout
</r><m>1025   </m><U>end</U></b>
     ;;
     
     <b><U>let</U><r> to_string f =
       open_block "TEMP" "";
<m>1030   </m>f () ;
       </r><U>let</U></b> r = Out.to_string !cur_out.out <b><U>in</U><r>
       close_block "TEMP";
       r
     ;;
</r><m>1035 
     </m><U>let</U></b> open_group ss =
       open_block "" "";
       open_mod (Style ss);
     ;;
<m>1040 
     <b><U>let</U></b></m> open_aftergroup f =
       open_block "AFTER" "" ;
       push stacks.s_after f
     ;;
<m>1045 
     <b><U>let</U></b></m> close_group () =
       close_mod ();
       close_block "";
     ;;
<m>1050 
     
     <b><U>let</U></b></m> put s =
       <b><U>if</U><r> !verbose &gt; 3 </r><U>then</U></b>
         Printf.fprintf stderr "put: %s\n" s ;
<m>1055   <r>do_pending ();
       do_put s
     ;;
     
     <b><U>let</U></b> put_char c =
</r>1060   <b><U>if</U></b></m> !verbose &gt; 3 <b><U>then</U><r>
         Printf.fprintf stderr "put_char: %c\n" c ;
       do_pending ();
       do_put_char c
     ;;
</r><m>1065 
     </m><U>let</U></b> flush_out () =
       Out.flush !cur_out.out
     ;;
     
<m>1070 <b><U>let</U></b></m> skip_line () =
       <b><U>if</U><r> !verbose &gt; 2 </r><U>then</U></b>
         prerr_endline "skip_line" ;
       put_char '\n'
     ;;
<m>1075 
     <b><U>let</U></b></m> loc_name s1 = ()
     ;;
     
     <b><U>let</U><r> open_chan chan =
<m>1080   </m>free !cur_out;
       !cur_out.out&lt;- Out.create_chan chan
     ;;
     
     </r><U>let</U></b> close_chan () =
<m>1085   <r>Out.close !cur_out.out;
       !cur_out.out &lt;- Out.create_buff()
     ;;
     
     
</r>1090 <b><U>let</U></b></m> to_style f =
       !cur_out.active&lt;-[];
       open_block "TEMP" "";
       f ();
       <b><U>let</U><r> r = !cur_out.active </r><U>in</U><m>
1095   <r>erase_block "TEMP";
       r
     ;;
     
     <b><U>let</U></b> get_current_output () =
</r>1100   <r>Out.to_string !cur_out.out
     ;;
     
     <b><U>let</U><r> finalize check =
       </r><U>if</U></b> check <b><U>then</U><m>
1105     <r>check_stacks () ;
       finit_ligne () ;
       Out.close !cur_out.out ;
       !cur_out.out &lt;- Out.create_null ()
     ;;
</r>1110 
     
     
     
     </m><U>let</U></b> unskip () = do_unskip ()
</r>1115 
     </m><U>let</U></b> put_separator () = put " "
     ;;
     
     <b><U>let</U><r> put_tag tag = ()
<m>1120 </m>;;
     
     </r><U>let</U></b> put_nbsp () =  put " "
     ;;
     
<m>1125 <b><U>let</U></b></m> put_open_group () =
       ()
     ;;
     
     <b><U>let</U><r> put_close_group () =
<m>1130   </m>()
     ;;
     
     </r><U>let</U></b> put_in_math s =
       put s
<m>1135 </m>;;
     
     
     </r>(*--------------*)
     (*-- TABLEAUX --*)
<m>1140 </m>(*--------------*)
     
     <b><U>type</U><r> align = Top | Middle | Bottom | Base </r><U>of</U><r> int
     <b><U>and</U><r> wrap_t = True | False | Fill
     ;;
</r><m>1145 
     
     </m><U>type</U></b> cell_t = {
         <b><U>mutable</U><r> ver : align;
         </r><U>mutable</U></b> hor : align_t;
<m>1150     <b><U>mutable</U></b></m> h : int;
         <b><U>mutable</U></b> w : int;
         </r><U>mutable</U><r> wrap : wrap_t;
         </r><U>mutable</U><r> span : int; <w>(* Nombre de colonnes *)
         <b><U>mutable</U></b></w> text : string;
<m>1155     <b><U>mutable</U></b></m> pre  : string; <w>(* bordures *)
         <b><U>mutable</U></b></w> post : string;
         <b><U>mutable</U><r> pre_inside  : int list;
         </r><U>mutable</U></b> post_inside : int list;
       }
<m>1160 <r>;;
     
     <b><U>type</U><r> cell_set = Tabl </r><U>of</U></b> cell_t Table.t | Arr <b><U>of</U></b> cell_t array
     ;;
     
</r>1165 <b><U>type</U></b></m> row_t = {
         <b><U>mutable</U><r> haut : int;
         </r><U>mutable</U></b> cells : cell_set;
       }
     ;;
<m>1170 
     <b><U>type</U></b></m> table_t = {
         <b><U>mutable</U><r> lines : int;
         </r><U>mutable</U></b> cols : int;
         <b><U>mutable</U><r> width : int;
</r><m>1175     </m><U>mutable</U></b> taille : int Table.t;
         <b><U>mutable</U><r> tailles : int array;
         </r><U>mutable</U></b> table : row_t Table.t;
         <b><U>mutable</U><r> line : int;
         </r><U>mutable</U></b> col : int;
<m>1180     <b><U>mutable</U></b></m> in_cell : bool;
       }
     ;;
     
     <b><U>let</U><r> cell = ref {
</r><m>1185   <r>ver = Middle;
       hor = Left;
       h = 0;
       w = 0;
       wrap = False;
</r>1190   <r>span = 1;
       text = "";
       pre  = "";
       post = "";
       pre_inside  = [];
</r>1195   <r>post_inside = [];
     }
     ;;
     
     
</r>1200 </m><U>let</U></b> row= ref {
       haut = 0;
       cells = Tabl (Table.create  !cell)
     }
     ;;
<m>1205 
     <b><U>let</U></b></m> table =  ref {
       lines = 0;
       cols = 0;
       width = 0;
<m>1210   <r>taille = Table.create 0;
       tailles = Array.create 0 0;
       table = Table.create {haut = 0; cells = Arr (Array.create 0 !cell)};
       line = 0;
       col = 0;
</r>1215   <r>in_cell = <b><U>false</U><r>;
     }
     ;;
     
     </r><U>let</U></b> table_stack = Stack.create "table_stack";;
</r>1220 <b><U>let</U></b></m> row_stack = Stack.create "row_stack";;
     <b><U>let</U><r> cell_stack = Stack.create "cell_stack";;
     
     </r><U>let</U></b> multi = ref []
     <b><U>and</U><r> multi_stack = Stack.create "multi_stack";;
</r><m>1225 
     
     </m><U>let</U></b> open_table border _ =
       <w>(* creation d'une table : on prepare les donnees : creation de l'environnement qvb, empilage du precedent. *)
       </w>push table_stack !table;
<m>1230   <r>push row_stack !row;
       push cell_stack !cell;
       push stacks.s_in_table flags.in_table;
       push multi_stack !multi;
       push stacks.s_align flags.align;
</r>1235 
       <b><U>if</U></b></m> !verbose&gt;2 <b><U>then</U><r> prerr_endline "=&gt; open_table";
     
       finit_ligne ();
       open_block "" "";
<m>1240   </m>flags.first_line &lt;- 0;
     
       table := {
         lines = 0;
         cols = 0;
<m>1245     </m>width = 0;
         taille = Table.create 0;
         tailles = Array.create 0 0;
         table = Table.create {haut = 0; cells = Arr (Array.create 0 !cell)};
         line = -1;
<m>1250     </m>col = -1;
         in_cell = </r><U>false</U></b>;
       };
     
       row := {
<m>1255     <r>haut = 0;
         cells = Tabl (Table.create  !cell)
       };
     
       cell :=  {
</r>1260     <r>ver = Middle;
         hor = Left;
         h = 0;
         w = 0;
         wrap = False;
</r>1265     <r>span = 1;
         text = "";
         pre  = "";
         post = "";
         pre_inside  = [];
</r>1270     <r>post_inside = [];
       };
     
       multi := [];
       flags.in_table&lt;-<b><U>true</U></b>;
</r>1275 <r>;;
     
     <b><U>let</U><r> new_row () =
       </r><U>if</U></b> !table.col&gt; !table.cols <b><U>then</U></b> !table.cols&lt;- !table.col;
       !table.col &lt;- -1;
</r>1280   <r>!table.line &lt;- !table.line +1;
       <b><U>if</U><r> !table.line = 1 &amp;&amp; (( Array.length !table.tailles)=0) </r><U>then</U></b>
         !table.tailles&lt;-Table.trim !table.taille;
       <b><U>let</U><r> _ =</r><U>match</U></b> !row.cells <b><U>with</U></b>
       | Tabl t -&gt; Table.reset t
</r>1285   <r>| _-&gt; raise (Error "invalid table type in array")
       <b><U>in</U></b>
       !cell.pre &lt;- "";
       !cell.pre_inside &lt;- [];
       !row.haut&lt;-0;
</r>1290   <b><U>if</U></b></m> !verbose&gt;2 <b><U>then</U><r> prerr_endline ("new_row, line ="^string_of_int !table.line)
     ;;
     
     </r><U>let</U></b> change_format format = <b><U>match</U><r> format </r><U>with</U></b>
       Tabular.Align {Tabular.vert=v ; Tabular.hor=h ; Tabular.wrap=w ; Tabular.width=size} -&gt;
<m>1295     <r>!cell.ver &lt;-
           (<b><U>match</U><r> v </r><U>with</U></b>
           | "" -&gt; Base 50
           | "middle" -&gt; Base 50
           | "top" -&gt; Top
</r>1300       <r>| "bottom" -&gt; Bottom
           | s -&gt;
        <b><U>let</U><r> n =
          </r><U>try</U></b>
            int_of_string s
</r>1305      <b><U>with</U></b></m> (Failure fail) -&gt; raise (Misc.Fatal ("open_cell, invalid vertical format :"^v));
        <b><U>in</U>
        <U>if</U><r> n&gt;100 || n&lt;0 <b><U>then</U></b> raise (Misc.Fatal ("open_cell, invalid vertical format :"^v));
        Base n);
         !cell.hor &lt;-
<m>1310       <r>(<b><U>match</U><r> h </r><U>with</U></b>
           | "" -&gt; Left
           | "center" -&gt; Center
           | "left" -&gt; Left
           | "right" -&gt; Right
</r>1315       <r>| _-&gt; raise (Misc.Fatal ("open_cell, invalid horizontal format :"^h)));
         !cell.wrap &lt;- (<b><U>if</U><r> w </r><U>then</U></b> True <b><U>else</U><r> False);
         </r><U>if</U></b> w <b><U>then</U><r>
           !cell.w &lt;-
      (</r><U>match</U></b> size <b><U>with</U><m>
1320  <r>| Length.Char l -&gt; l
      | Length.Pixel l -&gt; l / Length.font
      | Length.Percent l -&gt; l * !Parse_opts.width / 100
      | Length.Default -&gt; !cell.wrap &lt;- False; warning "cannot wrap column with no width"; 0
             | Length.No s -&gt;
</r>1325             <r>raise (Misc.Fatal ("No-length ``"^s^"'' in out-manager")))
         <b><U>else</U></b> !cell.w &lt;- 0;
     | _       -&gt;  raise (Misc.Fatal ("as_align"))
     ;;
     
</r>1330 </m><U>let</U></b> open_cell format span insides =
       open_block "TEMP" "";
     
       <w>(* preparation du formattage : les flags de position sont sauvegardes par l'ouverture du bloc TEMP *)
     
<m>1335 
        </m>(* remplir les champs de formattage de cell *)
       </w>!table.col &lt;- !table.col+1;
       <b><U>if</U><r> !verbose&gt;2 </r><U>then</U></b> prerr_endline ("open_cell, col="^string_of_int !table.col);
     
</r>1340   <r>change_format format;
       !cell.span &lt;- span - insides;
       <b><U>if</U><r> !table.col &gt; 0 &amp;&amp; !cell.span=1 </r><U>then</U> <U>begin</U></b>
         !cell.pre &lt;- "";
         !cell.pre_inside &lt;- [];
</r>1345   <b><U>end</U><r>;
       !cell.post &lt;- "";
       !cell.post_inside &lt;- [];
       open_block "" "";
       </r><U>if</U><r> !cell.w &gt; String.length line <b><U>then</U></b> raise ( Error "Column too wide");
</r></b>1350   <b><U>if</U><r> (!cell.wrap=True) </r><U>then</U> <U>begin</U><w> (* preparation de l'alignement *)
         <r>!cur_out.temp &lt;- <b><U>false</U></b>;
         flags.x_start &lt;- 0;
         flags.x_end &lt;- !cell.w-1;
         flags.hsize &lt;- !cell.w;
<m>1355     <r>flags.first_line &lt;- 0;
         flags.x &lt;- -1;
         flags.last_space &lt;- -1;
         push stacks.s_align flags.align;
         push stacks.s_in_align flags.in_align;
</r>1360     <r>flags.in_align &lt;- <b><U>true</U><r>;
         flags.align &lt;- Left;
       </r><U>end</U></b>;
     ;;
     
</r>1365 
     <b><U>let</U><r> close_cell content =
       </r><U>if</U><r> !verbose&gt;2 <b><U>then</U><r> prerr_endline "=&gt; force_cell";
       </r><U>if</U></b> (!cell.wrap=True) <b><U>then</U> <U>begin</U></b>
         do_flush ();
</r></b>1370     <r>flags.in_align &lt;- pop stacks.s_in_align;
         flags.align &lt;- pop stacks.s_align;
       <b><U>end</U></b>;
       force_block "" content;
       !cell.text&lt;-Out.to_string !cur_out.out;
</r>1375   <r>close_block "TEMP";
       <b><U>if</U><r> !verbose&gt;2 </r><U>then</U></b> prerr_endline ("cell :#"^ !cell.text^
             "#,pre :#"^ !cell.pre^
             "#,post :#"^ !cell.post^
             "#");
</r>1380   </m></r>(* il faut remplir les champs w et h de cell *)
       </w><U>if</U><r> (!cell.wrap = False ) <b><U>then</U><r> !cell.w &lt;- 0;
       !cell.h &lt;- 1;
       </r><U>let</U></b> taille = ref 0 <b><U>in</U>
       <U>for</U></b> i = 0 <b><U>to</U><r> (String.length !cell.text) -1 </r><U>do</U><m>
1385     </m><U>if</U></b> !cell.text.[i]='\n' <b><U>then</U> <U>begin</U></b>
           !cell.h&lt;- !cell.h+1;
           <b><U>if</U><r> (!cell.wrap = False) &amp;&amp; (!taille &gt; !cell.w) </r><U>then</U> <U>begin</U></b>
      !cell.w &lt;- !taille;
           <b><U>end</U></b>;
</r></b>1390       <r>taille:=0;
         <b><U>end</U> <U>else</U> <U>begin</U></b>
           taille:=!taille+1;
         <b><U>end</U><r>;
       </r><U>done</U></b>;
</r>1395   <b><U>if</U><r> (!cell.wrap = False) &amp;&amp; (!taille &gt; !cell.w) </r><U>then</U><r> !cell.w &lt;- !taille;
       !cell.w &lt;- !cell.w + (String.length !cell.pre) + (String.length !cell.post);
       <b><U>if</U><r> !verbose&gt;2 </r><U>then</U></b> prerr_endline ("size : width="^string_of_int !cell.w^
             ", height="^string_of_int !cell.h^
             ", span="^string_of_int !cell.span);
</r></b>1400   <r><b><U>let</U><r> _ = </r><U>match</U></b> !row.cells <b><U>with</U></b>
       | Tabl t -&gt;
           Table.emit t { ver = !cell.ver;
            hor = !cell.hor;
            h = !cell.h;
</r>1405        <r>w = !cell.w;
            wrap = !cell.wrap;
            span = !cell.span;
            text = !cell.text;
            pre  = !cell.pre;
</r>1410        <r>post = !cell.post;
            pre_inside  = !cell.pre_inside;
            post_inside = !cell.post_inside;
          }
       | _ -&gt; raise (Error "Invalid row type")
</r>1415   <b><U>in</U><w>
     
       (* on a la taille de la cellule, on met sa largeur au bon endroit, si necessaire.. *)
       (* Multicolonne : Il faut mettre des zeros dans le tableau pour avoir la taille minimale des colonnes atomiques. Puis on range start,end dans une liste que l'on regardera a la fin pour ajuster les tailles selon la loi : la taille de la multicolonne doit etre &lt;= la somme des tailles minimales. Sinon, il faut agrandir les colonnes atomiques pour que ca rentre. *)
       </w><U>if</U><r> !cell.span = 1 <b><U>then</U> <U>begin</U><m>
1420     </m><U>if</U></b> !table.line = 0 <b><U>then</U><r>
           Table.emit !table.taille !cell.w
         </r><U>else</U>
           <U>begin</U>
      <U>if</U></b> !table.col &gt;= (Array.length !table.tailles) <b><U>then</U><m>
1425    </m><U>begin</U><w> (* depassement du tableau : on l'agrandit.. *)
          </w><U>let</U></b> t = Array.create (!table.col +1) 0 <b><U>in</U><r>
          Array.blit !table.tailles 0 t 0 (Array.length !table.tailles) ;
          !table.tailles &lt;- t;
        </r><U>end</U></b>;
</r></b>1430  <b><U>if</U><r> (!cell.w &gt; (!table.tailles.(!table.col))) </r><U>then</U>
        <U>begin</U><r>
          !table.tailles.(!table.col)&lt;- !cell.w;
        <b><U>end</U><r>;
           </r><U>end</U></b>;
</r></b>1435   <b><U>end</U> <U>else</U> <U>if</U><r> !cell.span = 0 <b><U>then</U> <U>begin</U>
         <U>if</U></b> !table.line = 0 <b><U>then</U><r> Table.emit !table.taille 0;
       </r><U>end</U> <U>else</U> <U>begin</U>
         <U>if</U></b> !table.line=0 <b><U>then</U>
           <U>for</U></b> i = 1 <b><U>to</U></b> !cell.span </r><U>do</U></b>
1440  <r>Table.emit !table.taille 0
           <b><U>done</U><r>;
         multi := (!table.col,!table.col + !cell.span -1,!cell.w) :: !multi;
       </r><U>end</U></b>;
       !table.col &lt;- !table.col + !cell.span -1;
</r>1445   </m></r><U>if</U><r> !cell.h&gt; !row.haut </r><U>then</U><r> !row.haut&lt;- !cell.h;
       !cell.pre &lt;- "";
       !cell.pre_inside &lt;- [];
       <b><U>if</U><r> !verbose&gt;2 </r><U>then</U></b> prerr_endline "&lt;= force_cell";
     ;;
<m>1450 
     <b><U>let</U></b></m> do_close_cell () = close_cell ""
     ;;
     
     <b><U>let</U><r> open_cell_group () = !table.in_cell &lt;- </r><U>true</U></b>;
<m>1455 
     <b><U>and</U></b></m> close_cell_group () = !table.in_cell &lt;- <b><U>false</U><r>;
     
     </r><U>and</U></b> erase_cell_group () = !table.in_cell &lt;- <b><U>false</U><r>;
     ;;
</r><m>1460 
     
     </m><U>let</U></b> erase_cell () =
       <b><U>if</U><r> !verbose&gt;2 </r><U>then</U></b> prerr_endline "erase cell";
       <b><U>if</U><r> (!cell.wrap=True) </r><U>then</U> <U>begin</U><m>
1465     <r>flags.in_align &lt;- pop stacks.s_in_align;
         flags.align &lt;- pop stacks.s_align;
       <b><U>end</U><r>;
       erase_block "";
       </r><U>let</U></b> _ = Out.to_string !cur_out.out <b><U>in</U><m>
1470   <r>erase_block "TEMP";
       !table.col &lt;- !table.col -1;
       !cell.pre &lt;- "";
       !cell.pre_inside &lt;- [];
     ;;
</r>1475 
     </m><U>let</U></b> erase_row () = !table.line &lt;- !table.line -1
     <b><U>and</U><r> close_row erase =
       </r><U>if</U></b> !verbose&gt;2 <b><U>then</U></b> prerr_endline "close_row";
       Table.emit !table.table
</r>1480      <r>{ haut = !row.haut;
          cells = Arr (Table.trim
           (<b><U>match</U><r> !row.cells </r><U>with</U></b>
           | Tabl t -&gt; t
           | _-&gt; raise (Error "Invalid row type")))};
</r>1485 <r>;;
     
     
     <b><U>let</U></b> center_format =
       Tabular.Align  {Tabular.hor="center" ; Tabular.vert = "top" ;
</r>1490      <r>Tabular.wrap = <b><U>false</U></b> ; Tabular.pre = "" ;
          Tabular.post = "" ; Tabular.width = Length.Default}
     ;;
     
     
</r>1495 </m><U>let</U></b> make_border s =
       <b><U>if</U><r> !verbose&gt; 2 </r><U>then</U></b> prerr_endline ("Adding border after column "^string_of_int !table.col^" :'"^s^"'");
     
       <b><U>if</U><r> (!table.col = -1) || not ( !table.in_cell) </r><U>then</U></b>
         !cell.pre &lt;- !cell.pre ^ s
<m>1500   <b><U>else</U></b></m>
         !cell.post &lt;- !cell.post ^ s
     ;;
     
     <b><U>let</U><r> make_inside s multi =
</r><m>1505   </m><U>if</U></b> !verbose&gt;2 <b><U>then</U><r> prerr_endline ("Adding inside after column "^string_of_int !table.col^" :'"^s^"'");
     
       </r><U>if</U></b> (!table.col = -1) || not ( !table.in_cell) <b><U>then</U> <U>begin</U>
         <U>let</U></b> start = String.length !cell.pre <b><U>in</U><r>
         !cell.pre &lt;- !cell.pre ^ s;
</r><m>1510     </m><U>for</U></b> i = start <b><U>to</U><r> String.length !cell.pre -1 </r><U>do</U></b>
           !cell.pre_inside &lt;- i::!cell.pre_inside;
         <b><U>done</U><r>;
       </r><U>end</U> <U>else</U> <U>begin</U>
         <U>let</U></b> start = String.length !cell.post <b><U>in</U><m>
1515     <r>!cell.post &lt;- !cell.post ^ s;
         <b><U>for</U><r> i = start </r><U>to</U></b> String.length !cell.post -1 <b><U>do</U><r>
           !cell.post_inside &lt;- i::!cell.post_inside;
         </r><U>done</U></b>;
       <b><U>end</U></b>;
</r>1520 <r>;;
     
     
     <b><U>let</U></b> make_hline w noborder =
       new_row();
</r>1525   <r>open_cell center_format 0 0;
       close_mods ();
       !cell.w &lt;- 0;
       !cell.wrap &lt;- Fill;
       put_char '-';
</r>1530   <r>close_cell "";
       close_row ();
     ;;
     
     <b><U>let</U></b> text_out j hauteur height align =
</r>1535   </m><U>match</U></b> align <b><U>with</U><r>
       | Top -&gt;    (j &lt; height)
       | Middle -&gt; ((j &gt;= (hauteur-height)/2) &amp;&amp; (j &lt;= ((hauteur-height)/2)+height-1))
       | Bottom -&gt; (j &gt;= hauteur - height)
       | Base i -&gt;
</r><m>1540       </m><U>if</U></b> ( hauteur * i) &gt;= 50 * ( 2*hauteur - height )
           <b><U>then</U><r> (j &gt;= hauteur - height) </r><w>(* Bottom *)
           </w><U>else</U> <U>if</U></b> ( hauteur * i) &lt;= height * 50
           <b><U>then</U><r> (j &lt; height) </r><w>(* Top *)
           </w><U>else</U></b> ((100*j &gt;= i*hauteur - 50*height) &amp;&amp; (100*j &lt; i*hauteur + 50*height)) <w>(* Elsewhere *)
<m>1545 <r>;;
     </r></m>(* dis si oui ou non on affiche la ligne de cette cellule, etant donne l'alignement vertical.*)
     
     <b><U>let</U></b></w> put_ligne texte pos align width taille wrap=
     <w>(* envoie la ligne de texte apres pos, sur out, en alignant horizontalement et en completant pour avoir la bonne taille *)
<m>1550   </m><b><U>let</U></b></w> pos_suiv = <b><U>try</U><r>
         String.index_from texte pos '\n'
       </r><U>with</U></b>
       | Not_found -&gt; String.length texte
       | Invalid_argument _ -&gt;
<m>1555       <b><U>let</U></b></m> l = String.length texte <b><U>in</U>
           <U>assert</U></b> (pos=l) ;
           l
       <b><U>in</U>
       <U>let</U></b> s = String.sub texte pos (pos_suiv - pos) <b><U>in</U><m>
1560   </m><U>let</U></b> t,post=
         <b><U>if</U><r> wrap=True </r><U>then</U></b> String.length s,0
         <b><U>else</U><r> width,width - String.length s </r><U>in</U>
       <U>let</U></b> ligne = <b><U>match</U><r> align </r><U>with</U></b>
       | Left -&gt; String.concat ""
<m>1565  <r>[s; String.make (taille-t+post) ' ']
       | Center -&gt; String.concat ""
      [String.make ((taille-t)/2) ' ';
        s;
        String.make (taille - t + post- (taille-t)/2) ' ']
</r>1570   <r>| Right -&gt; String.concat ""
      [String.make (taille-t) ' ';
        s;
        String.make (post) ' ']
        <b><U>in</U><m>
1575   </m><U>if</U></b> !verbose&gt;2 <b><U>then</U></b> prerr_endline ("line sent :#"^ligne^"#");
       do_put ligne;
       pos_suiv + 1
     ;;
     
</r>1580 
     <b><U>let</U></b></m> put_border s inside j =
       <b><U>for</U><r> i = 0 </r><U>to</U></b> String.length s -1 <b><U>do</U>
         <U>if</U></b> j=0 || not (List.mem i inside) <b><U>then</U><r> do_put_char s.[i]
         </r><U>else</U></b> do_put_char ' ';
<m>1585   <b><U>done</U></b></m>;
     ;;
     
     <b><U>let</U> <U>rec</U></b> somme debut fin =
       <b><U>if</U></b> debut = fin
</r><m>1590   </m><U>then</U></b> !table.tailles.(debut)
       <b><U>else</U><r> !table.tailles.(debut)
           + (somme (debut+1) fin)
     ;;
     
</r><m>1595 
     </m><U>let</U></b> calculate_multi () =
       <w>(* Finalisation des multi-colonnes : on les repasse toutes pour ajuster les tailles eventuellement *)
       <b><U>let</U> <U>rec</U></b></w> do_rec = <b><U>function</U><r>
           [] -&gt; ()
<m>1600     </m>| (debut,fin,taille_mini) :: reste -&gt; </r><U>begin</U>
      <U>let</U></b> taille = somme debut fin <b><U>in</U>
      <U>if</U></b> !verbose&gt;3 <b><U>then</U><r> prerr_endline ("from "^string_of_int debut^
            " to "^string_of_int fin^
            ", size was "^string_of_int taille^
<m>1605        </m>" and should be at least "^string_of_int taille_mini);
      </r><U>if</U></b> taille &lt; taille_mini <b><U>then</U> <U>begin</U><w> (* il faut agrandir *)
        </w><U>if</U></b> !verbose&gt;3 <b><U>then</U><r> prerr_endline ("ajusting..");
        </r><U>for</U></b> i = debut <b><U>to</U><r> fin </r><U>do</U>
          <U>if</U></b> taille = 0
<m>1610      <b><U>then</U></b></m>
            !table.tailles.(debut) &lt;- taille_mini
          <b><U>else</U>
            <U>let</U></b> t = !table.tailles.(i) * taille_mini <b><U>in</U><r>
            !table.tailles.(i) &lt;- (t / taille
<m>1615            </m>+ ( </r><U>if</U></b> 2*(t <b><U>mod</U><r> taille) &gt;= taille </r><U>then</U></b> 1 <b><U>else</U><r> 0));
     
        </r><U>done</U></b>; <w>(* Attention : on agrandit aussi les colonnes p !! *)
      <b><U>end</U></b></w>;
      do_rec reste;
<m>1620     <b><U>end</U>
       <U>in</U>
       <U>if</U></b></m> !verbose&gt;2 <b><U>then</U><r> prerr_endline "Finalizing multi-columns.";
       do_rec !multi;
       </r><U>if</U></b> !verbose&gt;2 <b><U>then</U><r> prerr_endline "Finalized multi-columns.";
<m>1625 </m>;;
     
     
     </r><U>let</U></b> close_table () =
       <b><U>if</U><r> !verbose&gt;2 </r><U>then</U> <U>begin</U><m>
1630     <r>prerr_endline "=&gt; close_table";
         pretty_stack out_stack
       <b><U>end</U><r>;
       </r><U>if</U></b> !table.line=0 <b><U>then</U><r>  !table.tailles&lt;-Table.trim !table.taille;
       </r><U>let</U></b> tab = Table.trim !table.table <b><U>in</U><m>
1635   <w>(* il reste a formatter et a flusher dans la sortie principale.. *)
       <r>!table.lines&lt;-Array.length tab;
       <b><U>if</U><r> !verbose&gt;2 </r><U>then</U></b> prerr_endline ("lines :"^string_of_int !table.lines);
     
       calculate_multi ();
<m>1640 
       <r>!table.width &lt;- somme 0 (Array.length !table.tailles -1);
       finit_ligne();
     
       <b><U>if</U><r> !table.width &gt; flags.hsize </r><U>then</U></b> warning ("overfull line in array : array too wide");
</r>1645 
       <b><U>for</U></b></m> i = 0 <b><U>to</U><r> !table.lines - 1 </r><U>do</U>
         <U>let</U></b> ligne = <b><U>match</U><r> tab.(i).cells </r><U>with</U></b>
         | Arr a -&gt; a
         | _-&gt; raise (Error "Invalid row type:table")
<m>1650     <b><U>in</U><w>
         (* affichage de la ligne *)
         (* il faut envoyer ligne apres ligne dans chaque cellule, en tenant compte de l'alignement vertical et horizontal..*)
         </w><U>if</U></b></m> !verbose&gt;2 <b><U>then</U><r> prerr_endline ("line "^string_of_int i^", columns:"^string_of_int (Array.length ligne)^", height:"^string_of_int tab.(i).haut);
         </r><U>let</U></b> pos = Array.create (Array.length ligne) 0 <b><U>in</U><m>
1655     <r>!row.haut &lt;-0;
         <b><U>for</U><r> j = 0 </r><U>to</U></b> tab.(i).haut -1 <b><U>do</U>
           <U>if</U></b> not ( i=0 &amp;&amp; j=0) <b><U>then</U><r> do_put_char '\n';
           </r><U>let</U></b> col = ref 0 <b><U>in</U>
           <U>for</U></b> k = 0 <b><U>to</U><r> Array.length ligne -1 </r><U>do</U><m>
1660  </m><U>begin</U><w>
        (* ligne j de la cellule k *)
        </w><U>if</U></b> ligne.(k).wrap = Fill <b><U>then</U><r> ligne.(k).span &lt;- Array.length !table.tailles;
        </r><U>let</U></b> taille_borders = (String.length ligne.(k).pre) + (String.length ligne.(k).post) <b><U>in</U>
        <U>let</U></b> taille = (somme !col (!col + ligne.(k).span-1)) - taille_borders <b><U>in</U><m>
1665    </m><U>if</U></b> !verbose&gt;3 <b><U>then</U></b> prerr_endline ("cell to output:"^
              ligne.(k).pre^
              ligne.(k).text^
              ligne.(k).post^
              ", taille="^string_of_int taille);
</r>1670 
        <r>put_border ligne.(k).pre ligne.(k).pre_inside j;
     
        <b><U>if</U><r> (text_out j tab.(i).haut ligne.(k).h ligne.(k).ver)
            &amp;&amp; (ligne.(k).wrap &lt;&gt; Fill )</r><U>then</U> <U>begin</U><m>
1675      <r>pos.(k) &lt;-
            put_ligne
       ligne.(k).text
       pos.(k)
       ligne.(k).hor
</r>1680   <r>(ligne.(k).w - taille_borders)
       taille
       ligne.(k).wrap
        <b><U>end</U> <U>else</U>
          <U>if</U></b> ligne.(k).wrap = Fill <b><U>then</U></b> do_put (String.make taille ligne.(k).text.[0])
</r>1685      </m><U>else</U></b> do_put (String.make taille ' ');
        col := !col + ligne.(k).span;
        put_border ligne.(k).post ligne.(k).post_inside j;
      <b><U>end</U><r>;
           </r><U>done</U></b>;
</r>1690       </m><U>if</U></b> !col&lt; Array.length !table.tailles -1 <b><U>then</U> <U>begin</U>
      <U>let</U></b> len = !table.width - (somme 0 (!col-1)) <b><U>in</U><r>
      do_put ( String.make len ' ');
           </r><U>end</U></b>;
         <b><U>done</U><r>;
</r><m>1695   </m><U>done</U></b>;
     
       flags.align &lt;- pop stacks.s_align;
       table := pop table_stack;
       row := pop row_stack;
<m>1700   <r>cell := pop cell_stack;
       multi := pop multi_stack;
       flags.in_table &lt;- pop stacks.s_in_table;
       close_block "";
       <b><U>if</U><r> not (flags.in_table) </r><U>then</U></b> finit_ligne ();
</r>1705   <b><U>if</U></b></m> !verbose&gt;2 <b><U>then</U></b> prerr_endline "&lt;= close_table"
     ;;
     
     
     </r>(* Info *)
</w>1710 
     
     </m><U>let</U></b> infomenu arg = ()
     ;;
     
</r>1715 </m><U>let</U></b> infonode opt num arg = ()
     <b><U>and</U><r> infoextranode num arg text = ()
     ;;
     
     </r><w>(* Divers *)
<m>1720 
     <b><U>let</U><r> is_blank s =
       </r><U>let</U><r> b = ref <b><U>true</U> <U>in</U>
       <U>for</U></b> i = 0 <b><U>to</U><r> String.length s </r><U>do</U></b>
         b := !b &amp;&amp; s.[i]=' '
</r></b>1725   <b><U>done</U><r>;
       !b
     ;;
     
     </r><U>let</U><r> is_empty () =
<m>1730   </m>flags.in_table &amp;&amp; (Out.is_empty !cur_out.out) &amp;&amp; (flags.x= -1);;
     
     <b><U>let</U><r> image arg n =
         </r><U>if</U></b> arg &lt;&gt; "" <b><U>then</U> <U>begin</U></b>
         put arg;
<m>1735     </m>put_char ' '
       <b><U>end</U><r>
     ;;
     
     </r><U>let</U></b> horizontal_line s width height =
<m>1740   <b><U>if</U><r> flags.in_table </r><U>then</U> <U>begin</U><r>
         !cell.w &lt;- 0;
         !cell.wrap &lt;- Fill;
         put_char '-';
       </r><U>end</U> <U>else</U> <U>begin</U></b>
1745     </m>open_block "INFO" "";
         finit_ligne ();
         <b><U>let</U><r> taille = </r><U>match</U></b> width <b><U>with</U><r>
         | Char x -&gt; x
         | Pixel x -&gt; x / Length.font
<m>1750     </m>| Percent x -&gt; (flags.hsize -1) * x / 100
         | Default   -&gt; flags.hsize - 1
         | No s      -&gt; raise (Fatal ("No-length ``"^s^"'' in out-manager")) </r><U>in</U>
         <U>let</U></b> ligne = String.concat ""
      [(<b><U>match</U></b> s </r><U>with</U></b>
1755  <r>| "right" -&gt; String.make (flags.hsize - taille -1) ' '
      | "center" -&gt; String.make ((flags.hsize - taille)/2) ' '
      | _ -&gt; "");
        String.make taille '-'] <b><U>in</U></b>
         put ligne;
</r>1760     <r>finit_ligne ();
         close_block "INFO";
       <b><U>end</U></b>
     ;;
     
</r>1765 
     </m>(*------------*)
     (*---MATHS ---*)
     (*------------*)
     
<m>1770 <b><U>let</U><r> cm_format =
       Tabular.Align  {Tabular.hor="center" ; Tabular.vert = "middle" ;
          Tabular.wrap = </r><U>false</U><r> ; Tabular.pre = "" ;
          Tabular.post = "" ; Tabular.width = Length.Default}
     ;;
</r></b>1775 <b><U>let</U><r> lm_format =
       Tabular.Align  {Tabular.hor="left" ; Tabular.vert = "middle" ;
          Tabular.wrap = </r><U>false</U><r> ; Tabular.pre = "" ;
          Tabular.post = "" ; Tabular.width = Length.Default}
     ;;
</r></b>1780 
     <b><U>let</U><r> formated s = Tabular.Align
         { Tabular.hor=
           (</r><U>match</U><r> s <b><U>with</U></b>
           | "cm" | "cmm" | "cb" | "ct" -&gt; "center"
</r></b>1785       <r>|       "lt" | "lb" | "lm" -&gt; "left"
           | _ -&gt; "left") ;
           Tabular.vert =
           (<b><U>match</U><r> s </r><U>with</U></b>
           | "cm" | "lm" -&gt;"middle"
</r>1790       <r>| "lt" | "ct" -&gt; "top"
           | "lb" | "cb" -&gt; "bottom"
           | "cmm" -&gt; "45"
           | _ -&gt; "middle") ;
           Tabular.wrap = <b><U>false</U></b> ; Tabular.pre = "" ;
</r>1795       <r>Tabular.post = "" ; Tabular.width = Length.Default}
     ;;
     
     
     
</r>1800 <b><U>let</U><r> freeze f =
       push out_stack (Freeze f) ;
       </r><U>if</U><r> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
         prerr_string "freeze: stack=" ;
         pretty_stack out_stack
</r></b>1805   <b><U>end</U><r>
     ;;
     
     </r><U>let</U><r> flush_freeze () = <b><U>match</U><r> top out_stack </r><U>with</U></b>
       Freeze f -&gt;
</r></b>1810     <b><U>let</U><r> _ = pop out_stack </r><U>in</U>
         <U>if</U><r> !verbose &gt; 2 <b><U>then</U> <U>begin</U></b>
           prerr_string "flush_freeze" ;
           pretty_stack out_stack
         <b><U>end</U><r> ;
<m>1815     </m>f () ; </r><U>true</U></b>
     | _ -&gt; <b><U>false</U><r>
     ;;
     
     </r><U>let</U></b> pop_freeze () = <b><U>match</U></b> top  out_stack </r><U>with</U></b>
1820   <r>Freeze f -&gt;
         <b><U>let</U><r> _ = pop out_stack </r><U>in</U></b>
         f,<b><U>true</U><r>
     | _ -&gt; (</r><U>fun</U></b> () -&gt; ()),<b><U>false</U></b>
     ;;
</r>1825 
     </m>(* Displays *)
     </w><U>let</U></b> open_display args =
       open_table (!verbose&gt;1) "";
       new_row ();
<m>1830   <b><U>if</U></b></m> !verbose &gt; 1 <b><U>then</U><r> make_border "{";
       open_cell cm_format 1 0;
       open_cell_group ();
     ;;
     
</r><m>1835 </m><U>let</U></b> close_display () =
       <b><U>if</U><r> not (flush_freeze ()) </r><U>then</U> <U>begin</U>
         <U>if</U></b> !verbose &gt; 1 <b><U>then</U><r> make_border "}";
         close_cell_group ();
         close_cell ();
<m>1840     </m>close_row ();
         close_table ();
       </r><U>end</U></b>;
     ;;
     
<m>1845 <b><U>let</U></b></m> item_display () =
       <b><U>let</U><r> f,is_freeze = pop_freeze () </r><U>in</U>
       <U>if</U></b> !verbose &gt; 1 <b><U>then</U><r> make_border "|";
       close_cell ();
       close_cell_group ();
<m>1850   </m>open_cell cm_format 1 0;
       open_cell_group ();
       </r><U>if</U></b> is_freeze <b><U>then</U><r> freeze f;
     ;;
     
</r><m>1855 </m><U>let</U></b> item_display_format format =
       <b><U>let</U><r> f,is_freeze = pop_freeze () </r><U>in</U>
       <U>if</U></b> !verbose &gt; 1 <b><U>then</U><r> make_border "|";
       close_cell ();
       close_cell_group ();
<m>1860   </m>open_cell (formated format) 1 0;
       open_cell_group ();
       </r><U>if</U></b> is_freeze <b><U>then</U><r> freeze f;
     ;;
     
</r><m>1865 </m><U>let</U></b> force_item_display () = item_display ()
     ;;
     
     <b><U>let</U><r> erase_display () =
       erase_cell ();
</r><m>1870   <r>erase_cell_group ();
       erase_row ();
       close_table ();
     ;;
     
</r>1875 
     </m><U>let</U></b> open_maths display =
       <b><U>if</U><r> !verbose &gt;1 </r><U>then</U></b>
         prerr_endline "open_maths";
       <b><U>if</U><r> display </r><U>then</U> <U>begin</U><m>
1880     <r>open_block "ALIGN" "CENTER";
     
         open_display "";
         flags.first_line &lt;- 0;
     
</r>1885     <r>open_display ""
       <b><U>end</U> <U>else</U></b> open_block "" "";
     
     <b><U>and</U><r> close_maths display =
       </r><U>if</U></b> display <b><U>then</U> <U>begin</U><m>
1890     <r>close_display ();
         close_display ();
         close_block "ALIGN";
       <b><U>end</U> <U>else</U></b> close_block "";
       <b><U>if</U><r> !verbose&gt;1 </r><U>then</U><m>
1895     <r>prerr_endline "close_maths";
     ;;
     
     
     
</r>1900 </m><U>let</U></b> open_vdisplay display =
       open_table (!verbose&gt;1) "";
     
     <b><U>and</U></b> close_vdisplay () =
       close_table ();
</r>1905 
     </m><U>and</U></b> open_vdisplay_row s =
       new_row ();
       <b><U>if</U><r> !verbose &gt; 0 </r><U>then</U></b> make_border "[";
       open_cell (formated s) 1 0;
</r>1910   <r>open_cell_group ();
       open_display "";
     
     <b><U>and</U></b> close_vdisplay_row () =
       close_display ();
</r>1915   </m><U>if</U></b> !verbose &gt; 0 <b><U>then</U><r> make_border "]";
       close_cell ();
       close_cell_group ();
       close_row ();
       </r><U>if</U></b> !verbose &gt; 0 <b><U>then</U><r> make_hline 0 </r><U>false</U></b>;
<m>1920 <r>;;
     
     <b><U>let</U><r> insert_sup_sub () =
       </r><U>let</U></b> f,is_freeze = pop_freeze () <b><U>in</U>
       <U>let</U></b> ps,parg,pout = pop_out out_stack <b><U>in</U><m>
1925   </m><U>if</U></b> ps &lt;&gt; "" <b><U>then</U><r> failclose ("sup_sub : "^ps^" closes \"\"");
       </r><U>let</U></b> new_out = newstatus <b><U>false</U><r> [] [] </r><U>true</U> <U>in</U></b>
       push_out out_stack (ps,parg,new_out);
       close_block "";
       cur_out := pout;
</r>1930   <r>open_block "" "";
       <b><U>if</U><r> is_freeze </r><U>then</U></b> freeze f;
       open_display "";
       <b><U>let</U><r> s =(Out.to_string new_out.out) </r><U>in</U></b>
       do_put s;
</r>1935   <r>flags.empty &lt;- (s="");
       free new_out;
     ;;
     
     
</r>1940 <b><U>let</U></b></m> standard_sup_sub scanner what sup sub display =
       <b><U>if</U><r> display </r><U>then</U> <U>begin</U></b>
         insert_sup_sub ();
         <b><U>let</U><r> f,ff = </r><U>match</U></b> sup.arg,sub.arg <b><U>with</U><r>
         | "","" -&gt; "cm","cm"
<m>1945     </m>| "",_ -&gt; change_format (formated "lt"); "lb","cm"
         | _,"" -&gt; change_format (formated "lm"); "lt","cmm"
         | _,_ -&gt; "cm","cm"
         </r><U>in</U>
         <U>let</U></b> vide= flags.empty <b><U>in</U><m>
1950     <r>item_display_format f ;
         <b><U>if</U><r> sup.arg &lt;&gt;"" || sub.arg&lt;&gt;"" </r><U>then</U> <U>begin</U></b>
           open_vdisplay display;
           <w>(*if sup&lt;&gt;"" || vide then*) <b><U>begin</U></b></w>
      open_vdisplay_row "lt";
</r>1955  <r>scanner sup ;
      close_vdisplay_row ();
           <b><U>end</U></b>;
           open_vdisplay_row "lm";
           what ();
</r>1960       <r>close_vdisplay_row ();
           <b><U>if</U><r> sub.arg &lt;&gt;"" || vide </r><U>then</U> <U>begin</U></b>
      open_vdisplay_row "lb";
      scanner sub ;
      close_vdisplay_row ();
</r>1965       </m><U>end</U></b>;
           close_vdisplay ();
           item_display ();
         <b><U>end</U> <U>else</U></b> what ();
         close_display ();
<m>1970     </m>change_format (formated ff);
         item_display ();
       <b><U>end</U> <U>else</U> <U>begin</U></b>
         what ();
         <b><U>if</U></b> sub.arg &lt;&gt; "" </r><U>then</U> <U>begin</U><m>
1975       <r>put "_";
           scanner sub;
         <b><U>end</U><r>;
         </r><U>if</U></b> sup.arg &lt;&gt; "" <b><U>then</U> <U>begin</U></b>
           put "^";
</r>1980       <r>scanner sup;
         <b><U>end</U><r>;
       </r><U>end</U>
     
     <U>and</U></b> limit_sup_sub scanner what sup sub display =
</r>1985   <r>item_display ();
       open_vdisplay display;
       open_vdisplay_row "cm";
       scanner sup;
       close_vdisplay_row ();
</r>1990   <r>open_vdisplay_row "cm";
       what ();
       close_vdisplay_row ();
       open_vdisplay_row "cm";
       scanner sub;
</r>1995   <r>close_vdisplay_row ();
       close_vdisplay ();
       item_display ();
     
     <b><U>and</U></b> int_sup_sub something vsize scanner what sup sub display =
</r>2000   </m><U>if</U><r> something <b><U>then</U><r> what ();
       item_display ();
       open_vdisplay display;
       open_vdisplay_row "lm";
       scanner sup;
</r><m>2005   <r>close_vdisplay_row ();
       open_vdisplay_row "lm";
       put "";
       close_vdisplay_row ();
       open_vdisplay_row "lm";
</r>2010   <r>scanner sub;
       close_vdisplay_row ();
       close_vdisplay ();
       item_display ();
     ;;
</r>2015 
     
     </m><U>let</U></b> insert_vdisplay open_fun =
       <b><U>let</U><r> ps,parg,pout = pop_out out_stack </r><U>in</U>
       <U>if</U></b> ps &lt;&gt; "" <b><U>then</U><m>
2020     <r>failclose ("insert_vdisplay : "^ps^" closes the cell.");
       <b><U>let</U><r> pps,pparg,ppout = pop_out out_stack </r><U>in</U>
       <U>if</U></b> pps &lt;&gt; "TEMP" <b><U>then</U><r>
         failclose ("insert_vdisplay : "^pps^" closes the cell2.");
       </r><U>let</U></b> ts,targ,tout = pop_out out_stack <b><U>in</U><m>
2025   </m><U>if</U></b> ts &lt;&gt; "" <b><U>then</U><r>
         failclose ("insert_vdisplay : "^ts^" closes the table.");
     
       </r><U>let</U></b> new_out = newstatus <b><U>false</U><r> [] [] tout.temp </r><U>in</U></b>
       push_out out_stack (ts,targ,new_out);
</r>2030   <r>push_out out_stack (pps,pparg,ppout);
       push_out out_stack (ps,parg,pout);
       close_display ();
     
     
</r>2035   <r>cur_out :=tout;
       open_display "";
       open_fun ();
     
       <b><U>let</U><r> s = Out.to_string new_out.out </r><U>in</U><m>
2040   <r>put s;
       free new_out;
       []
     ;;
     
</r>2045 
     
     </m><U>let</U></b> over display lexbuf =
       <b><U>if</U><r> !verbose&gt;1 </r><U>then</U></b>
         prerr_endline "over";
</r>2050   </m><U>if</U></b> display <b><U>then</U> <U>begin</U>
         <U>let</U></b> _=insert_vdisplay
      ( <b><U>fun</U><r> () -&gt;
        </r><U>begin</U></b>
          open_vdisplay display;
<m>2055      <r>open_vdisplay_row "cm";
        <b><U>end</U><r>) </r><U>in</U></b>
         close_vdisplay_row ();
         make_hline 0 <b><U>false</U></b>;
         open_vdisplay_row "cm";
</r>2060     <r>freeze (<b><U>fun</U><r> () -&gt;
           close_vdisplay_row ();
           close_vdisplay ();
           close_display (););
       </r><U>end</U> <U>else</U> <U>begin</U><m>
2065     <r>put "/";
       <b><U>end</U>
     
     <U>let</U></b> translate = <b><U>function</U></b>
       "&lt;" -&gt; "&lt;"
</r>2070 <r>| "&gt;" -&gt; "&gt;"
     | "\\{" -&gt; "{"
     | "\\}" -&gt; "}"
     | s   -&gt; s
     ;;
</r>2075 
     </m><U>let</U></b> left delim k =
       item_display ();
       open_display "";
       close_cell_group ();
</r>2080   <b><U>if</U></b></m> delim&lt;&gt;"." <b><U>then</U><r> make_border (translate delim);
       k 3 ;
       open_cell_group ();
     ;;
     
</r><m>2085 </m><U>let</U></b> right delim =
       <b><U>let</U><r> vsize = 3 </r><U>in</U>
       <U>if</U></b> delim&lt;&gt;"." <b><U>then</U><r> make_border (translate delim);
       item_display ();
       close_display ();
<m>2090   </m>vsize
     ;;
     
     </r><w>(*
       C'est fini, elegamment
<m>2095 </m>*)<r><PL><B>
<6>118 thread.ml</6>
</B></PL></r> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(***********************************************************************)
     
     </w><U>let</U></b> header = "$Id: thread.ml,v 1.4 2000/05/22 12:19:14 maranget Exp $"
     <b><U>let</U><r> uptable = Hashtbl.create 17
     </r><U>and</U></b> nexttable = Hashtbl.create 17
  <m>15 <b><U>and</U></b></m> prevtable = Hashtbl.create 17
     ;;
     
     <b><U>let</U><r> setup file upname = Hashtbl.add uptable file (ref upname)
     </r><U>and</U></b> setprev file prevname = Hashtbl.add prevtable file (ref prevname)
  <m>20 <b><U>let</U></b></m> setnext file nextname = Hashtbl.add nexttable file (ref nextname)
     ;;
     
     <b><U>let</U><r> setprevnext prev now =
       </r><U>if</U></b> prev &lt;&gt; "" <b><U>then</U> <U>begin</U><m>
  25     <r>Hashtbl.add nexttable prev (ref now) ;
         Hashtbl.add prevtable now (ref prev)
       <b><U>end</U></b>
     ;;
     
  </r>30 </m><U>let</U></b> next name = !(Hashtbl.find nexttable name)
     <b><U>and</U><r> up   name = !(Hashtbl.find uptable name)
     </r><U>and</U></b> prev name = !(Hashtbl.find prevtable name)
     ;;
     
  <m>35 <b><U>let</U></b></m> change_aux t oldname name =
       <b><U>let</U><r> olds = Hashtbl.find_all t oldname </r><U>in</U></b>
       List.iter
         (<b><U>fun</U><r> s -&gt;
           Hashtbl.remove t oldname ;
  <m>40       </m>Hashtbl.add t name s)
         olds ;
       Hashtbl.iter
         (</r><U>fun</U></b> k x -&gt;
           <b><U>if</U><r> !x = oldname </r><U>then</U> <U>begin</U><m>
  45         <r>x := name
           <b><U>end</U><r>)
         t
     
     </r><U>let</U></b> change oldname name =
  </r>50   <r>change_aux nexttable oldname name ;
       change_aux prevtable oldname name ;
       change_aux uptable oldname name<PL><B>
<6>119 ultra.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: ultra.ml,v 1.8 2001/06/05 17:57:41 maranget Exp $             *)
     (***********************************************************************)
     
     </w><b><U>open</U><r> Tree
     </r><U>open</U></b> Htmltext
  </r>15 </m><U>open</U></b> Util
     
     <b><U>let</U><r> verbose = ref 0
     
     </r><U>let</U></b> same_prop f s =
  <m>20   <b><U>try</U>
         <U>let</U></b></m> p = Htmltext.get_prop f.nat <b><U>in</U><r>
         List.exists (</r><U>fun</U></b> s -&gt; p s.nat) s
       <b><U>with</U><r>
       | NoProp -&gt; </r><U>false</U><m>
  25 
     </m><U>let</U> <U>rec</U></b> part_factor some blanks i s keep leave = </r><U>function</U></b></TT><r><TT>
       | [] -&gt; keep,leave
       | ((f,_) <b><U>as</U><r> x)::rem </r><U>when</U></b> there f s ||
         same_prop f s ||
  <m>30     <r>(blanks &amp;&amp; Htmltext.blanksNeutral f)-&gt;
           part_factor some blanks i s (x::keep) leave rem
       | (f,j)::rem -&gt;
           part_factor some blanks i s keep
             (some f j (i-1) leave) rem
  </r>35 
     <b><U>let</U><r> there_factor s fs =  List.exists (</r><U>fun</U><r> (f,_) -&gt; same_style s f) fs
     
     <b><U>let</U> <U>rec</U></b> start_factor i fs start = <b><U>function</U><r>
       | [] -&gt; start
  <m>40   </m>| s::rem </r><U>when</U></b> there_factor s fs -&gt;
           start_factor i fs start rem
       | s::rem -&gt;
           start_factor i fs ((s,i)::start) rem
     
  <m>45 <b><U>let</U></b></m> extend_factors some blanks i s r fs =
       <b><U>let</U><r> keep,leave = part_factor some blanks i s [] r fs </r><U>in</U></b>
       start_factor i fs keep s,leave
     
     
  <m>50 <b><U>let</U> <U>rec</U></b></m> part_factor_neutral some i keep leave = <b><U>function</U><r>
       | [] -&gt; keep,leave
       | ((f,_) </r><U>as</U></b> x)::rem <b><U>when</U><r> Htmltext.blanksNeutral f -&gt;
           part_factor_neutral some i (x::keep) leave rem
       | (f,j)::rem -&gt;
  <m>55       </m>part_factor_neutral some i keep (some f j (i-1) leave) rem
     
     </r><U>let</U></b> extend_factors_neutral some i r fs = part_factor_neutral some i [] r fs
     
     
  <m>60 <b><U>let</U></b></m> finish_factors some i r fs = part_factor some <b><U>false</U><r> i [] [] r fs
     
     </r><U>let</U></b> pfactor chan fs =
       List.iter
         (<b><U>fun</U><r> ((i,j),f) -&gt;
  <m>65       </m>Printf.fprintf chan " %d,%d:%s" i j f.txt)
         fs ;
       output_char chan '\n'
     
     </r><U>let</U></b> covers (i1:int) (j1:int) i2 j2 =
  <m>70   <r>(i1 &lt;= i2 &amp;&amp; j2 &lt; j1) ||
       (i1 &lt; i2 &amp;&amp;  j2 &lt;= j1)
     
     
     <b><U>let</U> <U>rec</U></b> all_blanks ts i j =
  </r>75   <b><U>if</U></b></m> i &lt;= j <b><U>then</U><r>
         is_blank ts.(i) &amp;&amp; all_blanks ts (i+1) j
       </r><U>else</U>
         <U>true</U><m>
     
  80 </m><U>let</U> <U>rec</U></b> get_same ts i j f = <b><U>function</U><r>
       | [] -&gt; ((i,j),f)
       | ((ii,jj),g)::rem </r><U>when</U></b>
            covers i j ii jj &amp;&amp;
            all_blanks ts i (ii-1) &amp;&amp;
  <m>85        <r>all_blanks ts (jj+1) j -&gt; ((ii,jj),f)
       | _::rem -&gt; get_same ts i j f rem
     
     <b><U>let</U><r> get_sames ts fs =
       </r><U>let</U> <U>rec</U></b> do_rec r = <b><U>function</U><m>
  90     <r>| [] -&gt; r
         | (((i,j),f) <b><U>as</U><r> x)::rem -&gt;
             do_rec
               (</r><U>if</U></b> blanksNeutral f <b><U>then</U></b>
                 get_same ts i j f fs::r
  </r>95           </m><U>else</U></b>
                 x::r)
               rem <b><U>in</U></b>
       do_rec [] fs
     
 </r>100 
     
     <b><U>let</U></b></m> group_font ts fs =
       <b><U>let</U><r> fonts,no_fonts =
         List.partition (</r><U>fun</U></b> (_,f) -&gt; is_font f.nat) fs <b><U>in</U><m>
 105   <r>get_sames ts fonts@no_fonts
     
     <b><U>let</U><r> conflict_low i1 j1 i2 j2 =  i1 &lt; i2 &amp;&amp; i2 &lt;= j1 &amp;&amp; j1 &lt; j2
     
     </r><U>let</U></b> correct_cfl_low ts i1 j1 i2 j2 =
 </r>110   </m><U>if</U></b> conflict_low i1 j1 i2 j2 &amp;&amp;
         all_blanks ts i1 (i2-1)
       <b><U>then</U><r>
         i1
       </r><U>else</U><m>
 115     <r>i2
     
     <b><U>and</U><r> correct_cfl_high ts i1 j1 i2 j2 =
       </r><U>if</U></b> conflict_low i1 j1 i2 j2 &amp;&amp;
         all_blanks ts (j1+1) j2
 </r>120   </m><U>then</U></b>
         j2
       <b><U>else</U><r>
         j1
     
 </r><m>125 
     
     
     
     </m><U>let</U> <U>rec</U></b> mk_cover_one ts i j f = <b><U>function</U><m>
 130   <r>| [] -&gt; (i,j),f
       | ((ii,jj),g)::rem -&gt;
           mk_cover_one
             ts
             (correct_cfl_low ts ii jj i j)
 </r>135         <r>(correct_cfl_high ts i j ii jj)
             f rem
     
     <b><U>let</U> <U>rec</U></b> mk_cover ts fs = <b><U>function</U></b>
       | [] -&gt; []
 </r>140   <r>| ((i,j),f)::rem -&gt;
           mk_cover_one ts i j f fs :: mk_cover ts fs rem
     
     <b><U>let</U><r> extend_neutrals ts fs =
       </r><U>let</U></b> neutral,not_neutral =
 </r>145     <r>List.partition (<b><U>fun</U><r> (_,f) -&gt; blanksNeutral f) fs </r><U>in</U></b>
       mk_cover ts fs neutral @ not_neutral
     
     <b><U>let</U><r> factorize low high ts =
       </r><U>if</U></b> low &gt;= high <b><U>then</U></b> []
 </r>150   </m><U>else</U>
       <U>let</U></b> extend_blanks_left i =
         <b><U>let</U> <U>rec</U></b> do_rec i =
           <b><U>if</U><r> i &lt;= low </r><U>then</U></b> low
           <b><U>else</U> <U>begin</U><m>
 155         </m><U>if</U></b> is_blank ts.(i-1) <b><U>then</U><r>
               do_rec (i-1)
             </r><U>else</U></b>
               i
           <b><U>end</U> <U>in</U><m>
 160     <r>do_rec i
     
       <b><U>and</U><r> limit_blanks_right i =
         </r><U>let</U> <U>rec</U></b> do_rec i =
           <b><U>if</U><r> i &lt;= low </r><U>then</U></b> low
 </r>165       </m><U>else</U> <U>begin</U>
             <U>if</U></b> is_blank ts.(i) <b><U>then</U><r>
               do_rec (i-1)
             </r><U>else</U></b>
               i
 <m>170       <b><U>end</U> <U>in</U></b></m>
         do_rec i <b><U>in</U>
     
       <U>let</U></b> correct_prop f i j env =
         <b><U>try</U><m>
 175       </m><U>let</U></b> _ = Htmltext.get_prop f.nat <b><U>in</U>
           <U>let</U> <U>rec</U></b> find_same  k = <b><U>match</U><r> ts.(k) </r><U>with</U></b>
             | Node (s,_) <b><U>when</U></b> there f s -&gt; k
             | _ -&gt; find_same (k-1) </r><U>in</U>
           <U>let</U><r> j = find_same j </r><U>in</U><m>
 180       </m><U>if</U><r> j=i || (blanksNeutral f &amp;&amp; all_blanks ts i (j-1)) <b><U>then</U><r>
             env
           </r><U>else</U></b>
             ((i,j),f)::env
         <b><U>with</U><m>
 185     <r>| NoProp -&gt; ((i,j),f)::env <b><U>in</U>
     
       <U>let</U></b> some f i j env =
           <b><U>if</U><r> not (Htmltext.blanksNeutral f) </r><U>then</U> <U>begin</U>
             <U>if</U></b> j-i &gt; 0 <b><U>then</U><m>
 190           <r>correct_prop f i j env
             <b><U>else</U><r>
               env
           </r><U>end</U> <U>else</U> <U>begin</U>
             <U>let</U></b> r = ref 0 <b><U>in</U><m>
 195         </m><U>for</U></b> k = i <b><U>to</U><r> j </r><U>do</U>
               <U>if</U></b> not (is_blank ts.(k)) <b><U>then</U><r> incr r
             </r><U>done</U></b> ;
             <b><U>if</U><r> !r &gt; 1 </r><U>then</U></b>
               correct_prop f i (limit_blanks_right j) env
 </r>200         </m><U>else</U></b>
               env
           <b><U>end</U> <U>in</U>
     
       <U>let</U> <U>rec</U></b> do_rec i r fs =
 </r>205     </m><U>if</U></b> i &lt;= high <b><U>then</U> <U>begin</U>
           <U>let</U></b> fs,r = <b><U>match</U><r> ts.(i) </r><U>with</U></b>
             | Node (s,ts) -&gt;
                 extend_factors some (is_blanks ts) i s r fs
             | t -&gt;
 <m>210             <b><U>if</U></b></m> is_blank t <b><U>then</U><r>
                   extend_factors_neutral some i r fs
                 </r><U>else</U></b>
                   finish_factors some i r fs <b><U>in</U><r>
           do_rec (i+1) r fs
 </r><m>215     </m><U>end</U> <U>else</U>
           <U>let</U></b> _,r = finish_factors some i r fs <b><U>in</U><r>
           r </r><U>in</U>
       <U>let</U></b> r = do_rec low [] [] <b><U>in</U>
       <U>let</U></b> r = group_font ts r <b><U>in</U><m>
 220   </m><U>let</U></b> r = extend_neutrals ts r <b><U>in</U>
       <U>if</U></b> r &lt;&gt; [] &amp;&amp; !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
         Printf.fprintf stderr "Factors in %d %d\n" low high ;
         <b><U>for</U><r> i=low </r><U>to</U></b> high <b><U>do</U><r>
           Pp.tree stderr ts.(i)
 </r><m>225     </m><U>done</U></b> ;
         prerr_endline "\n*********" ;
         pfactor stderr r
       <b><U>end</U><r> ;
       r
 </r><m>230 
     </m><U>let</U></b> same ((i1,j1),_) ((i2,j2),_) = i1=i2 &amp;&amp; j1=j2
     
     <b><U>let</U><r> covers_cost ((((i1:int),(j1:int)),_),_) (((i2,j2),_),_) =
       covers i1 j1 i2 j2
 </r><m>235 
     </m><U>let</U></b> biggest fs =
       <b><U>let</U> <U>rec</U></b> through r = <b><U>function</U><r>
         | [] -&gt; r
         | x::rem -&gt;
 </r><m>240         </m><U>if</U></b> List.exists (<b><U>fun</U><r> y -&gt; covers_cost y x) rem </r><U>then</U></b>
               through r rem
             <b><U>else</U><r>
               through (x::r) rem </r><U>in</U></b>
       through [] (through [] fs)
 <m>245 
     <b><U>let</U></b></m> conflicts ((i1,j1),_) ((i2,j2),_) =
       (i1 &lt; i2 &amp;&amp; i2 &lt;= j1 &amp;&amp; j1 &lt; j2) ||
       (i2 &lt; i1 &amp;&amp; i1 &lt;= j2 &amp;&amp; j2 &lt; j1)
     
 <m>250 
     <b><U>let</U></b></m> num_conflicts f fs =
       List.fold_left
         (<b><U>fun</U><r> r g -&gt;
           </r><U>if</U></b> conflicts f g <b><U>then</U><r> 1+r </r><U>else</U></b> r)
 <m>255     <r>0 fs
     
     <b><U>let</U><r> put_conflicts fs =
       List.fold_left
         (</r><U>fun</U></b> r g -&gt; (g,num_conflicts g fs)::r)
 </r>260     <r>[] fs
     
     
     <b><U>let</U> <U>rec</U></b> add f = <b><U>function</U><r>
       | [] -&gt; </r><U>let</U></b> i,f = f <b><U>in</U></b> [i,[f]]
 </r>265   <r>| x::rem <b><U>as</U><r> r -&gt;
           </r><U>if</U></b> same f x <b><U>then</U>
             <U>let</U></b> _,f = f
             <b><U>and</U><r> i,r = x </r><U>in</U></b>
             (i,(f::r))::rem
 </r>270       <b><U>else</U> <U>if</U></b></m> conflicts f x <b><U>then</U><r>
             r
           </r><U>else</U></b>
             x::add f rem
     
 <m>275 <b><U>let</U></b></m> get_them fs =
       List.fold_left
         (<b><U>fun</U><r> r (f,_) -&gt;  add f r)
         [] fs
     
 </r><m>280 </m><U>let</U></b> pfactorc chan fs =
       List.iter
         (<b><U>fun</U><r> (((i,j),f),c) -&gt;
           Printf.fprintf chan " %d,%d:%s(%d)" i j f.txt c)
         fs ;
 <m>285   </m>output_char chan '\n'
     
     </r><U>let</U></b> slen f =
       (<b><U>if</U><r> is_font f.nat </r><U>then</U></b>
         5
 <m>290   <b><U>else</U></b></m>
         0) + String.length f.txt + String.length f.ctxt
     
     <b><U>let</U><r> order_factors (((i1,j1),f1),c1) (((i2,j2),f2),c2) =
       </r><U>if</U></b> c1 &lt; c2 <b><U>then</U> <U>true</U><m>
 295   </m><U>else</U> <U>if</U></b> c1=c2 <b><U>then</U><r>
         slen f1 &gt;= slen f2
       </r><U>else</U>
         <U>false</U><m>
     
 300 </m><U>let</U></b> select_factors fs =
       <b><U>let</U></b> fs1 = put_conflicts fs </r><U>in</U>
       <U>let</U></b></m> fs2 = biggest fs1 <b><U>in</U>
       <U>let</U></b> fs3 = Sort.list order_factors fs2 <b><U>in</U>
       <U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U><m>
 305     <r>prerr_string "fs1:" ; pfactorc stderr fs1 ;
         prerr_string "fs2:" ; pfactorc stderr fs2 ;
         prerr_string "fs3:" ; pfactorc stderr fs3
       <b><U>end</U></b> ;
       Sort.list
 </r>310     <r>(<b><U>fun</U><r> ((_,j1),_) ((i2,_),_) -&gt; j1 &lt;= i2)
         (get_them fs3)
     
     
     </r><U>let</U></b> some_font s = List.exists (<b><U>fun</U></b> s -&gt; is_font s.nat) s
 </r>315 
     </m><U>let</U> <U>rec</U></b> font_tree = <b><U>function</U><r>
       | Node (s,ts) -&gt;
           some_font s || font_trees ts
       | Blanks _ -&gt; </r><U>true</U><m>
 320   <r>| _ -&gt; <b><U>false</U>
     
     <U>and</U></b> font_trees ts = List.for_all font_tree ts
     
     <b><U>let</U></b> other_props s =
 </r>325   </m><U>let</U> <U>rec</U></b> other r = <b><U>function</U><r>
         | [] -&gt; r
         | s::rem </r><U>when</U></b> is_font s.nat -&gt;
             other
               (List.fold_left
 <m>330              <r>(<b><U>fun</U><r> r p -&gt; </r><U>if</U></b> p s.nat <b><U>then</U><r> r </r><U>else</U></b> p::r)
                  [] r)
               rem
         | _::rem -&gt; other r rem <b><U>in</U></b>
       other font_props s
 </r>335 
     <b><U>let</U> <U>rec</U><r> all_props r ts = <b><U>match</U><r> r </r><U>with</U></b>
     | [] -&gt; []
     | _  -&gt; <b><U>match</U><r> ts </r><U>with</U></b>
       | [] -&gt; r
 </r></b>340   <r>| Node (s,_)::rem <b><U>when</U><r> some_font s -&gt;
           all_props
             (List.filter
                (</r><U>fun</U></b> p -&gt; List.exists (<b><U>fun</U></b> s -&gt; is_font s.nat &amp;&amp; p s.nat) s)
                r)
 </r>345         <r>rem
       | Node (_,ts)::rem -&gt;
           all_props (all_props r ts) rem
       | Blanks _::rem -&gt;
           all_props
 </r>350         <r>(List.filter neutral_prop r)
             rem
       | _ -&gt; <b><U>assert</U> <U>false</U>
     
     <U>let</U></b> extract_props ps s =
 </r>355   <r>List.partition
         (<b><U>fun</U><r> s -&gt;
           is_font s.nat &amp;&amp;
           List.exists (</r><U>fun</U></b> p -&gt; p s.nat) ps)
         s
 </r>360 
     
     <r><b><U>let</U><r>  clean t k = </r><U>match</U></b> t <b><U>with</U></b>
       | Node ([],ts) -&gt; ts@k
       | _ -&gt; t::k
 </r>365 
     <b><U>let</U> <U>rec</U><r> as_long p = <b><U>function</U><r>
       | x::rem </r><U>when</U></b> p x -&gt;
           <b><U>let</U><r> yes,no = as_long p rem </r><U>in</U></b>
           x::yes,no
 </r></b>370   <r>| l -&gt; [],l
     
     <b><U>let</U> <U>rec</U></b> as_long_end p = <b><U>function</U></b>
       | [] -&gt; [],[]
       | x::rem -&gt;
 </r>375       <b><U>match</U><r> as_long_end p rem </r><U>with</U><r>
           | [],no <b><U>when</U></b> p x -&gt; [],x::no
           | yes,no -&gt; x::yes,no
     
     
 </r></b>380 
     <b><U>let</U><r> bouts p ts =
       </r><U>let</U><r> bef,rem = as_long is_blank ts <b><U>in</U>
       <U>let</U></b> inside,aft = as_long_end is_blank rem <b><U>in</U></b>
       bef,inside,aft
 </r></b>385 
     <b><U>exception</U><r> Failed
     
     </r><U>let</U><r> extract_props_trees ps ts =
       <b><U>let</U><r> card = List.length ps </r><U>in</U><m>
 390   </m><U>let</U> <U>rec</U></b> do_rec seen = <b><U>function</U><r>
         | [] -&gt; seen,[]
         | Blanks _ </r><U>as</U></b> t::rem -&gt;
             <b><U>begin</U> <U>match</U></b> do_rec seen rem <b><U>with</U></b>
             | r,rem -&gt; r,t::rem
 </r></b>395         <b><U>end</U><r>
         | Node (s,args)::rem -&gt;
             </r><U>let</U><r> lift,keep = extract_props ps s <b><U>in</U>
             <U>let</U></b> seen = union seen lift <b><U>in</U>
             <U>if</U></b> List.length seen &gt; card <b><U>then</U><m>
 400           <r>raise Failed
             <b><U>else</U>
               <U>let</U></b> r,rem = do_rec seen rem <b><U>in</U>
               <U>begin</U> <U>match</U></b> keep <b><U>with</U></b>
               | [] -&gt; r,args@rem
 </r>405           <r>| _  -&gt; r,Node (keep,args)::rem
               <b><U>end</U><r>
         | _ -&gt; </r><U>assert</U> <U>false</U> <U>in</U></b>
       do_rec [] ts
     
 </r>410 
     </m><U>let</U> <U>rec</U></b> neutrals started r = <b><U>function</U></b>
       | [] -&gt; r
       | Blanks _::rem -&gt; neutrals started r rem
       | Node (s, _)::rem -&gt;
 </r></b>415       <b><U>if</U><r> started </r><U>then</U><r>
             neutrals <b><U>true</U><r> (inter r (List.filter blanksNeutral s)) rem
           </r><U>else</U></b>
             neutrals <b><U>true</U></b> (List.filter blanksNeutral s) rem
       | _ -&gt; []
 </r></b>420 
     <b><U>let</U> <U>rec</U><r> remove_list fs ts = <b><U>match</U><r> ts </r><U>with</U></b>
       | [] -&gt; []
       | Node (gs,args)::rem -&gt;
           <b><U>begin</U> <U>match</U></b> sub gs fs <b><U>with</U><m>
 425       <r>| [] -&gt; args @ remove_list fs rem
           | ks -&gt; Node (ks,args) :: remove_list fs rem
           <b><U>end</U></b>
       | t::rem -&gt; t::remove_list fs rem
     
 </r>430 </m><U>let</U></b> lift_neutral fs ts k = <b><U>match</U><r> neutrals </r><U>false</U></b> [] ts <b><U>with</U></b>
     | [] -&gt; Node (fs,ts)::k
     | lift -&gt; Node (lift@fs, remove_list lift ts)::k
     
     
 </r></b>435 <b><U>let</U><r> check_node fs ts k = </r><U>match</U><r> ts <b><U>with</U><r>
       | Node (si,args)::rem </r><U>when</U></b>
         some_font fs &amp;&amp; font_trees ts -&gt;
         <b><U>begin</U> <U>match</U></b> all_props (other_props fs) ts <b><U>with</U></b>
         | [] -&gt; lift_neutral fs ts k
 </r></b>440     <r>| ps -&gt;
             <b><U>let</U><r> lift,keep = extract_props ps si </r><U>in</U></b>
             lift_neutral
               (lift@fs) (clean (Node (keep,args)) rem) k
         <b><U>end</U><m>
 445   <r>| _ -&gt; lift_neutral fs ts k
     
     <b><U>let</U> <U>rec</U></b> as_list i j ts k =
       <b><U>if</U><r> i &gt; j </r><U>then</U></b> k
       <b><U>else</U><m>
 450     <r>(clean ts.(i)) (as_list (i+1) j ts k)
     
     <b><U>let</U><r> remove s = </r><U>function</U></b>
       | Node (os,ts) -&gt; node (sub os s) ts
       | t -&gt; t
 </r>455 
     
     </m><U>let</U></b> is_text = <b><U>function</U><r>
       | Text _ -&gt; </r><U>true</U></b>
       | _ -&gt; <b><U>false</U><m>
 460 
     </m><U>and</U></b> is_text_blank = <b><U>function</U><r>
       | Text _ | Blanks _ -&gt; </r><U>true</U></b>
       | _ -&gt; <b><U>false</U><m>
     
 465 </m><U>and</U></b> is_node = <b><U>function</U><r>
       | Node (_::_,_) -&gt; </r><U>true</U></b>
       | _ -&gt; <b><U>false</U>
     
     <U>let</U> <U>rec</U></b> cut_begin p ts l i =
 </r>470   </m><U>if</U></b> i &gt;= l <b><U>then</U><r> l,[]
       </r><U>else</U>
         <U>if</U></b> p ts.(i) <b><U>then</U>
           <U>let</U></b> j,l = cut_begin p ts l (i+1) <b><U>in</U></b>
           j,ts.(i)::l
 </r>475     <b><U>else</U><r>
           i,[]
     
     </r><U>let</U><r> cut_end p ts l =
       <b><U>let</U> <U>rec</U></b> do_rec r i =
 </r></b>480     <b><U>if</U><r> i &lt; 0 </r><U>then</U><r> i,r
         <b><U>else</U>
           <U>if</U></b> p ts.(i) <b><U>then</U><r>
             do_rec (ts.(i)::r) (i-1)
           </r><U>else</U><m>
 485         <r>i,r <b><U>in</U><r>
       do_rec [] (l-1)
     
     </r><U>let</U></b> is_other s = <b><U>match</U><r> s.nat </r><U>with</U></b>
     | Other -&gt; <b><U>true</U><m>
 490 <r>| _ -&gt; <b><U>false</U>
     
     <U>let</U> <U>rec</U></b> deeper i j ts k =
       <b><U>let</U> <U>rec</U></b> again r i =
         <b><U>if</U><r> i &gt; j </r><U>then</U></b> r
 </r>495     </m><U>else</U> <U>match</U></b> ts.(i) <b><U>with</U><r>
         | Node ([],args) -&gt;
             </r><U>let</U></b> b1 =  List.exists is_node args <b><U>in</U><r>
             again (b1 || r) (i+1)
         | Node (s,args) </r><U>when</U></b> List.exists is_other s -&gt;
 </r>500         </m><U>let</U></b> r = again r (i+1) <b><U>in</U>
             <U>if</U></b> not r <b><U>then</U><r>
               ts.(i) &lt;- Node (s,opt </r><U>true</U></b> (Array.of_list args) []) ;
             r
         | t -&gt; again r (i+1) <b><U>in</U><m>
 505   </m><U>if</U></b> again <b><U>false</U><r> i </r><U>then</U> <U>begin</U>
         <U>let</U></b> ts = as_list i j ts [] <b><U>in</U>
         <U>let</U></b> rs = opt <b><U>true</U><r>  (Array.of_list ts) k </r><U>in</U></b>
         rs
       <b><U>end</U> <U>else</U><m>
 510     <r>as_list i j ts k
     
     
     <b><U>and</U><r> trees i j ts k =
       </r><U>if</U></b> i &gt; j <b><U>then</U></b>  k
 </r>515   </m><U>else</U>
         <U>match</U></b> factorize i j ts <b><U>with</U><r>
         | [] -&gt; deeper i j ts k
         | fs -&gt;
             </r><U>let</U> <U>rec</U></b> zyva cur fs k = <b><U>match</U><r> fs </r><U>with</U><m>
 520         <r>| [] -&gt; deeper cur j ts k
             | ((ii,jj),gs)::rem -&gt;
                 <b><U>for</U><r> k=ii </r><U>to</U></b> jj <b><U>do</U><r>
                   ts.(k) &lt;- remove gs ts.(k)
                 </r><U>done</U></b> ;
 </r>525             <r>deeper cur (ii-1) ts
                   (check_node gs (trees ii jj ts [])
                      (zyva (jj+1) rem k)) <b><U>in</U>
             <U>let</U></b> fs = select_factors fs <b><U>in</U>
             <U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U><m>
 530           <r>prerr_endline "selected" ;
               List.iter
                 (<b><U>fun</U></b> ((i,j),fs) -&gt;
                   Printf.fprintf stderr " %d,%d:" i j ;
                   List.iter
 </r>535                 <r>(<b><U>fun</U><r> f -&gt; output_string stderr (" "^f.txt))
                     fs)
                 fs ;
               prerr_endline ""
             </r><U>end</U></b> ;
 </r>540         <r>zyva i fs k
     
     <b><U>and</U><r> opt_onodes ts i = </r><U>match</U></b> ts.(i) <b><U>with</U><r>
       |  ONode (o,c,args) -&gt; </r><U>begin</U> <U>match</U></b> opt <b><U>false</U><r> (Array.of_list args) [] </r><U>with</U></b>
           | [Node (s,args)] -&gt;
 </r>545           <r>ts.(i) &lt;- Node (s,[ONode (o,c,args)])
           | t -&gt;
               ts.(i) &lt;- ONode (o,c,t)
       <b><U>end</U></b>
       | _ -&gt; ()
 </r>550 
     </m><U>and</U></b> opt top ts k =
       <b><U>let</U><r> l = Array.length ts </r><U>in</U>
       <U>for</U></b> i = 0 <b><U>to</U><r> l-1 </r><U>do</U></b>
         opt_onodes ts i
 </r>555   </m><U>done</U></b> ;
       <b><U>let</U><r> p =  is_text_blank </r><U>in</U>
       <U>let</U></b> start,pre = cut_begin p ts l 0 <b><U>in</U>
       <U>if</U></b> start &gt;= l <b><U>then</U><r> pre@k
       </r><U>else</U><m>
 560     </m><U>let</U></b> fin,post  = cut_end p ts l <b><U>in</U>
         <U>if</U></b> top <b><U>then</U><r> pre@trees start fin ts (post@k)
         </r><U>else</U></b>
           extend_blanks pre (trees start fin ts []) post k
     
 </r></b>565 <b><U>and</U><r> extend_blanks pre ts post k = </r><U>match</U><r> ts <b><U>with</U><r>
     | [Node (s,args)] </r><U>when</U></b>
         pre &lt;&gt; [] &amp;&amp; post &lt;&gt; [] &amp;&amp;
         List.exists blanksNeutral s &amp;&amp;
         is_blanks pre &amp;&amp; is_blanks post -&gt;
 </r></b>570       <b><U>let</U><r> neutral,not_neutral =
             List.partition blanksNeutral s </r><U>in</U><r>
           [Node
               (neutral,
                (<b><U>match</U><r> not_neutral </r><U>with</U><m>
 575            <r>| [] -&gt; pre@args@post@k
                | _  -&gt; pre@Node (not_neutral,args)::post@k))]
     | _ -&gt; pre@ts@post@k
     
     
 </r>580 
     </m><U>let</U></b> main chan ts =
       <b><U>let</U><r> ci = costs Htmllex.cost ts </r><U>in</U>
       <U>let</U></b> rs =  opt <b><U>true</U><r> (Array.of_list (Explode.trees ts)) [] </r><U>in</U>
       <U>let</U></b> cf = costs Htmltext.cost rs <b><U>in</U><m>
 585   </m><U>if</U></b> compare ci cf &lt; 0 <b><U>then</U> <U>begin</U>
         <U>if</U></b> !verbose &gt; 1 <b><U>then</U> <U>begin</U></b>
           prerr_endline "*********** Pessimization ***********" ;
           Pp.ptrees stderr ts ;
           prerr_endline "***********   Into        ***********" ;
 </r></b>590       <r>Pp.trees stderr rs
         <b><U>end</U><r> ;
         Pp.ptrees chan ts
       </r><U>end</U> <U>else</U></b>
         Pp.trees chan rs<PL><B>
<6>120 util.ml</6>
</B></PL><w> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: util.ml,v 1.5 2001/05/28 17:28:56 maranget Exp $c             *)
     (***********************************************************************)
     
     </w><b><U>open</U><r> Tree
     </r><U>open</U></b> Htmltext
  </r>15 
     <b><U>let</U> <U>rec</U><r> do_cost ks ((k1,k2) <b><U>as</U><r> c) = </r><U>function</U></b>
       | Text _ | Blanks _ -&gt; c
       | ONode (_,_,ts) -&gt;
           <b><U>let</U><r> c1,c2 = c </r><U>in</U><m>
  20       <r>do_costs ks (1+c1,c2) ts
       | Node (s,ts) -&gt;
           <b><U>let</U><r> l1, l2 = ks s </r><U>in</U></b>
           do_costs ks (l1+k1, l2+k2) ts
     
  </r>25 </m><U>and</U></b> do_costs ks k ts = List.fold_left (do_cost ks) k ts
     
     <b><U>let</U><r> cost ks t = do_cost ks (0,0) t
     </r><U>and</U></b> costs ks ts = do_costs ks (0,0) ts
     
  </r></b>30 <b><U>let</U><r> cost_compare  (tags1,fonts1) (tags2, fonts2) =
       </r><U>if</U><r> tags1 &lt; tags2 <b><U>then</U><r> -1
       </r><U>else</U> <U>if</U></b> tags1 &gt; tags2 <b><U>then</U><r> 1
       </r><U>else</U> <U>if</U></b> fonts1 &lt; fonts2 <b><U>then</U><r> -1
       </r><U>else</U> <U>if</U></b> fonts1 &gt; fonts2 <b><U>then</U></b> 1
  </r></b>35   <b><U>else</U><r> 0
     
     
     
     </r><U>let</U><r> there s l = List.exists (<b><U>fun</U></b> os -&gt; Htmltext.same_style s os) l
  </r></b>40 
     <b><U>let</U><r> inter s1 s2 =
       List.fold_left
         (</r><U>fun</U><r> r s -&gt; <b><U>if</U><r> there s s2 </r><U>then</U></b> s::r <b><U>else</U></b> r)
         [] s1
  </r></b>45 
     <b><U>let</U><r> sub s1 s2 =
       List.fold_left
         (</r><U>fun</U><r> r s -&gt; <b><U>if</U><r> there s s2 </r><U>then</U></b> r <b><U>else</U></b> s::r)
         [] s1
  </r></b>50 
     <b><U>let</U><r> union s1 s2 =
       List.fold_left
         (</r><U>fun</U><r> r s -&gt; <b><U>if</U><r> there s r </r><U>then</U></b> r <b><U>else</U></b> s::r)
         s1 s2
  </r></b>55 
     
     <b><U>let</U><r> neutral s =  List.partition Htmltext.blanksNeutral s
     
     </r><U>let</U> <U>rec</U><r> is_blank = <b><U>function</U><m>
  60   <r>| Text _ -&gt; <b><U>false</U><r>
       | Blanks _ -&gt; </r><U>true</U></b>
       | Node (_,ts) | ONode (_,_,ts) -&gt; is_blanks ts
     
     <b><U>and</U><r> is_blanks = </r><U>function</U><m>
  65   <r>| [] -&gt; <b><U>true</U><r>
       | t::ts -&gt; is_blank t &amp;&amp; is_blanks ts
     
     </r><U>let</U></b> nodes ss ts = <b><U>match</U><r> ss </r><U>with</U></b>
     | [] -&gt; ts
  </r>70 <r>| _  -&gt; [Node (ss,ts)]
     
     <b><U>and</U><r> node ss ts = Node (ss,ts)<PL><B>
<6>121 verb.ml</6>
</B></PL> 
      12 "verb.mll"
     
     </r><U>exception</U></b> VError <b><U>of</U></b> string
     
   </r>5 </m><U>module</U> <U>type</U></b> S = <b><U>sig</U>  <U>end</U></b>
     ;;
     <b><U>module</U></b> Make
       (Dest : OutManager.S) (Image : ImageManager.S)
       (Scan : Latexscan.S) : S =
  </r>10 </m><U>struct</U>
     <U>open</U></b> Misc
     <b><U>open</U><r> Lexing
     </r><U>open</U></b> Save
     <b><U>open</U></b> Lexstate
  </r></b>15 <b><U>open</U><r> Latexmacros
     </r><U>open</U><r> Stack
     <b><U>open</U><r> Scan
     </r><U>open</U></b> Subst
     
  </r></b>20 <b><U>exception</U><r> Eof </r><U>of</U><r> string
     ;;
     
     <w>(* For file verbatim scanning *)
     <b><U>let</U></b></w> input_verb = ref <b><U>false</U><m>
  25 <r>;;
     
     <w>(* For scanning by line *)
     <b><U>let</U></b></w> verb_delim = ref (Char.chr 0)
     <b><U>and</U></b> line_buff = Out.create_buff ()
  </r>30 </m><U>and</U></b> process = ref (<b><U>fun</U><r> () -&gt; ())
     </r><U>and</U></b> finish = ref (<b><U>fun</U><r> () -&gt; ())
     ;;
     
     </r><U>let</U></b> env_extract s =
  </r></b>35   <b><U>let</U><r> i = String.index s '{'
       </r><U>and</U><r> j = String.rindex s '}' <b><U>in</U><r>
       String.sub s (i+1) (j-i-1)
     
     </r><U>and</U></b> newlines_extract s =
  </r></b>40   <b><U>let</U> <U>rec</U><r> do_rec i =
         <b><U>if</U><r> i &lt; String.length s </r><U>then</U> <U>begin</U>
           <U>if</U></b> s.[i] = '\n' <b><U>then</U><r>
             1+do_rec (i+1)
           </r><U>else</U><m>
  45         <r>0
         <b><U>end</U> <U>else</U></b>
           0 <b><U>in</U></b>
       do_rec 0
     
  </r>50 <w>(* For scanning the ``listings'' way *)
     
     </w></m><U>let</U></b> lst_process_error _ lxm =
        warning ("listings, unknown character: ``"^Char.escaped lxm^"''")
     
  </r></b>55 <b><U>let</U><r> lst_char_table = Array.create 256 lst_process_error
     ;;
     
     </r><U>let</U><r> lst_init_char c f =
       lst_char_table.(Char.code c) &lt;- f
  </r></b>60 
     <b><U>let</U><r> lst_init_chars s f =
       </r><U>let</U><r> last = String.length s - 1 <b><U>in</U>
       <U>for</U></b> i = 0 <b><U>to</U><r> last </r><U>do</U></b>
         lst_char_table.(Char.code s.[i]) &lt;- f
  </r></b>65   <b><U>done</U>
     
     <U>let</U><r> lst_init_save_char c f =
       <b><U>let</U><r> old = lst_char_table.(Char.code c) </r><U>in</U></b>
       lst_char_table.(Char.code c) &lt;- f old
  </r></b>70 
     <b><U>let</U><r> lst_init_save_chars s f =
       </r><U>let</U><r> last = String.length s - 1 <b><U>in</U>
       <U>for</U></b> i = 0 <b><U>to</U><r> last </r><U>do</U></b>
         lst_init_save_char s.[i] f
  </r></b>75   <b><U>done</U><w>
     
     (* Output functions *)
     </w><U>let</U><r> lst_gobble  = ref 0
     <b><U>and</U></b> lst_nlines  = ref 0
  </r></b>80 <b><U>and</U><r> lst_first   = ref 1
     </r><U>and</U><r> lst_last    = ref 9999
     <b><U>and</U><r> lst_print   = ref </r><U>true</U>
     <U>and</U></b> lst_string_spaces = ref <b><U>true</U>
     <U>and</U></b> lst_texcl   = ref <b><U>false</U><m>
  85 </m><U>and</U></b> lst_extended = ref <b><U>false</U>
     <U>and</U></b> lst_sensitive = ref <b><U>true</U>
     <U>and</U></b> lst_mathescape = ref <b><U>false</U>
     <U>and</U></b> lst_directives = ref <b><U>false</U>
     <U>and</U></b> lst_showlines = ref <b><U>false</U><m>
  90 
     </m><U>let</U></b> lst_effective_spaces = ref <b><U>false</U><w> (* false =&gt; spaces are spaces *)
     </w><U>and</U></b> lst_save_spaces  = ref <b><U>false</U>
     
     <U>let</U></b> lst_buff = Out.create_buff ()
  </r></b>95 
     <b><U>let</U><r> lst_last_char = ref ' '
     </r><U>and</U><r> lst_finish_comment = ref 0
     
     <b><U>let</U></b> lst_put c =
 </r></b>100   <r>lst_last_char := c ;
       Out.put_char lst_buff c
     
     <b><U>and</U></b> lst_direct_put c =
       lst_last_char := c ;
 </r>105   <r>Dest.put_char c
     
     <b><U>type</U><r> lst_scan_mode =
       | Letter | Other | Empty | Start
       | Directive </r><U>of</U></b> bool <w>(* bool flags some letter read *)
 <m>110 
     <b><U>let</U><r> lst_scan_mode = ref Empty
     
     </r><U>type</U><r> comment_type =
       | Nested <b><U>of</U></b> int
 </r></b>115   <r>| Balanced <b><U>of</U><r> (char -&gt; string -&gt; bool)
       | Line
     
     </r><U>type</U></b> lst_top_mode =
       | Skip
 </r>120   <r>| String <b><U>of</U><r> (char * (char * (Lexing.lexbuf -&gt; char -&gt; unit)) list)
       | Normal | Comment </r><U>of</U></b> comment_type
       | Delim <b><U>of</U><r> int * (char * (Lexing.lexbuf -&gt; char -&gt; unit)) list
       | Gobble </r><U>of</U></b> lst_top_mode * int
       | Escape <b><U>of</U><r> lst_top_mode * char * bool </r><w>(* bool flags mathescape *)
 <m>125 
     <r><b><U>let</U><r> string_of_top_mode = </r><U>function</U></b>
       | Delim (i,_) -&gt; "Delim: "^string_of_int i
       | Skip -&gt; "Skip"
       | Comment (Balanced _) -&gt; "Balanced"
 </r>130   <r>| Comment (Nested n)   -&gt; "(Nested "^string_of_int n^")"
       | _ -&gt; "?"
     
     <b><U>let</U></b> lst_top_mode = ref Skip
     
 </r>135 
     <b><U>let</U><r> lst_ptok s =  prerr_endline (s^": "^Out.to_string lst_buff)
     
     </r><w>(* Final ouput, with transformations *)
     </w><U>let</U><r> dest_string s =
 </r></b>140   <b><U>for</U><r> i = 0 </r><U>to</U><r> String.length s - 1 <b><U>do</U><r>
         Dest.put (Dest.iso s.[i])
       </r><U>done</U><w>
     
     (* Echo, with case change *)
 <m>145 <b><U>let</U><r> dest_case s =
       Dest.put
         (</r><U>match</U><r> !case <b><U>with</U></b>
         | Upper -&gt; String.uppercase s
         | Lower -&gt; String.lowercase s
 </r></b>150     <r>| _     -&gt; s)
     
     <w>(* Keywords *)
     
     <b><U>let</U></b></w> def_print s =
 </r>155   <r>Latexmacros.def "\\@tmp@lst" zero_pat
         (CamlCode (<b><U>fun</U><r> _ -&gt;  dest_case s)) ;
       Latexmacros.def "\\@tmp@lst@print" zero_pat
         (CamlCode (</r><U>fun</U></b> _ -&gt;  dest_string s))
     ;;
 </r>160 
     <b><U>let</U><r> lst_output_other () =
       </r><U>if</U><r> not (Out.is_empty lst_buff) <b><U>then</U> <U>begin</U>
         <U>let</U></b> arg = Out.to_string lst_buff <b><U>in</U>
         <U>match</U></b> !lst_top_mode <b><U>with</U><m>
 165     <r>| Normal -&gt;
             def_print arg ;
             scan_this Scan.main
               ("\\lst@output@other{\\@tmp@lst}{\\@tmp@lst@print}")
         | _ -&gt;
 </r>170         <r>scan_this main "\\@NewLine" ;
             dest_string arg
       <b><U>end</U>
     
     <U>and</U></b> lst_output_letter () =
 </r>175   </m><U>if</U></b> not (Out.is_empty lst_buff) <b><U>then</U> <U>begin</U>
         <U>match</U></b> !lst_top_mode <b><U>with</U><r>
         | Normal -&gt;
             </r><U>let</U></b> arg = Out.to_string lst_buff <b><U>in</U></b>
             def_print arg ;
 </r></b>180         <r>scan_this Scan.main ("\\lst@output{\\@tmp@lst}{\\@tmp@lst@print}")
         | _ -&gt;
             scan_this main "\\@NewLine" ;
             dest_string (Out.to_string lst_buff)
       <b><U>end</U><m>
 185 
     </m><U>and</U></b> lst_output_directive () =
       <b><U>if</U><r> not (Out.is_empty lst_buff) </r><U>then</U> <U>begin</U>
         <U>match</U></b> !lst_top_mode <b><U>with</U></b>
         | Normal -&gt;
 </r>190         <b><U>let</U><r> arg = Out.to_string lst_buff </r><U>in</U><r>
             def_print arg ;
             scan_this Scan.main ("\\lst@output@directive{\\@tmp@lst}{\\@tmp@lst@print}")
         | _ -&gt;
             scan_this main "\\@NewLine" ;
 </r></b>195         <r>dest_string (Out.to_string lst_buff)
       <b><U>end</U>
     
     <U>let</U></b> lst_output_token () =
       <b><U>match</U><r> !lst_scan_mode </r><U>with</U><m>
 200   <r>| Letter -&gt; lst_output_letter ()
       | Other  -&gt; lst_output_other ()
       | Directive _ -&gt; lst_output_directive ()
       | Empty|Start  -&gt; scan_this main "\\@NewLine"
     
 </r>205 
     </m><U>let</U></b> lst_finalize inline =
      scan_this main "\\lst@forget@lastline" ;
      <b><U>if</U><r> inline || !lst_showlines </r><U>then</U></b>
        lst_output_token ()
 </r>210 
     
     
     </m>(* Process functions *)
     </w><U>let</U></b> lst_do_gobble mode n =
 </r></b>215   <r><b><U>if</U><r> n &gt; 1 </r><U>then</U></b>
         lst_top_mode := Gobble (mode,n-1)
       <b><U>else</U></b>
         lst_top_mode := mode
     
 </r>220 <b><U>let</U><r> lst_do_escape mode endchar math lb lxm =
       </r><U>if</U><r> lxm = endchar <b><U>then</U> <U>begin</U></b>
         scan_this main "\\begingroup\\lst@escapebegin" ;
         <b><U>if</U><r> math </r><U>then</U></b> scan_this main "$" ;
         scan_this main (Out.to_string lst_buff) ;
 </r></b>225     <b><U>if</U><r> math </r><U>then</U><r> scan_this main "$" ;
         scan_this main "\\lst@escapeend\\endgroup" ;
         lst_top_mode := mode
       <b><U>end</U> <U>else</U></b>
         Out.put_char lst_buff lxm
 </r></b>230 
     
     
     <b><U>let</U> <U>rec</U><r> lst_process_newline lb c =
     <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U><m>
 235   <r>Printf.fprintf stderr "lst_process_newline\n" ;
     <b><U>match</U><r> !lst_top_mode </r><U>with</U></b>
     | Skip -&gt;
         <b><U>if</U><r> !lst_nlines = !lst_first - 1 </r><U>then</U> <U>begin</U></b>
           lst_top_mode := Normal ;
 </r>240       <r>scan_this Scan.main "\\let\\old@br\\@br\\def\\@br{
     } " ;
           lst_process_newline lb c ;
           scan_this Scan.main "\\let\\@br\\old@br"
         <b><U>end</U> <U>else</U><m>
 245       <r>incr lst_nlines
     | Gobble (mode,_) -&gt;
         lst_top_mode := mode ;
         lst_process_newline lb c
     | Escape (mode,cc,math) -&gt;
 </r>250     <r>lst_do_escape (Comment Line) cc math lb c ;
         <b><U>if</U><r> !lst_top_mode = Comment Line </r><U>then</U></b>
           lst_process_newline lb c
     | Comment Line -&gt;
         lst_output_token () ;
 </r>255     <r>scan_this Scan.main "\\endgroup" ;
         lst_top_mode := Normal ;
         lst_process_newline lb c
     | mode  -&gt;
         scan_this Scan.main "\\lsthk@InitVarEOL\\lsthk@EOL" ;
 </r>260     </m><U>begin</U> <U>match</U></b> !lst_scan_mode <b><U>with</U></b>
         | Empty -&gt; lst_scan_mode := Start
         | Start -&gt; ()
         | _ -&gt;
             lst_output_token () ;
 </r>265         <r>lst_scan_mode := Start
         <b><U>end</U><r> ;
         incr lst_nlines ;
         </r><U>if</U></b> !lst_nlines &lt;= !lst_last <b><U>then</U> <U>begin</U></b>
           scan_this Scan.main
 </r>270         <r>"\\lsthk@InitVarBOL\\lsthk@EveryLine" ;
           <b><U>if</U><r> !lst_gobble &gt; 0 </r><U>then</U></b>
             lst_top_mode := Gobble (mode,!lst_gobble)
         <b><U>end</U> <U>else</U></b>
           lst_top_mode := Skip
 </r>275 
     </m><U>let</U></b> lst_process_letter lb lxm =
     <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b>  Printf.fprintf stderr "lst_process_letter: %c\n" lxm ;
     <b><U>match</U><r> !lst_top_mode </r><U>with</U></b>
     | Skip -&gt; ()
 </r></b>280 <r>| Gobble (mode,n) -&gt; lst_do_gobble mode n
     | Escape (mode,c,math) -&gt; lst_do_escape mode c math lb lxm
     | _ -&gt; <b><U>match</U><r> !lst_scan_mode </r><U>with</U></b>
       | Letter -&gt; lst_put lxm
       | Directive <b><U>true</U></b> -&gt;
 </r>285       <r>lst_put lxm
       | Directive <b><U>false</U><r> -&gt;
           lst_scan_mode := Directive </r><U>true</U></b> ;
           lst_put lxm
       | Empty|Start -&gt;
 </r>290       <r>lst_scan_mode := Letter ;
           lst_put lxm
       | Other  -&gt;
           lst_output_other () ;
           lst_scan_mode := Letter ;
 </r>295       <r>lst_put lxm
     
     <b><U>let</U><r> lst_process_digit lb lxm =
     </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U></b>
      Printf.fprintf stderr "lst_process_digit: %c\n" lxm ;
 </r>300 <b><U>match</U><r> !lst_top_mode </r><U>with</U><r>
     | Skip -&gt; ()
     | Gobble (mode,n) -&gt; lst_do_gobble mode n
     | Escape (mode,c,math) -&gt; lst_do_escape mode c math lb lxm
     | _ -&gt;  <b><U>match</U><r> !lst_scan_mode </r><U>with</U><m>
 305   <r>| Letter|Other -&gt; lst_put lxm
       | Directive _ -&gt;
           lst_output_directive () ;
           lst_scan_mode := Other ;
           lst_put lxm
 </r>310   <r>| Empty|Start  -&gt;
           lst_scan_mode := Other ;
           lst_put lxm
     
     <b><U>let</U></b> lst_process_other lb lxm =
 </r>315 </m><U>if</U></b> !verbose &gt; 1 <b><U>then</U><r>
       Printf.fprintf stderr "process_other: %c\n" lxm ;
     </r><U>match</U></b> !lst_top_mode <b><U>with</U></b>
     | Skip -&gt; ()
     | Gobble (mode,n) -&gt; lst_do_gobble mode n
 </r></b>320 <r>| Escape (mode,c,math) -&gt; lst_do_escape mode c math lb lxm
     |  _ -&gt; <b><U>match</U><r> !lst_scan_mode </r><U>with</U></b>
         | Other -&gt; lst_put lxm
         | Empty|Start -&gt;
             lst_scan_mode := Other ;
 </r>325         <r>lst_put lxm
         | Directive _ -&gt;
             lst_output_directive () ;
             lst_scan_mode := Other ;
             lst_put lxm
 </r>330     <r>| Letter -&gt;
             lst_output_letter () ;
             lst_scan_mode := Other ;
             lst_put lxm
     
 </r>335 </m>(*  Caml code for \stepcounter{lst@space}  *)
     </w><U>let</U></b> lst_output_space () = Counter.step_counter "lst@spaces"
     
     <b><U>let</U><r> lst_process_space lb lxm =
     </r><U>if</U></b> !verbose &gt; 1 <b><U>then</U><m>
 340  <r>Printf.fprintf stderr "process_space: ``%c''\n" lxm ;
     <b><U>match</U><r> !lst_top_mode </r><U>with</U></b>
     | Skip -&gt; ()
     | Gobble (mode,n) -&gt; lst_do_gobble mode n
     | Escape (mode,c,math) -&gt; lst_do_escape mode c math lb lxm
 </r>345 <r>| _ -&gt;
         <b><U>begin</U> <U>match</U></b> !lst_scan_mode <b><U>with</U></b>
         | Other -&gt;
             lst_output_other ()  ;
             lst_scan_mode := Empty
 </r>350     <r>| Letter|Directive <b><U>true</U><r> -&gt;
             lst_output_token () ;
             lst_scan_mode := Empty
         | Empty|Directive </r><U>false</U></b> -&gt; ()
         | Start -&gt;
 </r>355         <r>lst_scan_mode := Empty
         <b><U>end</U><r> ;
         lst_output_space ()
     
     </r><U>let</U></b> lst_process_start_directive  old_process lb lxm =
 </r>360   </m><U>match</U></b> !lst_top_mode <b><U>with</U><r>
       | Normal -&gt; </r><U>begin</U> <U>match</U></b> !lst_scan_mode <b><U>with</U><r>
         | Start -&gt;
             lst_scan_mode := Directive </r><U>false</U></b>
         | _ -&gt; old_process lb lxm
 </r>365   <b><U>end</U><r>
       | _ -&gt;  old_process lb lxm
     
     
     
 </r></b>370 <r><b><U>exception</U><r> EndVerb
     
     </r><U>let</U></b> lst_process_end  endstring old_process lb lxm =
     <b><U>if</U><r> !verbose &gt; 1 </r><U>then</U></b>
      Printf.fprintf stderr "process_end: ``%c''\n" lxm ;
 </r>375   <b><U>if</U><r>
         (not !input_verb || Stack.empty stack_lexbuf)
           &amp;&amp; if_next_string endstring lb </r><U>then</U> <U>begin</U><r>
         Save.skip_delim endstring lb ;
         raise EndVerb
 </r></b>380   <b><U>end</U> <U>else</U><r>
         old_process lb lxm
     
     <b><U>let</U></b> lst_init_char_table inline =
       lst_init_chars
 </r></b>385     <r>"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@_$"
         lst_process_letter ;
       lst_init_chars "!\"#%&amp;'()*+,-./:;&lt;=&gt;?[\\]^{}|`~" lst_process_other ;
       lst_init_chars "0123456789" lst_process_digit ;
       lst_init_chars " \t" lst_process_space ;
 </r>390   <r><b><U>if</U><r> inline </r><U>then</U></b>
         lst_init_char '\n' lst_process_space
       <b><U>else</U></b>
         lst_init_char '\n' lst_process_newline
     ;;
 </r>395 
     </m>(* TeX escapes *)
     <b><U>let</U></b></w> start_escape mode endchar math =
       lst_output_token () ;
       lst_top_mode := Escape (mode, endchar, math)
 </r>400 
     <b><U>let</U><r> lst_process_escape math ec old_process lb lxm =
     </r><U>if</U><r> !verbose &gt; 1 <b><U>then</U><r>
      Printf.fprintf stderr "lst_process_escape: %c\n" lxm ;
     </r><U>match</U></b> !lst_top_mode </r><U>with</U></b>
 405 <r>| Skip -&gt; ()
     | Gobble (mode,n) -&gt; lst_do_gobble mode n
     | Escape _        -&gt; old_process lb lxm
     | mode            -&gt; start_escape mode ec math
     
 </r>410 
     <w>(* Strings *)
     <b><U>let</U> <U>rec</U><r> restore_char_table to_restore =
       <b><U>let</U> <U>rec</U></b> do_rec = <b><U>function</U><r>
         | [] -&gt; ()
 <m>415     </m>| (c,f)::rest -&gt;
             lst_init_char c f ;
             do_rec rest </r><U>in</U></b>
       do_rec to_restore
     
 <m>420 <b><U>let</U></b></m> lst_bs_string old_process lb lxm =
       old_process lb lxm ;
       <b><U>let</U><r> saved = Array.copy lst_char_table </r><U>in</U>
       <U>let</U></b> process_quoted _ lxm =
         lst_put lxm ;
 <m>425     <r>Array.blit saved 0 lst_char_table 0 (Array.length saved) <b><U>in</U><r>
       Array.fill lst_char_table 0 (Array.length lst_char_table) process_quoted
     
     
     </r><U>let</U></b> lst_init_quote s =
 </r>430   <b><U>let</U></b></m> r = ref [] <b><U>in</U>
       <U>for</U></b> i = 0 <b><U>to</U><r> String.length s-1 </r><U>do</U>
         <U>if</U></b> s.[i] = 'b' <b><U>then</U> <U>begin</U></b>
           r := ('\\',lst_char_table.(Char.code '\\')) :: !r ;
           lst_init_save_char '\\' lst_bs_string
 <m>435     <b><U>end</U>
       <U>done</U><r> ;
       !r
     
     <b><U>let</U><r> lst_process_stringizer quote old_process lb lxm = </r><U>match</U></b> !lst_top_mode </r><U>with</U></b>
 440   </m>| Normal -&gt;
           lst_output_token () ;
           <b><U>let</U><r> to_restore = lst_init_quote quote </r><U>in</U></b>
           lst_top_mode := String (lxm, to_restore) ;
           lst_save_spaces := !lst_effective_spaces ;
 <m>445       </m>lst_effective_spaces := !lst_string_spaces ;
           scan_this Scan.main "\\begingroup\\lst@string@style" ;
           old_process lb lxm
       | String (c,to_restore) <b><U>when</U></b> lxm = c -&gt;
           old_process lb lxm ;
 <m>450       </m>lst_output_token () ;
           scan_this Scan.main "\\endgroup" ;
           restore_char_table to_restore ;
           lst_effective_spaces := !lst_save_spaces ;
           lst_top_mode := Normal
 <m>455   </m>| _ -&gt; old_process lb lxm
     
     
     
     </r></b>(* Comment *)
 </w>460 
     </m></TT></r></w></m></r><b><TT><U>let</U><r> chars_string c s =
       </r><U>let</U> <U>rec</U><r> do_rec r i =
         <b><U>if</U><r> i &lt; String.length s </r><U>then</U>
           <U>if</U></b> List.mem s.[i] r <b><U>then</U><m>
 465         <r>do_rec r (i+1)
           <b><U>else</U><r>
             do_rec (s.[i]::r) (i+1)
         </r><U>else</U></b>
           r <b><U>in</U><m>
 470   <r>do_rec [c] 0
     
     <b><U>let</U><r> init_char_table_delim chars wrapper =
       List.map
         (</r><U>fun</U></b> c -&gt;
 </r>475       </m><U>let</U></b> old_process = lst_char_table.(Char.code c) <b><U>in</U></b>
           lst_init_save_char c wrapper ;
           (c,old_process))
       chars
     
 </r>480 
     </m><U>let</U></b> eat_delim k new_mode old_process lb c s =
       <b><U>let</U><r> chars = chars_string c s </r><U>in</U>
       <U>let</U></b> wrapper old_process lb c = <b><U>match</U><r> !lst_top_mode </r><U>with</U></b>
       | Delim (n,to_restore) -&gt;
 <m>485       <r>old_process lb c ;
           <b><U>if</U><r> n = 1 </r><U>then</U> <U>begin</U></b>
             lst_output_token () ;
             lst_top_mode := new_mode ;
             restore_char_table to_restore ;
 </r>490         <r>k ()
           <b><U>end</U> <U>else</U></b>
             lst_top_mode := Delim (n-1,to_restore)
       | _ -&gt; <b><U>assert</U> <U>false</U> <U>in</U>
       <U>let</U></b> to_restore = init_char_table_delim chars wrapper <b><U>in</U><m>
 495   <r>lst_top_mode := Delim (1+String.length s, to_restore) ;
       wrapper old_process lb c
     
     <b><U>let</U></b> begin_comment () =
       lst_output_token () ;
 </r>500   <r>scan_this Scan.main "\\begingroup\\lst@comment@style"
     
     <b><U>let</U><r> lst_process_BNC _ s old_process lb c =  </r><U>match</U></b> !lst_top_mode <b><U>with</U><r>
     | Normal </r><U>when</U></b> if_next_string s lb -&gt;
         begin_comment () ;
 </r>505     <r>eat_delim (<b><U>fun</U><r> () -&gt; ()) (Comment (Nested 0)) old_process lb c s
     | Comment (Nested n) </r><U>when</U></b> if_next_string s lb -&gt;
         eat_delim (<b><U>fun</U></b> () -&gt; ()) (Comment (Nested (n+1))) old_process lb c s
     | _ -&gt; old_process lb c
     
 </r>510 </m><U>and</U></b> lst_process_ENC s old_process lb c = <b><U>match</U><r> !lst_top_mode </r><U>with</U></b>
     | Comment (Nested 0) <b><U>when</U><r> if_next_string s lb -&gt;
         eat_delim
           (</r><U>fun</U></b> () -&gt; scan_this Scan.main "\\endgroup")
           Normal
 </r>515       <r>old_process
           lb c s
     |  Comment (Nested n) <b><U>when</U><r> if_next_string s lb -&gt;
         eat_delim
           (</r><U>fun</U></b> () -&gt; ())
 </r>520       <r>(Comment (Nested (n-1)))
           old_process lb c s
     | _ -&gt; old_process lb c
     
     <b><U>let</U><r> lst_process_BBC check s old_process lb c =  </r><U>match</U></b> !lst_top_mode <b><U>with</U><m>
 525 <r>| Normal <b><U>when</U><r> if_next_string s lb -&gt;
         begin_comment () ;
         eat_delim
           (</r><U>fun</U></b> () -&gt; ())
           (Comment (Balanced check))
 </r>530       <r>old_process lb c s
     | _ -&gt; old_process lb c
     
     <b><U>and</U><r> lst_process_EBC s old_process lb c = </r><U>match</U></b> !lst_top_mode <b><U>with</U><r>
     | Comment (Balanced check) </r><U>when</U><m>
 535   <r>check c s &amp;&amp; if_next_string  s lb -&gt;
          eat_delim
           (<b><U>fun</U></b> () -&gt; scan_this Scan.main "\\endgroup")
           Normal
           old_process
 </r>540       <r>lb c s
     | _ -&gt; old_process lb c
     
     <b><U>let</U><r> lst_process_LC s old_process lb c = </r><U>match</U></b> !lst_top_mode <b><U>with</U><r>
     | Normal </r><U>when</U></b> if_next_string s lb -&gt;
 </r>545     <r>begin_comment () ;
         eat_delim
           (<b><U>fun</U><r> () -&gt; ())
           (</r><U>if</U></b> !lst_texcl <b><U>then</U><r> Escape (Normal,'\n', </r><U>false</U></b>) <b><U>else</U></b> Comment Line)
           old_process lb c s
 </r>550 <r>| _ -&gt; old_process lb c
     
     <b><U>let</U></b> lex_tables = {
       Lexing.lex_base =
        "\000\000\001\000\002\000\003\000\004\000\005\000\006\000\253\255\
    \000\000\255\255\000\000\000\000\254\255\254\255\001\000\252\255\
    \000\000\000\000\000\000\007\000\008\000";
 </r>555   <r>Lexing.lex_backtrk =
        "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \002\000\255\255\255\255\255\255\255\255\255\255\002\000\255\255\
    \255\255\255\255\255\255\255\255\255\255";
       Lexing.lex_default =
        "\009\000\009\000\007\000\012\000\012\000\012\000\007\000\000\000\
    \255\255\000\000\255\255\255\255\000\000\000\000\255\255\000\000\
    \255\255\255\255\255\255\020\000\020\000";
       Lexing.lex_trans =
 </r>560    <r>"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\018\000\000\000\000\000\013\000\000\000\007\000\007\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \018\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\014\000\000\000\
    \000\000\000\000\008\000\012\000\018\000\010\000\016\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\017\000\000\000\
    \000\000\000\000\000\000\011\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\019\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\255\255\009\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \012\000\012\000\015\000\009\000\009\000\009\000\009\000\255\255\
    \255\255";
       Lexing.lex_check =
        "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\018\000\255\255\255\255\002\000\255\255\004\000\005\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \018\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\002\000\255\255\
    \255\255\255\255\006\000\011\000\017\000\008\000\014\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\016\000\255\255\
    \255\255\255\255\255\255\010\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\018\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\019\000\020\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\001\000\002\000\003\000\004\000\005\000\006\000\019\000\
    \020\000"
     }
     
 </r>565 </m><U>let</U> <U>rec</U></b> inverb lexbuf = __ocaml_lex_inverb_rec lexbuf 0
     <b><U>and</U><r> __ocaml_lex_inverb_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
      567 "verb.mll"
 </r>570      <r>(<b><U>fun</U><r> put -&gt; </r><U>let</U></b> c = lexeme_char lexbuf 0 <b><U>in</U>
         <U>if</U></b> c = !verb_delim <b><U>then</U> <U>begin</U></b>
           Dest.close_group () ;
         <b><U>end</U> <U>else</U> <U>begin</U></b>
           put c ;
 </r>575       <r>inverb lexbuf put
         <b><U>end</U><r>))
       | 1 -&gt; (
      575 "verb.mll"
          (</r><U>fun</U></b> put -&gt; <b><U>if</U><r> not (empty stack_lexbuf) </r><U>then</U><m>
 580       </m><U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U><r>
           inverb lexbuf put
         </r><U>else</U></b>
           raise (VError ("End of file after \\verb"))))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_inverb_rec lexbuf n
 </r>585 
     </m><U>and</U></b> start_inverb lexbuf = __ocaml_lex_start_inverb_rec lexbuf 1
     <b><U>and</U><r> __ocaml_lex_start_inverb_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U></b>
         0 -&gt; (
 </r>590  <r>583 "verb.mll"
          (<b><U>fun</U><r> put -&gt; </r><U>let</U></b> c = lexeme_char lexbuf 0 <b><U>in</U></b>
         verb_delim := c ;
         inverb lexbuf put))
       | 1 -&gt; (
 </r>595  <r>587 "verb.mll"
          (<b><U>fun</U><r> put -&gt;
           </r><U>if</U></b> not (empty stack_lexbuf) <b><U>then</U>
             <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U></b>
             start_inverb lexbuf put
 </r>600       <b><U>else</U></b></m>
             raise (VError ("End of file after \\verb"))))
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_start_inverb_rec lexbuf n
     
     </r><U>and</U><r> scan_byline lexbuf = __ocaml_lex_scan_byline_rec lexbuf 2
 </r><m>605 </m><U>and</U><r> __ocaml_lex_scan_byline_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
      596 "verb.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U><m>
 610     </m><U>let</U></b> env = env_extract lxm <b><U>in</U>
         <U>if</U></b>
           (not !input_verb || Stack.empty stack_lexbuf)
             &amp;&amp; env = !Scan.cur_env <b><U>then</U> <U>begin</U></b>
           !finish () ;
 <m>615       <r>scan_this Scan.main ("\\end"^env) ;
           Scan.top_close_block "" ;
           Scan.close_env !Scan.cur_env ;
           Scan.check_alltt_skip lexbuf
         <b><U>end</U> <U>else</U> <U>begin</U><m>
 620       <r>Out.put line_buff lxm ;
           scan_byline lexbuf
         <b><U>end</U></b>)
       | 1 -&gt; (
      611 "verb.mll"
 </r>625      <r>!process () ; scan_byline lexbuf)
       | 2 -&gt; (
      613 "verb.mll"
          <b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U></b>
         Out.put_char line_buff lxm ;
 </r>630     <r>scan_byline lexbuf)
       | 3 -&gt; (
      617 "verb.mll"
          <b><U>if</U><r> not (Stack.empty stack_lexbuf) </r><U>then</U> <U>begin</U>
           <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U><m>
 635       <r>scan_byline lexbuf
         <b><U>end</U> <U>else</U> <U>begin</U></b>
           !finish () ;
           raise
             (Eof "scan_byline")
 </r>640     </m><U>end</U></b>)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_scan_byline_rec lexbuf n
     
     <b><U>and</U><r> listings lexbuf = __ocaml_lex_listings_rec lexbuf 3
     </r><U>and</U></b> __ocaml_lex_listings_rec lexbuf state =
 </r>645   </m><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      628 "verb.mll"
          </r><U>if</U></b> not (Stack.empty stack_lexbuf) <b><U>then</U> <U>begin</U>
           <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U><m>
 650       <r>listings lexbuf
         <b><U>end</U> <U>else</U> <U>begin</U></b>
           raise
             (Eof "listings")
         <b><U>end</U></b>)
 </r>655   <r>| 1 -&gt; (
      636 "verb.mll"
          <b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U></b>
         lst_char_table.(Char.code lxm) lexbuf lxm ;
         listings lexbuf)
 </r>660   <r>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_listings_rec lexbuf n
     
     <b><U>and</U><r> eat_line lexbuf = __ocaml_lex_eat_line_rec lexbuf 4
     </r><U>and</U></b> __ocaml_lex_eat_line_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><m>
 665     <r>0 -&gt; (
      642 "verb.mll"
          <b><U>if</U><r> not (Stack.empty stack_lexbuf) </r><U>then</U> <U>begin</U>
           <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U></b>
           eat_line lexbuf
 </r>670     </m><U>end</U> <U>else</U> <U>begin</U></b>
           raise
             (Eof "eat_line")
         <b><U>end</U></b>)
       | 1 -&gt; (
 </r>675  <r>649 "verb.mll"
                 eat_line lexbuf)
       | 2 -&gt; (
      650 "verb.mll"
                 lst_process_newline lexbuf '\n')
 </r>680   <r>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_eat_line_rec lexbuf n
     
     <b><U>and</U><r> get_line lexbuf = __ocaml_lex_get_line_rec lexbuf 5
     </r><U>and</U></b> __ocaml_lex_get_line_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U><m>
 685     <r>0 -&gt; (
      654 "verb.mll"
          <b><U>if</U><r> not (Stack.empty stack_lexbuf) </r><U>then</U> <U>begin</U>
           <U>let</U></b> lexbuf = previous_lexbuf () <b><U>in</U></b>
           get_line lexbuf
 </r>690     </m><U>end</U> <U>else</U> <U>begin</U></b>
           raise
             (Eof "get_line")
         <b><U>end</U></b>)
       | 1 -&gt; (
 </r>695  <r>662 "verb.mll"
          <b><U>let</U><r> lxm = lexeme_char lexbuf 0 </r><U>in</U></b>
         Out.put_char line_buff lxm ;
         get_line lexbuf)
       | 2 -&gt; (
 </r>700  <r>665 "verb.mll"
                 Out.to_string line_buff)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_get_line_rec lexbuf n
     
     <b><U>and</U></b> do_escape lexbuf = __ocaml_lex_do_escape_rec lexbuf 6
 </r>705 </m><U>and</U></b> __ocaml_lex_do_escape_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
     )
       | 1 -&gt; (
 </r>710  <r>670 "verb.mll"
          <b><U>let</U><r> arg = save_arg lexbuf </r><U>in</U></b>
         scan_this main "\\mbox{" ;
         scan_this_arg Scan.main arg ;
         scan_this main "}" ;
 </r>715     <r>do_escape lexbuf)
       | 2 -&gt; (
      676 "verb.mll"
          <b><U>let</U><r> lxm = Lexing.lexeme_char lexbuf 0 </r><U>in</U></b>
         Dest.put (Dest.iso lxm) ;
 </r>720     <r>do_escape lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_do_escape_rec lexbuf n
     
     ;;
     
 </r>725  <r>679 "verb.mll"
     
     <b><U>let</U><r> _ = ()
     ;;
     </r><U>let</U></b> put_char_star = <b><U>function</U><m>
 730   <r>| ' '|'\t' -&gt; Dest.put_char '_' ;
       | c -&gt;  Dest.put (Dest.iso c)
     
     <b><U>and</U><r> put_char = </r><U>function</U></b>
       |  '\t' -&gt; Dest.put_char ' '
 </r>735   <r>| c -&gt; Dest.put (Dest.iso c)
     ;;
     
     
     <b><U>let</U></b> open_verb put lexbuf =
 </r>740   <r>Dest.open_group "CODE" ;
       start_inverb lexbuf put
     ;;
     
     def_code "\\verb" (open_verb (<b><U>fun</U></b> c -&gt; Dest.put (Dest.iso c)));
 </r>745 <r>def_code "\\verb*" (open_verb put_char_star);
     ();;
     
     <b><U>let</U></b> put_line_buff_verb () =
       Out.iter put_char line_buff ;
 </r>750   <r>Out.reset line_buff
     
     <b><U>and</U></b> put_line_buff_verb_star () =
       Out.iter put_char_star line_buff ;
       Out.reset line_buff
 </r>755 <r>;;
     
     <b><U>let</U><r> noeof lexer lexbuf =
       </r><U>try</U></b> lexer lexbuf
       <b><U>with</U><m>
 760   <r>| Eof s -&gt;
         raise
             (Misc.Close
                ("End of file in environment: ``"^ !Scan.cur_env^"'' ("^s^")"))
       | EndVerb -&gt; ()
 </r>765 
     </m><U>let</U></b> open_verbenv star =
       Scan.top_open_block "PRE" "" ;
       process :=
          <b><U>if</U><r> star </r><U>then</U><m>
 770        <r>(<b><U>fun</U><r> () -&gt; put_line_buff_verb_star () ; Dest.put_char '\n')
          </r><U>else</U></b>
            (<b><U>fun</U><r> () -&gt; put_line_buff_verb () ; Dest.put_char '\n') ;
       finish :=
          </r><U>if</U></b> star <b><U>then</U><m>
 775        <r>put_line_buff_verb_star
          <b><U>else</U><r>
            put_line_buff_verb
     
     </r><U>and</U></b> close_verbenv _ = Scan.top_close_block "PRE"
 </r>780 
     </m><U>let</U></b> put_html () =
       Out.iter (<b><U>fun</U></b> c -&gt; Dest.put_char c) line_buff ;
       Out.reset line_buff
     ;;
 </r>785 
     </m><U>let</U></b> open_rawhtml lexbuf =
       <b><U>begin</U> <U>match</U></b> !Parse_opts.destination <b><U>with</U></b>
         | Parse_opts.Html -&gt; ()
         | _ -&gt;  Misc.warning "rawhtml detected"
 </r>790   </m><U>end</U></b> ;
       process :=
          (<b><U>fun</U></b> () -&gt; put_html () ; Dest.put_char '\n') ;
       finish := put_html ;
       noeof scan_byline lexbuf
 </r>795 
     <b><U>and</U></b></m> close_rawhtml _ = ()
     
     <b><U>let</U><r> open_forget lexbuf =
       process := (</r><U>fun</U></b> () -&gt; Out.reset line_buff) ;
 <m>800   <r>finish := (<b><U>fun</U><r> () -&gt; Out.reset line_buff) ;
       noeof scan_byline lexbuf
     
     </r><U>and</U></b> close_forget _ = ()
     
 </r>805 <b><U>let</U></b></m> open_tofile chan lexbuf =
       process :=
          (<b><U>fun</U><r> () -&gt;
            output_string chan (Out.to_string line_buff) ;
            output_char chan '\n') ;
 <m>810   </m>finish :=
          (</r><U>fun</U></b> () -&gt;
            output_string chan (Out.to_string line_buff) ;
            close_out chan) ;
       noeof scan_byline lexbuf
 <m>815 
     <b><U>and</U></b></m> close_tofile lexbuf = ()
     
     
     <b><U>let</U><r> put_line_buff_image () =
 <m>820   </m>Out.iter (</r><U>fun</U></b> c -&gt; Image.put_char c) line_buff ;
       Out.reset line_buff
     
     <b><U>let</U><r> open_verbimage lexbuf =
       process := (</r><U>fun</U></b> () -&gt; put_line_buff_image () ; Image.put_char '\n') ;
 <m>825   <r>finish := put_line_buff_image ;
       noeof scan_byline lexbuf
     
     <b><U>and</U></b> close_verbimage _ = ()
     ;;
 </r>830 
     
     <r>def_code "\\verbatim"
         (<b><U>fun</U><r> lexbuf -&gt;
           open_verbenv </r><U>false</U></b> ;
 </r>835       <r>noeof scan_byline lexbuf) ;
     def_code "\\endverbatim" close_verbenv ;
     
     
     def_code "\\verbatim*"
 </r>840     <r>(<b><U>fun</U><r> lexbuf -&gt;
           open_verbenv </r><U>true</U></b> ;
           noeof scan_byline lexbuf) ;
     def_code "\\endverbatim*" close_verbenv ;
     
 </r>845 <r>def_code "\\rawhtml" open_rawhtml ;
     def_code "\\endrawhtml" close_forget ;
     def_code "\\verblatex" open_forget ;
     def_code "\\endverblatex" Scan.check_alltt_skip ;
     def_code "\\verbimage" open_verbimage ;
 </r>850 <r>def_code "\\endverbimage" Scan.check_alltt_skip ;
     ()
     ;;
     
     <b><U>let</U></b> init_verbatim () =
 </r>855 <w>(* comment clashes with the ``comment'' package *)
       <r>Latexmacros.def "\\comment"  zero_pat (CamlCode open_forget) ;
       Latexmacros.def "\\endcomment" zero_pat (CamlCode Scan.check_alltt_skip) ;
     ()
     ;;
 <m>860 
     </m>register_init "verbatim" init_verbatim
     ;;
     
     </r>(* The program package for JJL  que j'aime bien *)
 </w>865 
     <b><U>let</U></b></m> look_escape () =
       <b><U>let</U><r> lexbuf = Lexing.from_string (Out.to_string line_buff) </r><U>in</U></b>
       do_escape lexbuf
     ;;
 <m>870 
     <b><U>let</U></b></m> init_program () =
       def_code "\\program"
         (<b><U>fun</U><r> lexbuf -&gt;
           Scan.top_open_block "PRE" "" ;
 <m>875       </m>process :=
              (</r><U>fun</U></b> () -&gt; look_escape () ; Dest.put_char '\n') ;
           finish := look_escape  ;
           noeof scan_byline lexbuf) ;
       def_code "\\endprogram" close_verbenv
 <m>880 <r>;;
     
     register_init "program" init_program
     ;;
     
 </r>885 
     <w>(* The moreverb package *)
     <b><U>let</U><r> tab_val = ref 8
     
     </r><U>let</U><r> put_verb_tabs () =
 <m>890   <b><U>let</U></b></m> char = ref 0 <b><U>in</U><r>
       Out.iter
         (</r><U>fun</U></b> c -&gt; <b><U>match</U><r> c </r><U>with</U></b>
           | '\t' -&gt;
               <b><U>let</U><r> limit = !tab_val - !char </r><U>mod</U></b> !tab_val <b><U>in</U><m>
 895           </m><U>for</U></b> j = 1 <b><U>to</U><r> limit </r><U>do</U></b>
                 Dest.put_char ' ' ; incr char
               <b><U>done</U><r> ;
           | c -&gt; Dest.put (Dest.iso c) ; incr char)
         line_buff ;
 <m>900   </m>Out.reset line_buff
     
     </r><U>let</U></b> open_verbenv_tabs () =
       Scan.top_open_block "PRE" "" ;
       process := (<b><U>fun</U><r> () -&gt; put_verb_tabs () ; Dest.put_char '\n') ;
 <m>905   </m>finish := put_verb_tabs
     
     </r><U>and</U></b> close_verbenv_tabs lexbuf =
       Scan.top_close_block "PRE" ;
       Scan.check_alltt_skip lexbuf
 <m>910 <r>;;
     
     <b><U>let</U><r> line = ref 0
     </r><U>and</U></b> interval = ref 1
     ;;
 </r>915 
     
     <b><U>let</U></b></m> output_line inter_arg star =
       <b><U>if</U><r> !line = 1 || !line </r><U>mod</U></b> inter_arg = 0 <b><U>then</U><r>
         scan_this Scan.main ("\\listinglabel{"^string_of_int !line^"}")
 </r><m>920   </m><U>else</U></b>
         Dest.put "     " ;
       <b><U>if</U><r> star </r><U>then</U></b>
         put_line_buff_verb_star ()
       <b><U>else</U><m>
 925     <r>put_verb_tabs () ;
       incr line
     
     
     <b><U>let</U></b> open_listing start_arg inter_arg star =
 </r>930   <r>Scan.top_open_block "PRE" "" ;
       line := start_arg ;
       <b><U>let</U><r> first_line = ref </r><U>true</U> <U>in</U>
       <U>let</U></b> inter = <b><U>if</U><r> inter_arg &lt;= 0 </r><U>then</U></b> 1 <b><U>else</U><r> inter_arg </r><U>in</U></b>
       process :=
 </r>935     <r>(<b><U>fun</U><r> () -&gt;
           </r><U>if</U></b> !first_line <b><U>then</U> <U>begin</U></b>
             first_line := <b><U>false</U><r> ;
             </r><U>if</U></b> not (Out.is_empty line_buff) <b><U>then</U></b>
               output_line inter_arg star ;
 </r>940       </m><U>end</U> <U>else</U></b>
             output_line inter_arg star  ;
           Dest.put_char '\n') ;
       finish :=
          (<b><U>fun</U><r> () -&gt;
 </r><m>945        </m><U>if</U></b> not (Out.is_empty line_buff) <b><U>then</U><r>
              output_line inter_arg star)
     
     </r><U>and</U></b> close_listing lexbuf =
       Scan.top_close_block "PRE" ;
 <m>950   <r>Scan.check_alltt_skip lexbuf
     ;;
     
     
     register_init "moreverb"
 </r>955 <r>(<b><U>fun</U><r> () -&gt;
       def_code "\\verbatimwrite"
         (</r><U>fun</U></b> lexbuf -&gt;
           <b><U>let</U><r> name = Scan.get_prim_arg lexbuf </r><U>in</U></b>
           Scan.check_alltt_skip lexbuf ;
 </r>960       <b><U>let</U></b></m> chan = open_out name <b><U>in</U><r>
           open_tofile chan lexbuf) ;
     
       def_code "\\endverbatimwrite" Scan.check_alltt_skip ;
     
 <m>965   </m>def_code "\\verbatimtab"
         (</r><U>fun</U></b> lexbuf -&gt;
           <b><U>let</U><r> opt = Get.get_int (save_opt "\\verbatimtabsize" lexbuf) </r><U>in</U></b>
           tab_val := opt ;
           open_verbenv_tabs () ;
 <m>970       </m>Lexstate.save_lexstate () ;
           <b><U>let</U><r> first = get_line lexbuf </r><U>in</U></b>
           Lexstate.restore_lexstate () ;
           scan_this Scan.main first ;
           Dest.put_char '\n' ;
 <m>975       </m>noeof scan_byline lexbuf) ;
       def_code "\\endverbatimtab" close_verbenv_tabs ;
     </r></b>(*
       def_code "\\verbatimtabinput"
         (fun lexbuf -&gt;
 </w>980       <w>let opt = Get.get_int (save_opt "\\verbatimtabsize" lexbuf) in
           tab_val := opt ;
           let name = Scan.get_prim_arg lexbuf in
           open_verbenv_tabs () ;
           verb_input scan_byline name ;
 </w>985       <w>close_verbenv_tabs lexbuf) ;
     *)
       <r>def_code "\\listinglabel"
         (<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> arg = Get.get_int (save_arg lexbuf) <b><U>in</U><m>
 990       <r>Dest.put (Printf.sprintf "%4d " arg)) ;
     
       def_code "\\listing"
         (<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> inter = Get.get_int (save_opt "1" lexbuf) <b><U>in</U><m>
 995       </m><U>let</U></b> start = Get.get_int (save_arg lexbuf) <b><U>in</U><r>
           interval := inter ;
           open_listing start inter </r><U>false</U></b> ;
           noeof scan_byline lexbuf) ;
       def_code "\\endlisting" close_listing ;
</r>1000 <w>(*
       def_code "\\listinginput"
         (fun lexbuf -&gt;
           let inter = Get.get_int (save_opt "1" lexbuf) in
           let start = Get.get_int (save_arg lexbuf) in
</w>1005       <w>let name = Scan.get_prim_arg lexbuf in
           interval := inter  ;
           open_listing start inter false ;
           verb_input scan_byline name ;
           close_listing lexbuf) ;
</w>1010 <w>*)
       <r>def_code "\\listingcont"
         (<b><U>fun</U><r> lexbuf -&gt;
           open_listing !line !interval </r><U>false</U></b> ;
           noeof scan_byline lexbuf) ;
<m>1015   </m>def_code "\\endlistingcont" close_listing ;
     
       def_code "\\listing*"
         (<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> inter = Get.get_int (save_opt "1" lexbuf) <b><U>in</U><m>
1020       </m><U>let</U></b> start = Get.get_int (save_arg lexbuf) <b><U>in</U><r>
           interval := inter ;
           open_listing start inter </r><U>true</U></b> ;
           noeof scan_byline lexbuf) ;
       def_code "\\endlisting*" close_listing ;
<m>1025 
       </m>def_code "\\listingcont*"
         (<b><U>fun</U><r> lexbuf -&gt;
           Scan.check_alltt_skip lexbuf ;
           open_listing !line !interval </r><U>false</U></b> ;
<m>1030       </m>noeof scan_byline lexbuf) ;
       def_code "\\endlistingcont*" close_listing ;
       ())
     
     </r>(* The comment package *)
</w>1035 
     </m><U>let</U></b> init_comment () =
       def_code "\\@excludecomment" open_forget ;
       def_code "\\end@excludecomment"  Scan.check_alltt_skip ;
     ;;
<m>1040 
     </m>register_init "comment" init_comment
     ;;
     
     </r>(* The listings package *)
</w>1045 
     <w>(*
       Caml code for
       \def\lst@spaces
         {\whiledo{\value{lst@spaces}&gt;0}{~\addtocounter{lst@spaces}{-1}}}
</w>1050 <w>*)
     <b><U>let</U><r> code_spaces lexbuf =
       </r><U>let</U><r> n = Counter.value_counter "lst@spaces" <b><U>in</U>
       <U>if</U></b> !lst_effective_spaces <b><U>then</U>
         <U>for</U></b> i = n-1 <b><U>downto</U><r> 0 </r><U>do</U><m>
1055       <r>Dest.put_char '_'
         <b><U>done</U>
       <U>else</U>
         <U>for</U></b> i = n-1 <b><U>downto</U><r> 0 </r><U>do</U></b>
           Dest.put_nbsp ()
</r>1060     </m><U>done</U></b> ;
       Counter.set_counter "lst@spaces" 0
     ;;
     
     <b><U>let</U><r> code_double_comment process_B process_E lexbuf =
</r><m>1065   </m><U>let</U></b> lxm_B = get_prim_arg lexbuf <b><U>in</U>
       <U>let</U></b> lxm_E = get_prim_arg lexbuf <b><U>in</U>
       <U>if</U></b> lxm_B &lt;&gt; "" &amp;&amp; lxm_E &lt;&gt; "" <b><U>then</U> <U>begin</U>
         <U>let</U></b> head_B = lxm_B.[0]
         <b><U>and</U><r> rest_B = String.sub lxm_B 1 (String.length lxm_B-1)
<m>1070     <b><U>and</U><r> head_E = lxm_E.[0]
         </r><U>and</U><r> rest_E = String.sub lxm_E 1 (String.length lxm_E-1) <b><U>in</U><r>
         lst_init_save_char head_B
           (process_B
              (</r><U>fun</U></b> c s -&gt;
<m>1075            </m>c = head_E &amp;&amp; s = rest_E)
              rest_B) ;
         lst_init_save_char head_E (process_E rest_E)
       </r><U>end</U></b>
     
1080 <b><U>let</U><r> code_line_comment lexbuf =
       </r><U>let</U><r> lxm_LC = get_prim_arg lexbuf <b><U>in</U>
       <U>if</U></b> lxm_LC &lt;&gt; "" <b><U>then</U> <U>begin</U>
         <U>let</U></b> head = lxm_LC.[0]
         <b><U>and</U></b> rest = String.sub lxm_LC 1 (String.length lxm_LC-1) </r><U>in</U></b>
1085     </m>lst_init_save_char head (lst_process_LC rest)
       </r><U>end</U>
     
     <U>let</U></b> code_stringizer lexbuf =
       <b><U>let</U><r> mode = Scan.get_prim_arg lexbuf </r><U>in</U><m>
1090   </m><U>let</U></b> schars = Scan.get_prim_arg lexbuf <b><U>in</U><r>
       lst_init_save_chars schars (lst_process_stringizer mode)
     ;;
     
     </r><U>let</U></b> open_lst inline keys lab =
<m>1095   </m>scan_this Scan.main ("\\lsthk@PreSet\\lstset{"^keys^"}") ;
     </r></b>(* For inline *)
       <r><b><U>if</U><r> inline </r><U>then</U></b>
         scan_this Scan.main "\\lsthk@InlineUnsave" ;
     </r>(* Ignoring output *)
</w>1100   <r>lst_gobble := Get.get_int (string_to_arg "\\lst@gobble") ;
       lst_first := Get.get_int (string_to_arg "\\lst@first") ;
       lst_last := Get.get_int (string_to_arg "\\lst@last") ;
       lst_nlines := 0 ;
       lst_init_char_table inline ;
</r>1105   <r>scan_this Scan.main "\\lsthk@SelectCharTable" ;
       <b><U>if</U><r> !lst_extended </r><U>then</U>
         <U>for</U></b> i = 128 <b><U>to</U><r> 255 </r><U>do</U></b>
           lst_init_char (Char.chr i) lst_process_letter
         <b><U>done</U></b> ;
</r>1110   <r>scan_this Scan.main "\\lsthk@Init" ;
     <w>(* Directives *)
       <b><U>if</U></b></w> !lst_directives <b><U>then</U> <U>begin</U></b>
         lst_init_save_char '#' lst_process_start_directive
       <b><U>end</U></b> ;
</r>1115 <w>(* Print key *)
       <b><U>if</U><r> not !lst_print </r><U>then</U> <U>begin</U><r>
         lst_last := -2 ; lst_first := -1
       <b><U>end</U></b> ;
     </r></b>(* Strings *)
</w>1120 <w>(* Escapes to TeX *)
       <b><U>if</U><r> !lst_mathescape </r><U>then</U> <U>begin</U><r>
         lst_init_save_char '$' (lst_process_escape <b><U>true</U><r> '$')
       </r><U>end</U></b> ;
       <b><U>let</U><r> begc = Scan.get_this_main "\\@getprintnostyle{\\lst@BET}"
</r><m>1125   </m><U>and</U></b> endc = Scan.get_this_main "\\@getprintnostyle{\\lst@EET}" <b><U>in</U>
       <U>if</U></b> begc &lt;&gt; "" &amp;&amp; endc &lt;&gt; "" <b><U>then</U> <U>begin</U></b>
         lst_init_save_char begc.[0] (lst_process_escape <b><U>false</U><r> endc.[0])
       </r><U>end</U></b> ;
       scan_this Scan.main "\\lsthk@InitVar" ;
<m>1130   <r>lst_scan_mode := Empty ;
       <b><U>if</U><r> inline </r><U>then</U></b>
         lst_top_mode := Normal
       <b><U>else</U></b>
         lst_top_mode := Skip
</r>1135 
     <b><U>and</U></b></m> close_lst inline =
       lst_finalize inline ;
       <b><U>while</U><r> !Scan.cur_env = "command-group" </r><U>do</U></b>
         scan_this Scan.main "\\endgroup"
<m>1140   <b><U>done</U></b></m> ;
       scan_this Scan.main "\\lsthk@DeInit"
     ;;
     
     <b><U>let</U><r> lst_boolean lexbuf =
</r><m>1145   </m><U>let</U></b> b = get_prim_arg lexbuf <b><U>in</U><r>
       Dest.put
         (</r><U>match</U></b> b <b><U>with</U><r>
         | "" -&gt; "false"
         | s  </r><U>when</U></b> s.[0] = 't' || s.[0] = 'T' -&gt; "true"
<m>1150     <r>| _ -&gt; "false")
     ;;
     
     def_code "\\@callopt"
         (<b><U>fun</U></b> lexbuf -&gt;
</r>1155       <b><U>let</U></b></m> csname = Scan.get_csname lexbuf <b><U>in</U>
           <U>let</U></b> old_raw = !raw_chars <b><U>in</U>
           <U>let</U></b> all_arg = get_prim_arg lexbuf <b><U>in</U>
           <U>let</U></b> lexarg = Lexing.from_string all_arg <b><U>in</U>
           <U>let</U></b> opt = Subst.subst_opt "" lexarg <b><U>in</U><m>
1160       </m><U>let</U></b> arg = Save.rest lexarg <b><U>in</U>
           <U>let</U></b> exec = csname^"["^opt^"]{"^arg^"}" <b><U>in</U><r>
           scan_this  Scan.main exec)
     ;;
     </r><U>let</U></b> init_listings () =
<m>1165   </m>Scan.newif_ref "lst@print" lst_print ;
       Scan.newif_ref "lst@extendedchars" lst_extended ;
       Scan.newif_ref "lst@texcl" lst_texcl ;
       Scan.newif_ref "lst@sensitive" lst_sensitive ;
       Scan.newif_ref "lst@mathescape" lst_mathescape ;
<m>1170   </m>Scan.newif_ref "lst@directives" lst_directives ;
       Scan.newif_ref "lst@stringspaces" lst_string_spaces ;
       Scan.newif_ref "lst@showlines" lst_showlines ;
       def_code "\\lst@spaces" code_spaces ;
       def_code "\\lst@boolean" lst_boolean ;
<m>1175   </m>def_code "\\lst@def@stringizer" code_stringizer ;
       def_code "\\lst@AddTo"
         (<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> sep = Scan.get_prim_arg lexbuf <b><U>in</U>
           <U>let</U></b> name = Scan.get_csname lexbuf <b><U>in</U><m>
1180       </m><U>let</U></b> old =
             <b><U>try</U> <U>match</U></b> Latexmacros.find_fail name <b><U>with</U><r>
             | _, Subst s -&gt; s
             | _,_        -&gt; ""
             </r><U>with</U><m>
1185         <r>| Latexmacros.Failed -&gt; "" <b><U>in</U>
           <U>let</U></b> toadd = get_prim_arg lexbuf <b><U>in</U><r>
           Latexmacros.def name zero_pat
             (Subst (</r><U>if</U></b> old="" <b><U>then</U><r> toadd </r><U>else</U></b> old^sep^toadd))) ;
       def_code "\\lst@lExtend"
</r>1190     <r>(<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> name = Scan.get_csname lexbuf <b><U>in</U>
           <U>try</U>
             <U>match</U></b> Latexmacros.find_fail name <b><U>with</U></b>
             | _, Subst body -&gt;
</r>1195             </m><U>let</U></b> toadd = Subst.subst_arg lexbuf <b><U>in</U><r>
                 Latexmacros.def name zero_pat (Subst (body^"%\n"^toadd))
             | _, _ -&gt;
                 warning ("Cannot \\lst@lExtend ``"^name^"''")
           </r><U>with</U><m>
1200       <r>| Latexmacros.Failed -&gt;
                 warning ("Cannot \\lst@lExtend ``"^name^"''")) ;
       def_code "\\lstlisting"
         (<b><U>fun</U></b> lexbuf -&gt;
           Image.stop () ;
</r>1205       </m><U>let</U></b> keys = Subst.subst_opt "" lexbuf <b><U>in</U>
           <U>let</U></b> lab = Scan.get_prim_arg lexbuf <b><U>in</U>
           <U>let</U></b> lab = <b><U>if</U><r> lab = " " </r><U>then</U></b> "" <b><U>else</U><r> lab </r><U>in</U>
           <U>if</U></b> lab &lt;&gt; "" <b><U>then</U><r>
             def "\\lst@intname" zero_pat (CamlCode (</r><U>fun</U></b> _ -&gt; Dest.put lab)) ;
<m>1210       </m>open_lst <b><U>false</U></b> keys lab ;
           scan_this Scan.main "\\lst@pre\\@open@lstbox" ;
           scan_this Scan.main "\\lst@basic@style" ;
           </r></b>(* Eat first line *)
           <r>save_lexstate () ;
<m>1215       </m>noeof eat_line lexbuf ;
           restore_lexstate () ;
     </r>(* For detecting endstring, must be done after eat_line *)
           <r>lst_init_save_char '\\' (lst_process_end "end{lstlisting}") ;
           noeof listings lexbuf ;
<m>1220       </m>close_lst <b><U>false</U></b>  ;
           scan_this Scan.main "\\@close@lstbox\\lst@post" ;
           Scan.top_close_block "" ;
           Scan.close_env !Scan.cur_env ;
           Image.restart () ;
<m>1225       </m>Scan.check_alltt_skip lexbuf) ;
     </r>(* Init comments from .hva *)
       <r>def_code "\\lst@balanced@comment"
         (<b><U>fun</U><r> lexbuf -&gt;
           code_double_comment lst_process_BBC lst_process_EBC lexbuf) ;
<m>1230   </m>def_code "\\lst@nested@comment"
         (</r><U>fun</U></b> lexbuf -&gt;
           code_double_comment lst_process_BNC lst_process_ENC lexbuf) ;
       def_code "\\lst@line@comment" code_line_comment ;
     
<m>1235   </m>def_code "\\lstinline"
         (<b><U>fun</U><r> lexbuf -&gt;
           </r><U>let</U></b> keys = Subst.subst_opt "" lexbuf <b><U>in</U>
           <U>let</U></b> {arg=arg} = save_verbatim lexbuf <b><U>in</U><r>
           Scan.new_env "*lstinline*" ;
<m>1240       </m>scan_this main "\\mbox{" ;
           open_lst </r><U>true</U></b> keys "" ;
           Dest.open_group "CODE" ;
           <b><U>begin</U> <U>try</U></b>
             scan_this listings arg
<m>1245       <b><U>with</U><r>
           | Eof _ -&gt; ()
           </r><U>end</U><r> ;
           close_lst <b><U>true</U><r> ;
           Dest.close_group () ;
<m>1250       </m>scan_this main "}" ;
           Scan.close_env "*lstinline*") ;
     
       def_code "\\lst@definelanguage"
         (</r><U>fun</U></b> lexbuf -&gt;
<m>1255       <b><U>let</U><r> dialect = get_prim_opt "" lexbuf </r><U>in</U>
           <U>let</U><r> language = get_prim_arg lexbuf <b><U>in</U>
           <U>let</U></b> base_dialect = get_prim_opt "!*!" lexbuf <b><U>in</U>
     
           <U>match</U></b> base_dialect </r><U>with</U></b>
1260       </m>| "!*!" -&gt;
               <b><U>let</U><r> keys = subst_arg lexbuf </r><U>in</U>
               <U>let</U></b> _ = save_opt "" lexbuf <b><U>in</U><r>
               scan_this main
                 ("\\lst@definelanguage@{"^language^"}{"^
<m>1265              </m>dialect^"}{"^keys^"}")
           | _  -&gt;
               </r><U>let</U></b> base_language = get_prim_arg lexbuf <b><U>in</U>
               <U>let</U></b> keys = subst_arg lexbuf <b><U>in</U>
               <U>let</U></b> _ = save_opt "" lexbuf </r><U>in</U></b>
1270           </m>scan_this main
                 ("\\lst@derivelanguage@{"^
                  language^"}{"^ dialect^"}{"^
                  base_language^"}{"^base_dialect^"}{"^
                  keys^"}"))
<m>1275 </m>;;
     
     register_init "listings" init_listings
     ;;
     
<m>1280 
     <b><U>let</U><r> init_fancyvrb () =
       def_code "\\@Verbatim"
         (</r><U>fun</U><r> lexbuf -&gt;
           open_verbenv <b><U>false</U><r> ;
<m>1285       </m>noeof scan_byline lexbuf) ;
       def_code "\\@endVerbatim" close_verbenv
     ;;
     
     
<m>1290 </m>register_init "fancyvrb" init_fancyvrb
     ;;
     
     
     
<m>1295 </m>def_code "\\@scaninput"
       (</r><U>fun</U></b> lexbuf -&gt;
         <b><U>let</U><r> pre = save_arg lexbuf </r><U>in</U>
         <U>let</U></b> file = get_prim_arg lexbuf <b><U>in</U>
         <U>let</U></b> {arg=post ; subst=post_subst} = save_arg lexbuf </r><U>in</U></b>
1300     <b><U>try</U>
           <U>let</U><r> true_name,chan = Myfiles.open_tex file <b><U>in</U>
           <U>if</U></b> !verbose &gt; 0 <b><U>then</U><r>
             message ("Scan input file: "^true_name) ;
           </r><U>let</U></b> filebuff = Lexing.from_channel chan </r><U>in</U></b>
1305       </m>start_lexstate () ;
           <b><U>let</U><r> old_input = !input_verb </r><U>in</U>
           <U>if</U></b> old_input <b><U>then</U><r> warning "Nested \\@scaninput" ;
           input_verb := </r><U>true</U></b> ;
           Location.set true_name filebuff ;
<m>1310       <b><U>begin</U> <U>try</U><r>
             record_lexbuf (Lexing.from_string post) post_subst ;
             scan_this_may_cont Scan.main filebuff top_subst
               pre ;
           <b><U>with</U><r> e -&gt;
<m>1315         </m>restore_lexstate () ;
             Location.restore () ;
             close_in chan ;
             raise e
           </r><U>end</U></b> ;
<m>1320       </m>restore_lexstate () ;
           Location.restore () ;
           close_in chan ;
           input_verb := old_input
         </r><U>with</U></b>
1325     </m>| Myfiles.Except -&gt;
             warning ("Not opening file: "^file)
         | Myfiles.Error s -&gt;
             warning s)
     <b><U>end</U></b><PL><B>
<6>122 version.ml</6>
</B></PL></r> 
     (***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   </w>5 <w>(*  Luc Maranget, projet PARA, INRIA Rocquencourt                      *)
     (*                                                                     *)
     (*  Copyright 1998 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  </w>10 <w>(***********************************************************************)
     
     <b><U>let</U><r> header = "$Id: version.ml,v 1.64 2001/05/29 15:11:19 maranget Exp $"
     </r><U>let</U><r> real_version = "1.06-7"
     <b><U>let</U><r> release_date = "2001-05-29"
  </r><m>15 
     </m><U>let</U></b> version =
       <b><U>try</U>
        <U>let</U></b> _ = String.index real_version '-' <b><U>in</U><r>
        real_version^" of "^release_date
  </r><m>20   </m><U>with</U></b>
       | Not_found -&gt; real_version<PL><B>
<6>123 videoc.ml</6>
</B></PL> 
      17 "videoc.mll"
     
     <b><U>module</U> <U>type</U></b> T =
       <b><U>sig</U><m>
   5   </m><U>end</U></b>;;
     
     <b><U>module</U><r> Make
         (Dest : OutManager.S)
         (Image : ImageManager.S)
  <m>10     </m>(Scan : Latexscan.S) =
     </r><U>struct</U>
     <U>open</U></b> Misc
     <b><U>open</U><r> Parse_opts
     </r><U>open</U></b> Lexing
  <m>15 <b><U>open</U></b></m> Myfiles
     <b><U>open</U><r> Lexstate
     </r><U>open</U></b> Latexmacros
     <b><U>open</U><r> Subst
     </r><U>open</U></b> Scan
  <m>20 
     
     <b><U>let</U></b></m> header =
       "$Id: videoc.mll,v 1.26 2001/05/25 12:37:35 maranget Exp $"
     </r></b>(* So I can synchronize my changes from Luc's ones *)
  </w>25 <b><U>let</U></b></m> qnc_header =
       "30 oct 2000"
     
     <b><U>exception</U><r> EndSnippet
     ;;
  </r><m>30 </m><U>exception</U></b> EndTeXInclusion
     ;;
     
     <w>(* Re-link with these variables inserted in latexscan. *)
     
  <m>35 <b><U>let</U><r> withinSnippet = ref </r><U>false</U><r>;;
     <b><U>let</U><r> withinTeXInclusion = ref </r><U>false</U></b>;;
     <b><U>let</U><r> endSnippetRead = ref </r><U>false</U></b>;;
     
     <w>(* Snippet global defaults *)
  <m>40 
     <b><U>let</U><r> snippetLanguage = ref "";;
     </r><U>let</U><r> enableLispComment = ref <b><U>false</U><r>;;
     </r><U>let</U></b> enableSchemeCharacters = ref <b><U>false</U></b>;;
     
  </r></b>45 </m>(* Snippet Environment: run a series of hooks provided they exist as
        user macros. *)
     
     <b><U>let</U></b></w> runHook prefix parsing name =
       <b><U>let</U><r> run name = </r><U>begin</U><m>
  50     </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("Trying to run hook " ^ name);
         </r><U>if</U></b> Latexmacros.exists name
         <b><U>then</U> <U>begin</U></b> Lexstate.scan_this parsing name; () <b><U>end</U>
       <U>end</U> <U>in</U>
       <U>let</U> <U>rec</U></b> iterate name suffix =
  </r></b>55     <r>run name;
         <b><U>if</U><r> suffix &lt;&gt; ""
         </r><U>then</U></b> iterate (name ^ (String.make 1 (String.get suffix 0)))
                      (String.sub suffix 1 ((String.length suffix) - 1))
       <b><U>in</U></b> iterate (prefix ^ name ^ "Hook") !snippetLanguage;;
  </r>60 
     <b><U>let</U><r> snippetRunHook parsing name =
       runHook "\\snippet" parsing name;;
     
     </r><U>let</U><r> snipRunHook parsing name =
  </r></b>65   <r>runHook "\\snip" parsing name;;
     
     <w>(* Hack for mutual recursion between modules: *)
     
     <b><U>let</U></b></w> handle_command = ref
  </r>70   <r>((<b><U>function</U><r> lexbuf -&gt; </r><U>function</U></b> s -&gt; ())
          : (Lexing.lexbuf -&gt; string -&gt; unit));;
     
     <w>(* Convert a reference to a hint such as "3" "annote.ann" "premier indice"
        into "3_annote_ann". This is needed for the annote tool.  *)
  <m>75 
     <b><U>let</U></b><r> compute_hint_id number filename notename =
       <b><U>let</U><r> result = number ^ "_" ^ filename </r><U>in</U>
       <U>let</U> <U>rec</U></b> convert i = <b><U>begin</U>
         <U>if</U></b> i&lt;String.length(result)
  </r>80     <b><U>then</U> <U>let</U></b><r> c = String.get result i <b><U>in</U>
              <U>if</U> <U>true</U></b> || ('a' &lt;= c &amp;&amp; c &lt;= 'z') <w>(* test *)
                 </w>|| ('A' &lt;= c &amp;&amp; c &lt;= 'z')
                 || ('0' &lt;= c &amp;&amp; c &lt;= '9')
              <b><U>then</U></b> ()
  </r>85          <b><U>else</U></b><r> String.set result i '_';
              convert (i+1);
         <b><U>end</U> <U>in</U></b>
       convert 0;
       result;;
  </r>90 
     <b><U>let</U><r> increment_internal_counter =
       </r><U>let</U><r> counter = ref 99 <b><U>in</U>
       <U>function</U></b> () -&gt;
         </r><U>begin</U></b>
  95       <r>counter := !counter + 1;
           !counter
         <b><U>end</U><r>;;
     
     </r><U>let</U></b> lex_tables = {
 </r>100   <r>Lexing.lex_base =
        "\000\000\001\000\001\000\001\000\002\000\255\255\254\255\002\000\
    \030\000\111\000\249\255\252\255\253\255\250\255\001\000\195\000\
    \020\001\002\000";
       Lexing.lex_backtrk =
        "\255\255\001\000\002\000\255\255\255\255\255\255\255\255\000\000\
    \255\255\000\000\255\255\255\255\255\255\255\255\004\000\006\000\
    \001\000\004\000";
       Lexing.lex_default =
 </r>105    <r>"\010\000\255\255\255\255\004\000\004\000\000\000\000\000\255\255\
    \005\000\255\255\000\000\000\000\000\000\000\000\255\255\006\000\
    \255\255\255\255";
       Lexing.lex_trans =
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\011\000\012\000\006\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \011\000\007\000\007\000\013\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\005\000\005\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\014\000\017\000\017\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\015\000\008\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\000\000\000\000\000\000\000\000\000\000\000\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\005\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \005\000\006\000\255\255\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\255\255\000\000\
    \000\000\000\000\000\000\000\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\006\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\255\255\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000";
       Lexing.lex_check =
        "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\002\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\002\000\007\000\000\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\003\000\004\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\000\000\014\000\017\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\000\000\001\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\255\255\255\255\255\255\255\255\255\255\255\255\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
    \008\000\009\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
    \009\000\009\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\003\000\004\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\008\000\255\255\
    \255\255\255\255\255\255\255\255\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\015\000\015\000\
    \015\000\015\000\015\000\015\000\015\000\015\000\016\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
    \016\000\016\000\016\000\016\000\016\000\016\000\016\000\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\015\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255"
 </r>110 <r>}
     
     <b><U>let</U> <U>rec</U></b> snippetenv lexbuf = __ocaml_lex_snippetenv_rec lexbuf 0
     <b><U>and</U><r> __ocaml_lex_snippetenv_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><m>
 115     <r>0 -&gt; (
      119 "videoc.mll"
             () )
       | 1 -&gt; (
      121 "videoc.mll"
 </r>120     </m><U>let</U></b> csname = lexeme lexbuf <b><U>in</U>
         <U>let</U></b> pat,body = Latexmacros.find csname <b><U>in</U>
         <U>begin</U> <U>match</U></b> pat <b><U>with</U><r>
         | [],[] -&gt;
           </r><U>let</U></b> args =  make_stack csname pat lexbuf <b><U>in</U><m>
 125       </m><U>let</U></b> cur_subst = get_subst () <b><U>in</U>
           <U>let</U></b> exec = <b><U>function</U><r>
             | Subst body -&gt;
                 </r><U>if</U></b> !verbose &gt; 2 <b><U>then</U></b>
                   prerr_endline ("user macro in snippet: "^body) ;
 </r>130             <r>Lexstate.scan_this_may_cont Scan.main
                   lexbuf cur_subst (string_to_arg body)
             | Toks l -&gt;
                 List.iter
                   (<b><U>fun</U></b> s -&gt; scan_this Scan.main s)
 </r>135               <r>(List.rev l)
             | CamlCode f -&gt; f lexbuf <b><U>in</U></b>
           scan_body exec body args
         |  _ -&gt;
           raise (Misc.ScanError ("Command with arguments inside snippet"))
 </r>140     <b><U>end</U><r> ;
         snippetenv lexbuf)
       | 2 -&gt; (
      144 "videoc.mll"
          Dest.put_tag "&lt;BR&gt;";
 <m>145      </m>Dest.put_char '\n';
          snippetRunHook Scan.main "AfterLine";
          snippetRunHook Scan.main "BeforeLine";
          snippetenv lexbuf)
       | 3 -&gt; (
 <m>150  </m>150 "videoc.mll"
          Dest.put_nbsp ();
          snippetenv lexbuf)
       | 4 -&gt; (
      153 "videoc.mll"
 <m>155      </m>Dest.put (lexeme lexbuf);
          Dest.put_char ' ';
          </r><U>if</U><r> !enableLispComment
          <b><U>then</U> <U>begin</U>
             <U>if</U></b> !verbose &gt; 1 <b><U>then</U><m>
 160           <r>prerr_endline "Within snippet: Lisp comment entered";
             Lexstate.withinLispComment := <b><U>true</U></b>;
             Scan.top_open_block "SPAN"
               ("class=\"" ^ !snippetLanguage ^ "Comment\"");
             snippetRunHook Scan.main "BeforeComment";
 </r>165         </m><U>try</U></b> Scan.main lexbuf </r><U>with</U></b></m> (* until a \n is read *)
             </w>| exc -&gt; <b><U>begin</U><r>
                 snippetRunHook Scan.main "AfterComment";
                 Scan.top_close_block "SPAN";
                 Lexstate.withinLispComment := </r><U>false</U></b>;
 </r>170             </m>(* re-raise every exception but EndOfLispComment *)
                 <b><U>try</U></b></w> raise exc <b><U>with</U><r>
                 | Misc.EndOfLispComment nlnum -&gt; </r><U>begin</U>
                     <U>let</U></b> addon = (<b><U>if</U><r> !endSnippetRead </r><U>then</U></b> "\\endsnippet" <b><U>else</U><r> "") </r><U>in</U>
                     <U>if</U></b> !verbose &gt; 1 <b><U>then</U><m>
 175                   <r>Printf.fprintf stderr "%d NL after LispComment %s\n"
                         nlnum ((<b><U>if</U><r> !endSnippetRead </r><U>then</U></b> "and " <b><U>else</U><r> "")^addon);
                     </r><U>let</U></b> _ = Lexstate.scan_this snippetenv
                         ((String.make (1+nlnum) '\n')^addon) <b><U>in</U></b>
                     ()
 </r>180             </m><U>end</U></b>;
             <b><U>end</U><r>;
          </r><U>end</U></b>;
          snippetenv lexbuf)
       | 5 -&gt; (
 <m>185  </m>183 "videoc.mll"
          Dest.put_char '#';
          <b><U>if</U><r> !enableSchemeCharacters
          </r><U>then</U> <U>begin</U>
             <U>if</U></b> !verbose &gt; 1 <b><U>then</U><m>
 190           <r>prerr_endline "Within snippet: scheme characters enabled";
             schemecharacterenv lexbuf
          <b><U>end</U></b>;
          snippetenv lexbuf)
       | 6 -&gt; (
 </r>195  <r>192 "videoc.mll"
          Dest.put (Dest.iso (lexeme_char lexbuf 0));
          snippetenv lexbuf)
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_snippetenv_rec lexbuf n
     
 </r>200 </m><U>and</U></b> schemecharacterenv lexbuf = __ocaml_lex_schemecharacterenv_rec lexbuf 1
     <b><U>and</U><r> __ocaml_lex_schemecharacterenv_rec lexbuf state =
       </r><U>match</U></b> Lexing.engine lex_tables state lexbuf <b><U>with</U><r>
         0 -&gt; (
      199 "videoc.mll"
 <m>205      <b><U>let</U><r> csname = lexeme lexbuf </r><U>in</U><r>
          Dest.put csname)
       | 1 -&gt; (
      202 "videoc.mll"
           () )
 <m>210   </m>| n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_schemecharacterenv_rec lexbuf n
     
     <b><U>and</U><r> skip_blanks_till_eol_included lexbuf = __ocaml_lex_skip_blanks_till_eol_included_rec lexbuf 2
     </r><U>and</U></b> __ocaml_lex_skip_blanks_till_eol_included_rec lexbuf state =
       <b><U>match</U></b> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
 215     </m>0 -&gt; (
      208 "videoc.mll"
          skip_blanks_till_eol_included lexbuf)
       | 1 -&gt; (
      210 "videoc.mll"
 <m>220       </m>() )
       | 2 -&gt; (
      212 "videoc.mll"
           () )
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_skip_blanks_till_eol_included_rec lexbuf n
 <m>225 
     <b><U>and</U><r> comma_separated_values lexbuf = __ocaml_lex_comma_separated_values_rec lexbuf 3
     </r><U>and</U><r> __ocaml_lex_comma_separated_values_rec lexbuf state =
       <b><U>match</U><r> Lexing.engine lex_tables state lexbuf </r><U>with</U></b>
         0 -&gt; (
 <m>230  </m>218 "videoc.mll"
          <b><U>let</U><r> lxm = lexeme lexbuf </r><U>in</U>
          <U>let</U></b> s = String.sub lxm 0 (String.length lxm - 1) <b><U>in</U>
          <U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("CSV" ^ s);
          s :: comma_separated_values lexbuf)
 <m>235   </m>| 1 -&gt; (
      223 "videoc.mll"
           [] )
       | n -&gt; lexbuf.Lexing.refill_buff lexbuf; __ocaml_lex_comma_separated_values_rec lexbuf n
     
 <m>240 </m>;;
     
      227 "videoc.mll"
     
     </r><U>let</U></b> caml_print s = CamlCode (<b><U>fun</U><r> _ -&gt; Dest.put s)
 <m>245 <b><U>let</U><r> snippet_def name d = Latexmacros.def name zero_pat (CamlCode d)
     
     </r><U>let</U> <U>rec</U><r> do_endsnippet _ =
       <b><U>if</U><r> !Lexstate.withinLispComment </r><U>then</U> <U>begin</U></b>
         endSnippetRead := <b><U>true</U><r>;
 <m>250     </m>raise (Misc.EndOfLispComment 0)
       </r><U>end</U></b>;
       <b><U>if</U><r> !Scan.cur_env = "snippet" </r><U>then</U></b>
         raise EndSnippet
       </r><U>else</U></b>
 255     </m>raise (Misc.ScanError ("\\endsnippet without opening \\snippet"))
     
     </r><U>and</U></b> do_texinclusion lexbuf =
       Scan.top_open_block "SPAN"
         ("class=\"" ^ !snippetLanguage ^ "Inclusion\"");
 <m>260   </m>snippetRunHook Scan.main "BeforeTeX";
       withinTeXInclusion := <b><U>true</U><r>;
       </r><U>begin</U><w> (* Until a \] is read *)
         </w><U>try</U></b> Scan.main lexbuf <b><U>with</U></b>
         | exc -&gt; </r><U>begin</U></b>
 265         </m>snippetRunHook Scan.main "AfterTeX";
             Scan.top_close_block "SPAN";
             snippetRunHook Scan.main "Restart";
             </r><w>(* Re-raise every thing but EndTeXInclusion *)
             </w><U>try</U></b> raise exc <b><U>with</U><m>
 270         <r>| EndTeXInclusion -&gt; ()
         <b><U>end</U><r>;
       </r><U>end</U></b> ;
     
     <b><U>and</U></b> do_texexclusion _ =
 </r>275  </m><U>if</U></b> !withinSnippet </r><U>then</U> <U>begin</U>
        <U>if</U><r> !verbose &gt; 2 </r><U>then</U><r> prerr_endline "\\] caught within TeX escape";
        withinTeXInclusion := <b><U>false</U><r>;
        raise EndTeXInclusion
      </r><U>end</U> <U>else</U><m>
 280    <r>raise (Misc.ScanError ("\\] without opening \\[ in snippet"))
     
     <b><U>and</U></b> do_backslash_newline  _ =
       Dest.put "\\\n";
       Lexstate.scan_this snippetenv "\n"
 </r>285 
     </m><U>and</U></b> do_four_backslashes _ = Dest.put "\\"
     
     <w>(* HACK: Define a macro with a body that is obtained via substitution.
        This is a kind of restricted \edef as in TeX.
 <m>290    </m>Syntax:    \@EDEF\macroName{#2#1..}                                 *)
     
     <b><U>and</U></b></w> do_edef lxm lexbuf =
       <b><U>let</U><r> name = Scan.get_csname lexbuf </r><U>in</U>
       <U>let</U></b> body = subst_arg lexbuf <b><U>in</U><m>
 295   </m><U>if</U></b> Scan.echo_toimage () <b><U>then</U><r>
         Image.put ("\\def"^name^"{"^body^"}\n") ;
       Latexmacros.def name zero_pat (caml_print body);
       ()
     
 </r><m>300 <w>(* Syntax:  \@MULEDEF{\macroName,\macroName,...}{#1#3...}
        This is an awful hack extending the \@EDEF command. It locally
        rebinds the (comma-separated) \macronames to the corresponding
        (comma-separated) expansion of second argument. All \macronames
        should be a zero-ary macro. *)
 </w>305 
     </m><U>and</U></b> do_muledef lxm lexbuf =
       <b><U>let</U><r> names = subst_arg lexbuf </r><U>in</U>
       <U>let</U></b> bodies = subst_arg lexbuf <b><U>in</U>
       <U>let</U> <U>rec</U></b> bind lasti lastj =
 <m>310     <b><U>try</U> <U>let</U><r> i = String.index_from names lasti ',' <b><U>in</U>
         <U>try</U> <U>let</U></b> j = String.index_from bodies lastj ',' <b><U>in</U>
         <U>let</U></b> name = String.sub names lasti (i - lasti) <b><U>in</U>
         <U>let</U></b> body = String.sub bodies lastj (j - lastj) <b><U>in</U>
         <U>if</U></b> !verbose &gt; 2 <b><U>then</U></b> prerr_endline (lxm ^ name ^ ";" ^ body);
 </r></b>315     <r>Latexmacros.def name zero_pat (caml_print body);
           bind (i+1) (j+1)
         <b><U>with</U><r> Not_found -&gt; failwith "Missing bodies for \\@MULEDEF"
         </r><U>with</U></b> Not_found -&gt;
           <b><U>let</U><r> name = String.sub names lasti (String.length names - lasti) </r><U>in</U><m>
 320       </m><U>let</U></b> body = String.sub bodies lastj (String.length bodies - lastj) <b><U>in</U>
           <U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline (lxm ^ name ^ ";" ^ body);
           Latexmacros.def name zero_pat (caml_print body) ;
       </r><U>in</U></b> bind 0 0;
       ()
 </r>325 
     
     <w>(* The command that starts the \snippet inner environment: *)
     
     </w></m><b><U>and</U><r> do_snippet lexbuf =
 </r><m>330   </m><U>if</U></b> !withinSnippet
       <b><U>then</U><r> raise (Misc.ScanError "No snippet within snippet.")
       </r><U>else</U> <U>begin</U><w>
         (* Obtain the current TeX value of \snippetDefaultLanguage *)
         </w><U>let</U></b> snippetDefaultLanguage =   "\\snippetDefaultLanguage" <b><U>in</U><m>
 335     </m><U>let</U></b> language = get_prim_opt snippetDefaultLanguage lexbuf <b><U>in</U>
         <U>let</U></b> language = <b><U>if</U><r> language = "" </r><U>then</U></b> snippetDefaultLanguage
                                         <b><U>else</U><r> language </r><U>in</U></b>
         skip_blanks_till_eol_included lexbuf;
         Dest.put "&lt;BR&gt;\n";
 <m>340     <r>Scan.top_open_block "DIV" ("class=\"div" ^ language ^ "\"");
         Dest.put "\n";
         Scan.new_env "snippet";
         <w>(* Define commands local to \snippet *)
         </w>snippet_def "\\endsnippet"  do_endsnippet;
 </r>345     <r>snippet_def "\\[" do_texinclusion ;
         snippet_def "\\]" do_texexclusion ;
         snippet_def "\\\\" do_four_backslashes ;
         snippet_def "\\\n" do_backslash_newline ;
     
 </r>350     <r>snippetLanguage := language;
         enableLispComment := <b><U>false</U><r>;
         enableSchemeCharacters := </r><U>false</U></b>;
         withinSnippet := <b><U>true</U></b>;
         snippetRunHook Scan.main "Before";
 </r>355     <b><U>try</U><r> snippetenv lexbuf </r><U>with</U><r>
           exc -&gt; <b><U>begin</U><r>
             snippetRunHook Scan.main "AfterLine";
             snippetRunHook Scan.main "After";
             withinSnippet := </r><U>false</U></b>;
 </r></b>360         <r>Scan.close_env "snippet";
             Scan.top_close_block "DIV";
             <w>(* Re-raise all exceptions but EndSnippet *)
             <b><U>try</U></b></w> raise exc <b><U>with</U></b>
               EndSnippet -&gt; ()
 </r>365       <b><U>end</U><r>;
       </r><U>end</U>
     
     <U>and</U><r> do_enable_backslashed_chars lexbuf =
       <b><U>let</U><r> def_echo s = snippet_def s (</r><U>fun</U></b> _ -&gt; Dest.put s) <b><U>in</U><m>
 370   </m><U>let</U></b> chars = subst_arg lexbuf <b><U>in</U> <U>begin</U>
       <U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("\\enableBackslashedChar "^chars);
       </r><U>for</U></b> i=0 <b><U>to</U><r> (String.length chars - 1) </r><U>do</U>
         <U>let</U></b> charcommandname = "\\" ^ (String.sub chars i 1) <b><U>in</U></b>
         def_echo charcommandname;
 </r></b>375   <b><U>done</U><r>;
       </r><U>end</U><r>;
       ()
     
     <b><U>and</U></b> do_enableLispComment lexbuf =
 </r></b>380   <r>enableLispComment := <b><U>true</U><r>;
       ()
     
     </r><U>and</U></b> do_disableLispComment lexbuf =
       enableLispComment := <b><U>false</U></b>;
 </r>385   <r>()
     
     <b><U>and</U><r> do_enableSchemeCharacters lexbuf =
       enableSchemeCharacters := </r><U>true</U></b>;
       ()
 </r>390 
     <b><U>and</U><r> do_disableSchemeCharacters lexbuf =
       enableSchemeCharacters := </r><U>false</U><r>;
       ()
     
 </r></b>395 <r><b><U>and</U><r> do_snippet_run_hook lexbuf =
       </r><U>let</U></b> name = subst_arg lexbuf <b><U>in</U> <U>begin</U></b>
         snippetRunHook Scan.main name;
         ()
       <b><U>end</U><m>
 400 
     </m><U>and</U></b> do_snip_run_hook lexbuf =
       <b><U>let</U><r> name = subst_arg lexbuf </r><U>in</U> <U>begin</U></b>
         snipRunHook Scan.main name;
         ()
 </r>405   <b><U>end</U><w>
     
     (* These macros are defined in Caml since they are not nullary macros.
        They require some arguments but they cannot get them in the snippet
        environment. So I code them by hand. *)
 <m>410 
     <b><U>and</U><r> do_vicanchor lexbuf = </r><U>begin</U>
       <U>let</U><r> {arg=style} = Lexstate.save_opt "" lexbuf <b><U>in</U>
       <U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("\\vicanchor"^style);
       </r><U>let</U></b> {arg=nfn}   = Lexstate.save_opt "0,filename,notename" lexbuf <b><U>in</U><m>
 415   </m><U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("\\vicanchor"^style^nfn);
       </r><U>let</U></b> fields =
         comma_separated_values (Lexing.from_string (nfn ^ ",")) <b><U>in</U>
       <U>match</U></b> fields <b><U>with</U></b>
       | [number;filename;notename] -&gt;
 </r></b>420       <b><U>begin</U>
             <U>let</U><r> uniqueNumber = <w>(* Would be better: truncate(Unix.gettimeofday()) *)
               </w>increment_internal_counter()
             <b><U>and</U><r> hintId = compute_hint_id number filename notename </r><U>in</U></b>
             Dest.put_tag ("&lt;A id=\"a" ^ string_of_int(uniqueNumber)
 </r></b>425                       <r>^ "__" ^ hintId
                           ^ "\" href=\"javascript: void showMessage('"
                           ^ hintId ^ "')\" class=\"mousable\"&gt;&lt;SPAN style=\""
                           ^ style ^ "\"&gt;&lt;!-- " ^ nfn ^ " --&gt;");
             ()
 </r>430       <b><U>end</U><r>
       | _ -&gt; failwith "Missing comma-separated arguments"
     </r><U>end</U>
     
     <U>and</U><r> do_vicendanchor lexbuf = <b><U>begin</U><m>
 435   </m><U>let</U></b> {arg=nfn} = Lexstate.save_opt "0,filename,notename" lexbuf <b><U>in</U>
       <U>if</U></b> !verbose &gt; 2 <b><U>then</U><r> prerr_endline ("\\vicendanchor"^nfn);
       </r><U>let</U></b> fields =
         comma_separated_values (Lexing.from_string (nfn ^ ",")) <b><U>in</U>
       <U>match</U></b> fields <b><U>with</U><m>
 440   <r>| [number;filename;notename] -&gt; <b><U>begin</U><r>
           Dest.put_tag ("&lt;/SPAN&gt;&lt;/A&gt;");
           ()
       </r><U>end</U></b>
       | _ -&gt; failwith "Missing comma-separated arguments"
 </r>445 </m><U>end</U>
     
     <U>and</U></b> do_vicindex lexbuf = <b><U>begin</U>
       <U>let</U></b> nfn = Lexstate.save_opt "0,filename,notename" lexbuf <b><U>in</U></b>
       Dest.put_char ' ';
 </r></b>450   <r>()
     <b><U>end</U></b>
     ;;
     
     
 </r>455 </m>(* This is the initialization function of the plugin: *)
     
     </w><U>let</U><r> init = <b><U>function</U><r> () -&gt;
       </r><U>begin</U><w>
         (* Register global TeX macros: *)
 <m>460     <r>def_code "\\snippet"                    do_snippet;
         def_name_code "\\@EDEF"                 do_edef;
         def_name_code "\\@MULEDEF"              do_muledef;
     
         def_code "\\ViCEndAnchor"               do_vicendanchor;
 </r>465     <r>def_code "\\ViCAnchor"                  do_vicanchor;
         def_code "\\ViCIndex"                   do_vicindex;
     
         def_code "\\enableLispComment"          do_enableLispComment;
         def_code "\\disableLispComment"         do_disableLispComment;
 </r>470     <r>def_code "\\enableSchemeCharacters"     do_enableSchemeCharacters;
         def_code "\\disableSchemeCharacters"    do_disableSchemeCharacters;
         def_code "\\enableBackslashedChars"     do_enable_backslashed_chars;
         def_code "\\snippetRunHook"             do_snippet_run_hook;
         def_code "\\snipRunHook"                do_snip_run_hook;
 </r>475     <r>()
       <b><U>end</U><r>;;
     
     register_init "videoc" init
     ;;<PL><B>
<6>124 zyva.ml</6>
</B></PL></r><w> 
     end(***********************************************************************)
     (*                                                                     *)
     (*                          HEVEA                                      *)
     (*                                                                     *)
   <m>5 </m>(*  Luc Maranget, projet Moscova, INRIA Rocquencourt                   *)
     (*                                                                     *)
     (*  Copyright 2001 Institut National de Recherche en Informatique et   *)
     (*  Automatique.  Distributed only by permission.                      *)
     (*                                                                     *)
  <m>10 </m>(*  $Id: zyva.ml,v 1.3 2001/05/25 12:37:36 maranget Exp $              *)
     (***********************************************************************)
     </w><U>module</U> <U>type</U></b> S =
      <b><U>functor</U><r> (Dest : OutManager.S) -&gt;
        </r><U>functor</U></b> (Image : ImageManager.S) -&gt;
  </r>15      <b><U>functor</U><r> (Scan : Latexscan.S) -&gt;
            </r><U>sig</U> <U>end</U>
     
     
     <U>module</U><m>
  20     <r>Make
         (Dest: OutManager.S) (Image : ImageManager.S) (Scan : Latexscan.S)
         (ToMake : S) =
     <b><U>struct</U>
       <U>module</U></b> Rien = ToMake (Dest) (Image) (Scan)
  </r>25 
     </m><U>end</U><r><PL><B>
<6>125 Arbre.java</6>
</B></PL> 
     <b><U>import</U></b> java.io.*;
     <b><U>public</U> <U>class</U></b> Arbre {
      String tag;
      <b><U>int</U><r> tagchiffre; </r><w>//chaque tag a optimiser est repere par un chiffre
   <m>5  <b><U>char</U><r> type; </r><w>//O pour ouverture, S pour special, F pour fermeture et T pour texte
      <r>String attribut1; </r>//pour type S
      <r>String attribut2; </r>//pour type S
      <r>String attribut3; </r>//pour type S
     
  <m>10  <r>Arbre filsG;
      Arbre filsD;
     
      <b><U>public</U><r> Arbre(String balise) {
       </r><U>if</U></b> (balise == <b><U>null</U></b>)
  </r>15    <r>tag = <b><U>null</U><r>;
       </r><U>else</U></b> {
        <b><U>if</U><r> (Balise.estOuverture(balise)) {
         </r><U>int</U></b> i = balise.indexOf("&gt;");
         tag = balise.substring(1,i);
  </r>20     <r>i = tag.indexOf(" ");<w>//pour les espaces
         <b><U>if</U></b></w> (i != -1)
          tag = tag.substring(0,i);
         type = 'O';
     
  </r>25     <r>tagchiffre = 0;
         <b><U>while</U><r> (! tag.equals(Balise.liste[tagchiffre]) )
          tagchiffre++;
     
         </r><U>if</U></b> ( (tag.indexOf("font") == 0) || (tag.indexOf("basefont") == 0) ) {
  </r>30      <r>type = 'S';
          String tempo = balise;
     
         tagchiffre = 24;
         <b><U>while</U></b> (! tag.equals(Balise.liste[tagchiffre]) )
  </r>35      <r>tagchiffre++;
     
          <b><U>int</U><r> j = tempo.indexOf("size");
          </r><U>int</U></b> k = tempo.indexOf("color");
          <b><U>int</U></b> m = tempo.indexOf("face");
  </r>40 
          <b><U>if</U><r> (j != -1) {
           tempo = balise.substring(j);
           tempo = tempo.substring(tempo.indexOf("=") + 1);
           </r><U>while</U><r> (tempo.indexOf(" ") == 0)
  </r></b>45        <r>tempo = tempo.substring(1);
           j = tempo.indexOf(" ");
           <b><U>if</U><r> (j != -1)
            attribut1 = tempo.substring(0,j);
           </r><U>else</U><m>
  50        <r>attribut1 = tempo.substring(0,tempo.indexOf("&gt;"));
          }
     
          <b><U>if</U></b> (k != -1) {
           tempo = balise.substring(k);
  </r>55       <r>tempo = tempo.substring(tempo.indexOf("=") + 1);
           <b><U>while</U><r> (tempo.indexOf(" ") == 0)
            tempo = tempo.substring(1);
           k = tempo.indexOf(" ");
           </r><U>if</U></b> (k != -1)
  </r>60        <r>attribut2 = tempo.substring(0,k);
           <b><U>else</U></b>
            attribut2 = tempo.substring(0,tempo.indexOf("&gt;"));
          }
     
  </r>65      </m><U>if</U></b> (m != -1) {
           tempo = balise.substring(m);
           tempo = tempo.substring(tempo.indexOf("=") + 1);
           <b><U>while</U></b> (tempo.indexOf(" ") == 0)
            tempo = tempo.substring(m);
  </r>70       <r>m = tempo.indexOf(" ");
           <b><U>if</U><r> (m != -1)
            attribut3 = tempo.substring(0,m);
           </r><U>else</U></b>
            attribut3 = tempo.substring(0,tempo.indexOf("&gt;"));
  </r>75      <r>}
         }
        }
     
        <b><U>if</U></b> (Balise.estFermeture(balise)) {
  </r>80     <b><U>int</U><r> i = balise.indexOf("&gt;");
         tag = balise.substring(2,i);
         </r><U>while</U><r> (tag.indexOf(" ") == 0)
          tag = tag.substring (1);
         i = balise.indexOf(" ");
  </r></b>85     <b><U>if</U><r> (i != -1)
          tag = tag.substring(0,i);
         type = 'F';
        }
     
  </r></b>90    <b><U>if</U><r> (Balise.estText (balise)) {
         tag = balise;
         type = 'T';
         tagchiffre = 26;
        }
  </r></b>95   <r>}
      }
     
      <w>//Pour imprimer un arbre avec toutes les balises sur la meme ligne
      <b><U>public</U> <U>static</U> <U>void</U></b></w> imprimer (Arbre a) {
 </r>100   <b><U>if</U><r> (a.type == 'T')
        System.out.print(a.tag);
       </r><U>if</U><r> (a.type == 'O')
        System.out.print('&lt;' + a.tag + '&gt;');
       <b><U>if</U></b> (a.type == 'S') {
 </r></b>105    <r>System.out.print('&lt;' + a.tag);
        <b><U>if</U><r> (a.attribut1 != </r><U>null</U></b>)
         System.out.print(" size=" + a.attribut1);
        <b><U>if</U><r> (a.attribut2 != </r><U>null</U></b>)
         System.out.print(" color=" + a.attribut2);
 </r>110    <r><b><U>if</U><r> (a.attribut3 != </r><U>null</U></b>)
         System.out.print(" face=" + a.attribut3);
        System.out.print('&gt;');
       }
     
 </r>115   <b><U>if</U><r> (a.filsG == </r><U>null</U><r>) {
        <b><U>if</U><r> ( (a.type == 'O') || (a.type == 'S') ) {
         System.out.print(Balise.fermeture(a.tag));
        }
        </r><U>if</U></b> (a.filsD == <b><U>null</U></b>) {
 </r></b>120    <b><U>return</U><r>;
        }
        </r><U>else</U><r> {
         imprimer(a.filsD);
         <b><U>return</U></b>;
 </r></b>125    <r>}
       }
       <b><U>else</U><r>
        imprimer(a.filsG);
       </r><U>if</U></b> (a.filsD == <b><U>null</U></b>) {
 </r>130    <b><U>if</U><r> ( (a.type == 'O') || (a.type == 'S') )
         System.out.print(Balise.fermeture(a.tag));
        </r><U>return</U><r>;
       }
       <b><U>else</U></b> {
 </r></b>135    <b><U>if</U><r> ( (a.type == 'O') || (a.type == 'S') )
         System.out.print(Balise.fermeture(a.tag));
        imprimer(a.filsD);
       }
       </r><U>return</U><r>;
 </r></b>140  <r>}
     
      <w>//Creation de l'arbre
      <b><U>public</U> <U>static</U></b></w> Arbre construire () <b><U>throws</U><r> Exception {
       Arbre a = </r><U>new</U></b> Arbre (<b><U>null</U></b>);
 </r>145   <b><U>if</U><r> (Balise.estOuverture(HTML.balise_courante)) {
        a = </r><U>new</U><r> Arbre (HTML.balise_courante);
        HTML.Suivante();
     
        <b><U>if</U></b> (Balise.estFermeture(HTML.balise_courante)) {
 </r></b>150     <r>HTML.Suivante();
         <b><U>if</U><r> ((HTML.balise_courante.indexOf("&lt;/") == 0) &amp;&amp; (HTML.balise_courante.indexOf("html") != -1))
          </r><U>return</U></b> a;
         <b><U>else</U><r> {
          </r><U>if</U></b> (Balise.estFermeture(HTML.balise_courante)) {
 </r>155       <r>HTML.Suivante();
           <b><U>return</U></b> a;
          }
          a.filsD = construire ();
         }
 </r>160    <r>}
        <b><U>else</U><r> {
         a.filsG = construire ();
         </r><U>if</U></b> (HTML.balise_courante == <b><U>null</U><r>)
          </r><U>return</U></b> a;
 </r>165 
         <b><U>if</U><r> (Balise.estFermeture(HTML.balise_courante)) {
          HTML.Suivante();
          </r><U>return</U><r> a;
         }
 </r></b>170     <b><U>else</U><r>
          a.filsD = construire ();
        }
       }
       </r><U>else</U><r> {
 </r></b>175    <r>a = <b><U>new</U><r> Arbre (HTML.balise_courante);
        HTML.Suivante();
        </r><U>if</U></b> (Balise.estFermeture(HTML.balise_courante)) {
         HTML.Suivante();
         <b><U>return</U></b> a;
 </r>180    <r>}
        <b><U>else</U><r> {
         a.filsD = construire ();
         </r><U>if</U></b> (HTML.balise_courante == <b><U>null</U><r>)
          </r><U>return</U></b> a;
 </r>185 
         <b><U>if</U><r> (Balise.estFermeture(HTML.balise_courante))
          </r><U>return</U><r> a;
         <b><U>else</U> <U>return</U></b> a;
        }
 </r></b>190   <r>}
       <b><U>return</U><r> a;
      }
     
      </r><w>//Recollage de la branche1 le + bas a droite de la branche2
 <m>195  <b><U>public</U> <U>static</U><r> Arbre recoller(Arbre branche1, Arbre branche2) {
       <b><U>if</U><r> (branche2.filsD == </r><U>null</U></b>) {
        branche2.filsD = branche1;
        <b><U>return</U></b> branche2;
       }
 </r></b>200   <b><U>else</U><r> {
        branche2.filsD = recoller (branche1, branche2.filsD);
        </r><U>return</U><r> branche2;
       }
      }
 </r></b>205 
      </m>//Suppression d'un element
      </w><U>public</U> <U>static</U></b> Arbre supprimer (Arbre a) {
       <b><U>if</U><r> (a.filsG == </r><U>null</U></b>) {
        <b><U>if</U><r> (a.filsD == </r><U>null</U></b>)
 </r>210     <b><U>return</U> <U>new</U><r> Arbre(<b><U>null</U><r>);
        </r><U>else</U>
         <U>return</U></b> a.filsD;
       }
       <b><U>else</U></b> {
 </r></b>215    <b><U>if</U><r> (a.filsD == </r><U>null</U><r>)
         <b><U>return</U><r> a.filsG;
        </r><U>else</U></b> {
         a.filsG = recoller (a.filsD,a.filsG);
         <b><U>return</U></b> a.filsG;
 </r></b>220    <r>}
       }
      }
     
      <w>//Comparaison des attributs de 2 balises speciales (tableau,arbre)
 <m>225  <b><U>public</U> <U>static</U> <U>boolean</U><r>[] memes_att (String[] Balise1, Arbre Balise2) {
       <b><U>boolean</U><r>[] tab = </r><U>new</U> <U>boolean</U></b>[4];
       <b><U>if</U><r> (Balise1[0] == "vide") {
        </r><U>if</U></b> (Balise2.attribut1 == <b><U>null</U><r>)
         tab[0] = </r><U>true</U></b>;
 </r></b>230    <b><U>else</U><r>
         tab[0] = </r><U>false</U><r>;
       }
       <b><U>else</U><r> {
        </r><U>if</U></b> (Balise2.attribut1 == <b><U>null</U></b>)
 </r></b>235     <r>tab[0] = <b><U>false</U><r>;
        </r><U>else</U>
         <U>if</U></b> (Balise1[0].equals(Balise2.attribut1))
          tab[0] = <b><U>true</U><r>;
         </r><U>else</U><m>
 240      <r>tab[0] = <b><U>false</U><r>;
       }
       </r><U>if</U></b> (Balise1[1] == "vide") {
        <b><U>if</U><r> (Balise2.attribut2 == </r><U>null</U></b>)
         tab[1] = <b><U>true</U></b>;
 </r>245    </m><U>else</U></b>
         tab[1] = <b><U>false</U><r>;
       }
       </r><U>else</U></b> {
        <b><U>if</U><r> (Balise2.attribut2 == </r><U>null</U></b>)
 </r>250     <r>tab[1] = <b><U>false</U><r>;
        </r><U>else</U>
         <U>if</U></b> (Balise1[1].equals(Balise2.attribut2))
          tab[1] = <b><U>true</U><r>;
         </r><U>else</U><m>
 255      <r>tab[1] = <b><U>false</U><r>;
       }
       </r><U>if</U></b> (Balise1[2] == "vide") {
        <b><U>if</U><r> (Balise2.attribut3 == </r><U>null</U></b>)
         tab[2] = <b><U>true</U></b>;
 </r>260    </m><U>else</U></b>
         tab[2] = <b><U>false</U><r>;
       }
       </r><U>else</U></b> {
        <b><U>if</U><r> (Balise2.attribut3 == </r><U>null</U></b>)
 </r>265     <r>tab[2] = <b><U>false</U><r>;
        </r><U>else</U>
         <U>if</U></b> (Balise1[2].equals(Balise2.attribut3))
          tab[2] = <b><U>true</U><r>;
         </r><U>else</U><m>
 270      <r>tab[2] = <b><U>false</U><r>;
       }
       </r><U>if</U></b> ( (tab[0] == <b><U>true</U><r>) &amp;&amp; (tab[1] == </r><U>true</U></b>) &amp;&amp; (tab[2] == <b><U>true</U><r>) )
        tab[3] = </r><U>true</U></b>;
       <b><U>else</U><m>
 275    <r>tab[3] = <b><U>false</U><r>;
       </r><U>return</U></b> tab;
      }
     
      <w>//Comparaison des attributs de 2 balises speciales (arbre,arbre)
 <m>280  <b><U>public</U> <U>static</U> <U>boolean</U><r>[] memes_att (Arbre Balise1, Arbre Balise2) {
       <b><U>boolean</U><r>[] tab = </r><U>new</U> <U>boolean</U></b>[4];
       <b><U>if</U><r> (Balise1.attribut1 == </r><U>null</U></b>) {
        <b><U>if</U><r> (Balise2.attribut1 == </r><U>null</U></b>)
         tab[0] = <b><U>true</U></b>;
 </r></b>285    <b><U>else</U><r>
         tab[0] = </r><U>false</U><r>;
       }
       <b><U>else</U><r> {
        </r><U>if</U></b> (Balise2.attribut1 == <b><U>null</U></b>)
 </r></b>290     <r>tab[0] = <b><U>false</U><r>;
        </r><U>else</U>
         <U>if</U></b> (Balise1.attribut1.equals(Balise2.attribut1))
          tab[0] = <b><U>true</U><r>;
         </r><U>else</U><m>
 295      <r>tab[0] = <b><U>false</U><r>;
       }
       </r><U>if</U></b> (Balise1.attribut2 == <b><U>null</U><r>) {
        </r><U>if</U></b> (Balise2.attribut2 == <b><U>null</U><r>)
         tab[1] = </r><U>true</U></b>;
 </r>300    </m><U>else</U></b>
         tab[1] = <b><U>false</U><r>;
       }
       </r><U>else</U></b> {
        <b><U>if</U><r> (Balise2.attribut2 == </r><U>null</U></b>)
 </r>305     <r>tab[1] = <b><U>false</U><r>;
        </r><U>else</U>
         <U>if</U></b> (Balise1.attribut2.equals(Balise2.attribut2))
          tab[1] = <b><U>true</U><r>;
         </r><U>else</U><m>
 310      <r>tab[1] = <b><U>false</U><r>;
       }
       </r><U>if</U></b> (Balise1.attribut3 == <b><U>null</U><r>) {
        </r><U>if</U></b> (Balise2.attribut3 == <b><U>null</U><r>)
         tab[2] = </r><U>true</U></b>;
 </r>315    </m><U>else</U></b>
         tab[2] = <b><U>false</U><r>;
       }
       </r><U>else</U></b> {
        <b><U>if</U><r> (Balise2.attribut3 == </r><U>null</U></b>)
 </r>320     <r>tab[2] = <b><U>false</U><r>;
        </r><U>else</U>
         <U>if</U></b> (Balise1.attribut3.equals(Balise2.attribut3))
          tab[2] = <b><U>true</U><r>;
         </r><U>else</U><m>
 325      <r>tab[2] = <b><U>false</U><r>;
       }
       </r><U>if</U></b> ( (tab[0] == <b><U>true</U><r>) &amp;&amp; (tab[1] == </r><U>true</U></b>) &amp;&amp; (tab[2] == <b><U>true</U><r>) )
        tab[3] = </r><U>true</U></b>;
       <b><U>else</U><m>
 330    <r>tab[3] = <b><U>false</U><r>;
       </r><U>return</U></b> tab;
      }
     
      <w>//Optimisation de l'arbre
 <m>335  <b><U>public</U> <U>static</U><r> Arbre optimiser (Arbre a) {
      <w>//optimisation a droite
     
       //cas d'une ouverture sans rien dedans
      <b><U>while</U></b></w> ( (a.filsD != <b><U>null</U><r>) &amp;&amp; (a.filsD.type != 'T') &amp;&amp; (a.filsD.filsG == </r><U>null</U></b>) ) {
 </r></b>340    <r><b><U>if</U><r> (a.filsD.filsD == </r><U>null</U></b>)
         a.filsD = <b><U>null</U><r>;
        </r><U>else</U></b>
         a.filsD = a.filsD.filsD;
       }
 </r>345 
       </m>//suppression d'une balise speciale sans attributs
       <b><U>while</U></b></w> ( (a.filsD != <b><U>null</U><r>) &amp;&amp; (a.filsD.type == 'S') &amp;&amp; (a.filsD.attribut1 == </r><U>null</U></b>) &amp;&amp; (a.filsD.attribut2 == <b><U>null</U><r>) &amp;&amp; (a.filsD.attribut3 == </r><U>null</U></b>) ) {
        <b><U>if</U><r> (a.filsD.filsD == </r><U>null</U></b>)
         a.filsD = a.filsD.filsG;
 </r>350    </m><U>else</U></b>
         a.filsD = recoller (a.filsD.filsD,a.filsD.filsG);
        <b><U>while</U><r> ( (a.filsD != </r><U>null</U></b>) &amp;&amp; (a.filsD.type != 'T') &amp;&amp; (a.filsD.filsG == <b><U>null</U><r>) ) {
         </r><U>if</U></b> (a.filsD.filsD == <b><U>null</U><r>)
          a.filsD = </r><U>null</U></b>;
 </r>355     </m><U>else</U></b>
          a.filsD = a.filsD.filsD;
        }
       }
     
 </r>360   </m>//cas d'un fils droit identique a son pere
       <b><U>while</U></b></w> ( (a.filsD != <b><U>null</U><r>) &amp;&amp; (a.tag.equals(a.filsD.tag)) &amp;&amp; ( (a.filsD.type == 'O') || ( (a.filsD.type == 'S') &amp;&amp; (memes_att (a, a.filsD)[3]) ) ) ){
        </r><U>if</U></b> (a.filsD.filsG != <b><U>null</U><r>) {
         </r><U>if</U></b> (a.filsG == <b><U>null</U></b>)
          a.filsG = a.filsD.filsG;
 </r>365     </m><U>else</U></b>
          a.filsG = recoller (a.filsD.filsG,a.filsG);
        }
        <b><U>if</U><r> (a.filsD.filsD == </r><U>null</U></b>)
         a.filsD = <b><U>null</U></b>;
 </r>370    </m><U>else</U></b>
         a.filsD = a.filsD.filsD;
        <b><U>while</U><r> ( (a.filsD != </r><U>null</U></b>) &amp;&amp; (a.filsD.type == 'S') &amp;&amp; (a.filsD.attribut1 == <b><U>null</U><r>) &amp;&amp; (a.filsD.attribut2 == </r><U>null</U></b>) &amp;&amp; (a.filsD.attribut3 == <b><U>null</U><r>) ) {
         </r><U>if</U></b> (a.filsD.filsD == <b><U>null</U></b>)
          a.filsD = a.filsD.filsG;
 </r>375     <b><U>else</U><r>
          a.filsD = recoller (a.filsD.filsD,a.filsD.filsG);
         </r><U>while</U><r> ( (a.filsD != <b><U>null</U><r>) &amp;&amp; (a.filsD.type != 'T') &amp;&amp; (a.filsD.filsG == </r><U>null</U></b>) ) {
          <b><U>if</U><r> (a.filsD.filsD == </r><U>null</U></b>)
           a.filsD = <b><U>null</U></b>;
 </r></b>380      <b><U>else</U><r>
           a.filsD = a.filsD.filsD;
         }
        }
       }
 </r></b>385 
       </m>// cas d'un fils droit deja ouvert plus haut
       <b><U>while</U></b></w> ( (a.filsD != <b><U>null</U></b>) &amp;&amp; (HTML.tab[a.filsD.tagchiffre]) &amp;&amp; (a.filsD.type == 'O') )
        a.filsD = supprimer (a.filsD);
     
 </r>390   <b><U>if</U><r> (a.type == 'O')
        HTML.tab[a.tagchiffre] = </r><U>true</U><r>;
       <b><U>if</U><r> (a.type == 'S') {
        HTML.tab[a.tagchiffre] = </r><U>true</U></b>;
        <b><U>if</U><r> (a.attribut1 != </r><U>null</U></b>)
 </r></b>395     <r>HTML.tab_att[0] = a.attribut1;
        <b><U>if</U><r> (a.attribut2 != </r><U>null</U></b>)
         HTML.tab_att[1] = a.attribut2;
        <b><U>if</U><r> (a.attribut3 != </r><U>null</U></b>)
         HTML.tab_att[2] = a.attribut3;
 </r>400   <r>}
     
      <w>//optimisation a gauche
     
       //suppression d'une balise speciale sans attributs
 <m>405   <r><b><U>while</U><r> ( (a.filsG != </r><U>null</U></b>) &amp;&amp; (a.filsG.type == 'S') &amp;&amp; (a.filsG.attribut1 == <b><U>null</U><r>) &amp;&amp; (a.filsG.attribut2 == </r><U>null</U></b>) &amp;&amp; (a.filsG.attribut3 == <b><U>null</U><r>) )
        a.filsG = supprimer(a.filsG);
     
       </r><w>//optimisation des balises deja ouvertes
       </w><U>while</U></b> ( (a.filsG != <b><U>null</U></b>) &amp;&amp; (HTML.tab[a.filsG.tagchiffre]) &amp;&amp; ( (a.filsG.type == 'O') || ( (a.filsG.type == 'S') &amp;&amp; (memes_att (HTML.tab_att, a.filsG) [3] ) ) ) ) {
 </r>410    <b><U>if</U><r> (a.filsG.type == 'O')
         a.filsG = supprimer(a.filsG);
        </r><U>if</U><r> (a.filsG.type == 'S') {
         a.filsG.attribut1 = <b><U>null</U><r>;
         a.filsG.attribut2 = </r><U>null</U></b>;
 </r></b>415     <r>a.filsG.attribut3 = <b><U>null</U><r>;
        }
        </r><U>while</U></b> ( (a.filsG != <b><U>null</U><r>) &amp;&amp; (a.filsG.type == 'S') &amp;&amp; (a.filsG.attribut1 == </r><U>null</U></b>) &amp;&amp; (a.filsG.attribut2 == <b><U>null</U><r>) &amp;&amp; (a.filsG.attribut3 == </r><U>null</U></b>) )
         a.filsG = supprimer(a.filsG);
       }
 </r>420 
       </m>//optimisation d'une balise speciale avec des attributs deja ouverts
       <b><U>if</U></b></w> ( (a.filsG != <b><U>null</U><r>) &amp;&amp; (a.filsG.type == 'S') &amp;&amp; (HTML.tab[a.filsG.tagchiffre]) &amp;&amp; ( (memes_att (HTML.tab_att, a.filsG) [0]) || (memes_att (HTML.tab_att, a.filsG) [1]) || (memes_att (HTML.tab_att, a.filsG) [2]) ) ) {
        </r><U>if</U></b> (memes_att (HTML.tab_att, a.filsG) [0])
          a.filsG.attribut1 = <b><U>null</U></b>;
 </r>425    <b><U>if</U><r> (memes_att (HTML.tab_att, a.filsG) [1])
          a.filsG.attribut2 = </r><U>null</U><r>;
        <b><U>if</U><r> (memes_att (HTML.tab_att, a.filsG) [2])
          a.filsG.attribut3 = </r><U>null</U></b>;
       }
 </r></b>430 
       </m>//optimisation d'une balise speciale avec des attributs deja ouverts dans son pere
       </w><U>if</U><r> ( (a.filsG != <b><U>null</U><r>) &amp;&amp; (a.filsG.type == 'S') &amp;&amp; (a.tag.equals(a.filsG.tag)) ){
        </r><U>if</U></b> (a.filsG.attribut1 != <b><U>null</U></b>)
          a.attribut1 = a.filsG.attribut1;
 </r></b>435    <r><b><U>if</U><r> (a.filsG.attribut2 != </r><U>null</U></b>)
          a.attribut2 = a.filsG.attribut2;
        <b><U>if</U><r> (a.filsG.attribut3 != </r><U>null</U></b>)
          a.attribut3 = a.filsG.attribut3;
        a.filsG = supprimer (a.filsG);
 </r>440   <r>}
     
       <w>//suppression d'une balise speciale sans attributs
       <b><U>while</U></b></w> ( (a.filsG != <b><U>null</U><r>) &amp;&amp; (a.filsG.type == 'S') &amp;&amp; (a.filsG.attribut1 == </r><U>null</U></b>) &amp;&amp; (a.filsG.attribut2 == <b><U>null</U><r>) &amp;&amp; (a.filsG.attribut3 == </r><U>null</U></b>) )
        a.filsG = supprimer(a.filsG);
 </r>445 
       </m>//parcours de l'arbre
       </w><U>if</U></b> (a.filsG == <b><U>null</U><r>) {
        </r><U>if</U></b> (a.type != 'T')
         HTML.tab[a.tagchiffre] = <b><U>false</U></b>;
 </r></b>450    <b><U>if</U><r> (a.type == 'S') {
         HTML.tab_att[0] = "vide";
         HTML.tab_att[1] = "vide";
         HTML.tab_att[2] = "vide";
        }
 </r></b>455    <b><U>if</U><r> (a.filsD == </r><U>null</U><r>){
         <b><U>if</U><r> (a.type == 'T')
          </r><U>return</U></b> a;
         <b><U>else</U>
          <U>return</U> <U>new</U></b> Arbre (<b><U>null</U></b>);
 </r></b>460    <r>}
        <b><U>else</U><r> {
         </r><U>if</U></b> (a.type == 'T') {
          a.filsD = optimiser (a.filsD);
          <b><U>return</U></b> a;
 </r>465     <r>}
         <b><U>else</U>
          <U>return</U></b> optimiser (a.filsD);
        }
       }
 </r>470   <b><U>else</U><r> {
        a.filsG = optimiser (a.filsG);
       }
       </r><U>if</U><r> (a.type != 'T')
        HTML.tab[a.tagchiffre] = <b><U>false</U></b>;
 </r></b>475   <b><U>if</U><r> (a.type == 'S') {
        HTML.tab_att[0] = "vide";
        HTML.tab_att[1] = "vide";
        HTML.tab_att[2] = "vide";
       }
 </r></b>480   <b><U>if</U><r> (a.filsD == </r><U>null</U><r>) {
        <b><U>if</U><r> (a.filsG.tag == </r><U>null</U></b>)
         <b><U>return</U> <U>new</U></b> Arbre(<b><U>null</U><r>);
        </r><U>else</U>
         <U>return</U></b> a;
 </r></b>485   <r>}
       <b><U>else</U><r> {
        </r><U>if</U></b> (a.filsG.tag == <b><U>null</U><r>) {
         </r><U>return</U></b> optimiser (a.filsD);
        }
 </r>490    <b><U>else</U><r> {
         a.filsD = optimiser (a.filsD);
         </r><U>return</U><r> a;
        }
       }
 </r></b>495  <r>}<PL><B>
<6>126 Balise.java</6>
</B></PL> 
     }import java.io.*;
     
     <b><U>public</U> <U>class</U></b> Balise {
      <w>//Liste des balises Text
   <m>5  <b><U>public</U> <U>static</U><r> String [] liste = {
       "tt", "i", "b", "big", "small", "strike", "s", "u", "del", "ins", "em",
       "strong", "dfn", "code", "samp", "kbd", "var", "cite", "abbr",
       "acronym", "sub", "sup", "html", "blink", "font", "basefont"};
     
  </r></b>10  </m>//Transformation d'une ouverture en fermeture
      <b><U>public</U> <U>static</U></b></w> String fermeture (String tag) {
       <b><U>return</U></b> "&lt;/" + tag + "&gt;";
      }
     
  </r>15  </m>//Test des balises
      </w><U>public</U> <U>static</U> <U>boolean</U></b> estOuverture (String bal) {
       <b><U>if</U><r> ((bal.indexOf('&lt;') == 0) &amp;&amp; (bal.indexOf('/') != 1)) {
        </r><U>for</U></b> (<b><U>int</U><r> i = 0 ; i&lt;26 ; i++) {
         </r><U>int</U></b> j = bal.indexOf(liste[i]);
  </r></b>20     <b><U>int</U><r> longueur = liste[i].length();
         </r><U>if</U><r> (j != -1)
          <b><U>if</U><r> ( (bal.charAt(j-1)=='&lt;')  &amp;&amp; ((bal.charAt(j+longueur)==' ') || (bal.charAt(j+longueur)=='&gt;') ) )
           </r><U>return</U> <U>true</U></b>;
        }
  </r></b>25   <r>}
       <b><U>return</U> <U>false</U></b>;
      }
     
      <b><U>public</U> <U>static</U> <U>boolean</U></b> estFermeture (String bal) {
  </r>30   <b><U>if</U><r> ((bal.indexOf('&lt;') == 0) &amp;&amp; (bal.indexOf('/') == 1)) {
        </r><U>for</U><r> (<b><U>int</U><r> i = 0 ; i&lt;26 ; i++) {
         </r><U>int</U></b> j = bal.indexOf(liste[i]);
         <b><U>int</U><r> longueur = liste[i].length();
         </r><U>if</U></b> (j != -1)
  </r></b>35      <b><U>if</U><r> ( ( (bal.charAt(j-1)=='/') || (bal.charAt(j-1)==' ') ) &amp;&amp; ( (bal.charAt(j+longueur)==' ') || (bal.charAt(j+longueur)=='&gt;') ) )
           </r><U>return</U> <U>true</U><r>;
        }
       }
       <b><U>return</U> <U>false</U></b>;
  </r></b>40  <r>}
     
      <b><U>public</U> <U>static</U> <U>boolean</U></b> estText (String bal) {
       <b><U>if</U><r> ( (estOuverture(bal)) || (estFermeture(bal)) )
        </r><U>return</U> <U>false</U></b>;
  </r>45   <b><U>else</U> <U>return</U> <U>true</U><r>;
      }<PL><B>
<6>127 HTML.java</6>
</B></PL> 
     }import java.io.*;
     <b><U>public</U> <U>class</U></b> HTML {
     <w>//Declaration des variables globales
      <b><U>public</U> <U>static</U></b></w> String balise_courante = "";
   </r></b>5  <b><U>public</U> <U>static</U><r> String ligne_balise = "";
      <b><U>public</U> <U>static</U></b> StreamTokenizer tok;
      <b><U>public</U> <U>static</U> <U>boolean</U></b> [] tab = <b><U>new</U> <U>boolean</U></b> [27] ;
      <b><U>public</U> <U>static</U></b> String [] tab_att = <b><U>new</U></b> String [3] ;
     
  </r></b>10 <w>//Tableau des majuscules
      </w></m><b><U>public</U> <U>static</U> <U>char</U></b> [] MAJ = {
       'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',
       'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',
       'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
  <m>15 
     <w>//Tableau des minuscules
      <b><U>public</U> <U>static</U> <U>char</U></b></w></m> [] min = {
       'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',
       'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',
  <m>20   <r>'s', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
     
     <w>//Echange un caractere MAJ en min
      <b><U>public</U> <U>static</U></b></w> String remplace (String balise, <b><U>int</U><r> i) {
       </r><U>int</U></b> j = 0;
  </r>25   <r>String tempo = balise ;
       balise = "";
       <b><U>while</U></b> (tempo.indexOf(MAJ[i]) != -1) {
        j = tempo.indexOf(MAJ[i]);
        balise = balise + tempo.substring(0,j) + min[i];
  </r>30    <r>tempo = tempo.substring(j+1);
       }
       <b><U>return</U></b> balise + tempo;
      }
     
  </r>35 <w>//Transformation des balises en minuscules
      <b><U>public</U> <U>static</U></b></w></m> String minuscules (String ligne) {
       <b><U>for</U><r> (</r><U>int</U></b> i=0 ; i&lt;26 ; i++) {
        ligne = remplace(ligne,i);
       }
  <m>40   <b><U>return</U><r> ligne;
      }
     
     </r><w>//Decoupage des balises
      </w><U>public</U> <U>static</U> <U>void</U><r> Suivante () <b><U>throws</U></b> Exception {
  </r></b>45 
      <w>//pour gerer la fin du fichier
       </w></m><b><U>if</U><r> ( (balise_courante.indexOf("&lt;/") == 0) &amp;&amp; (balise_courante.indexOf("html") != -1) ) {
        balise_courante = </r><U>null</U></b>;
        <b><U>return</U><r>;
  <m>50   </m>}
     
      </r><w>//pour gerer les lignes commencant par des tabulations
       </w><U>while</U></b> (ligne_balise.indexOf(' ') == 0)
        <b><U>if</U><r> (ligne_balise.length() == 1) {
  <m>55     </m>tok.nextToken();
         tok.nextToken();
         ligne_balise = tok.sval;
        }
        </r><U>else</U><m>
  60     <r>ligne_balise = ligne_balise.substring(1);
     
      <w>//pour gerer les commentaires qui peuvent contenir des balises a cheval sur plusieurs lignes
       <b><U>if</U></b></w> ((ligne_balise.indexOf("&lt;!--") == 0) &amp;&amp; (ligne_balise.indexOf("--&gt;") == -1)) {
        <b><U>do</U></b> {
  </r>65     <r>tok.nextToken();
         tok.nextToken();
         tok.nextToken();
         <b><U>while</U><r> (tok.sval == </r><U>null</U></b>) {
          tok.nextToken();
  </r>70      <r>tok.nextToken();
         }
         ligne_balise = ligne_balise + tok.sval;
        }
        <b><U>while</U></b>(ligne_balise.indexOf("--&gt;") == -1);
  </r>75   <r>}
     
      <w>//pour gerer les commentaires qui peuvent contenir des balises
       <b><U>if</U></b></w> ((ligne_balise.indexOf("&lt;!--") == 0) &amp;&amp; (ligne_balise.indexOf("--&gt;") != -1)) {
        <b><U>int</U></b> i = ligne_balise.indexOf("--&gt;") + 3;
  </r>80    <r>balise_courante = ligne_balise.substring(0,i);
     
        <b><U>if</U></b> (ligne_balise.length() == i) {
         tok.nextToken();
         tok.nextToken();
  </r>85     <r>tok.nextToken();
         <b><U>while</U><r> (tok.sval == </r><U>null</U></b>) {
          tok.nextToken();
          tok.nextToken();
         }
  </r>90     <r>ligne_balise = tok.sval;
         <b><U>return</U><r>;
        }
        </r><U>else</U></b> {
         ligne_balise = ligne_balise.substring(i);
  </r>95     </m><U>return</U></b>;
        }
       }
     
      <w>//pour gerer les lignes commencant par du texte
 <m>100   <b><U>if</U><r> (ligne_balise.indexOf('&lt;') != 0) {
        </r><U>if</U><r> (ligne_balise.indexOf('&lt;') == -1) {
         balise_courante = ligne_balise;
         tok.nextToken();
         tok.nextToken();
 </r></b>105     <r>tok.nextToken();
         <b><U>while</U><r> (tok.sval == </r><U>null</U></b>) {
          tok.nextToken();
          tok.nextToken();
         }
 </r>110     <r>ligne_balise = tok.sval;
         <b><U>return</U><r>;
        }
        </r><U>else</U></b> {
         <b><U>int</U></b> i = ligne_balise.indexOf('&lt;');
 </r>115     <r>balise_courante = ligne_balise.substring(0,i);
         ligne_balise = ligne_balise.substring(i);
         <b><U>return</U></b>;
        }
       }
 </r>120 
      </m>//pour gerer les lignes commencant par une balise incomplete
       <b><U>if</U></b></w> ((ligne_balise.indexOf('&lt;') == 0) &amp;&amp; (ligne_balise.indexOf('&gt;') == -1)) {
        <b><U>do</U><r> {
         tok.nextToken();
 <m>125     </m>tok.nextToken();
         tok.nextToken();
         </r><U>while</U></b> (tok.sval == <b><U>null</U><r>) {
          tok.nextToken();
          tok.nextToken();
 <m>130     </m>}
     
         balise_courante = tok.sval;
         </r><U>while</U></b> (balise_courante.indexOf(' ') == 0)
          <b><U>if</U><r> (balise_courante.length() == 1) {
 <m>135       </m>tok.nextToken();
           tok.nextToken();
           balise_courante = tok.sval;
          }
          </r><U>else</U><m>
 140       <r>balise_courante = balise_courante.substring(1);
          ligne_balise = ligne_balise + " " + balise_courante;
        }
        <b><U>while</U></b>(ligne_balise.indexOf('&gt;') == -1);
       }
 </r>145 
      <w>//pour gerer les lignes commencant par une balise
       <b><U>if</U><r> ((ligne_balise.indexOf('&lt;') == 0) &amp;&amp; (ligne_balise.indexOf('&gt;') != -1)) {
        </r><U>int</U><r> i = ligne_balise.indexOf('&gt;') + 1;
        balise_courante = minuscules(ligne_balise.substring(0,i));
 <m>150 
        <b><U>if</U></b></m> ((balise_courante.indexOf("&lt;/") == 0) &amp;&amp; (balise_courante.indexOf("html") != -1) )
         <b><U>return</U><r>;
     
        </r><U>if</U></b> (ligne_balise.length() == i) {
 <m>155     <r>tok.nextToken();
         tok.nextToken();
         tok.nextToken();
         <b><U>while</U><r> (tok.sval == </r><U>null</U></b>) {
          tok.nextToken();
 </r>160      <r>tok.nextToken();
         }
         ligne_balise = tok.sval;
         <b><U>return</U></b>;
        }
 </r>165    <b><U>else</U></b></m> {
         ligne_balise = ligne_balise.substring(i);
         <b><U>return</U><r>;
        }
       }
 </r><m>170 
       </m><U>return</U></b>;
      }
     
      <b><U>public</U> <U>static</U> <U>void</U></b> main(String[] args) <b><U>throws</U><r> Exception {
 </r><m>175   </m><U>if</U></b> ((args.length != 0)&amp;&amp;(args.length != 1)) {
        System.err.println("Usage: java Fichier &lt;nom&gt;");
        System.exit(1);
       }
       <b><U>if</U><r> (args.length == 0) {
 <m>180    </m>BufferedReader f = </r><U>new</U></b> BufferedReader (<b><U>new</U><r> InputStreamReader (System.in)) ;
        tok = </r><U>new</U></b> StreamTokenizer (f);
       }
       <b><U>else</U><r> {
        FileReader f = </r><U>new</U></b> FileReader(args[0]);
 <m>185    </m>tok = <b><U>new</U></b> StreamTokenizer(f);
       }
       tok.resetSyntax();
       tok.wordChars(' ', ' ');</r></b>//pour prendre les tabulations
       <r>tok.wordChars(' ','');  </r>//pour prendre les caracteres classiques
 </w>190 
     
       </m><U>int</U></b> i=0;
       Arbre a = <b><U>new</U><r> Arbre(</r><U>null</U></b>);
       tok.nextToken();
 <m>195   <b><U>while</U></b></m> (tok.sval == <b><U>null</U><r>) {
        tok.nextToken();
        tok.nextToken();
       }
     
 <m>200   </m>ligne_balise = tok.sval; <w>//pour prendre la premiere balise
       </w>Suivante();
     
       </r><U>while</U></b> (! balise_courante.equals ("&lt;html&gt;")) { <w>//pour imprimer les commentaires avant &lt;html&gt;
        </w>System.out.println(balise_courante);
 <m>205    <r>Suivante();
       }
       <b><U>for</U><r> (</r><U>int</U></b> k=0; k&lt;=26; k++)
        tab[k] = <b><U>false</U><r>;
       </r><U>for</U></b> (<b><U>int</U></b> k=0; k&lt;=2; k++)
 </r>210    <r>tab_att[k] = "vide";
       a = Arbre.construire ();
       a = Arbre.optimiser (a);
       Arbre.imprimer(a);
      }
 </r>215 <r>}<PL><B>
<6>128 Jeton.java</6>
</B></PL> 
     <b><U>import</U></b> java.io.*;
     
     <b><U>class</U><r> Jeton </r><U>extends</U></b> StreamTokenizer {
     
   </r>5   <r>Jeton (Reader f) {
         <b><U>super</U><r>(f) ;
       }
     
       </r><U>public</U> <U>int</U></b> jetonSuivant() <b><U>throws</U></b> IOException {
  </r>10     <b><U>int</U></b></m> r = <b><U>this</U><r>.nextToken() ;
         System.err.println("jeton suivant : " + r + " &lt;&lt; " + sval + "&gt;&gt;") ;
         </r><U>return</U></b> r ;
       }
     }</r></TT></b><EM>
This document was translated from L<c>A</c>T<g>E</g>X by
<b><U>H<c><2>E</2><b>V</b><2>E</2></c>A</U></b>.
</EM>